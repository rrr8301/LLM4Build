go: downloading github.com/goplus/lib v0.3.0
go: downloading github.com/qiniu/x v1.15.1
go: downloading github.com/goplus/mod v0.17.1
go: downloading github.com/goplus/gogen v1.19.5
go: downloading github.com/goplus/cobra v1.9.12
go: downloading github.com/fsnotify/fsnotify v1.9.0
go: downloading golang.org/x/sys v0.29.0
go: downloading golang.org/x/mod v0.20.0
	github.com/goplus/xgo/ast		coverage: 0.0% of statements
	github.com/goplus/xgo/ast/gopq		coverage: 0.0% of statements
	github.com/goplus/xgo/ast/goptest		coverage: 0.0% of statements
	github.com/goplus/xgo/ast/fromgo/typeparams		coverage: 0.0% of statements
	github.com/goplus/xgo/ast/mod		coverage: 0.0% of statements
=== RUN   TestErrASTFile
=== RUN   TestErrASTFile/ASTFile:_doesn't_support_keeping_cgo_now_
2025/12/19 11:09:15 ASTFile: doesn't support keeping cgo now
=== RUN   TestErrASTFile/ASTFile:_doesn't_support_keeping_func_body_now_
2025/12/19 11:09:15 ASTFile: doesn't support keeping func body now
--- PASS: TestErrASTFile (0.00s)
    --- PASS: TestErrASTFile/ASTFile:_doesn't_support_keeping_cgo_now_ (0.00s)
    --- PASS: TestErrASTFile/ASTFile:_doesn't_support_keeping_func_body_now_ (0.00s)
=== RUN   TestErrDecl
=== RUN   TestErrDecl/gopDecl:_unknown_decl_-_<nil>_
2025/12/19 11:09:15 gopDecl: unknown decl - <nil>
=== RUN   TestErrDecl/gopGenDecl:_unknown_spec_-_ILLEGAL_
2025/12/19 11:09:15 gopGenDecl: unknown spec - ILLEGAL
--- PASS: TestErrDecl (0.00s)
    --- PASS: TestErrDecl/gopDecl:_unknown_decl_-_<nil>_ (0.00s)
    --- PASS: TestErrDecl/gopGenDecl:_unknown_spec_-_ILLEGAL_ (0.00s)
=== RUN   TestErrExpr
=== RUN   TestErrExpr/gopExpr:_unknown_expr_-_*ast.BadExpr_
2025/12/19 11:09:15 gopExpr: unknown expr - *ast.BadExpr
--- PASS: TestErrExpr (0.00s)
    --- PASS: TestErrExpr/gopExpr:_unknown_expr_-_*ast.BadExpr_ (0.00s)
=== RUN   TestBasic
--- PASS: TestBasic (0.00s)
=== RUN   TestMethod
--- PASS: TestMethod (0.00s)
=== RUN   TestCheckIdent
--- PASS: TestCheckIdent (0.00s)
=== RUN   TestIndexListExpr
--- PASS: TestIndexListExpr (0.00s)
PASS
coverage: 9.1% of statements
ok  	github.com/goplus/xgo/ast/fromgo	0.018s	coverage: 9.1% of statements
=== RUN   TestErrASTFile
=== RUN   TestErrASTFile/ASTFile:_doesn't_support_keeping_func_body_now_
2025/12/19 11:09:15 ASTFile: doesn't support keeping func body now
--- PASS: TestErrASTFile (0.00s)
    --- PASS: TestErrASTFile/ASTFile:_doesn't_support_keeping_func_body_now_ (0.00s)
=== RUN   TestErrDecl
=== RUN   TestErrDecl/goDecl:_unknown_decl_-_<nil>_
2025/12/19 11:09:15 goDecl: unknown decl - <nil>
=== RUN   TestErrDecl/goGenDecl:_unknown_spec_-_ILLEGAL_
2025/12/19 11:09:15 goGenDecl: unknown spec - ILLEGAL
--- PASS: TestErrDecl (0.00s)
    --- PASS: TestErrDecl/goDecl:_unknown_decl_-_<nil>_ (0.00s)
    --- PASS: TestErrDecl/goGenDecl:_unknown_spec_-_ILLEGAL_ (0.00s)
=== RUN   TestErrExpr
=== RUN   TestErrExpr/goExpr:_unknown_expr_-_*ast.BadExpr_
2025/12/19 11:09:15 goExpr: unknown expr - *ast.BadExpr
--- PASS: TestErrExpr (0.00s)
    --- PASS: TestErrExpr/goExpr:_unknown_expr_-_*ast.BadExpr_ (0.00s)
=== RUN   TestBasic
--- PASS: TestBasic (0.00s)
PASS
coverage: 14.0% of statements
ok  	github.com/goplus/xgo/ast/togo	0.021s	coverage: 14.0% of statements
?   	github.com/goplus/xgo/cl/internal/testutil	[no test files]
	github.com/goplus/xgo/cl/internal/overload/foo			github.com/goplus/xgo/cl/internal/huh		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/mcp		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/spx3/jwt		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/llgo-hello		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/spx4/pkg		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/spx		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/cltest		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/typesalias		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/spx3		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/spx/pkg		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/test		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/overload/bar		coverage: 0.0% of statements
	github.com/goplus/xgo/cl/internal/spx2			github.com/goplus/xgo/cl/internal/spx4		coverage: 0.0% of statements
?   	github.com/goplus/xgo/cl/internal/unit	[no test files]
?   	github.com/goplus/xgo/cmd/internal/deps	[no test files]
?   	github.com/goplus/xgo/cmd/internal/list	[no test files]
	github.com/goplus/xgo/cl/outline		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/build		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/clean		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/chore/goptestgo		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/bug		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/version		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/base		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/help		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/watch		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/gengo		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/doc		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/env		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/mod		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/serve		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/run		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/gopfmt		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/test		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/install		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/internal/gopget		coverage: 0.0% of statements
	github.com/goplus/xgo/demo/fullspec/mixgo-complex		coverage: 0.0% of statements
	github.com/goplus/xgo/demo/mixgo		coverage: 0.0% of statements
	github.com/goplus/xgo/demo/xgo-sample/cpkag/b		coverage: 0.0% of statements
	github.com/goplus/xgo/demo/typeasparamsfunc		coverage: 0.0% of statements
	github.com/goplus/xgo/parser/fsx		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/variant		coverage: 0.0% of statements
	github.com/goplus/xgo/x/typesutil/internal/typesutil		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/encoding/csv		coverage: 0.0% of statements
	github.com/goplus/xgo/x/jsonrpc2/stdio		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/scanner/scannertest		coverage: 0.0% of statements
	github.com/goplus/xgo/x/watcher		coverage: 0.0% of statements
	github.com/goplus/xgo/x/typesutil/typeparams		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/variant/time		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/matcher		coverage: 0.0% of statements
	github.com/goplus/xgo/x/jsonrpc2/jsonrpc2test/cases		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl		coverage: 0.0% of statements
	github.com/goplus/xgo/cmd/xgo		coverage: 0.0% of statements
	github.com/goplus/xgo/x/jsonrpc2		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/encoding/xml		coverage: 0.0% of statements
	github.com/goplus/xgo/test		coverage: 0.0% of statements
	github.com/goplus/xgo/parser/fsx/memfs		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/cl		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/variant/builtin		coverage: 0.0% of statements
	github.com/goplus/xgo/parser/parsertest		coverage: 0.0% of statements
	github.com/goplus/xgo/format		coverage: 0.0% of statements
	github.com/goplus/xgo/x/langserver		coverage: 0.0% of statements
	github.com/goplus/xgo/tool		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/encoding/regexposix		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/ast		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/variant/delay		coverage: 0.0% of statements
	github.com/goplus/xgo/x/fsnotify		coverage: 0.0% of statements
	github.com/goplus/xgo/scanner		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/parser/parsertest		coverage: 0.0% of statements
	github.com/goplus/xgo/demo/typeasparamsmethod		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/encoding/regexp		coverage: 0.0% of statements
	github.com/goplus/xgo/demo/typeparamscast		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/variant/math		coverage: 0.0% of statements
	github.com/goplus/xgo/x/xgoenv		coverage: 0.0% of statements
	github.com/goplus/xgo/parser/iox		coverage: 0.0% of statements
	github.com/goplus/xgo/x/fakenet		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/types		coverage: 0.0% of statements
	github.com/goplus/xgo/tpl/encoding/json		coverage: 0.0% of statements
	github.com/goplus/xgo/x/gocmd		coverage: 0.0% of statements
	github.com/goplus/xgo/x/jsonrpc2/internal/stack		coverage: 0.0% of statements
	github.com/goplus/xgo/x/jsonrpc2/internal/stack/stacktest		coverage: 0.0% of statements
2025/12/19 11:09:21 SetDebug: import=true, match=true, instr=true
=== RUN   TestEmbeddedFieldCast
--- PASS: TestEmbeddedFieldCast (0.00s)
=== RUN   TestNonClosure
--- PASS: TestNonClosure (0.00s)
=== RUN   TestLoadExpr
--- PASS: TestLoadExpr (0.00s)
=== RUN   TestSpriteOf
--- PASS: TestSpriteOf (0.00s)
=== RUN   TestGetGameClass
--- PASS: TestGetGameClass (0.00s)
=== RUN   TestSimplifyPkgPath
--- PASS: TestSimplifyPkgPath (0.00s)
=== RUN   TestCompileLambdaExpr
--- PASS: TestCompileLambdaExpr (0.00s)
=== RUN   TestCompileLambda1
--- PASS: TestCompileLambda1 (0.00s)
=== RUN   TestCompileLambda2
--- PASS: TestCompileLambda2 (0.00s)
=== RUN   TestCompileExpr
--- PASS: TestCompileExpr (0.00s)
=== RUN   TestCompileStmt
2025/12/19 11:09:21 compileStmt failed: unknown - *ast.BadStmt
--- PASS: TestCompileStmt (0.00s)
=== RUN   TestTryGopExec
--- PASS: TestTryGopExec (0.25s)
=== RUN   TestCompileFuncAlias
--- PASS: TestCompileFuncAlias (0.00s)
=== RUN   TestErrStringLit
--- PASS: TestErrStringLit (0.00s)
=== RUN   TestErrPreloadFile
=== RUN   TestErrPreloadFile/unknown_decl
2025/12/19 11:09:21 TODO - cl.preloadFile: unknown decl - *ast.BadDecl
--- PASS: TestErrPreloadFile (0.00s)
    --- PASS: TestErrPreloadFile/unknown_decl (0.00s)
=== RUN   TestErrParseTypeEmbedName
--- PASS: TestErrParseTypeEmbedName (0.00s)
=== RUN   TestGmxCheckProjs
--- PASS: TestGmxCheckProjs (0.00s)
=== RUN   TestGmxCheckProjs2
--- PASS: TestGmxCheckProjs2 (0.00s)
=== RUN   TestNodeInterp
--- PASS: TestNodeInterp (0.00s)
=== RUN   TestMarkAutogen
2025/12/19 11:09:22 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:22 ==> NewOverloadFunc NewRange
2025/12/19 11:09:22 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:22 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:22 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:22 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:22 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:22 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:22 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:22 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:22 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:22 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:22 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:22 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:22 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:22 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:22 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:22 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:22 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:22 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:22 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:22 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:22 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:22 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:22 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:22 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:22 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:22 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:22 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:22 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:22 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:22 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:22 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:22 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:22 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:22 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:22 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:22 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:22 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:22 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:22 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:22 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:22 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:22 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:23 NewConstStart [_]
2025/12/19 11:09:23 Val true bool
2025/12/19 11:09:23 EndInit 1
--- PASS: TestMarkAutogen (1.46s)
=== RUN   TestClassNameAndExt
--- PASS: TestClassNameAndExt (0.00s)
=== RUN   TestFileClassType
--- PASS: TestFileClassType (0.00s)
=== RUN   TestErrMultiStarRecv
--- PASS: TestErrMultiStarRecv (0.00s)
=== RUN   TestErrAssign
--- PASS: TestErrAssign (0.00s)
=== RUN   TestErrPanicToRecv
--- PASS: TestErrPanicToRecv (0.00s)
=== RUN   TestCompileErrWrapExpr
--- PASS: TestCompileErrWrapExpr (0.00s)
=== RUN   TestToString
--- PASS: TestToString (0.00s)
=== RUN   TestGetTypeName
--- PASS: TestGetTypeName (0.00s)
=== RUN   TestHandleRecover
--- PASS: TestHandleRecover (0.00s)
=== RUN   TestCheckCommandWithoutArgs
--- PASS: TestCheckCommandWithoutArgs (0.00s)
=== RUN   TestClRangeStmt
2025/12/19 11:09:23 ForRange [_]
2025/12/19 11:09:23 SliceLit <nil> 0 false
2025/12/19 11:09:23 RangeAssignThen
2025/12/19 11:09:23 VBlock
2025/12/19 11:09:23 End // Vblock
2025/12/19 11:09:23 End // ForRange
2025/12/19 11:09:23 ForRange []
2025/12/19 11:09:23 VarRef _
2025/12/19 11:09:23 VarRef _
2025/12/19 11:09:23 SliceLit <nil> 0 false
2025/12/19 11:09:23 RangeAssignThen
2025/12/19 11:09:23 VBlock
2025/12/19 11:09:23 End // Vblock
2025/12/19 11:09:23 End // ForRange
--- PASS: TestClRangeStmt (0.00s)
=== RUN   TestGetStringConst
--- PASS: TestGetStringConst (0.00s)
=== RUN   TestSpxRef
--- PASS: TestSpxRef (0.00s)
=== RUN   TestGmxProject
2025/12/19 11:09:23 ==> InitClass main isProj: true
2025/12/19 11:09:23 Val Sched func()
2025/12/19 11:09:23 Call 0 0 // func()
2025/12/19 11:09:23 ==> MatchFuncCall func() args: 0 flags: 0
--- PASS: TestGmxProject (0.04s)
=== RUN   TestSpxLookup
--- PASS: TestSpxLookup (0.00s)
=== RUN   TestGetGoFile
--- PASS: TestGetGoFile (0.00s)
=== RUN   TestErrNewType
=== RUN   TestErrNewType/bar_redeclared_in_this_block__previous_declaration_at_<TODO>_
2025/12/19 11:09:23 bar redeclared in this block
	previous declaration at <TODO>
--- PASS: TestErrNewType (0.00s)
    --- PASS: TestErrNewType/bar_redeclared_in_this_block__previous_declaration_at_<TODO>_ (0.00s)
=== RUN   TestErrCompileBasicLit
=== RUN   TestErrCompileBasicLit/compileBasicLit:_invalid_syntax_
2025/12/19 11:09:23 compileBasicLit: invalid syntax
--- PASS: TestErrCompileBasicLit (0.00s)
    --- PASS: TestErrCompileBasicLit/compileBasicLit:_invalid_syntax_ (0.00s)
=== RUN   TestClassFileEnd
--- PASS: TestClassFileEnd (0.00s)
=== RUN   TestSpxError
2025/12/19 11:09:23 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:23 ==> NewOverloadFunc NewRange
2025/12/19 11:09:23 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:23 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:23 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:23 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:23 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:23 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:23 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:23 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:23 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:23 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:23 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:23 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:23 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:23 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:23 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:23 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:23 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:23 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:23 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:23 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:23 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:23 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:23 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:23 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:23 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:23 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:23 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:23 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:23 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:23 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:23 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:23 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:23 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:23 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:23 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:23 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:23 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:23 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:23 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:23 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:23 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:23 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:24 ==> ClassFile /foo/Game.tgmx
2025/12/19 11:09:24 ==> Import github.com/goplus/xgo/cl/internal/spx
2025/12/19 11:09:24 ==> NewTemplateRecvMethod MyGame Main
2025/12/19 11:09:24 ==> NewTemplateRecvMethod MyGame Run
2025/12/19 11:09:24 ==> NewTemplateRecvMethod Sprite OnKey2
2025/12/19 11:09:24 ==> NewOverloadFunc Gopt_Sprite_Clone
2025/12/19 11:09:24 ==> NewTemplateRecvMethod Sprite Clone
2025/12/19 11:09:24 ==> NewOverloadFunc Gopt_Sprite_OnKey
2025/12/19 11:09:24 ==> NewTemplateRecvMethod Sprite OnKey
2025/12/19 11:09:24 ==> NewOverloadMethod MyGame Broadcast
2025/12/19 11:09:24 ==> NewOverloadFunc Rand
2025/12/19 11:09:24 ==> Import github.com/goplus/xgo/cl/internal/spx/pkg
2025/12/19 11:09:24 ==> NewOverloadMethod Vector Add
2025/12/19 11:09:24 ==> InitClass Game isProj: true
2025/12/19 11:09:24 ==> ClassFile /foo/Kai.tspx
2025/12/19 11:09:24 ==> InitClass Kai isProj: false
2025/12/19 11:09:24 ==> Preload type Game
2025/12/19 11:09:24 ==> Preload method Game.MainEntry
2025/12/19 11:09:24 ==> Preload type Kai
2025/12/19 11:09:24 ==> Preload method Kai.Main
2025/12/19 11:09:24 ==> Load > NewType Game
2025/12/19 11:09:24 NewType Game
2025/12/19 11:09:24 ==> Load > NewType Kai
2025/12/19 11:09:24 NewType Kai
2025/12/19 11:09:24 ==> Load > InitType Game
2025/12/19 11:09:24 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:24 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; userScore int}
2025/12/19 11:09:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; userScore int}
2025/12/19 11:09:24 ==> Load method *Game.MainEntry
2025/12/19 11:09:24 ==> Load > InitType Kai
2025/12/19 11:09:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; userScore int}
2025/12/19 11:09:24 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:24 ==> Load method *Kai.Main
2025/12/19 11:09:24 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*Game) func()
2025/12/19 11:09:24 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/12/19 11:09:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Call 1 0 // func(game any)
2025/12/19 11:09:24 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType *Game, any
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*Kai) func()
2025/12/19 11:09:24 SetComments 0
//line Kai.tspx:2:1
2025/12/19 11:09:24 Val this *Kai
2025/12/19 11:09:24 Member println 1 // *Kai
2025/12/19 11:09:24 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 Val &{0 STRING "hi"} *ast.BasicLit
2025/12/19 11:09:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped string ("hi"), any
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc main func()
2025/12/19 11:09:24 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 Val Game Game
2025/12/19 11:09:24 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; userScore int} => Typ Game
2025/12/19 11:09:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:24 Member Main 0 // *Game
2025/12/19 11:09:24 Call 0 0 // func()
2025/12/19 11:09:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 ==> ClassFile /foo/Game.tgmx
2025/12/19 11:09:24 ==> InitClass Game isProj: true
2025/12/19 11:09:24 ==> ClassFile /foo/Kai.tspx
2025/12/19 11:09:24 ==> InitClass Kai isProj: false
2025/12/19 11:09:24 ==> Preload type Game
2025/12/19 11:09:24 ==> Preload method Game.MainEntry
2025/12/19 11:09:24 ==> Preload type Kai
2025/12/19 11:09:24 ==> Preload method Kai.Main
2025/12/19 11:09:24 ==> Load > NewType Game
2025/12/19 11:09:24 NewType Game
2025/12/19 11:09:24 ==> Load > NewType Kai
2025/12/19 11:09:24 NewType Kai
2025/12/19 11:09:24 ==> Load > InitType Game
2025/12/19 11:09:24 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:24 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; userScore int}
2025/12/19 11:09:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; userScore int}
2025/12/19 11:09:24 ==> Load method *Game.MainEntry
2025/12/19 11:09:24 ==> Load > InitType Kai
2025/12/19 11:09:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; userScore int}
2025/12/19 11:09:24 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; id int}
2025/12/19 11:09:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; id int}
2025/12/19 11:09:24 ==> Load method *Kai.Main
2025/12/19 11:09:24 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*Game) func()
2025/12/19 11:09:24 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/12/19 11:09:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Call 1 0 // func(game any)
2025/12/19 11:09:24 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType *Game, any
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*Kai) func()
2025/12/19 11:09:24 SetComments 0
//line Kai.tspx:6:1
2025/12/19 11:09:24 Val this *Kai
2025/12/19 11:09:24 Member println 1 // *Kai
2025/12/19 11:09:24 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 Val &{0 STRING "hi"} *ast.BasicLit
2025/12/19 11:09:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped string ("hi"), any
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc main func()
2025/12/19 11:09:24 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 Val Game Game
2025/12/19 11:09:24 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; userScore int} => Typ Game
2025/12/19 11:09:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:24 Member Main 0 // *Game
2025/12/19 11:09:24 Call 0 0 // func()
2025/12/19 11:09:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 ==> ClassFile /foo/Game.t4gmx
2025/12/19 11:09:24 ==> Import github.com/goplus/xgo/cl/internal/spx4
2025/12/19 11:09:24 ==> NewTemplateRecvMethod MyGame Main
2025/12/19 11:09:24 ==> NewTemplateRecvMethod MyGame Run
2025/12/19 11:09:24 ==> NewTemplateRecvMethod Sprite OnKey2
2025/12/19 11:09:24 ==> NewOverloadFunc Gopt_Sprite_OnKey
2025/12/19 11:09:24 ==> NewTemplateRecvMethod Sprite OnKey
2025/12/19 11:09:24 ==> NewOverloadMethod MyGame Broadcast
2025/12/19 11:09:24 ==> NewOverloadFunc Rand
2025/12/19 11:09:24 ==> NewOverloadFunc Gopt_Sprite_Clone
2025/12/19 11:09:24 ==> NewTemplateRecvMethod Sprite Clone
2025/12/19 11:09:24 ==> InitClass Game isProj: true
2025/12/19 11:09:24 ==> ClassFile /foo/Kai.t4spx
2025/12/19 11:09:24 ==> InitClass Kai isProj: false
2025/12/19 11:09:24 ==> Preload type Game
2025/12/19 11:09:24 ==> Preload method Game.MainEntry
2025/12/19 11:09:24 ==> Preload type Kai
2025/12/19 11:09:24 ==> Preload method Kai.Main
2025/12/19 11:09:24 ==> Load > NewType Game
2025/12/19 11:09:24 NewType Game
2025/12/19 11:09:24 ==> Load > NewType Kai
2025/12/19 11:09:24 NewType Kai
2025/12/19 11:09:24 ==> Load > InitType Game
2025/12/19 11:09:24 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:24 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame; Kai Kai; userScore int}
2025/12/19 11:09:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame; Kai Kai; userScore int}
2025/12/19 11:09:24 ==> Load method *Game.MainEntry
2025/12/19 11:09:24 ==> Load > InitType Kai
2025/12/19 11:09:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame; Kai Kai; userScore int}
2025/12/19 11:09:24 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx4.Sprite; *Game}
2025/12/19 11:09:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx4.Sprite; *Game}
2025/12/19 11:09:24 ==> Load method *Kai.Main
2025/12/19 11:09:24 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*Game) func()
2025/12/19 11:09:24 Typ github.com/goplus/xgo/cl/internal/spx4.MyGame
2025/12/19 11:09:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx4.MyGame}
2025/12/19 11:09:24 DefineVarStart [_xgo_obj0]
2025/12/19 11:09:24 Val 1 int
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 StructLit Kai 2 true
2025/12/19 11:09:24 UnaryOp & flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:24 EndInit 1
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Val _xgo_obj0 *Kai
2025/12/19 11:09:24 Call 2 0 // func(game any, sprites ...github.com/goplus/xgo/cl/internal/spx4.Sprite)
2025/12/19 11:09:24 ==> MatchFuncCall func(game any, sprites ...github.com/goplus/xgo/cl/internal/spx4.Sprite) args: 2 flags: 0
2025/12/19 11:09:24 ==> MatchType *Game, any
2025/12/19 11:09:24 ==> MatchType *Kai, github.com/goplus/xgo/cl/internal/spx4.Sprite
2025/12/19 11:09:24 ==> AssignableConv *Kai github.com/goplus/xgo/cl/internal/spx4.Sprite false
2025/12/19 11:09:24 ==> ClassFile /foo/Game.t4gmx
2025/12/19 11:09:24 ==> InitClass Game isProj: true
2025/12/19 11:09:24 ==> ClassFile /foo/Greem.t4spx
2025/12/19 11:09:24 ==> InitClass Greem isProj: false
2025/12/19 11:09:24 ==> ClassFile /foo/Kai.t4spx
2025/12/19 11:09:24 ==> InitClass Kai isProj: false
2025/12/19 11:09:24 ==> Preload type Game
2025/12/19 11:09:24 ==> Preload method Game.MainEntry
2025/12/19 11:09:24 ==> Preload type Greem
2025/12/19 11:09:24 ==> Preload method Greem.Main
2025/12/19 11:09:24 ==> Preload type Kai
2025/12/19 11:09:24 ==> Preload method Kai.Main
2025/12/19 11:09:24 ==> Load > NewType Game
2025/12/19 11:09:24 NewType Game
2025/12/19 11:09:24 ==> Load > NewType Greem
2025/12/19 11:09:24 NewType Greem
2025/12/19 11:09:24 ==> Load > NewType Kai
2025/12/19 11:09:24 NewType Kai
2025/12/19 11:09:24 ==> Load > InitType Game
2025/12/19 11:09:24 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame}
2025/12/19 11:09:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame}
2025/12/19 11:09:24 ==> Load method *Game.MainEntry
2025/12/19 11:09:24 ==> Load > InitType Greem
2025/12/19 11:09:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame}
2025/12/19 11:09:24 InitType Greem struct{github.com/goplus/xgo/cl/internal/spx4.Sprite; *Game}
2025/12/19 11:09:24 ==> LookupParent Greem => type Greem struct{github.com/goplus/xgo/cl/internal/spx4.Sprite; *Game}
2025/12/19 11:09:24 ==> Load method *Greem.Main
2025/12/19 11:09:24 ==> Load > InitType Kai
2025/12/19 11:09:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame}
2025/12/19 11:09:24 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:24 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx4.Sprite; *Game; Kai Kai; userScore int}
2025/12/19 11:09:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx4.Sprite; *Game; Kai Kai; userScore int}
2025/12/19 11:09:24 ==> Load method *Kai.Main
2025/12/19 11:09:24 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:24 SetComments 0
//line Game.t4gmx:1:1
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Member println 1 // *Game
2025/12/19 11:09:24 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 Val &{0 STRING "hi"} *ast.BasicLit
2025/12/19 11:09:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped string ("hi"), any
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*Game) func()
2025/12/19 11:09:24 Typ github.com/goplus/xgo/cl/internal/spx4.MyGame
2025/12/19 11:09:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx4.MyGame}
2025/12/19 11:09:24 DefineVarStart [_xgo_obj0]
2025/12/19 11:09:24 Val 1 int
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 StructLit Greem 2 true
2025/12/19 11:09:24 UnaryOp & flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:24 EndInit 1
2025/12/19 11:09:24 DefineVarStart [_xgo_obj1]
2025/12/19 11:09:24 Val 1 int
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 StructLit Kai 2 true
2025/12/19 11:09:24 UnaryOp & flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:24 EndInit 1
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Val _xgo_obj0 *Greem
2025/12/19 11:09:24 Val _xgo_obj1 *Kai
2025/12/19 11:09:24 Call 3 0 // func(game any, sprites ...github.com/goplus/xgo/cl/internal/spx4.Sprite)
2025/12/19 11:09:24 ==> MatchFuncCall func(game any, sprites ...github.com/goplus/xgo/cl/internal/spx4.Sprite) args: 3 flags: 0
2025/12/19 11:09:24 ==> MatchType *Game, any
2025/12/19 11:09:24 ==> MatchType *Greem, github.com/goplus/xgo/cl/internal/spx4.Sprite
2025/12/19 11:09:24 ==> AssignableConv *Greem github.com/goplus/xgo/cl/internal/spx4.Sprite false
2025/12/19 11:09:24 ==> ClassFile /foo/Game.t4gmx
2025/12/19 11:09:24 ==> InitClass Game isProj: true
2025/12/19 11:09:24 ==> Preload type Game
2025/12/19 11:09:24 ==> Preload method Game.MainEntry
2025/12/19 11:09:24 ==> Load > NewType Game
2025/12/19 11:09:24 NewType Game
2025/12/19 11:09:24 ==> Load > InitType Game
2025/12/19 11:09:24 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame}
2025/12/19 11:09:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame}
2025/12/19 11:09:24 ==> Load method *Game.MainEntry
2025/12/19 11:09:24 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:24 SetComments 0
//line Game.t4gmx:1:1
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Member println 1 // *Game
2025/12/19 11:09:24 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Member backdropName 1 // *Game
2025/12/19 11:09:24 Call 0 0 // func() string
2025/12/19 11:09:24 ==> MatchFuncCall func() string args: 0 flags: 0
2025/12/19 11:09:24 NewClosure func()
2025/12/19 11:09:24 NewVar [_xgo_err]
2025/12/19 11:09:24 VarRef _xgo_err error
2025/12/19 11:09:24 Assign 1 1
2025/12/19 11:09:24 ==> MatchType string, error
2025/12/19 11:09:24 ==> EnsureLoaded error
2025/12/19 11:09:24 ==> AssignableConv string error false
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Member Gop_Exec 0 // *Game
2025/12/19 11:09:24 Val println string
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Member backdropName 1 // *Game
2025/12/19 11:09:24 Call 0 0 // func() string
2025/12/19 11:09:24 ==> MatchFuncCall func() string args: 0 flags: 0
2025/12/19 11:09:24 NewClosure func()
2025/12/19 11:09:24 NewVar [_xgo_err]
2025/12/19 11:09:24 VarRef _xgo_err error
2025/12/19 11:09:24 Assign 1 1
2025/12/19 11:09:24 ==> MatchType string, error
2025/12/19 11:09:24 ==> EnsureLoaded error
2025/12/19 11:09:24 ==> AssignableConv string error false
2025/12/19 11:09:24 ResetStmt
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*Game) func()
2025/12/19 11:09:24 Typ github.com/goplus/xgo/cl/internal/spx4.MyGame
2025/12/19 11:09:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx4.MyGame}
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Call 1 0 // func(game any, sprites ...github.com/goplus/xgo/cl/internal/spx4.Sprite)
2025/12/19 11:09:24 ==> MatchFuncCall func(game any, sprites ...github.com/goplus/xgo/cl/internal/spx4.Sprite) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType *Game, any
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc main func()
2025/12/19 11:09:24 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 Val Game Game
2025/12/19 11:09:24 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame} => Typ Game
2025/12/19 11:09:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:24 Member Main 0 // *Game
2025/12/19 11:09:24 Call 0 0 // func()
2025/12/19 11:09:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 ==> ClassFile /foo/Game.t5gmx
2025/12/19 11:09:24 ==> InitClass Game isProj: true
2025/12/19 11:09:24 ==> ClassFile /foo/Kai.t5spx
2025/12/19 11:09:24 ==> InitClass Kai isProj: false
2025/12/19 11:09:24 ==> Preload type Game
2025/12/19 11:09:24 ==> Preload method Game.MainEntry
2025/12/19 11:09:24 ==> Preload type Kai
2025/12/19 11:09:24 ==> Preload method Kai.Main
2025/12/19 11:09:24 ==> Load > NewType Game
2025/12/19 11:09:24 NewType Game
2025/12/19 11:09:24 ==> Load > NewType Kai
2025/12/19 11:09:24 NewType Kai
2025/12/19 11:09:24 ==> Load > InitType Game
2025/12/19 11:09:24 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:24 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame; Kai *Kai}
2025/12/19 11:09:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame; Kai *Kai}
2025/12/19 11:09:24 ==> Load method *Game.MainEntry
2025/12/19 11:09:24 ==> Load > InitType Kai
2025/12/19 11:09:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx4.MyGame; Kai *Kai}
2025/12/19 11:09:24 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx4.Sprite; *Game}
2025/12/19 11:09:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx4.Sprite; *Game}
2025/12/19 11:09:24 ==> Load method *Kai.Main
2025/12/19 11:09:24 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*Game) func()
2025/12/19 11:09:24 Typ github.com/goplus/xgo/cl/internal/spx4.MyGame
2025/12/19 11:09:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx4.MyGame}
2025/12/19 11:09:24 DefineVarStart [_xgo_obj0]
2025/12/19 11:09:24 Val 1 int
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 StructLit Kai 2 true
2025/12/19 11:09:24 UnaryOp & flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:24 EndInit 1
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Member Kai -1 // *Game
2025/12/19 11:09:24 Val _xgo_obj0 *Kai
2025/12/19 11:09:24 Assign 1 1
2025/12/19 11:09:24 ==> MatchType *Kai, *Kai
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Val _xgo_obj0 *Kai
2025/12/19 11:09:24 Call 2 0 // func(game any, sprites ...github.com/goplus/xgo/cl/internal/spx4.Sprite)
2025/12/19 11:09:24 ==> MatchFuncCall func(game any, sprites ...github.com/goplus/xgo/cl/internal/spx4.Sprite) args: 2 flags: 0
2025/12/19 11:09:24 ==> MatchType *Game, any
2025/12/19 11:09:24 ==> MatchType *Kai, github.com/goplus/xgo/cl/internal/spx4.Sprite
2025/12/19 11:09:24 ==> AssignableConv *Kai github.com/goplus/xgo/cl/internal/spx4.Sprite false
--- PASS: TestSpxError (1.24s)
=== RUN   TestSpxBasic
=== RUN   TestSpxBasic/gopSpxTest
2025/12/19 11:09:24 ==> ClassFile /foo/bar.tspx
2025/12/19 11:09:24 ==> InitClass bar isProj: false
2025/12/19 11:09:24 ==> ClassFile /foo/index.tgmx
2025/12/19 11:09:24 ==> InitClass index isProj: true
2025/12/19 11:09:24 ==> Preload type bar
2025/12/19 11:09:24 ==> Preload method bar.Main
2025/12/19 11:09:24 ==> Preload type index
2025/12/19 11:09:24 NewConstDefs
2025/12/19 11:09:24 ==> Preload const [Foo]
2025/12/19 11:09:24 ==> Preload method index.bar
2025/12/19 11:09:24 ==> Preload method index.onInit
2025/12/19 11:09:24 ==> Preload method index.MainEntry
2025/12/19 11:09:24 ==> Load > NewType bar
2025/12/19 11:09:24 NewType bar
2025/12/19 11:09:24 ==> Load > NewType index
2025/12/19 11:09:24 NewType index
2025/12/19 11:09:24 ==> Load const [Foo] <nil>
2025/12/19 11:09:24 NewConst [Foo] 0
2025/12/19 11:09:24 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:24 EndInit 1
2025/12/19 11:09:24 ==> Load > InitType index
2025/12/19 11:09:24 InitType index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 ==> Load method *index.bar
2025/12/19 11:09:24 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 ==> Load method *index.onInit
2025/12/19 11:09:24 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 ==> Load method *index.MainEntry
2025/12/19 11:09:24 ==> Load > InitType bar
2025/12/19 11:09:24 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 InitType bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *index}
2025/12/19 11:09:24 ==> LookupParent bar => type bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *index}
2025/12/19 11:09:24 ==> Load method *bar.Main
2025/12/19 11:09:24 NewFunc bar (*index) func()
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc onInit (*index) func()
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Member Foo 1 // *index
2025/12/19 11:09:24 Val Foo untyped int
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Member bar 1 // *index
2025/12/19 11:09:24 Call 0 0 // func()
2025/12/19 11:09:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Member fmt 2 // *index
2025/12/19 11:09:24 Val Println func(a ...any) (n int, err error)
2025/12/19 11:09:24 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:24 Call 1 0 // func(a ...any) (n int, err error)
2025/12/19 11:09:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped string ("Hi"), any
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc MainEntry (*index) func()
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*index) func()
2025/12/19 11:09:24 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/12/19 11:09:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Call 1 0 // func(game any)
2025/12/19 11:09:24 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType *index, any
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*bar) func()
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc main func()
2025/12/19 11:09:24 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 Val index index
2025/12/19 11:09:24 Val type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ index
2025/12/19 11:09:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:24 Member Main 0 // *index
2025/12/19 11:09:24 Call 0 0 // func()
2025/12/19 11:09:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 ==> ASTFile
--- PASS: TestSpxBasic (0.00s)
    --- PASS: TestSpxBasic/gopSpxTest (0.00s)
=== RUN   TestEnvOp
=== RUN   TestEnvOp/gopSpxTest
2025/12/19 11:09:24 ==> ClassFile /foo/bar.tspx
2025/12/19 11:09:24 ==> InitClass bar isProj: false
2025/12/19 11:09:24 ==> ClassFile /foo/index.tgmx
2025/12/19 11:09:24 ==> InitClass index isProj: true
2025/12/19 11:09:24 ==> Preload type bar
2025/12/19 11:09:24 ==> Preload method bar.Main
2025/12/19 11:09:24 ==> Preload type index
2025/12/19 11:09:24 ==> Preload method index.MainEntry
2025/12/19 11:09:24 ==> Load > NewType bar
2025/12/19 11:09:24 NewType bar
2025/12/19 11:09:24 ==> Load > NewType index
2025/12/19 11:09:24 NewType index
2025/12/19 11:09:24 ==> Load > InitType index
2025/12/19 11:09:24 InitType index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 ==> Load method *index.MainEntry
2025/12/19 11:09:24 ==> Load > InitType bar
2025/12/19 11:09:24 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 InitType bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *index}
2025/12/19 11:09:24 ==> LookupParent bar => type bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *index}
2025/12/19 11:09:24 ==> Load method *bar.Main
2025/12/19 11:09:24 NewFunc MainEntry (*index) func()
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Member echo 1 // *index
2025/12/19 11:09:24 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Member Gop_Env 0 // *index
2025/12/19 11:09:24 Val PATH string
2025/12/19 11:09:24 Call 1 0 // func(name string) int
2025/12/19 11:09:24 ==> MatchFuncCall func(name string) int args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped string ("PATH"), string
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Member Gop_Env 0 // *index
2025/12/19 11:09:24 Val id string
2025/12/19 11:09:24 Call 1 0 // func(name string) int
2025/12/19 11:09:24 ==> MatchFuncCall func(name string) int args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped string ("id"), string
2025/12/19 11:09:24 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:24 ==> MatchType int, any
2025/12/19 11:09:24 ==> MatchType int, any
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*index) func()
2025/12/19 11:09:24 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/12/19 11:09:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Call 1 0 // func(game any)
2025/12/19 11:09:24 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType *index, any
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*bar) func()
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc main func()
2025/12/19 11:09:24 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 Val index index
2025/12/19 11:09:24 Val type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ index
2025/12/19 11:09:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:24 Member Main 0 // *index
2025/12/19 11:09:24 Call 0 0 // func()
2025/12/19 11:09:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 ==> ASTFile
--- PASS: TestEnvOp (0.00s)
    --- PASS: TestEnvOp/gopSpxTest (0.00s)
=== RUN   TestSpxGopEnv
=== RUN   TestSpxGopEnv/gopSpxTest
2025/12/19 11:09:24 ==> ClassFile /foo/bar.tspx
2025/12/19 11:09:24 ==> InitClass bar isProj: false
2025/12/19 11:09:24 ==> ClassFile /foo/index.tgmx
2025/12/19 11:09:24 ==> InitClass index isProj: true
2025/12/19 11:09:24 ==> Preload type bar
2025/12/19 11:09:24 ==> Preload method bar.Main
2025/12/19 11:09:24 ==> Preload type index
2025/12/19 11:09:24 ==> Preload method index.MainEntry
2025/12/19 11:09:24 ==> Load > NewType bar
2025/12/19 11:09:24 NewType bar
2025/12/19 11:09:24 ==> Load > NewType index
2025/12/19 11:09:24 NewType index
2025/12/19 11:09:24 ==> Load > InitType index
2025/12/19 11:09:24 InitType index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 ==> Load method *index.MainEntry
2025/12/19 11:09:24 ==> Load > InitType bar
2025/12/19 11:09:24 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 InitType bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *index}
2025/12/19 11:09:24 ==> LookupParent bar => type bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *index}
2025/12/19 11:09:24 ==> Load method *bar.Main
2025/12/19 11:09:24 NewFunc MainEntry (*index) func()
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Member echo 1 // *index
2025/12/19 11:09:24 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Member PATH 2 // *index
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Member Gop_Env 0 // *index
2025/12/19 11:09:24 Val PATH string
2025/12/19 11:09:24 Call 1 0 // func(name string) int
2025/12/19 11:09:24 ==> MatchFuncCall func(name string) int args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped string ("PATH"), string
2025/12/19 11:09:24 Member string 2 // int
2025/12/19 11:09:24 Val Itoa func(i int) string
2025/12/19 11:09:24 Call 1 0 // func(i int) string
2025/12/19 11:09:24 ==> MatchFuncCall func(i int) string args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType int, int
2025/12/19 11:09:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType string, any
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*index) func()
2025/12/19 11:09:24 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/12/19 11:09:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Call 1 0 // func(game any)
2025/12/19 11:09:24 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType *index, any
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*bar) func()
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc main func()
2025/12/19 11:09:24 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 Val index index
2025/12/19 11:09:24 Val type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ index
2025/12/19 11:09:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:24 Member Main 0 // *index
2025/12/19 11:09:24 Call 0 0 // func()
2025/12/19 11:09:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 ==> ASTFile
--- PASS: TestSpxGopEnv (0.00s)
    --- PASS: TestSpxGopEnv/gopSpxTest (0.00s)
=== RUN   TestSpxGopExec
=== RUN   TestSpxGopExec/gopSpxTest
2025/12/19 11:09:24 ==> ClassFile /foo/bar.tspx
2025/12/19 11:09:24 ==> InitClass bar isProj: false
2025/12/19 11:09:24 ==> ClassFile /foo/index.tgmx
2025/12/19 11:09:24 ==> InitClass index isProj: true
2025/12/19 11:09:24 ==> Preload type bar
2025/12/19 11:09:24 ==> Preload method bar.Main
2025/12/19 11:09:24 ==> Preload type index
2025/12/19 11:09:24 ==> Preload method index.MainEntry
2025/12/19 11:09:24 ==> Load > NewType bar
2025/12/19 11:09:24 NewType bar
2025/12/19 11:09:24 ==> Load > NewType index
2025/12/19 11:09:24 NewType index
2025/12/19 11:09:24 ==> Load > InitType index
2025/12/19 11:09:24 InitType index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 ==> Load method *index.MainEntry
2025/12/19 11:09:24 ==> Load > InitType bar
2025/12/19 11:09:24 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 InitType bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *index}
2025/12/19 11:09:24 ==> LookupParent bar => type bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *index}
2025/12/19 11:09:24 ==> Load method *bar.Main
2025/12/19 11:09:24 NewFunc MainEntry (*index) func()
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Member vim 1 // *index
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Member Gop_Exec 0 // *index
2025/12/19 11:09:24 Val &{0 STRING "vim"} *ast.BasicLit
2025/12/19 11:09:24 Val &{0 STRING "a.txt"} *ast.BasicLit
2025/12/19 11:09:24 Call 2 0 // func(name string, args ...any)
2025/12/19 11:09:24 ==> MatchFuncCall func(name string, args ...any) args: 2 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped string ("vim"), string
2025/12/19 11:09:24 ==> MatchType untyped string ("a.txt"), any
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Member vim 1 // *index
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Member Gop_Exec 0 // *index
2025/12/19 11:09:24 Val vim string
2025/12/19 11:09:24 Call 1 0 // func(name string, args ...any)
2025/12/19 11:09:24 ==> MatchFuncCall func(name string, args ...any) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped string ("vim"), string
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Member ls 1 // *index
2025/12/19 11:09:24 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:24 Call 1 0 // func(n int)
2025/12/19 11:09:24 ==> MatchFuncCall func(n int) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped int (10), int
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Member capout 1 // *index
2025/12/19 11:09:24 NewClosure func()
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Member ls 1 // *index
2025/12/19 11:09:24 Call 0 0 // func(n int)
2025/12/19 11:09:24 ==> MatchFuncCall func(n int) args: 0 flags: 0
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Member Gop_Exec 0 // *index
2025/12/19 11:09:24 Val ls string
2025/12/19 11:09:24 Call 1 0 // func(name string, args ...any)
2025/12/19 11:09:24 ==> MatchFuncCall func(name string, args ...any) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped string ("ls"), string
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 Call 1 0 // func(doSth func()) (string, error)
2025/12/19 11:09:24 ==> MatchFuncCall func(doSth func()) (string, error) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType func(), func()
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Member capout 1 // *index
2025/12/19 11:09:24 NewClosure func()
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Member ls 1 // *index
2025/12/19 11:09:24 Val &{0 STRING "-l"} *ast.BasicLit
2025/12/19 11:09:24 Call 1 0 // func(n int)
2025/12/19 11:09:24 ==> MatchFuncCall func(n int) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped string ("-l"), int
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Member Gop_Exec 0 // *index
2025/12/19 11:09:24 Val ls string
2025/12/19 11:09:24 Val &{0 STRING "-l"} *ast.BasicLit
2025/12/19 11:09:24 Call 2 0 // func(name string, args ...any)
2025/12/19 11:09:24 ==> MatchFuncCall func(name string, args ...any) args: 2 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped string ("ls"), string
2025/12/19 11:09:24 ==> MatchType untyped string ("-l"), any
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 Call 1 0 // func(doSth func()) (string, error)
2025/12/19 11:09:24 ==> MatchFuncCall func(doSth func()) (string, error) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType func(), func()
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*index) func()
2025/12/19 11:09:24 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/12/19 11:09:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Call 1 0 // func(game any)
2025/12/19 11:09:24 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType *index, any
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*bar) func()
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc main func()
2025/12/19 11:09:24 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 Val index index
2025/12/19 11:09:24 Val type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ index
2025/12/19 11:09:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:24 Member Main 0 // *index
2025/12/19 11:09:24 Call 0 0 // func()
2025/12/19 11:09:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 ==> ASTFile
--- PASS: TestSpxGopExec (0.00s)
    --- PASS: TestSpxGopExec/gopSpxTest (0.00s)
=== RUN   TestSpxMethod
=== RUN   TestSpxMethod/gopSpxTest
2025/12/19 11:09:24 ==> ClassFile /foo/Game.tgmx
2025/12/19 11:09:24 ==> InitClass Game isProj: true
2025/12/19 11:09:24 ==> ClassFile /foo/bar.tspx
2025/12/19 11:09:24 ==> InitClass bar isProj: false
2025/12/19 11:09:24 ==> Preload type Game
2025/12/19 11:09:24 ==> Preload method Game.onInit
2025/12/19 11:09:24 ==> Preload method Game.MainEntry
2025/12/19 11:09:24 ==> Preload type bar
2025/12/19 11:09:24 ==> Preload method bar.onInit
2025/12/19 11:09:24 ==> Preload method bar.Main
2025/12/19 11:09:24 ==> Load > NewType Game
2025/12/19 11:09:24 NewType Game
2025/12/19 11:09:24 ==> Load > NewType bar
2025/12/19 11:09:24 NewType bar
2025/12/19 11:09:24 ==> Load > InitType Game
2025/12/19 11:09:24 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 ==> Load method *Game.onInit
2025/12/19 11:09:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 ==> Load method *Game.MainEntry
2025/12/19 11:09:24 ==> Load > InitType bar
2025/12/19 11:09:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 InitType bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:24 ==> LookupParent bar => type bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:24 ==> Load method *bar.onInit
2025/12/19 11:09:24 ==> LookupParent bar => type bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:24 ==> Load method *bar.Main
2025/12/19 11:09:24 NewFunc onInit (*Game) func()
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Member sched 1 // *Game
2025/12/19 11:09:24 Val Sched func()
2025/12/19 11:09:24 Call 0 0 // func()
2025/12/19 11:09:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Member broadcast 1 // *Game
2025/12/19 11:09:24 Val &{0 STRING "msg1"} *ast.BasicLit
2025/12/19 11:09:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall func(msg string) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped string ("msg1"), string
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Member TestIntValue -1 // *Game
2025/12/19 11:09:24 VarRef TestIntValue int
2025/12/19 11:09:24 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:24 Assign 1 1
2025/12/19 11:09:24 ==> MatchType untyped int (1), int
2025/12/19 11:09:24 DefineVarStart [x]
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Member round 1 // *Game
2025/12/19 11:09:24 Val Round func(x float64) float64
2025/12/19 11:09:24 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/12/19 11:09:24 Call 1 0 // func(x float64) float64
2025/12/19 11:09:24 ==> MatchFuncCall func(x float64) float64 args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped float (1.2), float64
2025/12/19 11:09:24 EndInit 1
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*Game) func()
2025/12/19 11:09:24 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/12/19 11:09:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Call 1 0 // func(game any)
2025/12/19 11:09:24 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType *Game, any
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc onInit (*bar) func()
2025/12/19 11:09:24 Val this *bar
2025/12/19 11:09:24 Member setCostume 1 // *bar
2025/12/19 11:09:24 Val &{0 STRING "kai-a"} *ast.BasicLit
2025/12/19 11:09:24 Call 1 0 // func(costume any)
2025/12/19 11:09:24 ==> MatchFuncCall func(costume any) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped string ("kai-a"), any
2025/12/19 11:09:24 Val this *bar
2025/12/19 11:09:24 Member play 1 // *bar
2025/12/19 11:09:24 Val &{0 STRING "recordingWhere"} *ast.BasicLit
2025/12/19 11:09:24 Call 1 0 // func(media string, wait ...bool)
2025/12/19 11:09:24 ==> MatchFuncCall func(media string, wait ...bool) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped string ("recordingWhere"), string
2025/12/19 11:09:24 Val this *bar
2025/12/19 11:09:24 Member say 1 // *bar
2025/12/19 11:09:24 Val &{0 STRING "Where do you come from?"} *ast.BasicLit
2025/12/19 11:09:24 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:24 Call 2 0 // func(msg string, secs ...float64)
2025/12/19 11:09:24 ==> MatchFuncCall func(msg string, secs ...float64) args: 2 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped string ("Where do you come from?"), string
2025/12/19 11:09:24 ==> MatchType untyped int (2), float64
2025/12/19 11:09:24 Val this *bar
2025/12/19 11:09:24 Member broadcast 1 // *bar
2025/12/19 11:09:24 Val &{0 STRING "msg2"} *ast.BasicLit
2025/12/19 11:09:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall func(msg string) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped string ("msg2"), string
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*bar) func()
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc main func()
2025/12/19 11:09:24 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 Val Game Game
2025/12/19 11:09:24 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ Game
2025/12/19 11:09:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:24 Member Main 0 // *Game
2025/12/19 11:09:24 Call 0 0 // func()
2025/12/19 11:09:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 ==> ASTFile
--- PASS: TestSpxMethod (0.00s)
    --- PASS: TestSpxMethod/gopSpxTest (0.00s)
=== RUN   TestSpxVar
=== RUN   TestSpxVar/gopSpxTest
2025/12/19 11:09:24 ==> ClassFile /foo/Game.tgmx
2025/12/19 11:09:24 ==> InitClass Game isProj: true
2025/12/19 11:09:24 ==> ClassFile /foo/Kai.tspx
2025/12/19 11:09:24 ==> InitClass Kai isProj: false
2025/12/19 11:09:24 ==> Preload type Game
2025/12/19 11:09:24 ==> Preload method Game.onInit
2025/12/19 11:09:24 ==> Preload method Game.MainEntry
2025/12/19 11:09:24 ==> Preload type Kai
2025/12/19 11:09:24 ==> Preload method Kai.onInit
2025/12/19 11:09:24 ==> Preload method Kai.onCloned
2025/12/19 11:09:24 ==> Preload method Kai.Main
2025/12/19 11:09:24 ==> Load > NewType Game
2025/12/19 11:09:24 NewType Game
2025/12/19 11:09:24 ==> Load > NewType Kai
2025/12/19 11:09:24 NewType Kai
2025/12/19 11:09:24 ==> Load > InitType Game
2025/12/19 11:09:24 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:24 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/12/19 11:09:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/12/19 11:09:24 ==> Load method *Game.onInit
2025/12/19 11:09:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/12/19 11:09:24 ==> Load method *Game.MainEntry
2025/12/19 11:09:24 ==> Load > InitType Kai
2025/12/19 11:09:24 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/12/19 11:09:24 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; a int}
2025/12/19 11:09:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; a int}
2025/12/19 11:09:24 ==> Load method *Kai.onInit
2025/12/19 11:09:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; a int}
2025/12/19 11:09:24 ==> Load method *Kai.onCloned
2025/12/19 11:09:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; a int}
2025/12/19 11:09:24 ==> Load method *Kai.Main
2025/12/19 11:09:24 NewFunc onInit (*Game) func()
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Member Kai 2 // *Game
2025/12/19 11:09:24 Member clone 1 // Kai
2025/12/19 11:09:24 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 ==> MatchFuncCall TyTemplateRecvMethod args: 0 flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 16
2025/12/19 11:09:24 ==> MatchFuncCall func(sprite any) args: 1 flags: 16
2025/12/19 11:09:24 ==> MatchType Kai, any
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Member broadcast 1 // *Game
2025/12/19 11:09:24 Val &{0 STRING "msg1"} *ast.BasicLit
2025/12/19 11:09:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall func(msg string) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped string ("msg1"), string
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*Game) func()
2025/12/19 11:09:24 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/12/19 11:09:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Call 1 0 // func(game any)
2025/12/19 11:09:24 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType *Game, any
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc onInit (*Kai) func()
2025/12/19 11:09:24 Val this *Kai
2025/12/19 11:09:24 Member a -1 // *Kai
2025/12/19 11:09:24 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:24 Assign 1 1
2025/12/19 11:09:24 ==> MatchType untyped int (1), int
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc onCloned (*Kai) func()
2025/12/19 11:09:24 Val this *Kai
2025/12/19 11:09:24 Member say 1 // *Kai
2025/12/19 11:09:24 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:24 Call 1 0 // func(msg string, secs ...float64)
2025/12/19 11:09:24 ==> MatchFuncCall func(msg string, secs ...float64) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped string ("Hi"), string
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*Kai) func()
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc main func()
2025/12/19 11:09:24 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 Val Game Game
2025/12/19 11:09:24 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai} => Typ Game
2025/12/19 11:09:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:24 Member Main 0 // *Game
2025/12/19 11:09:24 Call 0 0 // func()
2025/12/19 11:09:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 ==> ASTFile
--- PASS: TestSpxVar (0.00s)
    --- PASS: TestSpxVar/gopSpxTest (0.00s)
=== RUN   TestSpxRun
=== RUN   TestSpxRun/gopSpxTest
2025/12/19 11:09:24 ==> ClassFile /foo/Kai.tspx
2025/12/19 11:09:24 ==> InitClass Kai isProj: false
2025/12/19 11:09:24 ==> ClassFile /foo/index.tgmx
2025/12/19 11:09:24 ==> InitClass index isProj: true
2025/12/19 11:09:24 ==> Preload type Kai
2025/12/19 11:09:24 ==> Preload method Kai.Main
2025/12/19 11:09:24 ==> Preload type index
2025/12/19 11:09:24 ==> Preload var [x]
2025/12/19 11:09:24 ==> Preload method index.MainEntry
2025/12/19 11:09:24 ==> Load > NewType Kai
2025/12/19 11:09:24 NewType Kai
2025/12/19 11:09:24 ==> Load > NewType index
2025/12/19 11:09:24 NewType index
2025/12/19 11:09:24 ==> Load var float64 [x]
2025/12/19 11:09:24 NewVarDefs
2025/12/19 11:09:24 NewVar [x]
2025/12/19 11:09:24 Val Rand func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/12/19 11:09:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall func(int) int args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped float (1.2), int
2025/12/19 11:09:24 ==> MatchFuncCall func(float64) float64 args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped float (1.2), float64
2025/12/19 11:09:24 EndInit 1
2025/12/19 11:09:24 ==> MatchType float64, float64
2025/12/19 11:09:24 ==> Load > InitType index
2025/12/19 11:09:24 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:24 InitType index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; t github.com/goplus/xgo/cl/internal/spx.Sound}
2025/12/19 11:09:24 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; t github.com/goplus/xgo/cl/internal/spx.Sound}
2025/12/19 11:09:24 ==> Load method *index.MainEntry
2025/12/19 11:09:24 ==> Load > InitType Kai
2025/12/19 11:09:24 ==> LookupParent index => type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; t github.com/goplus/xgo/cl/internal/spx.Sound}
2025/12/19 11:09:24 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *index}
2025/12/19 11:09:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *index}
2025/12/19 11:09:24 ==> Load method *Kai.Main
2025/12/19 11:09:24 NewFunc MainEntry (*index) func()
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Member run 1 // *index
2025/12/19 11:09:24 Val &{0 STRING "hzip://open.qiniu.us/weather/res.zip"} *ast.BasicLit
2025/12/19 11:09:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 ==> MatchFuncCall TyTemplateRecvMethod args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall func(game any, resource string) error args: 2 flags: 16
2025/12/19 11:09:24 ==> MatchType *index, any
2025/12/19 11:09:24 ==> MatchType untyped string ("hzip://open.qiniu.us/weather/res.zip"), string
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*index) func()
2025/12/19 11:09:24 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/12/19 11:09:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:24 Val this *index
2025/12/19 11:09:24 Call 1 0 // func(game any)
2025/12/19 11:09:24 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType *index, any
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*Kai) func()
2025/12/19 11:09:24 Val this *Kai
2025/12/19 11:09:24 Member println 1 // *Kai
2025/12/19 11:09:24 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped string ("Hi"), any
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc main func()
2025/12/19 11:09:24 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 Val index index
2025/12/19 11:09:24 Val type index struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai; t github.com/goplus/xgo/cl/internal/spx.Sound} => Typ index
2025/12/19 11:09:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:24 Member Main 0 // *index
2025/12/19 11:09:24 Call 0 0 // func()
2025/12/19 11:09:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 ==> ASTFile
--- PASS: TestSpxRun (0.00s)
    --- PASS: TestSpxRun/gopSpxTest (0.00s)
=== RUN   TestSpx2
=== RUN   TestSpx2/gopSpxTest
2025/12/19 11:09:24 ==> ClassFile /foo/Game.t2gmx
2025/12/19 11:09:24 ==> InitClass Game isProj: true
2025/12/19 11:09:24 ==> ClassFile /foo/Kai.t2spx
2025/12/19 11:09:24 ==> InitClass Kai isProj: false
2025/12/19 11:09:24 ==> Preload type Game
2025/12/19 11:09:24 ==> Preload method Game.MainEntry
2025/12/19 11:09:24 ==> Preload type Kai
2025/12/19 11:09:24 ==> Preload method Kai.onMsg
2025/12/19 11:09:24 ==> Preload method Kai.Main
2025/12/19 11:09:24 ==> Load > NewType Game
2025/12/19 11:09:24 NewType Game
2025/12/19 11:09:24 ==> Load > NewType Kai
2025/12/19 11:09:24 NewType Kai
2025/12/19 11:09:24 ==> Load > InitType Game
2025/12/19 11:09:24 InitType Game struct{github.com/goplus/xgo/cl/internal/spx2.Game}
2025/12/19 11:09:24 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game}
2025/12/19 11:09:24 ==> Load method *Game.MainEntry
2025/12/19 11:09:24 ==> Load > InitType Kai
2025/12/19 11:09:24 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game}
2025/12/19 11:09:24 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx2.Sprite; *Game}
2025/12/19 11:09:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx2.Sprite; *Game}
2025/12/19 11:09:24 ==> Load method *Kai.onMsg
2025/12/19 11:09:24 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx2.Sprite; *Game}
2025/12/19 11:09:24 ==> Load method *Kai.Main
2025/12/19 11:09:24 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Member println 1 // *Game
2025/12/19 11:09:24 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType untyped string ("Hi"), any
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*Game) func()
2025/12/19 11:09:24 Typ github.com/goplus/xgo/cl/internal/spx2.Game
2025/12/19 11:09:24 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx2.Game}
2025/12/19 11:09:24 Val this *Game
2025/12/19 11:09:24 Member Game -1 // *Game
2025/12/19 11:09:24 UnaryOp & flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:24 Call 1 0 // func(*github.com/goplus/xgo/cl/internal/spx2.Game)
2025/12/19 11:09:24 ==> MatchFuncCall func(*github.com/goplus/xgo/cl/internal/spx2.Game) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType *github.com/goplus/xgo/cl/internal/spx2.Game, *github.com/goplus/xgo/cl/internal/spx2.Game
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc onMsg (*Kai) func(msg string)
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc Main (*Kai) func()
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 NewFunc main func()
2025/12/19 11:09:24 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 Val Game Game
2025/12/19 11:09:24 Val type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game} => Typ Game
2025/12/19 11:09:24 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:24 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:24 Member Main 0 // *Game
2025/12/19 11:09:24 Call 0 0 // func()
2025/12/19 11:09:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 ==> ASTFile
--- PASS: TestSpx2 (0.01s)
    --- PASS: TestSpx2/gopSpxTest (0.01s)
=== RUN   TestSpxMainEntry
=== RUN   TestSpxMainEntry/Nocode
2025/12/19 11:09:24 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:24 ==> NewOverloadFunc NewRange
2025/12/19 11:09:25 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:25 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:25 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:25 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:25 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:25 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:25 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:25 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:25 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:25 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:25 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:25 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:25 ==> ClassFile /foo/Game.t2gmx
2025/12/19 11:09:25 ==> InitClass Game isProj: true
2025/12/19 11:09:25 ==> ClassFile /foo/Kai.t2spx
2025/12/19 11:09:25 ==> InitClass Kai isProj: false
2025/12/19 11:09:25 ==> Preload type Game
2025/12/19 11:09:25 ==> Preload method Game.MainEntry
2025/12/19 11:09:25 ==> Preload type Kai
2025/12/19 11:09:25 ==> Preload method Kai.Main
2025/12/19 11:09:25 ==> Load > NewType Game
2025/12/19 11:09:25 NewType Game
2025/12/19 11:09:25 ==> Load > NewType Kai
2025/12/19 11:09:25 NewType Kai
2025/12/19 11:09:25 ==> Load > InitType Game
2025/12/19 11:09:25 InitType Game struct{github.com/goplus/xgo/cl/internal/spx2.Game}
2025/12/19 11:09:25 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game}
2025/12/19 11:09:25 ==> Load method *Game.MainEntry
2025/12/19 11:09:25 ==> Load > InitType Kai
2025/12/19 11:09:25 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game}
2025/12/19 11:09:25 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx2.Sprite; *Game}
2025/12/19 11:09:25 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx2.Sprite; *Game}
2025/12/19 11:09:25 ==> Load method *Kai.Main
2025/12/19 11:09:25 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:25 End // Func
2025/12/19 11:09:25 NewFunc Main (*Game) func()
2025/12/19 11:09:25 Typ github.com/goplus/xgo/cl/internal/spx2.Game
2025/12/19 11:09:25 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx2.Game}
2025/12/19 11:09:25 Val this *Game
2025/12/19 11:09:25 Member Game -1 // *Game
2025/12/19 11:09:25 UnaryOp & flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:25 Call 1 0 // func(*github.com/goplus/xgo/cl/internal/spx2.Game)
2025/12/19 11:09:25 ==> MatchFuncCall func(*github.com/goplus/xgo/cl/internal/spx2.Game) args: 1 flags: 0
2025/12/19 11:09:25 ==> MatchType *github.com/goplus/xgo/cl/internal/spx2.Game, *github.com/goplus/xgo/cl/internal/spx2.Game
2025/12/19 11:09:25 End // Func
2025/12/19 11:09:25 NewFunc Main (*Kai) func()
2025/12/19 11:09:25 End // Func
2025/12/19 11:09:25 NewFunc main func()
2025/12/19 11:09:25 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:25 Val Game Game
2025/12/19 11:09:25 Val type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game} => Typ Game
2025/12/19 11:09:25 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:25 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:25 Member Main 0 // *Game
2025/12/19 11:09:25 Call 0 0 // func()
2025/12/19 11:09:25 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:25 End // Func
2025/12/19 11:09:25 ==> ASTFile
=== RUN   TestSpxMainEntry/OnlyGmx
2025/12/19 11:09:26 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:26 ==> NewOverloadFunc NewRange
2025/12/19 11:09:26 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:26 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:26 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:26 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:26 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:26 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:26 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:26 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:26 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:26 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:26 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:26 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:26 ==> ClassFile /foo/Game.t2gmx
2025/12/19 11:09:26 ==> InitClass Game isProj: true
2025/12/19 11:09:26 ==> ClassFile /foo/Kai.t2spx
2025/12/19 11:09:26 ==> InitClass Kai isProj: false
2025/12/19 11:09:26 ==> Preload type Game
2025/12/19 11:09:26 ==> Preload method Game.MainEntry
2025/12/19 11:09:26 ==> Preload type Kai
2025/12/19 11:09:26 ==> Preload method Kai.Main
2025/12/19 11:09:26 ==> Load > NewType Game
2025/12/19 11:09:26 NewType Game
2025/12/19 11:09:26 ==> Load > NewType Kai
2025/12/19 11:09:26 NewType Kai
2025/12/19 11:09:26 ==> Load > InitType Game
2025/12/19 11:09:26 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:26 InitType Game struct{github.com/goplus/xgo/cl/internal/spx2.Game; Kai Kai}
2025/12/19 11:09:26 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game; Kai Kai}
2025/12/19 11:09:26 ==> Load method *Game.MainEntry
2025/12/19 11:09:26 ==> Load > InitType Kai
2025/12/19 11:09:26 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game; Kai Kai}
2025/12/19 11:09:26 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx2.Sprite; *Game}
2025/12/19 11:09:26 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx2.Sprite; *Game}
2025/12/19 11:09:26 ==> Load method *Kai.Main
2025/12/19 11:09:26 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:26 End // Func
2025/12/19 11:09:26 NewFunc Main (*Game) func()
2025/12/19 11:09:26 Typ github.com/goplus/xgo/cl/internal/spx2.Game
2025/12/19 11:09:26 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx2.Game}
2025/12/19 11:09:26 Val this *Game
2025/12/19 11:09:26 Member Game -1 // *Game
2025/12/19 11:09:26 UnaryOp & flags: 0
2025/12/19 11:09:26 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:26 Call 1 0 // func(*github.com/goplus/xgo/cl/internal/spx2.Game)
2025/12/19 11:09:26 ==> MatchFuncCall func(*github.com/goplus/xgo/cl/internal/spx2.Game) args: 1 flags: 0
2025/12/19 11:09:26 ==> MatchType *github.com/goplus/xgo/cl/internal/spx2.Game, *github.com/goplus/xgo/cl/internal/spx2.Game
2025/12/19 11:09:26 End // Func
2025/12/19 11:09:26 NewFunc Main (*Kai) func()
2025/12/19 11:09:26 End // Func
2025/12/19 11:09:26 NewFunc main func()
2025/12/19 11:09:26 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:26 Val Game Game
2025/12/19 11:09:26 Val type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game; Kai Kai} => Typ Game
2025/12/19 11:09:26 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:26 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:26 Member Main 0 // *Game
2025/12/19 11:09:26 Call 0 0 // func()
2025/12/19 11:09:26 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:26 End // Func
2025/12/19 11:09:26 ==> ASTFile
=== RUN   TestSpxMainEntry/KaiAndGmx
2025/12/19 11:09:27 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:27 ==> NewOverloadFunc NewRange
2025/12/19 11:09:27 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:27 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:27 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:27 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:27 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:27 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:27 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:27 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:27 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:27 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:27 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:27 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:27 ==> ClassFile /foo/Game.t2gmx
2025/12/19 11:09:27 ==> InitClass Game isProj: true
2025/12/19 11:09:27 ==> ClassFile /foo/Kai.t2spx
2025/12/19 11:09:27 ==> InitClass Kai isProj: false
2025/12/19 11:09:27 ==> Preload type Game
2025/12/19 11:09:27 ==> Preload method Game.MainEntry
2025/12/19 11:09:27 ==> Preload type Kai
2025/12/19 11:09:27 ==> Preload method Kai.Main
2025/12/19 11:09:27 ==> Preload method Kai.onMsg
2025/12/19 11:09:27 ==> Load > NewType Game
2025/12/19 11:09:27 NewType Game
2025/12/19 11:09:27 ==> Load > NewType Kai
2025/12/19 11:09:27 NewType Kai
2025/12/19 11:09:27 ==> Load > InitType Game
2025/12/19 11:09:27 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:27 InitType Game struct{github.com/goplus/xgo/cl/internal/spx2.Game; Kai Kai}
2025/12/19 11:09:27 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game; Kai Kai}
2025/12/19 11:09:27 ==> Load method *Game.MainEntry
2025/12/19 11:09:27 ==> Load > InitType Kai
2025/12/19 11:09:27 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game; Kai Kai}
2025/12/19 11:09:27 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx2.Sprite; *Game}
2025/12/19 11:09:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx2.Sprite; *Game}
2025/12/19 11:09:27 ==> Load method *Kai.Main
2025/12/19 11:09:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx2.Sprite; *Game}
2025/12/19 11:09:27 ==> Load method *Kai.onMsg
2025/12/19 11:09:27 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:27 Val this *Game
2025/12/19 11:09:27 Member println 1 // *Game
2025/12/19 11:09:27 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType untyped string ("Hi"), any
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc Main (*Game) func()
2025/12/19 11:09:27 Typ github.com/goplus/xgo/cl/internal/spx2.Game
2025/12/19 11:09:27 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx2.Game}
2025/12/19 11:09:27 Val this *Game
2025/12/19 11:09:27 Member Game -1 // *Game
2025/12/19 11:09:27 UnaryOp & flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:27 Call 1 0 // func(*github.com/goplus/xgo/cl/internal/spx2.Game)
2025/12/19 11:09:27 ==> MatchFuncCall func(*github.com/goplus/xgo/cl/internal/spx2.Game) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType *github.com/goplus/xgo/cl/internal/spx2.Game, *github.com/goplus/xgo/cl/internal/spx2.Game
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc Main (*Kai) func()
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member println 1 // *Kai
2025/12/19 11:09:27 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType untyped string ("Hello"), any
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc onMsg (*Kai) func(msg string)
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc main func()
2025/12/19 11:09:27 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:27 Val Game Game
2025/12/19 11:09:27 Val type Game struct{github.com/goplus/xgo/cl/internal/spx2.Game; Kai Kai} => Typ Game
2025/12/19 11:09:27 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:27 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:27 Member Main 0 // *Game
2025/12/19 11:09:27 Call 0 0 // func()
2025/12/19 11:09:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 ==> ASTFile
--- PASS: TestSpxMainEntry (3.31s)
    --- PASS: TestSpxMainEntry/Nocode (1.10s)
    --- PASS: TestSpxMainEntry/OnlyGmx (1.11s)
    --- PASS: TestSpxMainEntry/KaiAndGmx (1.09s)
=== RUN   TestSpxGoxBasic
=== RUN   TestSpxGoxBasic/gopSpxTest
2025/12/19 11:09:27 ==> ClassFile /foo/Game.tgmx
2025/12/19 11:09:27 ==> InitClass Game isProj: true
2025/12/19 11:09:27 ==> ClassFile /foo/Kai.tspx
2025/12/19 11:09:27 ==> InitClass Kai isProj: false
2025/12/19 11:09:27 ==> Preload type Game
2025/12/19 11:09:27 ==> Preload method Game.onInit
2025/12/19 11:09:27 ==> Preload method Game.MainEntry
2025/12/19 11:09:27 ==> Preload type Kai
2025/12/19 11:09:27 ==> Preload method Kai.onMsg
2025/12/19 11:09:27 ==> Preload method Kai.Main
2025/12/19 11:09:27 ==> Load > NewType Game
2025/12/19 11:09:27 NewType Game
2025/12/19 11:09:27 ==> Load > NewType Kai
2025/12/19 11:09:27 NewType Kai
2025/12/19 11:09:27 ==> Load > InitType Game
2025/12/19 11:09:27 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 ==> Load method *Game.onInit
2025/12/19 11:09:27 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 ==> Load method *Game.MainEntry
2025/12/19 11:09:27 ==> Load > InitType Kai
2025/12/19 11:09:27 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:27 ==> Load method *Kai.onMsg
2025/12/19 11:09:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:27 ==> Load method *Kai.Main
2025/12/19 11:09:27 NewFunc onInit (*Game) func()
2025/12/19 11:09:27 For
2025/12/19 11:09:27 None
2025/12/19 11:09:27 Then
2025/12/19 11:09:27 Val Sched func()
2025/12/19 11:09:27 Call 0 0 // func()
2025/12/19 11:09:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:27 Val SchedNow func()
2025/12/19 11:09:27 Call 0 0 // func()
2025/12/19 11:09:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:27 End // For
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc Main (*Game) func()
2025/12/19 11:09:27 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/12/19 11:09:27 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 Val this *Game
2025/12/19 11:09:27 Call 1 0 // func(game any)
2025/12/19 11:09:27 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType *Game, any
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc onMsg (*Kai) func(msg string)
2025/12/19 11:09:27 For
2025/12/19 11:09:27 None
2025/12/19 11:09:27 Then
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member say 1 // *Kai
2025/12/19 11:09:27 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:27 Call 1 0 // func(msg string, secs ...float64)
2025/12/19 11:09:27 ==> MatchFuncCall func(msg string, secs ...float64) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType untyped string ("Hi"), string
2025/12/19 11:09:27 End // For
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc Main (*Kai) func()
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc main func()
2025/12/19 11:09:27 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:27 Val Game Game
2025/12/19 11:09:27 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ Game
2025/12/19 11:09:27 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:27 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:27 Member Main 0 // *Game
2025/12/19 11:09:27 Call 0 0 // func()
2025/12/19 11:09:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 ==> ASTFile
--- PASS: TestSpxGoxBasic (0.00s)
    --- PASS: TestSpxGoxBasic/gopSpxTest (0.00s)
=== RUN   TestSpxClone
=== RUN   TestSpxClone/gopSpxTest
2025/12/19 11:09:27 ==> ClassFile /foo/Game.tgmx
2025/12/19 11:09:27 ==> InitClass Game isProj: true
2025/12/19 11:09:27 ==> ClassFile /foo/Kai.tspx
2025/12/19 11:09:27 ==> InitClass Kai isProj: false
2025/12/19 11:09:27 ==> Preload type Game
2025/12/19 11:09:27 ==> Preload method Game.onInit
2025/12/19 11:09:27 ==> Preload method Game.MainEntry
2025/12/19 11:09:27 ==> Preload type Kai
2025/12/19 11:09:27 ==> Preload type info
2025/12/19 11:09:27 ==> Preload method Kai.onInit
2025/12/19 11:09:27 ==> Preload method Kai.onCloned
2025/12/19 11:09:27 ==> Preload method Kai.Main
2025/12/19 11:09:27 ==> Load > NewType Game
2025/12/19 11:09:27 NewType Game
2025/12/19 11:09:27 ==> Load > NewType Kai
2025/12/19 11:09:27 NewType Kai
2025/12/19 11:09:27 ==> Load > InitType Game
2025/12/19 11:09:27 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:27 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/12/19 11:09:27 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/12/19 11:09:27 ==> Load method *Game.onInit
2025/12/19 11:09:27 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/12/19 11:09:27 ==> Load method *Game.MainEntry
2025/12/19 11:09:27 ==> Load > NewType info
2025/12/19 11:09:27 NewType info
2025/12/19 11:09:27 ==> Load > InitType info
2025/12/19 11:09:27 InitType info struct{x int; y int}
2025/12/19 11:09:27 ==> Load > InitType Kai
2025/12/19 11:09:27 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/12/19 11:09:27 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; a int}
2025/12/19 11:09:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; a int}
2025/12/19 11:09:27 ==> Load method *Kai.onInit
2025/12/19 11:09:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; a int}
2025/12/19 11:09:27 ==> Load method *Kai.onCloned
2025/12/19 11:09:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; a int}
2025/12/19 11:09:27 ==> Load method *Kai.Main
2025/12/19 11:09:27 NewFunc onInit (*Game) func()
2025/12/19 11:09:27 Val this *Game
2025/12/19 11:09:27 Member Kai 2 // *Game
2025/12/19 11:09:27 Member clone 1 // Kai
2025/12/19 11:09:27 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyTemplateRecvMethod args: 0 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any) args: 1 flags: 16
2025/12/19 11:09:27 ==> MatchType Kai, any
2025/12/19 11:09:27 Val this *Game
2025/12/19 11:09:27 Member broadcast 1 // *Game
2025/12/19 11:09:27 Val &{0 STRING "msg1"} *ast.BasicLit
2025/12/19 11:09:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall func(msg string) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType untyped string ("msg1"), string
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc Main (*Game) func()
2025/12/19 11:09:27 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/12/19 11:09:27 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 Val this *Game
2025/12/19 11:09:27 Call 1 0 // func(game any)
2025/12/19 11:09:27 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType *Game, any
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc onInit (*Kai) func()
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member a -1 // *Kai
2025/12/19 11:09:27 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:27 Assign 1 1
2025/12/19 11:09:27 ==> MatchType untyped int (1), int
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member clone 1 // *Kai
2025/12/19 11:09:27 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyTemplateRecvMethod args: 0 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any) args: 1 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member clone 1 // *Kai
2025/12/19 11:09:27 ==> LookupParent info => type info struct{x int; y int}
2025/12/19 11:09:27 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:27 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:27 StructLit info 2 false
2025/12/19 11:09:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyTemplateRecvMethod args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any) args: 2 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, data any) args: 2 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType info, any
2025/12/19 11:09:27 ==> EnsureLoaded info
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member clone 1 // *Kai
2025/12/19 11:09:27 ==> LookupParent info => type info struct{x int; y int}
2025/12/19 11:09:27 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:27 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:27 StructLit info 2 false
2025/12/19 11:09:27 UnaryOp & flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyTemplateRecvMethod args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any) args: 2 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, data any) args: 2 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType *info, any
2025/12/19 11:09:27 ==> EnsureLoaded info
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc onCloned (*Kai) func()
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member say 1 // *Kai
2025/12/19 11:09:27 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:27 Call 1 0 // func(msg string, secs ...float64)
2025/12/19 11:09:27 ==> MatchFuncCall func(msg string, secs ...float64) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType untyped string ("Hi"), string
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc Main (*Kai) func()
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc main func()
2025/12/19 11:09:27 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:27 Val Game Game
2025/12/19 11:09:27 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai} => Typ Game
2025/12/19 11:09:27 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:27 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:27 Member Main 0 // *Game
2025/12/19 11:09:27 Call 0 0 // func()
2025/12/19 11:09:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 ==> ASTFile
--- PASS: TestSpxClone (0.00s)
    --- PASS: TestSpxClone/gopSpxTest (0.00s)
=== RUN   TestSpxErrorSel
2025/12/19 11:09:27 ==> ClassFile /foo/Game.tgmx
2025/12/19 11:09:27 ==> InitClass Game isProj: true
2025/12/19 11:09:27 ==> ClassFile /foo/Kai.tspx
2025/12/19 11:09:27 ==> InitClass Kai isProj: false
2025/12/19 11:09:27 ==> Preload type Game
2025/12/19 11:09:27 ==> Preload method Game.MainEntry
2025/12/19 11:09:27 ==> Preload type Kai
2025/12/19 11:09:27 ==> Preload method Kai.Main
2025/12/19 11:09:27 ==> Load > NewType Game
2025/12/19 11:09:27 NewType Game
2025/12/19 11:09:27 ==> Load > NewType Kai
2025/12/19 11:09:27 NewType Kai
2025/12/19 11:09:27 ==> Load > InitType Game
2025/12/19 11:09:27 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 ==> Load method *Game.MainEntry
2025/12/19 11:09:27 ==> Load > InitType Kai
2025/12/19 11:09:27 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:27 ==> Load method *Kai.Main
2025/12/19 11:09:27 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:27 SetComments 0
//line Game.tgmx:2:1
2025/12/19 11:09:27 Val this *Game
2025/12/19 11:09:27 Member println 1 // *Game
2025/12/19 11:09:27 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 Val &{0 STRING "hi"} *ast.BasicLit
2025/12/19 11:09:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType untyped string ("hi"), any
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc Main (*Game) func()
2025/12/19 11:09:27 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/12/19 11:09:27 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 Val this *Game
2025/12/19 11:09:27 Call 1 0 // func(game any)
2025/12/19 11:09:27 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType *Game, any
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc Main (*Kai) func()
2025/12/19 11:09:27 SetComments 0
//line Kai.tspx:2:1
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member println 1 // *Kai
2025/12/19 11:09:27 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member pos 2 // *Kai
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member Gop_Exec 0 // *Kai
2025/12/19 11:09:27 Val println string
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member pos 2 // *Kai
2025/12/19 11:09:27 ResetStmt
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc main func()
2025/12/19 11:09:27 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:27 Val Game Game
2025/12/19 11:09:27 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ Game
2025/12/19 11:09:27 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:27 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:27 Member Main 0 // *Game
2025/12/19 11:09:27 Call 0 0 // func()
2025/12/19 11:09:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:27 End // Func
--- PASS: TestSpxErrorSel (0.00s)
=== RUN   TestSpxMethodSel
=== RUN   TestSpxMethodSel/gopSpxTest
2025/12/19 11:09:27 ==> ClassFile /foo/Game.tgmx
2025/12/19 11:09:27 ==> InitClass Game isProj: true
2025/12/19 11:09:27 ==> ClassFile /foo/Kai.tspx
2025/12/19 11:09:27 ==> InitClass Kai isProj: false
2025/12/19 11:09:27 ==> Preload type Game
2025/12/19 11:09:27 ==> Preload method Game.MainEntry
2025/12/19 11:09:27 ==> Preload type Kai
2025/12/19 11:09:27 ==> Preload method Kai.onMsg
2025/12/19 11:09:27 ==> Preload method Kai.Main
2025/12/19 11:09:27 ==> Load > NewType Game
2025/12/19 11:09:27 NewType Game
2025/12/19 11:09:27 ==> Load > NewType Kai
2025/12/19 11:09:27 NewType Kai
2025/12/19 11:09:27 ==> Load > InitType Game
2025/12/19 11:09:27 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 ==> Load method *Game.MainEntry
2025/12/19 11:09:27 ==> Load > InitType Kai
2025/12/19 11:09:27 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:27 ==> Load method *Kai.onMsg
2025/12/19 11:09:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:27 ==> Load method *Kai.Main
2025/12/19 11:09:27 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:27 Val this *Game
2025/12/19 11:09:27 Member sendMessage 1 // *Game
2025/12/19 11:09:27 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:27 Call 1 0 // func(data any)
2025/12/19 11:09:27 ==> MatchFuncCall func(data any) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType untyped string ("Hi"), any
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc Main (*Game) func()
2025/12/19 11:09:27 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/12/19 11:09:27 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 Val this *Game
2025/12/19 11:09:27 Call 1 0 // func(game any)
2025/12/19 11:09:27 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType *Game, any
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc onMsg (*Kai) func(msg string)
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc Main (*Kai) func()
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc main func()
2025/12/19 11:09:27 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:27 Val Game Game
2025/12/19 11:09:27 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ Game
2025/12/19 11:09:27 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:27 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:27 Member Main 0 // *Game
2025/12/19 11:09:27 Call 0 0 // func()
2025/12/19 11:09:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 ==> ASTFile
--- PASS: TestSpxMethodSel (0.00s)
    --- PASS: TestSpxMethodSel/gopSpxTest (0.00s)
=== RUN   TestSpxPkgOverload
=== RUN   TestSpxPkgOverload/gopSpxTest
2025/12/19 11:09:27 ==> ClassFile /foo/Game.tgmx
2025/12/19 11:09:27 ==> InitClass Game isProj: true
2025/12/19 11:09:27 ==> ClassFile /foo/Kai.tspx
2025/12/19 11:09:27 ==> InitClass Kai isProj: false
2025/12/19 11:09:27 ==> Preload type Game
2025/12/19 11:09:27 ==> Preload method Game.MainEntry
2025/12/19 11:09:27 ==> Preload type Kai
2025/12/19 11:09:27 ==> Preload method Kai.onMsg
2025/12/19 11:09:27 ==> Preload method Kai.Main
2025/12/19 11:09:27 ==> Load > NewType Game
2025/12/19 11:09:27 NewType Game
2025/12/19 11:09:27 ==> Load > NewType Kai
2025/12/19 11:09:27 NewType Kai
2025/12/19 11:09:27 ==> Load > InitType Game
2025/12/19 11:09:27 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 ==> Load method *Game.MainEntry
2025/12/19 11:09:27 ==> Load > InitType Kai
2025/12/19 11:09:27 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:27 ==> Load method *Kai.onMsg
2025/12/19 11:09:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:27 ==> Load method *Kai.Main
2025/12/19 11:09:27 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:27 Val this *Game
2025/12/19 11:09:27 Member println 1 // *Game
2025/12/19 11:09:27 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType untyped string ("Hi"), any
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc Main (*Game) func()
2025/12/19 11:09:27 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/12/19 11:09:27 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 Val this *Game
2025/12/19 11:09:27 Call 1 0 // func(game any)
2025/12/19 11:09:27 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType *Game, any
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc onMsg (*Kai) func(msg string)
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member position 2 // *Kai
2025/12/19 11:09:27 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/12/19 11:09:27 Member add 1 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:27 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchType untyped int (100), int
2025/12/19 11:09:27 ==> MatchType untyped int (200), int
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc Main (*Kai) func()
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc main func()
2025/12/19 11:09:27 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:27 Val Game Game
2025/12/19 11:09:27 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ Game
2025/12/19 11:09:27 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:27 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:27 Member Main 0 // *Game
2025/12/19 11:09:27 Call 0 0 // func()
2025/12/19 11:09:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 ==> ASTFile
--- PASS: TestSpxPkgOverload (0.00s)
    --- PASS: TestSpxPkgOverload/gopSpxTest (0.00s)
=== RUN   TestSpxSelection
=== RUN   TestSpxSelection/gopSpxTest
2025/12/19 11:09:27 ==> ClassFile /foo/Game.tgmx
2025/12/19 11:09:27 ==> InitClass Game isProj: true
2025/12/19 11:09:27 ==> ClassFile /foo/Kai.tspx
2025/12/19 11:09:27 ==> InitClass Kai isProj: false
2025/12/19 11:09:27 ==> Preload type Game
2025/12/19 11:09:27 ==> Preload method Game.MainEntry
2025/12/19 11:09:27 ==> Preload type Kai
2025/12/19 11:09:27 ==> Preload method Kai.onMsg
2025/12/19 11:09:27 ==> Preload method Kai.Main
2025/12/19 11:09:27 ==> Load > NewType Game
2025/12/19 11:09:27 NewType Game
2025/12/19 11:09:27 ==> Load > NewType Kai
2025/12/19 11:09:27 NewType Kai
2025/12/19 11:09:27 ==> Load > InitType Game
2025/12/19 11:09:27 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 ==> Load method *Game.MainEntry
2025/12/19 11:09:27 ==> Load > InitType Kai
2025/12/19 11:09:27 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:27 ==> Load method *Kai.onMsg
2025/12/19 11:09:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:27 ==> Load method *Kai.Main
2025/12/19 11:09:27 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:27 Val this *Game
2025/12/19 11:09:27 Member println 1 // *Game
2025/12/19 11:09:27 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 Val &{0 STRING "hi"} *ast.BasicLit
2025/12/19 11:09:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType untyped string ("hi"), any
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc Main (*Game) func()
2025/12/19 11:09:27 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/12/19 11:09:27 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 Val this *Game
2025/12/19 11:09:27 Call 1 0 // func(game any)
2025/12/19 11:09:27 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType *Game, any
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc onMsg (*Kai) func(msg string)
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member fmt 2 // *Kai
2025/12/19 11:09:27 Val Println func(a ...any) (n int, err error)
2025/12/19 11:09:27 Val msg string
2025/12/19 11:09:27 Call 1 0 // func(a ...any) (n int, err error)
2025/12/19 11:09:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType string, any
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member position 2 // *Kai
2025/12/19 11:09:27 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/12/19 11:09:27 Member add 1 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:27 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchType untyped int (100), int
2025/12/19 11:09:27 ==> MatchType untyped int (200), int
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member position 2 // *Kai
2025/12/19 11:09:27 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/12/19 11:09:27 Member add 1 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:27 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchType untyped int (100), int
2025/12/19 11:09:27 ==> MatchType untyped int (200), int
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member position 2 // *Kai
2025/12/19 11:09:27 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/12/19 11:09:27 Member X -1 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:27 AssignOp += Gop_AddAssign
2025/12/19 11:09:27 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:27 ==> MatchType untyped int (100), unboundFuncParam{typ: int}
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member println 1 // *Kai
2025/12/19 11:09:27 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member position 2 // *Kai
2025/12/19 11:09:27 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/12/19 11:09:27 Member X 2 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType int, any
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member vector 2 // *Kai
2025/12/19 11:09:27 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/12/19 11:09:27 Member add 1 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:27 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchType untyped int (100), int
2025/12/19 11:09:27 ==> MatchType untyped int (200), int
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member vector 2 // *Kai
2025/12/19 11:09:27 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/12/19 11:09:27 Member add 1 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:27 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchType untyped int (100), int
2025/12/19 11:09:27 ==> MatchType untyped int (200), int
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member vector 2 // *Kai
2025/12/19 11:09:27 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/12/19 11:09:27 Member X -1 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:27 AssignOp += Gop_AddAssign
2025/12/19 11:09:27 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:27 ==> MatchType untyped int (100), unboundFuncParam{typ: int}
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member vector 2 // *Kai
2025/12/19 11:09:27 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/12/19 11:09:27 Member self 2 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/12/19 11:09:27 Member X -1 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:27 AssignOp += Gop_AddAssign
2025/12/19 11:09:27 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:27 ==> MatchType untyped int (100), unboundFuncParam{typ: int}
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member vector 2 // *Kai
2025/12/19 11:09:27 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/12/19 11:09:27 Member self 2 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/12/19 11:09:27 Member Y -1 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:27 AssignOp += Gop_AddAssign
2025/12/19 11:09:27 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:27 ==> MatchType untyped int (200), unboundFuncParam{typ: int}
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member vector 2 // *Kai
2025/12/19 11:09:27 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/12/19 11:09:27 Member self 2 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/12/19 11:09:27 Member add 1 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member position 2 // *Kai
2025/12/19 11:09:27 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/12/19 11:09:27 Member X 2 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member position 2 // *Kai
2025/12/19 11:09:27 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/12/19 11:09:27 Member Y 2 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchType int, int
2025/12/19 11:09:27 ==> MatchType int, int
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member println 1 // *Kai
2025/12/19 11:09:27 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member vector 2 // *Kai
2025/12/19 11:09:27 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/12/19 11:09:27 Member X 2 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType int, any
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member println 1 // *Kai
2025/12/19 11:09:27 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member vector 2 // *Kai
2025/12/19 11:09:27 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/12/19 11:09:27 Member self 2 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/12/19 11:09:27 Member self 2 // *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector
2025/12/19 11:09:27 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx/pkg.Vector args: 0 flags: 0
2025/12/19 11:09:27 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType *github.com/goplus/xgo/cl/internal/spx/pkg.Vector, any
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc Main (*Kai) func()
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc main func()
2025/12/19 11:09:27 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:27 Val Game Game
2025/12/19 11:09:27 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ Game
2025/12/19 11:09:27 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:27 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:27 Member Main 0 // *Game
2025/12/19 11:09:27 Call 0 0 // func()
2025/12/19 11:09:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 ==> ASTFile
--- PASS: TestSpxSelection (0.00s)
    --- PASS: TestSpxSelection/gopSpxTest (0.00s)
=== RUN   TestSpxOverload
=== RUN   TestSpxOverload/gopSpxTest
2025/12/19 11:09:27 ==> ClassFile /foo/Game.tgmx
2025/12/19 11:09:27 ==> InitClass Game isProj: true
2025/12/19 11:09:27 ==> ClassFile /foo/Kai.tspx
2025/12/19 11:09:27 ==> InitClass Kai isProj: false
2025/12/19 11:09:27 ==> Preload type Game
2025/12/19 11:09:27 ==> Preload method Game.onInit
2025/12/19 11:09:27 ==> Preload method Game.MainEntry
2025/12/19 11:09:27 ==> Preload type Kai
2025/12/19 11:09:27 ==> Preload type Mesh
2025/12/19 11:09:27 ==> Preload method Mesh.Name
2025/12/19 11:09:27 ==> Preload var [m1]
2025/12/19 11:09:27 ==> Preload var [m2]
2025/12/19 11:09:27 ==> Preload method Kai.Main
2025/12/19 11:09:27 ==> Load > NewType Game
2025/12/19 11:09:27 NewType Game
2025/12/19 11:09:27 ==> Load > NewType Kai
2025/12/19 11:09:27 NewType Kai
2025/12/19 11:09:27 ==> Load > InitType Game
2025/12/19 11:09:27 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:27 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/12/19 11:09:27 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/12/19 11:09:27 ==> Load method *Game.onInit
2025/12/19 11:09:27 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/12/19 11:09:27 ==> Load method *Game.MainEntry
2025/12/19 11:09:27 ==> Load > NewType Mesh
2025/12/19 11:09:27 NewType Mesh
2025/12/19 11:09:27 ==> Load > InitType Mesh
2025/12/19 11:09:27 InitType Mesh struct{}
2025/12/19 11:09:27 ==> LookupParent Mesh => type Mesh struct{}
2025/12/19 11:09:27 ==> Load method *Mesh.Name
2025/12/19 11:09:27 ==> Load var <nil> [m1]
2025/12/19 11:09:27 NewVarDefs
2025/12/19 11:09:27 NewVar [m1]
2025/12/19 11:09:27 ==> LookupParent Mesh => type Mesh struct{}
2025/12/19 11:09:27 StructLit Mesh 0 false
2025/12/19 11:09:27 UnaryOp & flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:27 EndInit 1
2025/12/19 11:09:27 ==> Load var <nil> [m2]
2025/12/19 11:09:27 NewVarDefs
2025/12/19 11:09:27 NewVar [m2]
2025/12/19 11:09:27 ==> LookupParent Mesh => type Mesh struct{}
2025/12/19 11:09:27 StructLit Mesh 0 false
2025/12/19 11:09:27 UnaryOp & flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:27 EndInit 1
2025/12/19 11:09:27 ==> Load > InitType Kai
2025/12/19 11:09:27 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai}
2025/12/19 11:09:27 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; a int}
2025/12/19 11:09:27 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game; a int}
2025/12/19 11:09:27 ==> Load method *Kai.Main
2025/12/19 11:09:27 NewFunc onInit (*Game) func()
2025/12/19 11:09:27 Val this *Game
2025/12/19 11:09:27 Member Kai 2 // *Game
2025/12/19 11:09:27 Member onKey 1 // Kai
2025/12/19 11:09:27 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:27 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:27 NewClosure func(key string)
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType Kai, any
2025/12/19 11:09:27 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:27 ==> MatchType func(key string), func()
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType Kai, any
2025/12/19 11:09:27 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:27 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc Main (*Game) func()
2025/12/19 11:09:27 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/12/19 11:09:27 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:27 Val this *Game
2025/12/19 11:09:27 Call 1 0 // func(game any)
2025/12/19 11:09:27 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType *Game, any
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc Name (*Mesh) func() string
2025/12/19 11:09:27 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:27 Return 1
2025/12/19 11:09:27 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc Main (*Kai) func()
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member onKey 1 // *Kai
2025/12/19 11:09:27 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:27 NewClosure func()
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:27 ==> MatchType func(), func()
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member onKey 1 // *Kai
2025/12/19 11:09:27 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:27 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:27 NewClosure func(key string)
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:27 ==> MatchType func(key string), func()
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:27 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member onKey 1 // *Kai
2025/12/19 11:09:27 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit <nil> 1 false
2025/12/19 11:09:27 NewClosure func()
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []string, string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []string, string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []string, []string
2025/12/19 11:09:27 ==> MatchType func(), func()
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member onKey 1 // *Kai
2025/12/19 11:09:27 Val &{0 STRING "2"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit <nil> 1 false
2025/12/19 11:09:27 Val &{0 STRING "2"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit <nil> 1 false
2025/12/19 11:09:27 NewClosure func(key string)
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []string, string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []string, string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []string, []string
2025/12/19 11:09:27 ==> MatchType func(key string), func()
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []string, []string
2025/12/19 11:09:27 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member onKey 1 // *Kai
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m1 2 // *Kai
2025/12/19 11:09:27 Val m1 *Mesh
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m2 2 // *Kai
2025/12/19 11:09:27 Val m2 *Mesh
2025/12/19 11:09:27 SliceLit <nil> 2 false
2025/12/19 11:09:27 NewClosure func()
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []*Mesh, string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []*Mesh, string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []*Mesh, []string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []*Mesh, []string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []*Mesh, []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key github.com/goplus/xgo/cl/internal/spx.Mesher)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []*Mesh, []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, b []string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, b []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, x int, y int) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []*Mesh, int
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m1 2 // *Kai
2025/12/19 11:09:27 Val m1 *Mesh
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m2 2 // *Kai
2025/12/19 11:09:27 Val m2 *Mesh
2025/12/19 11:09:27 SliceLit <nil> 2 false
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m1 2 // *Kai
2025/12/19 11:09:27 Val m1 *Mesh
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m2 2 // *Kai
2025/12/19 11:09:27 Val m2 *Mesh
2025/12/19 11:09:27 SliceLit []string 2 false
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m1 2 // *Kai
2025/12/19 11:09:27 Val m1 *Mesh
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m2 2 // *Kai
2025/12/19 11:09:27 Val m2 *Mesh
2025/12/19 11:09:27 SliceLit []string 2 false
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m1 2 // *Kai
2025/12/19 11:09:27 Val m1 *Mesh
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m2 2 // *Kai
2025/12/19 11:09:27 Val m2 *Mesh
2025/12/19 11:09:27 SliceLit []github.com/goplus/xgo/cl/internal/spx.Mesher 2 false
2025/12/19 11:09:27 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 NewClosure func()
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, []string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, []string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> MatchType func(), func()
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member onKey 1 // *Kai
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m1 2 // *Kai
2025/12/19 11:09:27 Val m1 *Mesh
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m2 2 // *Kai
2025/12/19 11:09:27 Val m2 *Mesh
2025/12/19 11:09:27 SliceLit <nil> 2 false
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m1 2 // *Kai
2025/12/19 11:09:27 Val m1 *Mesh
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m2 2 // *Kai
2025/12/19 11:09:27 Val m2 *Mesh
2025/12/19 11:09:27 SliceLit <nil> 2 false
2025/12/19 11:09:27 NewClosure func(key string)
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []*Mesh, string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []*Mesh, string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []*Mesh, []string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []*Mesh, []string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []*Mesh, []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key github.com/goplus/xgo/cl/internal/spx.Mesher)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []*Mesh, []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, b []string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, b []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, x int, y int) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []*Mesh, int
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m1 2 // *Kai
2025/12/19 11:09:27 Val m1 *Mesh
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m2 2 // *Kai
2025/12/19 11:09:27 Val m2 *Mesh
2025/12/19 11:09:27 SliceLit []string 2 false
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m1 2 // *Kai
2025/12/19 11:09:27 Val m1 *Mesh
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m2 2 // *Kai
2025/12/19 11:09:27 Val m2 *Mesh
2025/12/19 11:09:27 SliceLit []string 2 false
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m1 2 // *Kai
2025/12/19 11:09:27 Val m1 *Mesh
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m2 2 // *Kai
2025/12/19 11:09:27 Val m2 *Mesh
2025/12/19 11:09:27 SliceLit []github.com/goplus/xgo/cl/internal/spx.Mesher 2 false
2025/12/19 11:09:27 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m1 2 // *Kai
2025/12/19 11:09:27 Val m1 *Mesh
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m2 2 // *Kai
2025/12/19 11:09:27 Val m2 *Mesh
2025/12/19 11:09:27 SliceLit []github.com/goplus/xgo/cl/internal/spx.Mesher 2 false
2025/12/19 11:09:27 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 NewClosure func(key github.com/goplus/xgo/cl/internal/spx.Mesher)
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, []string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, []string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> MatchType func(key github.com/goplus/xgo/cl/internal/spx.Mesher), func()
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key github.com/goplus/xgo/cl/internal/spx.Mesher)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> MatchType func(key github.com/goplus/xgo/cl/internal/spx.Mesher), func(key github.com/goplus/xgo/cl/internal/spx.Mesher)
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member onKey 1 // *Kai
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit <nil> 1 false
2025/12/19 11:09:27 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit <nil> 1 false
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit <nil> 1 false
2025/12/19 11:09:27 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit <nil> 1 false
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit []string 1 false
2025/12/19 11:09:27 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit <nil> 1 false
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit []string 1 false
2025/12/19 11:09:27 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit <nil> 1 false
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit []github.com/goplus/xgo/cl/internal/spx.Mesher 1 false
2025/12/19 11:09:27 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/spx.Mesher false
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit []github.com/goplus/xgo/cl/internal/spx.Mesher 1 false
2025/12/19 11:09:27 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/spx.Mesher false
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit []string 1 false
2025/12/19 11:09:27 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit []string 1 false
2025/12/19 11:09:27 NewClosure func(key string)
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyTemplateRecvMethod args: 3 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, fn func(key string)) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func()) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key github.com/goplus/xgo/cl/internal/spx.Mesher)) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, b []string, fn func(key string)) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []string, []string
2025/12/19 11:09:27 ==> MatchType []string, []string
2025/12/19 11:09:27 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member onKey 1 // *Kai
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit <nil> 1 false
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m1 2 // *Kai
2025/12/19 11:09:27 Val m1 *Mesh
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m2 2 // *Kai
2025/12/19 11:09:27 Val m2 *Mesh
2025/12/19 11:09:27 SliceLit <nil> 2 false
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit <nil> 1 false
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m1 2 // *Kai
2025/12/19 11:09:27 Val m1 *Mesh
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m2 2 // *Kai
2025/12/19 11:09:27 Val m2 *Mesh
2025/12/19 11:09:27 SliceLit <nil> 2 false
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit []string 1 false
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m1 2 // *Kai
2025/12/19 11:09:27 Val m1 *Mesh
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m2 2 // *Kai
2025/12/19 11:09:27 Val m2 *Mesh
2025/12/19 11:09:27 SliceLit <nil> 2 false
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit []string 1 false
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m1 2 // *Kai
2025/12/19 11:09:27 Val m1 *Mesh
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m2 2 // *Kai
2025/12/19 11:09:27 Val m2 *Mesh
2025/12/19 11:09:27 SliceLit <nil> 2 false
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit []github.com/goplus/xgo/cl/internal/spx.Mesher 1 false
2025/12/19 11:09:27 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/spx.Mesher false
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit []github.com/goplus/xgo/cl/internal/spx.Mesher 1 false
2025/12/19 11:09:27 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/spx.Mesher false
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit []string 1 false
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m1 2 // *Kai
2025/12/19 11:09:27 Val m1 *Mesh
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m2 2 // *Kai
2025/12/19 11:09:27 Val m2 *Mesh
2025/12/19 11:09:27 SliceLit []string 2 false
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit []string 1 false
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m1 2 // *Kai
2025/12/19 11:09:27 Val m1 *Mesh
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member m2 2 // *Kai
2025/12/19 11:09:27 Val m2 *Mesh
2025/12/19 11:09:27 SliceLit []github.com/goplus/xgo/cl/internal/spx.Mesher 2 false
2025/12/19 11:09:27 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 NewClosure func(key string)
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyTemplateRecvMethod args: 3 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, fn func(key string)) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func()) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key github.com/goplus/xgo/cl/internal/spx.Mesher)) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, b []string, fn func(key string)) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []string, []string
2025/12/19 11:09:27 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, []string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, b []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key string)) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []string, []string
2025/12/19 11:09:27 ==> MatchType []github.com/goplus/xgo/cl/internal/spx.Mesher, []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member onKey 1 // *Kai
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit <nil> 1 false
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member nil 2 // *Kai
2025/12/19 11:09:27 Val nil untyped nil
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit <nil> 1 false
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member nil 2 // *Kai
2025/12/19 11:09:27 Val nil untyped nil
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit []string 1 false
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member nil 2 // *Kai
2025/12/19 11:09:27 Val nil untyped nil
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit []string 1 false
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member nil 2 // *Kai
2025/12/19 11:09:27 Val nil untyped nil
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit []github.com/goplus/xgo/cl/internal/spx.Mesher 1 false
2025/12/19 11:09:27 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/spx.Mesher false
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit []github.com/goplus/xgo/cl/internal/spx.Mesher 1 false
2025/12/19 11:09:27 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/spx.Mesher false
2025/12/19 11:09:27 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:27 SliceLit []string 1 false
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member nil 2 // *Kai
2025/12/19 11:09:27 Val nil untyped nil
2025/12/19 11:09:27 NewClosure func(key string)
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyTemplateRecvMethod args: 3 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, fn func(key string)) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func()) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key github.com/goplus/xgo/cl/internal/spx.Mesher)) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, b []string, fn func(key string)) args: 4 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType []string, []string
2025/12/19 11:09:27 ==> MatchType untyped nil, []string
2025/12/19 11:09:27 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member onKey 1 // *Kai
2025/12/19 11:09:27 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:27 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:27 NewClosure func() int
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType untyped int (100), string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType untyped int (100), string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType untyped int (100), []string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType untyped int (100), []string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key github.com/goplus/xgo/cl/internal/spx.Mesher)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, b []string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, b []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, x int, y int) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType untyped int (100), int
2025/12/19 11:09:27 ==> MatchType func() int, int
2025/12/19 11:09:27 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:27 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType untyped int (100), string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType untyped int (100), string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType untyped int (100), []string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType untyped int (100), []string
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func()) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key github.com/goplus/xgo/cl/internal/spx.Mesher)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/spx.Mesher
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, b []string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a []string, b []github.com/goplus/xgo/cl/internal/spx.Mesher, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, x int, y int) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType untyped int (100), int
2025/12/19 11:09:27 ==> MatchType untyped int (200), int
2025/12/19 11:09:27 Val this *Kai
2025/12/19 11:09:27 Member onKey2 1 // *Kai
2025/12/19 11:09:27 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:27 NewClosure func(key string)
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:27 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/12/19 11:09:27 ==> MatchFuncCall func(sprite any, a string, fn func(key string)) args: 3 flags: 16
2025/12/19 11:09:27 ==> MatchType *Kai, any
2025/12/19 11:09:27 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:27 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 NewFunc main func()
2025/12/19 11:09:27 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:27 Val Game Game
2025/12/19 11:09:27 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame; Kai Kai} => Typ Game
2025/12/19 11:09:27 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:27 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:27 Member Main 0 // *Game
2025/12/19 11:09:27 Call 0 0 // func()
2025/12/19 11:09:27 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:27 End // Func
2025/12/19 11:09:27 ==> ASTFile
--- PASS: TestSpxOverload (0.01s)
    --- PASS: TestSpxOverload/gopSpxTest (0.01s)
=== RUN   TestTestClassFile
=== RUN   TestTestClassFile/gopSpxTest
2025/12/19 11:09:27 ==> ClassFile /foo/Foo_xtest.gox
2025/12/19 11:09:27 ==> Import github.com/goplus/xgo/test
2025/12/19 11:09:27 ==> NewTemplateRecvMethod App TestMain
2025/12/19 11:09:27 ==> NewTemplateRecvMethod Case TestMain
2025/12/19 11:09:28 ==> InitClass Foo isProj: false
2025/12/19 11:09:28 ==> ClassFile /foo/main_xtest.gox
2025/12/19 11:09:28 ==> InitClass main isProj: true
2025/12/19 11:09:28 ==> Preload type caseFoo
2025/12/19 11:09:28 ==> Preload method caseFoo.Main
2025/12/19 11:09:28 ==> Preload type App
2025/12/19 11:09:28 ==> Preload method App.MainEntry
2025/12/19 11:09:28 ==> Load > NewType caseFoo
2025/12/19 11:09:28 NewType caseFoo
2025/12/19 11:09:28 ==> Load > NewType App
2025/12/19 11:09:28 NewType App
2025/12/19 11:09:28 ==> Load > InitType App
2025/12/19 11:09:28 InitType App struct{github.com/goplus/xgo/test.App}
2025/12/19 11:09:28 ==> LookupParent App => type App struct{github.com/goplus/xgo/test.App}
2025/12/19 11:09:28 ==> Load method *App.MainEntry
2025/12/19 11:09:28 ==> Load > InitType caseFoo
2025/12/19 11:09:28 InitType caseFoo struct{github.com/goplus/xgo/test.Case}
2025/12/19 11:09:28 ==> LookupParent caseFoo => type caseFoo struct{github.com/goplus/xgo/test.Case}
2025/12/19 11:09:28 ==> Load method *caseFoo.Main
2025/12/19 11:09:28 NewFunc TestFoo func(t *testing.T)
2025/12/19 11:09:28 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:28 Val caseFoo caseFoo
2025/12/19 11:09:28 Val type caseFoo struct{github.com/goplus/xgo/test.Case} => Typ caseFoo
2025/12/19 11:09:28 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:28 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:28 Member TestMain 0 // *caseFoo
2025/12/19 11:09:28 Val t *testing.T
2025/12/19 11:09:28 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> MatchFuncCall TyTemplateRecvMethod args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall func(c interface{initCase(t *testing.T)}, t *testing.T) args: 2 flags: 16
2025/12/19 11:09:28 ==> MatchType *caseFoo, interface{initCase(t *testing.T)}
2025/12/19 11:09:28 ==> MatchType *testing.T, *testing.T
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 NewFunc TestMain func(m *testing.M)
2025/12/19 11:09:28 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:28 Val App App
2025/12/19 11:09:28 Val type App struct{github.com/goplus/xgo/test.App} => Typ App
2025/12/19 11:09:28 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:28 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:28 Member TestMain 0 // *App
2025/12/19 11:09:28 Val m *testing.M
2025/12/19 11:09:28 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> MatchFuncCall TyTemplateRecvMethod args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall func(app interface{initApp(m *testing.M)}, m *testing.M) args: 2 flags: 16
2025/12/19 11:09:28 ==> MatchType *App, interface{initApp(m *testing.M)}
2025/12/19 11:09:28 ==> MatchType *testing.M, *testing.M
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 NewFunc MainEntry (*App) func()
2025/12/19 11:09:28 Val this *App
2025/12/19 11:09:28 Member println 1 // *App
2025/12/19 11:09:28 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:28 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped string ("Hi"), any
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 NewFunc Main (*caseFoo) func()
2025/12/19 11:09:28 Val this *caseFoo
2025/12/19 11:09:28 Member t 2 // *caseFoo
2025/12/19 11:09:28 Call 0 0 // func() *testing.T
2025/12/19 11:09:28 ==> MatchFuncCall func() *testing.T args: 0 flags: 0
2025/12/19 11:09:28 Member log 1 // *testing.T
2025/12/19 11:09:28 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:28 Call 1 0 // func(args ...any)
2025/12/19 11:09:28 ==> MatchFuncCall func(args ...any) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped string ("Hi"), any
2025/12/19 11:09:28 Val this *caseFoo
2025/12/19 11:09:28 Member t 2 // *caseFoo
2025/12/19 11:09:28 Call 0 0 // func() *testing.T
2025/12/19 11:09:28 ==> MatchFuncCall func() *testing.T args: 0 flags: 0
2025/12/19 11:09:28 Member run 1 // *testing.T
2025/12/19 11:09:28 Val &{0 STRING "a test"} *ast.BasicLit
2025/12/19 11:09:28 NewClosure func(t *testing.T)
2025/12/19 11:09:28 Val t *testing.T
2025/12/19 11:09:28 Member fatal 1 // *testing.T
2025/12/19 11:09:28 Val &{0 STRING "failed"} *ast.BasicLit
2025/12/19 11:09:28 Call 1 0 // func(args ...any)
2025/12/19 11:09:28 ==> MatchFuncCall func(args ...any) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped string ("failed"), any
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 Call 2 0 // func(name string, f func(t *testing.T)) bool
2025/12/19 11:09:28 ==> MatchFuncCall func(name string, f func(t *testing.T)) bool args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped string ("a test"), string
2025/12/19 11:09:28 ==> MatchType func(t *testing.T), func(t *testing.T)
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile _test
--- PASS: TestTestClassFile (0.35s)
    --- PASS: TestTestClassFile/gopSpxTest (0.35s)
=== RUN   TestTestClassFile2
=== RUN   TestTestClassFile2/gopSpxTest
2025/12/19 11:09:28 ==> ClassFile /foo/foo_xtest.gox
2025/12/19 11:09:28 ==> InitClass foo isProj: false
2025/12/19 11:09:28 ==> Preload type case_foo
2025/12/19 11:09:28 ==> Preload method case_foo.Main
2025/12/19 11:09:28 ==> Preload type main
2025/12/19 11:09:28 ==> Preload method main.Main
2025/12/19 11:09:28 ==> Load > NewType case_foo
2025/12/19 11:09:28 NewType case_foo
2025/12/19 11:09:28 ==> Load > NewType main
2025/12/19 11:09:28 NewType main
2025/12/19 11:09:28 ==> Load > InitType case_foo
2025/12/19 11:09:28 InitType case_foo struct{github.com/goplus/xgo/test.Case}
2025/12/19 11:09:28 ==> LookupParent case_foo => type case_foo struct{github.com/goplus/xgo/test.Case}
2025/12/19 11:09:28 ==> Load method *case_foo.Main
2025/12/19 11:09:28 ==> Load > InitType main
2025/12/19 11:09:28 InitType main struct{}
2025/12/19 11:09:28 ==> LookupParent main => type main struct{}
2025/12/19 11:09:28 ==> Load method *main.Main
2025/12/19 11:09:28 NewFunc Test_foo func(t *testing.T)
2025/12/19 11:09:28 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:28 Val case_foo case_foo
2025/12/19 11:09:28 Val type case_foo struct{github.com/goplus/xgo/test.Case} => Typ case_foo
2025/12/19 11:09:28 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:28 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:28 Member TestMain 0 // *case_foo
2025/12/19 11:09:28 Val t *testing.T
2025/12/19 11:09:28 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> MatchFuncCall TyTemplateRecvMethod args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall func(c interface{initCase(t *testing.T)}, t *testing.T) args: 2 flags: 16
2025/12/19 11:09:28 ==> MatchType *case_foo, interface{initCase(t *testing.T)}
2025/12/19 11:09:28 ==> MatchType *testing.T, *testing.T
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 NewFunc Main (*case_foo) func()
2025/12/19 11:09:28 Val this *case_foo
2025/12/19 11:09:28 Member t 2 // *case_foo
2025/12/19 11:09:28 Call 0 0 // func() *testing.T
2025/12/19 11:09:28 ==> MatchFuncCall func() *testing.T args: 0 flags: 0
2025/12/19 11:09:28 Member log 1 // *testing.T
2025/12/19 11:09:28 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:28 Call 1 0 // func(args ...any)
2025/12/19 11:09:28 ==> MatchFuncCall func(args ...any) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped string ("Hi"), any
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 NewFunc Main (*main) func()
2025/12/19 11:09:28 Val this *main
2025/12/19 11:09:28 Member println 1 // *main
2025/12/19 11:09:28 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:28 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped string ("Hi"), any
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile _test
--- PASS: TestTestClassFile2 (0.00s)
    --- PASS: TestTestClassFile2/gopSpxTest (0.00s)
=== RUN   TestGopxNoFunc
2025/12/19 11:09:28 ==> Preload type foo
2025/12/19 11:09:28 ==> Load > NewType foo
2025/12/19 11:09:28 NewType foo
2025/12/19 11:09:28 ==> Load > InitType foo
2025/12/19 11:09:28 InitType foo struct{a int}
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestGopxNoFunc (0.00s)
=== RUN   TestGopxOverload
2025/12/19 11:09:28 ==> Preload type Rect
2025/12/19 11:09:28 ==> Preload method Rect.addString
2025/12/19 11:09:28 ==> Preload method Rect.addInt
2025/12/19 11:09:28 ==> Preload method Rect.add__1
2025/12/19 11:09:28 NewConstDefs
2025/12/19 11:09:28 ==> Preload const [Gopo_Rect_add]
2025/12/19 11:09:28 ==> Load > NewType Rect
2025/12/19 11:09:28 NewType Rect
2025/12/19 11:09:28 ==> Load > InitType Rect
2025/12/19 11:09:28 InitType Rect struct{}
2025/12/19 11:09:28 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{}
2025/12/19 11:09:28 ==> Load method *github.com/goplus/xgo/cl.Rect.addString
2025/12/19 11:09:28 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{}
2025/12/19 11:09:28 ==> Load method *github.com/goplus/xgo/cl.Rect.addInt
2025/12/19 11:09:28 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{}
2025/12/19 11:09:28 ==> Load method *github.com/goplus/xgo/cl.Rect.add__1
2025/12/19 11:09:28 ==> Load const [Gopo_Rect_add] <nil>
2025/12/19 11:09:28 NewConst [Gopo_Rect_add] 0
2025/12/19 11:09:28 Val &{0 STRING ".addInt,,.addString"} *ast.BasicLit
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> NewOverloadMethod Rect add
2025/12/19 11:09:28 NewFunc addString (*github.com/goplus/xgo/cl.Rect) func(a string, b string) string
2025/12/19 11:09:28 Val a string
2025/12/19 11:09:28 Val b string
2025/12/19 11:09:28 BinaryOp +
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType string, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType string, unboundFuncParam{typ: string}
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType string, string
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 NewFunc addInt (*github.com/goplus/xgo/cl.Rect) func(a int, b int) int
2025/12/19 11:09:28 Val a int
2025/12/19 11:09:28 Val b int
2025/12/19 11:09:28 BinaryOp +
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType int, int
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 NewFunc add__1 (*github.com/goplus/xgo/cl.Rect) func(a float64, b float64) float64
2025/12/19 11:09:28 Val a float64
2025/12/19 11:09:28 Val b float64
2025/12/19 11:09:28 BinaryOp +
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType float64, float64
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestGopxOverload (0.00s)
=== RUN   TestClassFileGopx
2025/12/19 11:09:28 ==> Preload type Rect
2025/12/19 11:09:28 ==> Preload type BaseClass
2025/12/19 11:09:28 ==> Preload type AggClass
2025/12/19 11:09:28 ==> Preload method Rect.Area
2025/12/19 11:09:28 ==> Load > NewType Rect
2025/12/19 11:09:28 NewType Rect
2025/12/19 11:09:28 ==> Load > NewType BaseClass
2025/12/19 11:09:28 NewType BaseClass
2025/12/19 11:09:28 ==> Load > InitType BaseClass
2025/12/19 11:09:28 InitType BaseClass struct{x int; y int}
2025/12/19 11:09:28 ==> Load > NewType AggClass
2025/12/19 11:09:28 NewType AggClass
2025/12/19 11:09:28 ==> Load > InitType AggClass
2025/12/19 11:09:28 InitType AggClass struct{}
2025/12/19 11:09:28 ==> Load > InitType Rect
2025/12/19 11:09:28 ==> LookupParent BaseClass => type github.com/goplus/xgo/cl.BaseClass struct{x int; y int}
2025/12/19 11:09:28 ==> LookupParent AggClass => type github.com/goplus/xgo/cl.AggClass struct{}
2025/12/19 11:09:28 InitType Rect struct{github.com/goplus/xgo/cl.BaseClass; Width float64; Height float64; *github.com/goplus/xgo/cl.AggClass}
2025/12/19 11:09:28 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{github.com/goplus/xgo/cl.BaseClass; Width float64; Height float64; *github.com/goplus/xgo/cl.AggClass}
2025/12/19 11:09:28 ==> Load method *github.com/goplus/xgo/cl.Rect.Area
2025/12/19 11:09:28 NewFunc Area (*github.com/goplus/xgo/cl.Rect) func() float64
2025/12/19 11:09:28 Val this *github.com/goplus/xgo/cl.Rect
2025/12/19 11:09:28 Member Width 2 // *github.com/goplus/xgo/cl.Rect
2025/12/19 11:09:28 Val this *github.com/goplus/xgo/cl.Rect
2025/12/19 11:09:28 Member Height 2 // *github.com/goplus/xgo/cl.Rect
2025/12/19 11:09:28 BinaryOp *
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType float64, float64
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
2025/12/19 11:09:28 ==> Preload type Rect
2025/12/19 11:09:28 ==> Preload method Rect.test
2025/12/19 11:09:28 ==> Load > NewType Rect
2025/12/19 11:09:28 NewType Rect
2025/12/19 11:09:28 ==> Load > InitType Rect
2025/12/19 11:09:28 InitType Rect struct{bytes.Buffer}
2025/12/19 11:09:28 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{bytes.Buffer}
2025/12/19 11:09:28 ==> Load method *github.com/goplus/xgo/cl.Rect.test
2025/12/19 11:09:28 NewFunc test (*github.com/goplus/xgo/cl.Rect) func()
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
2025/12/19 11:09:28 ==> Preload type Rect
2025/12/19 11:09:28 ==> Preload method Rect.test
2025/12/19 11:09:28 ==> Load > NewType Rect
2025/12/19 11:09:28 NewType Rect
2025/12/19 11:09:28 ==> Load > InitType Rect
2025/12/19 11:09:28 InitType Rect struct{*bytes.Buffer}
2025/12/19 11:09:28 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{*bytes.Buffer}
2025/12/19 11:09:28 ==> Load method *github.com/goplus/xgo/cl.Rect.test
2025/12/19 11:09:28 NewFunc test (*github.com/goplus/xgo/cl.Rect) func()
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
2025/12/19 11:09:28 ==> Preload type Rect
2025/12/19 11:09:28 ==> Preload method Rect.test
2025/12/19 11:09:28 ==> Load > NewType Rect
2025/12/19 11:09:28 NewType Rect
2025/12/19 11:09:28 ==> Load > InitType Rect
2025/12/19 11:09:28 InitType Rect struct{*bytes.Buffer "spec:\"buffer\""; a int "json:\"a\""; b int}
2025/12/19 11:09:28 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{*bytes.Buffer "spec:\"buffer\""; a int "json:\"a\""; b int}
2025/12/19 11:09:28 ==> Load method *github.com/goplus/xgo/cl.Rect.test
2025/12/19 11:09:28 NewFunc test (*github.com/goplus/xgo/cl.Rect) func()
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestClassFileGopx (0.00s)
=== RUN   TestClassFileMember
2025/12/19 11:09:28 ==> Preload type Rect
2025/12/19 11:09:28 ==> Preload type Engine
2025/12/19 11:09:28 ==> Preload method Engine.EnterPointerLock
2025/12/19 11:09:28 ==> Preload method Engine.SetEnable
2025/12/19 11:09:28 ==> Preload method Rect.Engine
2025/12/19 11:09:28 ==> Preload method Rect.Test
2025/12/19 11:09:28 ==> Load > NewType Rect
2025/12/19 11:09:28 NewType Rect
2025/12/19 11:09:28 ==> Load > NewType Engine
2025/12/19 11:09:28 NewType Engine
2025/12/19 11:09:28 ==> Load > InitType Engine
2025/12/19 11:09:28 InitType Engine struct{}
2025/12/19 11:09:28 ==> LookupParent Engine => type github.com/goplus/xgo/cl.Engine struct{}
2025/12/19 11:09:28 ==> Load method *github.com/goplus/xgo/cl.Engine.EnterPointerLock
2025/12/19 11:09:28 ==> LookupParent Engine => type github.com/goplus/xgo/cl.Engine struct{}
2025/12/19 11:09:28 ==> Load method *github.com/goplus/xgo/cl.Engine.SetEnable
2025/12/19 11:09:28 ==> Load > InitType Rect
2025/12/19 11:09:28 InitType Rect struct{}
2025/12/19 11:09:28 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{}
2025/12/19 11:09:28 ==> Load method *github.com/goplus/xgo/cl.Rect.Engine
2025/12/19 11:09:28 ==> LookupParent Engine => type github.com/goplus/xgo/cl.Engine struct{}
2025/12/19 11:09:28 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{}
2025/12/19 11:09:28 ==> Load method *github.com/goplus/xgo/cl.Rect.Test
2025/12/19 11:09:28 NewFunc EnterPointerLock (*github.com/goplus/xgo/cl.Engine) func()
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 NewFunc SetEnable (*github.com/goplus/xgo/cl.Engine) func(b bool)
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 NewFunc Engine (*github.com/goplus/xgo/cl.Rect) func() *github.com/goplus/xgo/cl.Engine
2025/12/19 11:09:28 ==> LookupParent Engine => type github.com/goplus/xgo/cl.Engine struct{}
2025/12/19 11:09:28 StructLit github.com/goplus/xgo/cl.Engine 0 false
2025/12/19 11:09:28 UnaryOp & flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType *github.com/goplus/xgo/cl.Engine, *github.com/goplus/xgo/cl.Engine
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 NewFunc Test (*github.com/goplus/xgo/cl.Rect) func()
2025/12/19 11:09:28 Val this *github.com/goplus/xgo/cl.Rect
2025/12/19 11:09:28 Member engine 2 // *github.com/goplus/xgo/cl.Rect
2025/12/19 11:09:28 Call 0 0 // func() *github.com/goplus/xgo/cl.Engine
2025/12/19 11:09:28 ==> MatchFuncCall func() *github.com/goplus/xgo/cl.Engine args: 0 flags: 0
2025/12/19 11:09:28 Member setEnable 1 // *github.com/goplus/xgo/cl.Engine
2025/12/19 11:09:28 Val this *github.com/goplus/xgo/cl.Rect
2025/12/19 11:09:28 Member true 2 // *github.com/goplus/xgo/cl.Rect
2025/12/19 11:09:28 Val true untyped bool
2025/12/19 11:09:28 Call 1 0 // func(b bool)
2025/12/19 11:09:28 ==> MatchFuncCall func(b bool) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped bool (true), bool
2025/12/19 11:09:28 Val this *github.com/goplus/xgo/cl.Rect
2025/12/19 11:09:28 Member engine 2 // *github.com/goplus/xgo/cl.Rect
2025/12/19 11:09:28 Call 0 0 // func() *github.com/goplus/xgo/cl.Engine
2025/12/19 11:09:28 ==> MatchFuncCall func() *github.com/goplus/xgo/cl.Engine args: 0 flags: 0
2025/12/19 11:09:28 Member enterPointerLock 1 // *github.com/goplus/xgo/cl.Engine
2025/12/19 11:09:28 Call 0 0 // func()
2025/12/19 11:09:28 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestClassFileMember (0.00s)
=== RUN   TestTypeDoc
2025/12/19 11:09:28 ==> Preload type A
2025/12/19 11:09:28 ==> Load > NewType A
2025/12/19 11:09:28 NewType A
2025/12/19 11:09:28 ==> Load > InitType A
2025/12/19 11:09:28 InitType A int
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestTypeDoc (0.00s)
=== RUN   TestUnsafe
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 Val Sizeof invalid type
2025/12/19 11:09:28 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:28 Call 1 0 // TyInstruction{gogen.unsafeSizeofInstr}
2025/12/19 11:09:28 ==> MatchFuncCall TyInstruction{gogen.unsafeSizeofInstr} args: 1 flags: 0
2025/12/19 11:09:28 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType uintptr (8), any
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestUnsafe (0.00s)
=== RUN   Test_CastSlice_Issue1240
2025/12/19 11:09:28 ==> Preload type fvec
2025/12/19 11:09:28 ==> Preload type foo
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Load > NewType fvec
2025/12/19 11:09:28 NewType fvec
2025/12/19 11:09:28 ==> Load > InitType fvec
2025/12/19 11:09:28 InitType fvec []float64
2025/12/19 11:09:28 ==> Load > NewType foo
2025/12/19 11:09:28 NewType foo
2025/12/19 11:09:28 ==> Load > InitType foo
2025/12/19 11:09:28 InitType foo float64
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 DefineVarStart [a]
2025/12/19 11:09:28 Typ []float64
2025/12/19 11:09:28 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:28 SliceLit []float64 2 false
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 DefineVarStart [b]
2025/12/19 11:09:28 Val fvec github.com/goplus/xgo/cl.fvec
2025/12/19 11:09:28 Val type github.com/goplus/xgo/cl.fvec []float64 => Typ github.com/goplus/xgo/cl.fvec
2025/12/19 11:09:28 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:28 SliceLit github.com/goplus/xgo/cl.fvec 2 false
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 DefineVarStart [c]
2025/12/19 11:09:28 Val foo github.com/goplus/xgo/cl.foo
2025/12/19 11:09:28 Val type github.com/goplus/xgo/cl.foo float64 => Typ github.com/goplus/xgo/cl.foo
2025/12/19 11:09:28 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:28 SliceLit <nil> 2 false
2025/12/19 11:09:28 Call 1 0 // TypeType{typ: github.com/goplus/xgo/cl.foo}
2025/12/19 11:09:28 ==> MatchFuncCall TypeType{typ: github.com/goplus/xgo/cl.foo} args: 1 flags: 0
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 DefineVarStart [d]
2025/12/19 11:09:28 Val fvec github.com/goplus/xgo/cl.fvec
2025/12/19 11:09:28 Val type github.com/goplus/xgo/cl.fvec []float64 => Typ github.com/goplus/xgo/cl.fvec
2025/12/19 11:09:28 SliceLit github.com/goplus/xgo/cl.fvec 0 false
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 Val a []float64
2025/12/19 11:09:28 Val b github.com/goplus/xgo/cl.fvec
2025/12/19 11:09:28 Val c github.com/goplus/xgo/cl.foo
2025/12/19 11:09:28 Val d github.com/goplus/xgo/cl.fvec
2025/12/19 11:09:28 Call 4 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 4 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall func(a ...any) (n int, err error) args: 4 flags: 0
2025/12/19 11:09:28 ==> MatchType []float64, any
2025/12/19 11:09:28 ==> MatchType github.com/goplus/xgo/cl.fvec, any
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.fvec
2025/12/19 11:09:28 ==> MatchType github.com/goplus/xgo/cl.foo, any
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/12/19 11:09:28 ==> MatchType github.com/goplus/xgo/cl.fvec, any
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.fvec
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: Test_CastSlice_Issue1240 (0.00s)
=== RUN   TestUnderscoreRedeclared_Issue1197
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:28 NewClosure func() (_ [2]int)
2025/12/19 11:09:28 Return 0
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 Call 0 0 // func() (_ [2]int)
2025/12/19 11:09:28 ==> MatchFuncCall func() (_ [2]int) args: 0 flags: 0
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestUnderscoreRedeclared_Issue1197 (0.00s)
=== RUN   TestInterfaceBugNilUnderlying_Issue1198
2025/12/19 11:09:28 ==> Preload type Outer
2025/12/19 11:09:28 ==> Preload type impl
2025/12/19 11:09:28 ==> Preload func New
2025/12/19 11:09:28 ==> Preload type Inner
2025/12/19 11:09:28 ==> Preload method impl.DoStuff
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Load > NewType Outer
2025/12/19 11:09:28 NewType Outer
2025/12/19 11:09:28 ==> Load > InitType Outer
2025/12/19 11:09:28 ==> Load > NewType Inner
2025/12/19 11:09:28 NewType Inner
2025/12/19 11:09:28 ==> Lookup (LoadSymbol) Inner => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:28 ==> Load > InitType Inner
2025/12/19 11:09:28 InitType Inner interface{DoStuff() error}
2025/12/19 11:09:28 InitType Outer interface{github.com/goplus/xgo/cl.Inner}
2025/12/19 11:09:28 ==> Load > NewType impl
2025/12/19 11:09:28 NewType impl
2025/12/19 11:09:28 ==> Load > InitType impl
2025/12/19 11:09:28 InitType impl struct{}
2025/12/19 11:09:28 ==> LookupParent impl => type github.com/goplus/xgo/cl.impl struct{}
2025/12/19 11:09:28 ==> Load method *github.com/goplus/xgo/cl.impl.DoStuff
2025/12/19 11:09:28 ==> Load func New
2025/12/19 11:09:28 ==> LookupParent Outer => type github.com/goplus/xgo/cl.Outer interface{github.com/goplus/xgo/cl.Inner}
2025/12/19 11:09:28 NewFunc New func() github.com/goplus/xgo/cl.Outer
2025/12/19 11:09:28 ==> LookupParent impl => type github.com/goplus/xgo/cl.impl struct{}
2025/12/19 11:09:28 StructLit github.com/goplus/xgo/cl.impl 0 false
2025/12/19 11:09:28 UnaryOp & flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType *github.com/goplus/xgo/cl.impl, github.com/goplus/xgo/cl.Outer
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.Outer
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 ==> LookupParent Outer => type github.com/goplus/xgo/cl.Outer interface{github.com/goplus/xgo/cl.Inner}
2025/12/19 11:09:28 ==> Load var github.com/goplus/xgo/cl.Outer [outer]
2025/12/19 11:09:28 NewVarDefs
2025/12/19 11:09:28 NewVar [outer]
2025/12/19 11:09:28 Val New func() github.com/goplus/xgo/cl.Outer
2025/12/19 11:09:28 Call 0 0 // func() github.com/goplus/xgo/cl.Outer
2025/12/19 11:09:28 ==> MatchFuncCall func() github.com/goplus/xgo/cl.Outer args: 0 flags: 0
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> MatchType github.com/goplus/xgo/cl.Outer, github.com/goplus/xgo/cl.Outer
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.Outer
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.Outer
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 NewFunc DoStuff (*github.com/goplus/xgo/cl.impl) func() error
2025/12/19 11:09:28 Val nil untyped nil
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType untyped nil, error
2025/12/19 11:09:28 ==> EnsureLoaded error
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestInterfaceBugNilUnderlying_Issue1198 (0.10s)
=== RUN   TestInterfaceBugNilUnderlying_Issue1196
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Preload type I
2025/12/19 11:09:28 ==> Preload type T
2025/12/19 11:09:28 ==> Preload method T.M
2025/12/19 11:09:28 ==> Preload type A
2025/12/19 11:09:28 ==> Preload type B
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 DefineVarStart [i]
2025/12/19 11:09:28 ==> Load > NewType I
2025/12/19 11:09:28 NewType I
2025/12/19 11:09:28 Val I github.com/goplus/xgo/cl.I
2025/12/19 11:09:28 Val %!v(PANIC=String method: nil underlying) => Typ github.com/goplus/xgo/cl.I
2025/12/19 11:09:28 ==> Load > NewType A
2025/12/19 11:09:28 NewType A
2025/12/19 11:09:28 ==> Lookup (LoadSymbol) A => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:28 ==> Load > InitType A
2025/12/19 11:09:28 ==> Load > NewType T
2025/12/19 11:09:28 NewType T
2025/12/19 11:09:28 ==> Lookup (LoadSymbol) T => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:28 ==> Load > InitType T
2025/12/19 11:09:28 InitType T int
2025/12/19 11:09:28 ==> LookupParent T => type github.com/goplus/xgo/cl.T int
2025/12/19 11:09:28 ==> Load method github.com/goplus/xgo/cl.T.M
2025/12/19 11:09:28 InitType A struct{github.com/goplus/xgo/cl.T}
2025/12/19 11:09:28 StructLit github.com/goplus/xgo/cl.A 0 false
2025/12/19 11:09:28 Call 1 0 // TypeType{typ: github.com/goplus/xgo/cl.I}
2025/12/19 11:09:28 ==> MatchFuncCall TypeType{typ: github.com/goplus/xgo/cl.I} args: 1 flags: 0
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.A
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.I
2025/12/19 11:09:28 ==> Load > InitType I
2025/12/19 11:09:28 InitType I interface{M() int}
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 DefineVarStart [b]
2025/12/19 11:09:28 Val make TyInstruction{gogen.makeInstr}
2025/12/19 11:09:28 ==> LookupParent I => type github.com/goplus/xgo/cl.I interface{M() int}
2025/12/19 11:09:28 Typ chan github.com/goplus/xgo/cl.I
2025/12/19 11:09:28 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:28 Call 2 0 // TyInstruction{gogen.makeInstr}
2025/12/19 11:09:28 ==> MatchFuncCall TyInstruction{gogen.makeInstr} args: 2 flags: 0
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 Val b chan github.com/goplus/xgo/cl.I
2025/12/19 11:09:28 ==> Load > NewType B
2025/12/19 11:09:28 NewType B
2025/12/19 11:09:28 ==> Lookup (LoadSymbol) B => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:28 ==> Load > InitType B
2025/12/19 11:09:28 ==> LookupParent T => type github.com/goplus/xgo/cl.T int
2025/12/19 11:09:28 InitType B struct{github.com/goplus/xgo/cl.T}
2025/12/19 11:09:28 StructLit github.com/goplus/xgo/cl.B 0 false
2025/12/19 11:09:28 Send
2025/12/19 11:09:28 ==> Load var bool [ok]
2025/12/19 11:09:28 NewVarDefs
2025/12/19 11:09:28 NewVar [ok]
2025/12/19 11:09:28 VarRef i github.com/goplus/xgo/cl.I
2025/12/19 11:09:28 VarRef ok bool
2025/12/19 11:09:28 Val b chan github.com/goplus/xgo/cl.I
2025/12/19 11:09:28 UnaryOp <- flags: 2
2025/12/19 11:09:28 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 2
2025/12/19 11:09:28 Assign 2 1
2025/12/19 11:09:28 ==> MatchType github.com/goplus/xgo/cl.I, github.com/goplus/xgo/cl.I
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.I
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.I
2025/12/19 11:09:28 ==> MatchType bool, bool
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 NewFunc M (github.com/goplus/xgo/cl.T) func() int
2025/12/19 11:09:28 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType untyped int (0), int
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestInterfaceBugNilUnderlying_Issue1196 (0.00s)
=== RUN   TestMyIntInc_Issue1195
2025/12/19 11:09:28 ==> Preload type MyInt
2025/12/19 11:09:28 ==> Preload var [c]
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Load > NewType MyInt
2025/12/19 11:09:28 NewType MyInt
2025/12/19 11:09:28 ==> Load > InitType MyInt
2025/12/19 11:09:28 InitType MyInt int
2025/12/19 11:09:28 ==> LookupParent MyInt => type github.com/goplus/xgo/cl.MyInt int
2025/12/19 11:09:28 ==> Load var github.com/goplus/xgo/cl.MyInt [c]
2025/12/19 11:09:28 NewVarDefs
2025/12/19 11:09:28 NewVar [c]
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 VarRef c github.com/goplus/xgo/cl.MyInt
2025/12/19 11:09:28 IncDec ++
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestMyIntInc_Issue1195 (0.00s)
=== RUN   TestAutoPropMixedName_Issue1194
2025/12/19 11:09:28 ==> Preload type Point
2025/12/19 11:09:28 ==> Preload type Obj
2025/12/19 11:09:28 ==> Preload method Obj.Bbox
2025/12/19 11:09:28 ==> Preload method Obj.Points
2025/12/19 11:09:28 ==> Load > NewType Point
2025/12/19 11:09:28 NewType Point
2025/12/19 11:09:28 ==> Load > InitType Point
2025/12/19 11:09:28 InitType Point struct{Min int; Max int}
2025/12/19 11:09:28 ==> Load > NewType Obj
2025/12/19 11:09:28 NewType Obj
2025/12/19 11:09:28 ==> Load > InitType Obj
2025/12/19 11:09:28 ==> LookupParent Point => type github.com/goplus/xgo/cl.Point struct{Min int; Max int}
2025/12/19 11:09:28 InitType Obj struct{bbox github.com/goplus/xgo/cl.Point}
2025/12/19 11:09:28 ==> LookupParent Obj => type github.com/goplus/xgo/cl.Obj struct{bbox github.com/goplus/xgo/cl.Point}
2025/12/19 11:09:28 ==> Load method *github.com/goplus/xgo/cl.Obj.Bbox
2025/12/19 11:09:28 ==> LookupParent Point => type github.com/goplus/xgo/cl.Point struct{Min int; Max int}
2025/12/19 11:09:28 ==> LookupParent Obj => type github.com/goplus/xgo/cl.Obj struct{bbox github.com/goplus/xgo/cl.Point}
2025/12/19 11:09:28 ==> Load method *github.com/goplus/xgo/cl.Obj.Points
2025/12/19 11:09:28 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:28 NewFunc Bbox (*github.com/goplus/xgo/cl.Obj) func() github.com/goplus/xgo/cl.Point
2025/12/19 11:09:28 Val o *github.com/goplus/xgo/cl.Obj
2025/12/19 11:09:28 Member bbox 2 // *github.com/goplus/xgo/cl.Obj
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType github.com/goplus/xgo/cl.Point, github.com/goplus/xgo/cl.Point
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.Point
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.Point
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 NewFunc Points (*github.com/goplus/xgo/cl.Obj) func() [2]int
2025/12/19 11:09:28 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:28 Val o *github.com/goplus/xgo/cl.Obj
2025/12/19 11:09:28 Member bbox 2 // *github.com/goplus/xgo/cl.Obj
2025/12/19 11:09:28 Member Min 2 // github.com/goplus/xgo/cl.Point
2025/12/19 11:09:28 Val o *github.com/goplus/xgo/cl.Obj
2025/12/19 11:09:28 Member bbox 2 // *github.com/goplus/xgo/cl.Obj
2025/12/19 11:09:28 Member Max 2 // github.com/goplus/xgo/cl.Point
2025/12/19 11:09:28 ArrayLit [2]int 2 false
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType [2]int, [2]int
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestAutoPropMixedName_Issue1194 (0.00s)
=== RUN   TestShiftUntypedInt_Issue1193
2025/12/19 11:09:28 ==> Preload func GetValue
2025/12/19 11:09:28 ==> Load func GetValue
2025/12/19 11:09:28 NewFunc GetValue func(shift uint) uint
2025/12/19 11:09:28 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:28 Val shift uint
2025/12/19 11:09:28 BinaryOp <<
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType uint, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType untyped int, uint
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestShiftUntypedInt_Issue1193 (0.00s)
=== RUN   TestInitFunc
2025/12/19 11:09:28 ==> Preload func init
2025/12/19 11:09:28 ==> Preload func init
2025/12/19 11:09:28 ==> Load func init
2025/12/19 11:09:28 NewFunc init func()
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> Load func init
2025/12/19 11:09:28 NewFunc init func()
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestInitFunc (0.00s)
=== RUN   TestSlogan
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 DefineVarStart [fields]
2025/12/19 11:09:28 Val &{0 STRING "engineering"} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 STRING "STEM education"} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 STRING "data science"} *ast.BasicLit
2025/12/19 11:09:28 SliceLit <nil> 3 false
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 Val &{0 STRING "The XGo Language for"} *ast.BasicLit
2025/12/19 11:09:28 Val fields []string
2025/12/19 11:09:28 Member join 1 // []string
2025/12/19 11:09:28 Val Join func(elems []string, sep string) string
2025/12/19 11:09:28 Val &{0 STRING ", "} *ast.BasicLit
2025/12/19 11:09:28 Call 2 0 // func(elems []string, sep string) string
2025/12/19 11:09:28 ==> MatchFuncCall func(elems []string, sep string) string args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType []string, []string
2025/12/19 11:09:28 ==> MatchType untyped string (", "), string
2025/12/19 11:09:28 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped string ("The XGo Language for"), any
2025/12/19 11:09:28 ==> MatchType string, any
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestSlogan (0.00s)
=== RUN   TestAssignPrintln
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 DefineVarStart [p]
2025/12/19 11:09:28 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 Val p func(a ...any) (n int, err error)
2025/12/19 11:09:28 Val &{0 STRING "Hello world"} *ast.BasicLit
2025/12/19 11:09:28 Call 1 0 // func(a ...any) (n int, err error)
2025/12/19 11:09:28 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped string ("Hello world"), any
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestAssignPrintln (0.00s)
=== RUN   TestRedefineBuiltin
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 NewConstDefs
2025/12/19 11:09:28 ==> Preload const [append]
2025/12/19 11:09:28 ==> Preload const [len]
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 NewConstDefs
2025/12/19 11:09:28 ==> Load const [a] <nil>
2025/12/19 11:09:28 NewConst [a] 0
2025/12/19 11:09:28 ==> Load const [append] <nil>
2025/12/19 11:09:28 NewConst [append] 0
2025/12/19 11:09:28 Val iota untyped int
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> Load const [len]
2025/12/19 11:09:28 Val iota untyped int
2025/12/19 11:09:28 Val append untyped int
2025/12/19 11:09:28 Val len untyped int
2025/12/19 11:09:28 BinaryOp +
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (0), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (1), unboundFuncParam{typ: untyped int}
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestRedefineBuiltin (0.00s)
=== RUN   TestTypeConvIssue804
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 DefineVarStart [c]
2025/12/19 11:09:28 Val make TyInstruction{gogen.makeInstr}
2025/12/19 11:09:28 Typ chan int
2025/12/19 11:09:28 Call 1 0 // TyInstruction{gogen.makeInstr}
2025/12/19 11:09:28 ==> MatchFuncCall TyInstruction{gogen.makeInstr} args: 1 flags: 0
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 DefineVarStart [d]
2025/12/19 11:09:28 Typ chan<- int
2025/12/19 11:09:28 Val c chan int
2025/12/19 11:09:28 Call 1 0 // TypeType{typ: chan<- int}
2025/12/19 11:09:28 ==> MatchFuncCall TypeType{typ: chan<- int} args: 1 flags: 0
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 DefineVarStart [e]
2025/12/19 11:09:28 Typ <-chan int
2025/12/19 11:09:28 Val c chan int
2025/12/19 11:09:28 Call 1 0 // TypeType{typ: <-chan int}
2025/12/19 11:09:28 ==> MatchFuncCall TypeType{typ: <-chan int} args: 1 flags: 0
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 DefineVarStart [f]
2025/12/19 11:09:28 Val int int
2025/12/19 11:09:28 Val type int => Typ int
2025/12/19 11:09:28 Star
2025/12/19 11:09:28 Val nil untyped nil
2025/12/19 11:09:28 Call 1 0 // TypeType{typ: *int}
2025/12/19 11:09:28 ==> MatchFuncCall TypeType{typ: *int} args: 1 flags: 0
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 DefineVarStart [a]
2025/12/19 11:09:28 Val c chan int
2025/12/19 11:09:28 Val d chan<- int
2025/12/19 11:09:28 BinaryOp ==
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 DefineVarStart [b]
2025/12/19 11:09:28 Val c chan int
2025/12/19 11:09:28 Val e <-chan int
2025/12/19 11:09:28 BinaryOp ==
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestTypeConvIssue804 (0.00s)
=== RUN   TestUntypedFloatIssue798
2025/12/19 11:09:28 ==> Preload func isPow10
2025/12/19 11:09:28 ==> Load func isPow10
2025/12/19 11:09:28 NewFunc isPow10 func(x uint64) bool
2025/12/19 11:09:28 Switch
2025/12/19 11:09:28 Val x uint64
2025/12/19 11:09:28 Then
2025/12/19 11:09:28 Case
2025/12/19 11:09:28 Val &{0 FLOAT 1e0} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 FLOAT 1e1} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 FLOAT 1e2} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 FLOAT 1e3} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 FLOAT 1e4} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 FLOAT 1e5} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 FLOAT 1e6} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 FLOAT 1e7} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 FLOAT 1e8} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 FLOAT 1e9} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 FLOAT 1e10} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 FLOAT 1e11} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 FLOAT 1e12} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 FLOAT 1e13} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 FLOAT 1e14} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 FLOAT 1e15} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 FLOAT 1e16} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 FLOAT 1e17} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 FLOAT 1e18} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 FLOAT 1e19} *ast.BasicLit
2025/12/19 11:09:28 Then
2025/12/19 11:09:28 Val true untyped bool
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType untyped bool (true), bool
2025/12/19 11:09:28 End // Case
2025/12/19 11:09:28 End // Switch
2025/12/19 11:09:28 Val false untyped bool
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType untyped bool (false), bool
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestUntypedFloatIssue798 (0.00s)
=== RUN   TestInterfaceIssue795
2025/12/19 11:09:28 ==> Preload type I
2025/12/19 11:09:28 ==> Preload type T1
2025/12/19 11:09:28 ==> Preload method T1.a
2025/12/19 11:09:28 ==> Preload method T1.b
2025/12/19 11:09:28 ==> Load > NewType I
2025/12/19 11:09:28 NewType I
2025/12/19 11:09:28 ==> Load > InitType I
2025/12/19 11:09:28 ==> LookupParent I => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:28 InitType I interface{a(s string) github.com/goplus/xgo/cl.I; b(s string) string}
2025/12/19 11:09:28 ==> Load > NewType T1
2025/12/19 11:09:28 NewType T1
2025/12/19 11:09:28 ==> Load > InitType T1
2025/12/19 11:09:28 InitType T1 int
2025/12/19 11:09:28 ==> LookupParent T1 => type github.com/goplus/xgo/cl.T1 int
2025/12/19 11:09:28 ==> Load method github.com/goplus/xgo/cl.T1.a
2025/12/19 11:09:28 ==> LookupParent I => type github.com/goplus/xgo/cl.I interface{a(s string) github.com/goplus/xgo/cl.I; b(s string) string}
2025/12/19 11:09:28 ==> LookupParent T1 => type github.com/goplus/xgo/cl.T1 int
2025/12/19 11:09:28 ==> Load method github.com/goplus/xgo/cl.T1.b
2025/12/19 11:09:28 NewFunc a (github.com/goplus/xgo/cl.T1) func(s string) github.com/goplus/xgo/cl.I
2025/12/19 11:09:28 Val t github.com/goplus/xgo/cl.T1
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType github.com/goplus/xgo/cl.T1, github.com/goplus/xgo/cl.I
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.I
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 NewFunc b (github.com/goplus/xgo/cl.T1) func(s string) string
2025/12/19 11:09:28 Val s string
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType string, string
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestInterfaceIssue795 (0.00s)
=== RUN   TestChanRecvIssue789
2025/12/19 11:09:28 ==> Preload func foo
2025/12/19 11:09:28 ==> Load func foo
2025/12/19 11:09:28 NewFunc foo func(ch chan int) (int, bool)
2025/12/19 11:09:28 DefineVarStart [x ok]
2025/12/19 11:09:28 Val ch chan int
2025/12/19 11:09:28 UnaryOp <- flags: 2
2025/12/19 11:09:28 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 2
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 Val x int
2025/12/19 11:09:28 Val ok bool
2025/12/19 11:09:28 Return 2
2025/12/19 11:09:28 ==> MatchType int, int
2025/12/19 11:09:28 ==> MatchType bool, bool
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestChanRecvIssue789 (0.00s)
=== RUN   TestNamedChanCloseIssue790
2025/12/19 11:09:28 ==> Preload type XChan
2025/12/19 11:09:28 ==> Preload func foo
2025/12/19 11:09:28 ==> Load > NewType XChan
2025/12/19 11:09:28 NewType XChan
2025/12/19 11:09:28 ==> Load > InitType XChan
2025/12/19 11:09:28 InitType XChan chan int
2025/12/19 11:09:28 ==> Load func foo
2025/12/19 11:09:28 ==> LookupParent XChan => type github.com/goplus/xgo/cl.XChan chan int
2025/12/19 11:09:28 NewFunc foo func(ch github.com/goplus/xgo/cl.XChan)
2025/12/19 11:09:28 Val close TemplateSignature{func(c unboundProxyParam{typ: chan<- TemplateParamType{name: Type}})}
2025/12/19 11:09:28 Val ch github.com/goplus/xgo/cl.XChan
2025/12/19 11:09:28 Call 1 0 // TemplateSignature{func(c unboundProxyParam{typ: chan<- TemplateParamType{name: Type}})}
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(c unboundProxyParam{typ: chan<- TemplateParamType{name: Type}})} args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType chan int, unboundProxyParam{typ: chan<- unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestNamedChanCloseIssue790 (0.00s)
=== RUN   TestUntypedFloatIssue793
2025/12/19 11:09:28 ==> Preload var [a]
2025/12/19 11:09:28 Val &{0 FLOAT 1e1} *ast.BasicLit
2025/12/19 11:09:28 ==> Load var [10]int [a]
2025/12/19 11:09:28 NewVarDefs
2025/12/19 11:09:28 NewVar [a]
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestUntypedFloatIssue793 (0.00s)
=== RUN   TestUntypedFloatIssue788
2025/12/19 11:09:28 ==> Preload func foo
2025/12/19 11:09:28 ==> Load func foo
2025/12/19 11:09:28 NewFunc foo func(v int) bool
2025/12/19 11:09:28 Val v int
2025/12/19 11:09:28 Val &{0 FLOAT 1.1e5} *ast.BasicLit
2025/12/19 11:09:28 BinaryOp >
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped float (110000), unboundFuncParam{typ: int}
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType untyped bool, bool
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestUntypedFloatIssue788 (0.00s)
=== RUN   TestSwitchCompositeLitIssue801
2025/12/19 11:09:28 ==> Preload type T
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Load > NewType T
2025/12/19 11:09:28 NewType T
2025/12/19 11:09:28 ==> Load > InitType T
2025/12/19 11:09:28 InitType T struct{X int}
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 Switch
2025/12/19 11:09:28 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{X int}
2025/12/19 11:09:28 StructLit github.com/goplus/xgo/cl.T 0 false
2025/12/19 11:09:28 Then
2025/12/19 11:09:28 Case
2025/12/19 11:09:28 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{X int}
2025/12/19 11:09:28 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:28 StructLit github.com/goplus/xgo/cl.T 1 false
2025/12/19 11:09:28 Then
2025/12/19 11:09:28 Val panic func(v interface{})
2025/12/19 11:09:28 Val &{0 STRING "bad"} *ast.BasicLit
2025/12/19 11:09:28 Call 1 0 // func(v interface{})
2025/12/19 11:09:28 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped string ("bad"), interface{}
2025/12/19 11:09:28 End // Case
2025/12/19 11:09:28 End // Switch
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestSwitchCompositeLitIssue801 (0.00s)
=== RUN   TestConstIssue800
2025/12/19 11:09:28 NewConstDefs
2025/12/19 11:09:28 ==> Preload const [h0_0 h0_1]
2025/12/19 11:09:28 ==> Preload const [h1_0 h1_1]
2025/12/19 11:09:28 ==> Load const [h0_0 h0_1] <nil>
2025/12/19 11:09:28 NewConst [h0_0 h0_1] 0
2025/12/19 11:09:28 Val &{0 FLOAT 1.0} *ast.BasicLit
2025/12/19 11:09:28 Val iota untyped int
2025/12/19 11:09:28 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:28 BinaryOp +
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (0), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (1), unboundFuncParam{typ: untyped int}
2025/12/19 11:09:28 BinaryOp /
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped float (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (1), unboundFuncParam{typ: untyped float}
2025/12/19 11:09:28 Val &{0 FLOAT 1.0} *ast.BasicLit
2025/12/19 11:09:28 Val iota untyped int
2025/12/19 11:09:28 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:28 BinaryOp +
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (0), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (2), unboundFuncParam{typ: untyped int}
2025/12/19 11:09:28 BinaryOp /
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped float (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (2), unboundFuncParam{typ: untyped float}
2025/12/19 11:09:28 EndInit 2
2025/12/19 11:09:28 ==> Load const [h1_0 h1_1]
2025/12/19 11:09:28 Val &{0 FLOAT 1.0} *ast.BasicLit
2025/12/19 11:09:28 Val iota untyped int
2025/12/19 11:09:28 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:28 BinaryOp +
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (1), unboundFuncParam{typ: untyped int}
2025/12/19 11:09:28 BinaryOp /
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped float (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (2), unboundFuncParam{typ: untyped float}
2025/12/19 11:09:28 Val &{0 FLOAT 1.0} *ast.BasicLit
2025/12/19 11:09:28 Val iota untyped int
2025/12/19 11:09:28 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:28 BinaryOp +
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (2), unboundFuncParam{typ: untyped int}
2025/12/19 11:09:28 BinaryOp /
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped float (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (3), unboundFuncParam{typ: untyped float}
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestConstIssue800 (0.00s)
=== RUN   TestConstIssue805
2025/12/19 11:09:28 NewConstDefs
2025/12/19 11:09:28 ==> Preload const [n1]
2025/12/19 11:09:28 ==> Preload const [d1]
2025/12/19 11:09:28 ==> Preload const [q1]
2025/12/19 11:09:28 ==> Preload const [r1]
2025/12/19 11:09:28 NewConstDefs
2025/12/19 11:09:28 ==> Preload const [ret1]
2025/12/19 11:09:28 ==> Preload const [ret2]
2025/12/19 11:09:28 ==> Preload const [ret3]
2025/12/19 11:09:28 ==> Load const [n1] <nil>
2025/12/19 11:09:28 NewConst [n1] 0
2025/12/19 11:09:28 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:28 UnaryOp + flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (5), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> Load const [d1] <nil>
2025/12/19 11:09:28 NewConst [d1] 1
2025/12/19 11:09:28 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:28 UnaryOp + flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (3), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> Load const [q1] <nil>
2025/12/19 11:09:28 NewConst [q1] 2
2025/12/19 11:09:28 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:28 UnaryOp + flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> Load const [r1] <nil>
2025/12/19 11:09:28 NewConst [r1] 3
2025/12/19 11:09:28 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:28 UnaryOp + flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (2), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> Load const [ret1] <nil>
2025/12/19 11:09:28 NewConst [ret1] 0
2025/12/19 11:09:28 Val n1 untyped int
2025/12/19 11:09:28 Val d1 untyped int
2025/12/19 11:09:28 BinaryOp /
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (5), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (3), unboundFuncParam{typ: untyped int}
2025/12/19 11:09:28 Val q1 untyped int
2025/12/19 11:09:28 BinaryOp !=
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> Load const [ret2] <nil>
2025/12/19 11:09:28 NewConst [ret2] 1
2025/12/19 11:09:28 Val n1 untyped int
2025/12/19 11:09:28 Val d1 untyped int
2025/12/19 11:09:28 BinaryOp %
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (5), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (3), unboundFuncParam{typ: untyped int}
2025/12/19 11:09:28 Val r1 untyped int
2025/12/19 11:09:28 BinaryOp !=
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> Load const [ret3] <nil>
2025/12/19 11:09:28 NewConst [ret3] 2
2025/12/19 11:09:28 Val n1 untyped int
2025/12/19 11:09:28 Val d1 untyped int
2025/12/19 11:09:28 BinaryOp /
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (5), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (3), unboundFuncParam{typ: untyped int}
2025/12/19 11:09:28 Val q1 untyped int
2025/12/19 11:09:28 BinaryOp !=
2025/12/19 11:09:28 Val n1 untyped int
2025/12/19 11:09:28 Val d1 untyped int
2025/12/19 11:09:28 BinaryOp %
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (5), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (3), unboundFuncParam{typ: untyped int}
2025/12/19 11:09:28 Val r1 untyped int
2025/12/19 11:09:28 BinaryOp !=
2025/12/19 11:09:28 BinaryOp ||
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped bool (false), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped bool (false), unboundFuncParam{typ: untyped bool}
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestConstIssue805 (0.00s)
=== RUN   TestUntypedNilIssue806
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 Switch
2025/12/19 11:09:28 DefineVarStart [f]
2025/12/19 11:09:28 NewClosure func()
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 Val f func()
2025/12/19 11:09:28 Then
2025/12/19 11:09:28 Case
2025/12/19 11:09:28 Val nil untyped nil
2025/12/19 11:09:28 Then
2025/12/19 11:09:28 End // Case
2025/12/19 11:09:28 End // Switch
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestUntypedNilIssue806 (0.00s)
=== RUN   TestSwitchIssue807
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 Switch
2025/12/19 11:09:28 None
2025/12/19 11:09:28 Then
2025/12/19 11:09:28 Case
2025/12/19 11:09:28 Typ interface{}
2025/12/19 11:09:28 Val true untyped bool
2025/12/19 11:09:28 Call 1 0 // TypeType{typ: interface{}}
2025/12/19 11:09:28 ==> MatchFuncCall TypeType{typ: interface{}} args: 1 flags: 0
2025/12/19 11:09:28 Then
2025/12/19 11:09:28 End // Case
2025/12/19 11:09:28 End // Switch
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestSwitchIssue807 (0.00s)
=== RUN   TestUntypedComplexIssue799
2025/12/19 11:09:28 NewConstDefs
2025/12/19 11:09:28 ==> Preload const [ulp1]
2025/12/19 11:09:28 NewConstDefs
2025/12/19 11:09:28 ==> Preload const [ulp2]
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Load const [ulp1] <nil>
2025/12/19 11:09:28 NewConst [ulp1] 0
2025/12/19 11:09:28 Val imag func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 Val &{0 IMAG 1i} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 IMAG 2i} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:28 BinaryOp /
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped complex ((0 + 2i)), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (3), unboundFuncParam{typ: untyped complex}
2025/12/19 11:09:28 BinaryOp +
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped complex ((0 + 1i)), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped complex ((0 + 0.666667i)), unboundFuncParam{typ: untyped complex}
2025/12/19 11:09:28 Val &{0 IMAG 5i} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:28 BinaryOp /
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped complex ((0 + 5i)), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (3), unboundFuncParam{typ: untyped complex}
2025/12/19 11:09:28 BinaryOp -
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped complex ((0 + 1.66667i)), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped complex ((0 + 1.66667i)), unboundFuncParam{typ: untyped complex}
2025/12/19 11:09:28 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall func(c untyped complex) untyped float args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped complex ((0 + 0i)), untyped complex
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> Load const [ulp2] <nil>
2025/12/19 11:09:28 NewConst [ulp2] 0
2025/12/19 11:09:28 Val imag func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 Val &{0 IMAG 1i} *ast.BasicLit
2025/12/19 11:09:28 Val complex func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:28 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall func(r untyped float, i untyped float) untyped complex args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (0), untyped float
2025/12/19 11:09:28 ==> MatchType untyped int (2), untyped float
2025/12/19 11:09:28 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:28 BinaryOp /
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped complex ((0 + 2i)), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (3), unboundFuncParam{typ: untyped complex}
2025/12/19 11:09:28 BinaryOp +
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped complex ((0 + 1i)), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped complex ((0 + 0.666667i)), unboundFuncParam{typ: untyped complex}
2025/12/19 11:09:28 Val &{0 IMAG 5i} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:28 BinaryOp /
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped complex ((0 + 5i)), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (3), unboundFuncParam{typ: untyped complex}
2025/12/19 11:09:28 BinaryOp -
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped complex ((0 + 1.66667i)), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped complex ((0 + 1.66667i)), unboundFuncParam{typ: untyped complex}
2025/12/19 11:09:28 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall func(c untyped complex) untyped float args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped complex ((0 + 0i)), untyped complex
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 NewConstDefs
2025/12/19 11:09:28 ==> Load const [a] <nil>
2025/12/19 11:09:28 NewConst [a] 0
2025/12/19 11:09:28 Val ulp1 untyped float
2025/12/19 11:09:28 Val ulp2 untyped float
2025/12/19 11:09:28 BinaryOp ==
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestUntypedComplexIssue799 (0.00s)
=== RUN   TestUnderscoreConstAndVar
2025/12/19 11:09:28 NewConstDefs
2025/12/19 11:09:28 ==> Preload const [c0]
2025/12/19 11:09:28 ==> Preload const [_]
2025/12/19 11:09:28 ==> Preload const [_]
2025/12/19 11:09:28 ==> Preload const [_]
2025/12/19 11:09:28 ==> Preload const [c4]
2025/12/19 11:09:28 ==> Preload func i
2025/12/19 11:09:28 ==> Preload var [_]
2025/12/19 11:09:28 ==> Preload var [_]
2025/12/19 11:09:28 ==> Load const [c0] <nil>
2025/12/19 11:09:28 NewConst [c0] 0
2025/12/19 11:09:28 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:28 Val iota untyped int
2025/12/19 11:09:28 BinaryOp <<
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (0), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> Load const [_]
2025/12/19 11:09:28 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:28 Val iota untyped int
2025/12/19 11:09:28 BinaryOp <<
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> Load const [_]
2025/12/19 11:09:28 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:28 Val iota untyped int
2025/12/19 11:09:28 BinaryOp <<
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (2), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> Load const [_]
2025/12/19 11:09:28 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:28 Val iota untyped int
2025/12/19 11:09:28 BinaryOp <<
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (3), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> Load const [c4]
2025/12/19 11:09:28 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:28 Val iota untyped int
2025/12/19 11:09:28 BinaryOp <<
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped int (4), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> Load func i
2025/12/19 11:09:28 NewFunc i func() int
2025/12/19 11:09:28 Val &{0 INT 23} *ast.BasicLit
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType untyped int (23), int
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> Load var <nil> [_]
2025/12/19 11:09:28 NewVarDefs
2025/12/19 11:09:28 NewVar [_]
2025/12/19 11:09:28 Val i func() int
2025/12/19 11:09:28 Call 0 0 // func() int
2025/12/19 11:09:28 ==> MatchFuncCall func() int args: 0 flags: 0
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> Load var <nil> [_]
2025/12/19 11:09:28 NewVarDefs
2025/12/19 11:09:28 NewVar [_]
2025/12/19 11:09:28 Val i func() int
2025/12/19 11:09:28 Call 0 0 // func() int
2025/12/19 11:09:28 ==> MatchFuncCall func() int args: 0 flags: 0
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestUnderscoreConstAndVar (0.00s)
=== RUN   TestUnderscoreFuncAndMethod
2025/12/19 11:09:28 ==> Preload func _
2025/12/19 11:09:28 ==> Preload type T
2025/12/19 11:09:28 ==> Preload method T._
2025/12/19 11:09:28 ==> Preload method T._
2025/12/19 11:09:28 ==> Load > NewType T
2025/12/19 11:09:28 NewType T
2025/12/19 11:09:28 ==> Load > InitType T
2025/12/19 11:09:28 InitType T struct{_ int; _ int; _ int}
2025/12/19 11:09:28 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{_ int; _ int; _ int}
2025/12/19 11:09:28 ==> Load method github.com/goplus/xgo/cl.T._
2025/12/19 11:09:28 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{_ int; _ int; _ int}
2025/12/19 11:09:28 ==> Load method github.com/goplus/xgo/cl.T._
2025/12/19 11:09:28 ==> Load func _
2025/12/19 11:09:28 NewFunc _ func()
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 NewFunc _ (github.com/goplus/xgo/cl.T) func()
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 NewFunc _ (github.com/goplus/xgo/cl.T) func()
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestUnderscoreFuncAndMethod (0.00s)
=== RUN   TestErrWrapIssue772
2025/12/19 11:09:28 ==> Preload func t
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Load func t
2025/12/19 11:09:28 NewFunc t func() (int, int, error)
2025/12/19 11:09:28 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:28 Val nil untyped nil
2025/12/19 11:09:28 Return 3
2025/12/19 11:09:28 ==> MatchType untyped int (0), int
2025/12/19 11:09:28 ==> MatchType untyped int (0), int
2025/12/19 11:09:28 ==> MatchType untyped nil, error
2025/12/19 11:09:28 ==> EnsureLoaded error
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 DefineVarStart [a b]
2025/12/19 11:09:28 Val t func() (int, int, error)
2025/12/19 11:09:28 Call 0 0 // func() (int, int, error)
2025/12/19 11:09:28 ==> MatchFuncCall func() (int, int, error) args: 0 flags: 0
2025/12/19 11:09:28 NewClosure func() (_xgo_ret unboundType{typ: <nil>}, _xgo_ret2 unboundType{typ: <nil>})
2025/12/19 11:09:28 NewVar [_xgo_err]
2025/12/19 11:09:28 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:28 VarRef _xgo_ret2 unboundType{typ: <nil>}
2025/12/19 11:09:28 VarRef _xgo_err error
2025/12/19 11:09:28 Assign 3 1
2025/12/19 11:09:28 ==> MatchType int, unboundType{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType int, unboundType{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType error, error
2025/12/19 11:09:28 ==> EnsureLoaded error
2025/12/19 11:09:28 ==> EnsureLoaded error
2025/12/19 11:09:28 If
2025/12/19 11:09:28 Val _xgo_err error
2025/12/19 11:09:28 Val <nil> <nil>
2025/12/19 11:09:28 BinaryOp !=
2025/12/19 11:09:28 Typ error
2025/12/19 11:09:28 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:28 Then
2025/12/19 11:09:28 VarRef _xgo_err error
2025/12/19 11:09:28 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:28 Val _xgo_err error
2025/12/19 11:09:28 Val t() string
2025/12/19 11:09:28 Val /foo/bar.xgo string
2025/12/19 11:09:28 Val 9 int
2025/12/19 11:09:28 Val main.main string
2025/12/19 11:09:28 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:28 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/12/19 11:09:28 ==> MatchType error, error
2025/12/19 11:09:28 ==> EnsureLoaded error
2025/12/19 11:09:28 ==> EnsureLoaded error
2025/12/19 11:09:28 ==> MatchType untyped string ("t()"), string
2025/12/19 11:09:28 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/12/19 11:09:28 ==> MatchType untyped int (9), int
2025/12/19 11:09:28 ==> MatchType untyped string ("main.main"), string
2025/12/19 11:09:28 Assign 1 1
2025/12/19 11:09:28 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/12/19 11:09:28 ==> EnsureLoaded error
2025/12/19 11:09:28 Val panic func(v interface{})
2025/12/19 11:09:28 Val _xgo_err error
2025/12/19 11:09:28 Call 1 0 // func(v interface{})
2025/12/19 11:09:28 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType error, interface{}
2025/12/19 11:09:28 ==> EnsureLoaded error
2025/12/19 11:09:28 End // If
2025/12/19 11:09:28 Return 0
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 Call 0 0 // func() (_xgo_ret int, _xgo_ret2 int)
2025/12/19 11:09:28 ==> MatchFuncCall func() (_xgo_ret int, _xgo_ret2 int) args: 0 flags: 0
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 Val a int
2025/12/19 11:09:28 Val b int
2025/12/19 11:09:28 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType int, any
2025/12/19 11:09:28 ==> MatchType int, any
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestErrWrapIssue772 (0.14s)
=== RUN   TestErrWrapIssue778
2025/12/19 11:09:28 ==> Preload func t
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Load func t
2025/12/19 11:09:28 NewFunc t func() error
2025/12/19 11:09:28 Val nil untyped nil
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType untyped nil, error
2025/12/19 11:09:28 ==> EnsureLoaded error
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 Val t func() error
2025/12/19 11:09:28 Call 0 0 // func() error
2025/12/19 11:09:28 ==> MatchFuncCall func() error args: 0 flags: 0
2025/12/19 11:09:28 NewClosure func()
2025/12/19 11:09:28 NewVar [_xgo_err]
2025/12/19 11:09:28 VarRef _xgo_err error
2025/12/19 11:09:28 Assign 1 1
2025/12/19 11:09:28 ==> MatchType error, error
2025/12/19 11:09:28 ==> EnsureLoaded error
2025/12/19 11:09:28 ==> EnsureLoaded error
2025/12/19 11:09:28 If
2025/12/19 11:09:28 Val _xgo_err error
2025/12/19 11:09:28 Val <nil> <nil>
2025/12/19 11:09:28 BinaryOp !=
2025/12/19 11:09:28 Typ error
2025/12/19 11:09:28 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:28 Then
2025/12/19 11:09:28 VarRef _xgo_err error
2025/12/19 11:09:28 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:28 Val _xgo_err error
2025/12/19 11:09:28 Val t() string
2025/12/19 11:09:28 Val /foo/bar.xgo string
2025/12/19 11:09:28 Val 9 int
2025/12/19 11:09:28 Val main.main string
2025/12/19 11:09:28 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:28 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/12/19 11:09:28 ==> MatchType error, error
2025/12/19 11:09:28 ==> EnsureLoaded error
2025/12/19 11:09:28 ==> EnsureLoaded error
2025/12/19 11:09:28 ==> MatchType untyped string ("t()"), string
2025/12/19 11:09:28 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/12/19 11:09:28 ==> MatchType untyped int (9), int
2025/12/19 11:09:28 ==> MatchType untyped string ("main.main"), string
2025/12/19 11:09:28 Assign 1 1
2025/12/19 11:09:28 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/12/19 11:09:28 ==> EnsureLoaded error
2025/12/19 11:09:28 Val panic func(v interface{})
2025/12/19 11:09:28 Val _xgo_err error
2025/12/19 11:09:28 Call 1 0 // func(v interface{})
2025/12/19 11:09:28 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType error, interface{}
2025/12/19 11:09:28 ==> EnsureLoaded error
2025/12/19 11:09:28 End // If
2025/12/19 11:09:28 Return 0
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 Call 0 0 // func()
2025/12/19 11:09:28 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestErrWrapIssue778 (0.00s)
=== RUN   TestIssue774
=== RUN   TestIssue774/InterfaceTypeAssert
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Preload type AA
2025/12/19 11:09:28 ==> Preload type A
2025/12/19 11:09:28 ==> Preload method A.String
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 ==> Load > NewType AA
2025/12/19 11:09:28 NewType AA
2025/12/19 11:09:28 ==> Lookup (LoadSymbol) AA => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:28 ==> Load var github.com/goplus/xgo/cl.AA [a]
2025/12/19 11:09:28 NewVarDefs
2025/12/19 11:09:28 NewVar [a]
2025/12/19 11:09:28 ==> Load > NewType A
2025/12/19 11:09:28 NewType A
2025/12/19 11:09:28 ==> Lookup (LoadSymbol) A => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:28 ==> Load > InitType A
2025/12/19 11:09:28 InitType A struct{str string}
2025/12/19 11:09:28 ==> LookupParent A => type github.com/goplus/xgo/cl.A struct{str string}
2025/12/19 11:09:28 ==> Load method *github.com/goplus/xgo/cl.A.String
2025/12/19 11:09:28 Val 0 int
2025/12/19 11:09:28 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:28 StructLit github.com/goplus/xgo/cl.A 2 true
2025/12/19 11:09:28 UnaryOp & flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> MatchType *github.com/goplus/xgo/cl.A, github.com/goplus/xgo/cl.AA
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.AA
2025/12/19 11:09:28 ==> Load > InitType AA
2025/12/19 11:09:28 InitType AA interface{String() string}
2025/12/19 11:09:28 Val Println func(a ...any) (n int, err error)
2025/12/19 11:09:28 Val a github.com/goplus/xgo/cl.AA
2025/12/19 11:09:28 ==> LookupParent A => type github.com/goplus/xgo/cl.A struct{str string}
2025/12/19 11:09:28 TypeAssert *github.com/goplus/xgo/cl.A false
2025/12/19 11:09:28 Call 1 0 // func(a ...any) (n int, err error)
2025/12/19 11:09:28 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType *github.com/goplus/xgo/cl.A, any
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 NewFunc String (*github.com/goplus/xgo/cl.A) func() string
2025/12/19 11:09:28 Val a *github.com/goplus/xgo/cl.A
2025/12/19 11:09:28 Member str 2 // *github.com/goplus/xgo/cl.A
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType string, string
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
=== RUN   TestIssue774/getInterface
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Preload type AA
2025/12/19 11:09:28 ==> Preload func get
2025/12/19 11:09:28 ==> Preload type A
2025/12/19 11:09:28 ==> Preload method A.String
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 DefineVarStart [a]
2025/12/19 11:09:28 ==> Load func get
2025/12/19 11:09:28 ==> Load > NewType AA
2025/12/19 11:09:28 NewType AA
2025/12/19 11:09:28 ==> Lookup (LoadSymbol) AA => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:28 NewFunc get func() github.com/goplus/xgo/cl.AA
2025/12/19 11:09:28 ==> LookupParent AA => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:28 ==> Load var github.com/goplus/xgo/cl.AA [a]
2025/12/19 11:09:28 NewVarDefs
2025/12/19 11:09:28 NewVar [a]
2025/12/19 11:09:28 Val a github.com/goplus/xgo/cl.AA
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType github.com/goplus/xgo/cl.AA, github.com/goplus/xgo/cl.AA
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.AA
2025/12/19 11:09:28 ==> Load > InitType AA
2025/12/19 11:09:28 InitType AA interface{String() string}
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.AA
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 Val get func() github.com/goplus/xgo/cl.AA
2025/12/19 11:09:28 Call 0 0 // func() github.com/goplus/xgo/cl.AA
2025/12/19 11:09:28 ==> MatchFuncCall func() github.com/goplus/xgo/cl.AA args: 0 flags: 0
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 Val Println func(a ...any) (n int, err error)
2025/12/19 11:09:28 Val a github.com/goplus/xgo/cl.AA
2025/12/19 11:09:28 ==> Load > NewType A
2025/12/19 11:09:28 NewType A
2025/12/19 11:09:28 ==> Lookup (LoadSymbol) A => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:28 TypeAssert *github.com/goplus/xgo/cl.A false
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.A
2025/12/19 11:09:28 ==> Load > InitType A
2025/12/19 11:09:28 InitType A struct{str string}
2025/12/19 11:09:28 ==> LookupParent A => type github.com/goplus/xgo/cl.A struct{str string}
2025/12/19 11:09:28 ==> Load method *github.com/goplus/xgo/cl.A.String
2025/12/19 11:09:28 Call 1 0 // func(a ...any) (n int, err error)
2025/12/19 11:09:28 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType *github.com/goplus/xgo/cl.A, any
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 NewFunc String (*github.com/goplus/xgo/cl.A) func() string
2025/12/19 11:09:28 Val a *github.com/goplus/xgo/cl.A
2025/12/19 11:09:28 Member str 2 // *github.com/goplus/xgo/cl.A
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType string, string
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestIssue774 (0.00s)
    --- PASS: TestIssue774/InterfaceTypeAssert (0.00s)
    --- PASS: TestIssue774/getInterface (0.00s)
=== RUN   TestBlockStmt
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 Block
2025/12/19 11:09:28 NewType T
2025/12/19 11:09:28 InitType T int
2025/12/19 11:09:28 DefineVarStart [t]
2025/12/19 11:09:28 Val T github.com/goplus/xgo/cl.T
2025/12/19 11:09:28 Val type T int => Typ github.com/goplus/xgo/cl.T
2025/12/19 11:09:28 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:28 Call 1 0 // TypeType{typ: github.com/goplus/xgo/cl.T}
2025/12/19 11:09:28 ==> MatchFuncCall TypeType{typ: github.com/goplus/xgo/cl.T} args: 1 flags: 0
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.T
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 Val t github.com/goplus/xgo/cl.T
2025/12/19 11:09:28 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType github.com/goplus/xgo/cl.T, any
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.T
2025/12/19 11:09:28 End // Block
2025/12/19 11:09:28 Block
2025/12/19 11:09:28 NewType T
2025/12/19 11:09:28 InitType T string
2025/12/19 11:09:28 DefineVarStart [t]
2025/12/19 11:09:28 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 Val t string
2025/12/19 11:09:28 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType string, any
2025/12/19 11:09:28 End // Block
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestBlockStmt (0.00s)
=== RUN   TestConstTypeConvIssue792
2025/12/19 11:09:28 NewConstDefs
2025/12/19 11:09:28 ==> Preload const [dots]
2025/12/19 11:09:28 NewConstDefs
2025/12/19 11:09:28 ==> Preload const [n]
2025/12/19 11:09:28 ==> Load const [dots] <nil>
2025/12/19 11:09:28 NewConst [dots] 0
2025/12/19 11:09:28 Val &{0 STRING ". . . "} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 STRING ". . . . . "} *ast.BasicLit
2025/12/19 11:09:28 BinaryOp +
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped string (". . . "), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType untyped string (". . . . . "), unboundFuncParam{typ: untyped string}
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> Load const [n] <nil>
2025/12/19 11:09:28 NewConst [n] 0
2025/12/19 11:09:28 Val uint uint
2025/12/19 11:09:28 Val type uint => Typ uint
2025/12/19 11:09:28 Val len TyInstruction{gogen.lenInstr}
2025/12/19 11:09:28 Val dots untyped string
2025/12/19 11:09:28 Call 1 0 // TyInstruction{gogen.lenInstr}
2025/12/19 11:09:28 ==> MatchFuncCall TyInstruction{gogen.lenInstr} args: 1 flags: 0
2025/12/19 11:09:28 Call 1 0 // TypeType{typ: uint}
2025/12/19 11:09:28 ==> MatchFuncCall TypeType{typ: uint} args: 1 flags: 0
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestConstTypeConvIssue792 (0.00s)
=== RUN   TestVarInitTwoValueIssue791
2025/12/19 11:09:28 ==> Preload var [m]
2025/12/19 11:09:28 ==> Preload var [a ok]
2025/12/19 11:09:28 ==> Load var <nil> [m]
2025/12/19 11:09:28 NewVarDefs
2025/12/19 11:09:28 NewVar [m]
2025/12/19 11:09:28 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 STRING "A"} *ast.BasicLit
2025/12/19 11:09:28 MapLit map[string]string 2
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> Load var <nil> [a ok]
2025/12/19 11:09:28 NewVarDefs
2025/12/19 11:09:28 NewVar [a ok]
2025/12/19 11:09:28 Val m map[string]string
2025/12/19 11:09:28 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:28 Index 1 true
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestVarInitTwoValueIssue791 (0.00s)
=== RUN   TestVarAfterMain
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Preload var [i]
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> Load var int [i]
2025/12/19 11:09:28 NewVarDefs
2025/12/19 11:09:28 NewVar [i]
2025/12/19 11:09:28 Val i int
2025/12/19 11:09:28 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType int, any
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
2025/12/19 11:09:28 ==> Preload func f
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Preload var [sink]
2025/12/19 11:09:28 ==> Load func f
2025/12/19 11:09:28 NewFunc f func(v float64) float64
2025/12/19 11:09:28 Val v float64
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType float64, float64
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 ==> Load var float64 [sink]
2025/12/19 11:09:28 NewVarDefs
2025/12/19 11:09:28 NewVar [sink]
2025/12/19 11:09:28 VarRef sink float64
2025/12/19 11:09:28 Val f func(v float64) float64
2025/12/19 11:09:28 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:28 Call 1 0 // func(v float64) float64
2025/12/19 11:09:28 ==> MatchFuncCall func(v float64) float64 args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (100), float64
2025/12/19 11:09:28 Assign 1 1
2025/12/19 11:09:28 ==> MatchType float64, float64
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestVarAfterMain (0.00s)
=== RUN   TestVarAfterMain2
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Preload var [i]
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> Load var <nil> [i]
2025/12/19 11:09:28 NewVarDefs
2025/12/19 11:09:28 NewVar [i]
2025/12/19 11:09:28 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 Val i int
2025/12/19 11:09:28 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType int, any
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestVarAfterMain2 (0.00s)
=== RUN   TestVarInMain
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 DefineVarStart [v]
2025/12/19 11:09:28 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:28 SliceLit []uint64 3 false
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> Load var <nil> [n]
2025/12/19 11:09:28 NewVarDefs
2025/12/19 11:09:28 NewVar [n]
2025/12/19 11:09:28 Val len TyInstruction{gogen.lenInstr}
2025/12/19 11:09:28 Val v []uint64
2025/12/19 11:09:28 Call 1 0 // TyInstruction{gogen.lenInstr}
2025/12/19 11:09:28 ==> MatchFuncCall TyInstruction{gogen.lenInstr} args: 1 flags: 0
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 Val n int
2025/12/19 11:09:28 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType int, any
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestVarInMain (0.00s)
=== RUN   TestSelect
2025/12/19 11:09:28 ==> Preload func consume
2025/12/19 11:09:28 ==> Load func consume
2025/12/19 11:09:28 NewFunc consume func(xchg chan int)
2025/12/19 11:09:28 Select
2025/12/19 11:09:28 CommCase
2025/12/19 11:09:28 DefineVarStart [c]
2025/12/19 11:09:28 Val xchg chan int
2025/12/19 11:09:28 UnaryOp <- flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 0
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 Then
2025/12/19 11:09:28 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 Val c int
2025/12/19 11:09:28 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType int, any
2025/12/19 11:09:28 End // CommCase
2025/12/19 11:09:28 CommCase
2025/12/19 11:09:28 Val xchg chan int
2025/12/19 11:09:28 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:28 Send
2025/12/19 11:09:28 Then
2025/12/19 11:09:28 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 Val &{0 STRING "send ok"} *ast.BasicLit
2025/12/19 11:09:28 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped string ("send ok"), any
2025/12/19 11:09:28 End // CommCase
2025/12/19 11:09:28 CommCase
2025/12/19 11:09:28 Then
2025/12/19 11:09:28 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:28 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped int (0), any
2025/12/19 11:09:28 End // CommCase
2025/12/19 11:09:28 End // Select
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestSelect (0.00s)
=== RUN   TestTypeSwitch
2025/12/19 11:09:28 ==> Preload func bar
2025/12/19 11:09:28 ==> Preload func foo
2025/12/19 11:09:28 ==> Load func bar
2025/12/19 11:09:28 NewFunc bar func(p *interface{})
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> Load func foo
2025/12/19 11:09:28 NewFunc foo func(v interface{})
2025/12/19 11:09:28 TypeSwitch
2025/12/19 11:09:28 Val v interface{}
2025/12/19 11:09:28 TypeAssertThen
2025/12/19 11:09:28 TypeCase
2025/12/19 11:09:28 Val int int
2025/12/19 11:09:28 Val type int => Typ int
2025/12/19 11:09:28 Val string string
2025/12/19 11:09:28 Val type string => Typ string
2025/12/19 11:09:28 Then
2025/12/19 11:09:28 Val bar func(p *interface{})
2025/12/19 11:09:28 Val v interface{}
2025/12/19 11:09:28 UnaryOp & flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:28 Call 1 0 // func(p *interface{})
2025/12/19 11:09:28 ==> MatchFuncCall func(p *interface{}) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType *interface{}, *interface{}
2025/12/19 11:09:28 End // TypeCase
2025/12/19 11:09:28 TypeCase
2025/12/19 11:09:28 Val bool bool
2025/12/19 11:09:28 Val type bool => Typ bool
2025/12/19 11:09:28 Then
2025/12/19 11:09:28 ==> Load var bool [x]
2025/12/19 11:09:28 NewVarDefs
2025/12/19 11:09:28 NewVar [x]
2025/12/19 11:09:28 Val t bool
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ==> MatchType bool, bool
2025/12/19 11:09:28 End // TypeCase
2025/12/19 11:09:28 TypeCase
2025/12/19 11:09:28 Then
2025/12/19 11:09:28 Val bar func(p *interface{})
2025/12/19 11:09:28 Val nil untyped nil
2025/12/19 11:09:28 Call 1 0 // func(p *interface{})
2025/12/19 11:09:28 ==> MatchFuncCall func(p *interface{}) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped nil, *interface{}
2025/12/19 11:09:28 End // TypeCase
2025/12/19 11:09:28 End // TypeSwitch
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestTypeSwitch (0.00s)
=== RUN   TestTypeSwitch2
2025/12/19 11:09:28 ==> Preload func bar
2025/12/19 11:09:28 ==> Preload func foo
2025/12/19 11:09:28 ==> Load func bar
2025/12/19 11:09:28 NewFunc bar func(p *interface{})
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> Load func foo
2025/12/19 11:09:28 NewFunc foo func(v interface{})
2025/12/19 11:09:28 TypeSwitch
2025/12/19 11:09:28 Val bar func(p *interface{})
2025/12/19 11:09:28 Val nil untyped nil
2025/12/19 11:09:28 Call 1 0 // func(p *interface{})
2025/12/19 11:09:28 ==> MatchFuncCall func(p *interface{}) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped nil, *interface{}
2025/12/19 11:09:28 Val v interface{}
2025/12/19 11:09:28 TypeAssertThen
2025/12/19 11:09:28 TypeCase
2025/12/19 11:09:28 Val int int
2025/12/19 11:09:28 Val type int => Typ int
2025/12/19 11:09:28 Val string string
2025/12/19 11:09:28 Val type string => Typ string
2025/12/19 11:09:28 Then
2025/12/19 11:09:28 Val bar func(p *interface{})
2025/12/19 11:09:28 Val v interface{}
2025/12/19 11:09:28 UnaryOp & flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:28 Call 1 0 // func(p *interface{})
2025/12/19 11:09:28 ==> MatchFuncCall func(p *interface{}) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType *interface{}, *interface{}
2025/12/19 11:09:28 End // TypeCase
2025/12/19 11:09:28 End // TypeSwitch
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestTypeSwitch2 (0.00s)
=== RUN   TestTypeAssert
2025/12/19 11:09:28 ==> Preload func foo
2025/12/19 11:09:28 ==> Load func foo
2025/12/19 11:09:28 NewFunc foo func(v interface{})
2025/12/19 11:09:28 DefineVarStart [x]
2025/12/19 11:09:28 Val v interface{}
2025/12/19 11:09:28 TypeAssert int false
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 DefineVarStart [y ok]
2025/12/19 11:09:28 Val v interface{}
2025/12/19 11:09:28 TypeAssert string true
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestTypeAssert (0.00s)
=== RUN   TestInterface
2025/12/19 11:09:28 ==> Preload type Shape
2025/12/19 11:09:28 ==> Preload func foo
2025/12/19 11:09:28 ==> Load > NewType Shape
2025/12/19 11:09:28 NewType Shape
2025/12/19 11:09:28 ==> Load > InitType Shape
2025/12/19 11:09:28 InitType Shape interface{Area() float64}
2025/12/19 11:09:28 ==> Load func foo
2025/12/19 11:09:28 ==> LookupParent Shape => type github.com/goplus/xgo/cl.Shape interface{Area() float64}
2025/12/19 11:09:28 NewFunc foo func(shape github.com/goplus/xgo/cl.Shape)
2025/12/19 11:09:28 Val shape github.com/goplus/xgo/cl.Shape
2025/12/19 11:09:28 Member Area 1 // github.com/goplus/xgo/cl.Shape
2025/12/19 11:09:28 Call 0 0 // func() float64
2025/12/19 11:09:28 ==> MatchFuncCall func() float64 args: 0 flags: 0
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestInterface (0.00s)
=== RUN   TestInterfaceEmbedded
2025/12/19 11:09:28 ==> Preload type Shape
2025/12/19 11:09:28 ==> Preload type Bar
2025/12/19 11:09:28 ==> Load > NewType Shape
2025/12/19 11:09:28 NewType Shape
2025/12/19 11:09:28 ==> Load > InitType Shape
2025/12/19 11:09:28 InitType Shape interface{Area() float64}
2025/12/19 11:09:28 ==> Load > NewType Bar
2025/12/19 11:09:28 NewType Bar
2025/12/19 11:09:28 ==> Load > InitType Bar
2025/12/19 11:09:28 ==> LookupParent Shape => type github.com/goplus/xgo/cl.Shape interface{Area() float64}
2025/12/19 11:09:28 InitType Bar interface{github.com/goplus/xgo/cl.Shape}
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestInterfaceEmbedded (0.00s)
=== RUN   TestInterfaceExample
2025/12/19 11:09:28 ==> Preload type Shape
2025/12/19 11:09:28 ==> Preload type Rect
2025/12/19 11:09:28 ==> Preload method Rect.Area
2025/12/19 11:09:28 ==> Preload type Circle
2025/12/19 11:09:28 ==> Preload method Circle.Area
2025/12/19 11:09:28 ==> Preload func Area
2025/12/19 11:09:28 ==> Preload func main
2025/12/19 11:09:28 ==> Load > NewType Shape
2025/12/19 11:09:28 NewType Shape
2025/12/19 11:09:28 ==> Load > InitType Shape
2025/12/19 11:09:28 InitType Shape interface{Area() float64}
2025/12/19 11:09:28 ==> Load > NewType Rect
2025/12/19 11:09:28 NewType Rect
2025/12/19 11:09:28 ==> Load > InitType Rect
2025/12/19 11:09:28 InitType Rect struct{x float64; y float64; w float64; h float64}
2025/12/19 11:09:28 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{x float64; y float64; w float64; h float64}
2025/12/19 11:09:28 ==> Load method *github.com/goplus/xgo/cl.Rect.Area
2025/12/19 11:09:28 ==> Load > NewType Circle
2025/12/19 11:09:28 NewType Circle
2025/12/19 11:09:28 ==> Load > InitType Circle
2025/12/19 11:09:28 InitType Circle struct{x float64; y float64; r float64}
2025/12/19 11:09:28 ==> LookupParent Circle => type github.com/goplus/xgo/cl.Circle struct{x float64; y float64; r float64}
2025/12/19 11:09:28 ==> Load method *github.com/goplus/xgo/cl.Circle.Area
2025/12/19 11:09:28 ==> Load func Area
2025/12/19 11:09:28 ==> LookupParent Shape => type github.com/goplus/xgo/cl.Shape interface{Area() float64}
2025/12/19 11:09:28 NewFunc Area func(shapes ...github.com/goplus/xgo/cl.Shape) float64
2025/12/19 11:09:28 DefineVarStart [s]
2025/12/19 11:09:28 Val &{0 FLOAT 0.0} *ast.BasicLit
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 ForRange [_ shape]
2025/12/19 11:09:28 Val shapes []github.com/goplus/xgo/cl.Shape
2025/12/19 11:09:28 RangeAssignThen
2025/12/19 11:09:28 VBlock
2025/12/19 11:09:28 VarRef s float64
2025/12/19 11:09:28 Val shape github.com/goplus/xgo/cl.Shape
2025/12/19 11:09:28 Member Area 1 // github.com/goplus/xgo/cl.Shape
2025/12/19 11:09:28 Call 0 0 // func() float64
2025/12/19 11:09:28 ==> MatchFuncCall func() float64 args: 0 flags: 0
2025/12/19 11:09:28 AssignOp += Gop_AddAssign
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType refType{typ: float64}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:28 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:28 End // Vblock
2025/12/19 11:09:28 End // ForRange
2025/12/19 11:09:28 Val s float64
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType float64, float64
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> Load func main
2025/12/19 11:09:28 NewFunc main func()
2025/12/19 11:09:28 DefineVarStart [rect]
2025/12/19 11:09:28 ==> LookupParent Rect => type github.com/goplus/xgo/cl.Rect struct{x float64; y float64; w float64; h float64}
2025/12/19 11:09:28 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:28 StructLit github.com/goplus/xgo/cl.Rect 4 false
2025/12/19 11:09:28 UnaryOp & flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 DefineVarStart [circle]
2025/12/19 11:09:28 ==> LookupParent Circle => type github.com/goplus/xgo/cl.Circle struct{x float64; y float64; r float64}
2025/12/19 11:09:28 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:28 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:28 StructLit github.com/goplus/xgo/cl.Circle 3 false
2025/12/19 11:09:28 UnaryOp & flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:28 EndInit 1
2025/12/19 11:09:28 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 Val Area func(shapes ...github.com/goplus/xgo/cl.Shape) float64
2025/12/19 11:09:28 Val circle *github.com/goplus/xgo/cl.Circle
2025/12/19 11:09:28 Val rect *github.com/goplus/xgo/cl.Rect
2025/12/19 11:09:28 Call 2 0 // func(shapes ...github.com/goplus/xgo/cl.Shape) float64
2025/12/19 11:09:28 ==> MatchFuncCall func(shapes ...github.com/goplus/xgo/cl.Shape) float64 args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType *github.com/goplus/xgo/cl.Circle, github.com/goplus/xgo/cl.Shape
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.Shape
2025/12/19 11:09:28 ==> MatchType *github.com/goplus/xgo/cl.Rect, github.com/goplus/xgo/cl.Shape
2025/12/19 11:09:28 ==> EnsureLoaded github.com/goplus/xgo/cl.Shape
2025/12/19 11:09:28 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:28 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:28 ==> MatchType float64, any
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 NewFunc Area (*github.com/goplus/xgo/cl.Rect) func() float64
2025/12/19 11:09:28 Val p *github.com/goplus/xgo/cl.Rect
2025/12/19 11:09:28 Member w 2 // *github.com/goplus/xgo/cl.Rect
2025/12/19 11:09:28 Val p *github.com/goplus/xgo/cl.Rect
2025/12/19 11:09:28 Member h 2 // *github.com/goplus/xgo/cl.Rect
2025/12/19 11:09:28 BinaryOp *
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType float64, float64
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 NewFunc Area (*github.com/goplus/xgo/cl.Circle) func() float64
2025/12/19 11:09:28 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/12/19 11:09:28 Val p *github.com/goplus/xgo/cl.Circle
2025/12/19 11:09:28 Member r 2 // *github.com/goplus/xgo/cl.Circle
2025/12/19 11:09:28 BinaryOp *
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType untyped float (3.14), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType float64, unboundFuncParam{typ: untyped float}
2025/12/19 11:09:28 Val p *github.com/goplus/xgo/cl.Circle
2025/12/19 11:09:28 Member r 2 // *github.com/goplus/xgo/cl.Circle
2025/12/19 11:09:28 BinaryOp *
2025/12/19 11:09:28 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:28 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:28 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:28 Return 1
2025/12/19 11:09:28 ==> MatchType float64, float64
2025/12/19 11:09:28 End // Func
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestInterfaceExample (0.00s)
=== RUN   TestEmbeddField
2025/12/19 11:09:28 ==> Preload type BigInt
2025/12/19 11:09:28 ==> Load > NewType BigInt
2025/12/19 11:09:28 NewType BigInt
2025/12/19 11:09:28 ==> Load > InitType BigInt
2025/12/19 11:09:28 InitType BigInt struct{*math/big.Int}
2025/12/19 11:09:28 ==> ASTFile
--- PASS: TestEmbeddField (0.16s)
=== RUN   TestAutoProperty
2025/12/19 11:09:29 PkgHash: unexpected package - github.com/goplus/gogen/token
2025/12/19 11:09:29 ==> Import github.com/goplus/xgo/ast/goptest
2025/12/19 11:09:29 PkgHash: unexpected package - github.com/goplus/gogen/token
2025/12/19 11:09:29 ==> Import github.com/goplus/xgo/ast/gopq
2025/12/19 11:09:29 ==> NewOverloadMethod NodeSet CollectOne
2025/12/19 11:09:29 ==> NewOverloadMethod NodeSet UnquotedString
2025/12/19 11:09:29 ==> NewOverloadMethod NodeSet EltLen
2025/12/19 11:09:29 ==> NewOverloadMethod NodeSet Ident
2025/12/19 11:09:29 ==> NewOverloadFunc One
2025/12/19 11:09:29 ==> NewOverloadMethod NodeSet FuncDecl
2025/12/19 11:09:29 ==> NewOverloadMethod NodeSet GenDecl
2025/12/19 11:09:29 ==> NewOverloadMethod NodeSet CompositeLit
2025/12/19 11:09:29 ==> NewOverloadMethod NodeSet Positions
2025/12/19 11:09:29 ==> NewOverloadMethod NodeSet CallExpr
2025/12/19 11:09:29 ==> NewOverloadMethod NodeSet Elt
2025/12/19 11:09:29 ==> NewOverloadMethod NodeSet UnquotedStringElts
2025/12/19 11:09:29 ==> Preload func foo
2025/12/19 11:09:29 ==> Load func foo
2025/12/19 11:09:29 NewFunc foo func(script string)
2025/12/19 11:09:29 DefineVarStart [doc]
2025/12/19 11:09:29 Val New func(script string) (github.com/goplus/xgo/ast/gopq.NodeSet, error)
2025/12/19 11:09:29 Val script string
2025/12/19 11:09:29 Call 1 0 // func(script string) (github.com/goplus/xgo/ast/gopq.NodeSet, error)
2025/12/19 11:09:29 ==> MatchFuncCall func(script string) (github.com/goplus/xgo/ast/gopq.NodeSet, error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType string, string
2025/12/19 11:09:29 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:29 NewVar [_xgo_err]
2025/12/19 11:09:29 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 VarRef _xgo_err error
2025/12/19 11:09:29 Assign 2 1
2025/12/19 11:09:29 ==> MatchType github.com/goplus/xgo/ast/gopq.NodeSet, unboundType{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType error, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 If
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 Val <nil> <nil>
2025/12/19 11:09:29 BinaryOp !=
2025/12/19 11:09:29 Typ error
2025/12/19 11:09:29 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 VarRef _xgo_err error
2025/12/19 11:09:29 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 Val goptest.New(script) string
2025/12/19 11:09:29 Val /foo/bar.xgo string
2025/12/19 11:09:29 Val 4 int
2025/12/19 11:09:29 Val main.foo string
2025/12/19 11:09:29 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:29 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/12/19 11:09:29 ==> MatchType error, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> MatchType untyped string ("goptest.New(script)"), string
2025/12/19 11:09:29 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/12/19 11:09:29 ==> MatchType untyped int (4), int
2025/12/19 11:09:29 ==> MatchType untyped string ("main.foo"), string
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 Val panic func(v interface{})
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 Call 1 0 // func(v interface{})
2025/12/19 11:09:29 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType error, interface{}
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 0 0 // func() (_xgo_ret github.com/goplus/xgo/ast/gopq.NodeSet)
2025/12/19 11:09:29 ==> MatchFuncCall func() (_xgo_ret github.com/goplus/xgo/ast/gopq.NodeSet) args: 0 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val doc github.com/goplus/xgo/ast/gopq.NodeSet
2025/12/19 11:09:29 Member any 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/12/19 11:09:29 Call 0 0 // func() (ret github.com/goplus/xgo/ast/gopq.NodeSet)
2025/12/19 11:09:29 ==> MatchFuncCall func() (ret github.com/goplus/xgo/ast/gopq.NodeSet) args: 0 flags: 0
2025/12/19 11:09:29 Member funcDecl 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/12/19 11:09:29 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadMethod args: 0 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func() github.com/goplus/xgo/ast/gopq.NodeSet args: 0 flags: 0
2025/12/19 11:09:29 Member name 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/12/19 11:09:29 Call 0 0 // func() []string
2025/12/19 11:09:29 ==> MatchFuncCall func() []string args: 0 flags: 0
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType []string, any
2025/12/19 11:09:29 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val doc github.com/goplus/xgo/ast/gopq.NodeSet
2025/12/19 11:09:29 Member any 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/12/19 11:09:29 Call 0 0 // func() (ret github.com/goplus/xgo/ast/gopq.NodeSet)
2025/12/19 11:09:29 ==> MatchFuncCall func() (ret github.com/goplus/xgo/ast/gopq.NodeSet) args: 0 flags: 0
2025/12/19 11:09:29 Member importSpec 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/12/19 11:09:29 Call 0 0 // func() github.com/goplus/xgo/ast/gopq.NodeSet
2025/12/19 11:09:29 ==> MatchFuncCall func() github.com/goplus/xgo/ast/gopq.NodeSet args: 0 flags: 0
2025/12/19 11:09:29 Member name 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/12/19 11:09:29 Call 0 0 // func() []string
2025/12/19 11:09:29 ==> MatchFuncCall func() []string args: 0 flags: 0
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType []string, any
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestAutoProperty (1.27s)
=== RUN   TestSimplifyAutoProperty
2025/12/19 11:09:29 ==> Preload func foo
2025/12/19 11:09:29 ==> Load func foo
2025/12/19 11:09:29 NewFunc foo func(script string)
2025/12/19 11:09:29 DefineVarStart [doc]
2025/12/19 11:09:29 Val New func(script string) (github.com/goplus/xgo/ast/gopq.NodeSet, error)
2025/12/19 11:09:29 Val script string
2025/12/19 11:09:29 Call 1 0 // func(script string) (github.com/goplus/xgo/ast/gopq.NodeSet, error)
2025/12/19 11:09:29 ==> MatchFuncCall func(script string) (github.com/goplus/xgo/ast/gopq.NodeSet, error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType string, string
2025/12/19 11:09:29 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:29 NewVar [_xgo_err]
2025/12/19 11:09:29 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 VarRef _xgo_err error
2025/12/19 11:09:29 Assign 2 1
2025/12/19 11:09:29 ==> MatchType github.com/goplus/xgo/ast/gopq.NodeSet, unboundType{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType error, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 If
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 Val <nil> <nil>
2025/12/19 11:09:29 BinaryOp !=
2025/12/19 11:09:29 Typ error
2025/12/19 11:09:29 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 VarRef _xgo_err error
2025/12/19 11:09:29 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 Val goptest.New(script) string
2025/12/19 11:09:29 Val /foo/bar.xgo string
2025/12/19 11:09:29 Val 4 int
2025/12/19 11:09:29 Val main.foo string
2025/12/19 11:09:29 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:29 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/12/19 11:09:29 ==> MatchType error, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> MatchType untyped string ("goptest.New(script)"), string
2025/12/19 11:09:29 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/12/19 11:09:29 ==> MatchType untyped int (4), int
2025/12/19 11:09:29 ==> MatchType untyped string ("main.foo"), string
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 Val panic func(v interface{})
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 Call 1 0 // func(v interface{})
2025/12/19 11:09:29 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType error, interface{}
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 0 0 // func() (_xgo_ret github.com/goplus/xgo/ast/gopq.NodeSet)
2025/12/19 11:09:29 ==> MatchFuncCall func() (_xgo_ret github.com/goplus/xgo/ast/gopq.NodeSet) args: 0 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val doc github.com/goplus/xgo/ast/gopq.NodeSet
2025/12/19 11:09:29 Member any 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/12/19 11:09:29 Call 0 0 // func() (ret github.com/goplus/xgo/ast/gopq.NodeSet)
2025/12/19 11:09:29 ==> MatchFuncCall func() (ret github.com/goplus/xgo/ast/gopq.NodeSet) args: 0 flags: 0
2025/12/19 11:09:29 Member funcDecl 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/12/19 11:09:29 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadMethod args: 0 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func() github.com/goplus/xgo/ast/gopq.NodeSet args: 0 flags: 0
2025/12/19 11:09:29 Member name 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/12/19 11:09:29 Call 0 0 // func() []string
2025/12/19 11:09:29 ==> MatchFuncCall func() []string args: 0 flags: 0
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType []string, any
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val doc github.com/goplus/xgo/ast/gopq.NodeSet
2025/12/19 11:09:29 Member any 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/12/19 11:09:29 Call 0 0 // func() (ret github.com/goplus/xgo/ast/gopq.NodeSet)
2025/12/19 11:09:29 ==> MatchFuncCall func() (ret github.com/goplus/xgo/ast/gopq.NodeSet) args: 0 flags: 0
2025/12/19 11:09:29 Member importSpec 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/12/19 11:09:29 Call 0 0 // func() github.com/goplus/xgo/ast/gopq.NodeSet
2025/12/19 11:09:29 ==> MatchFuncCall func() github.com/goplus/xgo/ast/gopq.NodeSet args: 0 flags: 0
2025/12/19 11:09:29 Member name 2 // github.com/goplus/xgo/ast/gopq.NodeSet
2025/12/19 11:09:29 Call 0 0 // func() []string
2025/12/19 11:09:29 ==> MatchFuncCall func() []string args: 0 flags: 0
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType []string, any
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestSimplifyAutoProperty (0.00s)
=== RUN   TestErrWrapBasic
2025/12/19 11:09:29 ==> Preload func add
2025/12/19 11:09:29 ==> Load func add
2025/12/19 11:09:29 NewFunc add func(x string, y string) (int, error)
2025/12/19 11:09:29 Val Atoi func(s string) (int, error)
2025/12/19 11:09:29 Val x string
2025/12/19 11:09:29 Call 1 0 // func(s string) (int, error)
2025/12/19 11:09:29 ==> MatchFuncCall func(s string) (int, error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType string, string
2025/12/19 11:09:29 CallInlineClosureStart 0 false
2025/12/19 11:09:29 NewVar [_autoGo_1]
2025/12/19 11:09:29 NewVar [_xgo_err]
2025/12/19 11:09:29 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 VarRef _xgo_err error
2025/12/19 11:09:29 Assign 2 1
2025/12/19 11:09:29 ==> MatchType int, unboundType{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType error, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 If
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 Val <nil> <nil>
2025/12/19 11:09:29 BinaryOp !=
2025/12/19 11:09:29 Typ error
2025/12/19 11:09:29 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 VarRef _xgo_err error
2025/12/19 11:09:29 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 Val strconv.Atoi(x) string
2025/12/19 11:09:29 Val /foo/bar.xgo string
2025/12/19 11:09:29 Val 5 int
2025/12/19 11:09:29 Val main.add string
2025/12/19 11:09:29 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:29 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/12/19 11:09:29 ==> MatchType error, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> MatchType untyped string ("strconv.Atoi(x)"), string
2025/12/19 11:09:29 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/12/19 11:09:29 ==> MatchType untyped int (5), int
2025/12/19 11:09:29 ==> MatchType untyped string ("main.add"), string
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 ReturnErr true
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 Goto _autoGo_2
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Label _autoGo_2
2025/12/19 11:09:29 Val Atoi func(s string) (int, error)
2025/12/19 11:09:29 Val y string
2025/12/19 11:09:29 Call 1 0 // func(s string) (int, error)
2025/12/19 11:09:29 ==> MatchFuncCall func(s string) (int, error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType string, string
2025/12/19 11:09:29 CallInlineClosureStart 0 false
2025/12/19 11:09:29 NewVar [_autoGo_3]
2025/12/19 11:09:29 NewVar [_xgo_err]
2025/12/19 11:09:29 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 VarRef _xgo_err error
2025/12/19 11:09:29 Assign 2 1
2025/12/19 11:09:29 ==> MatchType int, unboundType{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType error, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 If
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 Val <nil> <nil>
2025/12/19 11:09:29 BinaryOp !=
2025/12/19 11:09:29 Typ error
2025/12/19 11:09:29 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 VarRef _xgo_err error
2025/12/19 11:09:29 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 Val strconv.Atoi(y) string
2025/12/19 11:09:29 Val /foo/bar.xgo string
2025/12/19 11:09:29 Val 5 int
2025/12/19 11:09:29 Val main.add string
2025/12/19 11:09:29 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:29 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/12/19 11:09:29 ==> MatchType error, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> MatchType untyped string ("strconv.Atoi(y)"), string
2025/12/19 11:09:29 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/12/19 11:09:29 ==> MatchType untyped int (5), int
2025/12/19 11:09:29 ==> MatchType untyped string ("main.add"), string
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 ReturnErr true
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 Goto _autoGo_4
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Label _autoGo_4
2025/12/19 11:09:29 BinaryOp +
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:29 Val nil untyped nil
2025/12/19 11:09:29 Return 2
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 ==> MatchType untyped nil, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestErrWrapBasic (0.00s)
=== RUN   TestErrWrapDefVal
2025/12/19 11:09:29 ==> Preload func addSafe
2025/12/19 11:09:29 ==> Load func addSafe
2025/12/19 11:09:29 NewFunc addSafe func(x string, y string) int
2025/12/19 11:09:29 Val Atoi func(s string) (int, error)
2025/12/19 11:09:29 Val x string
2025/12/19 11:09:29 Call 1 0 // func(s string) (int, error)
2025/12/19 11:09:29 ==> MatchFuncCall func(s string) (int, error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType string, string
2025/12/19 11:09:29 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:29 NewVar [_xgo_err]
2025/12/19 11:09:29 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 VarRef _xgo_err error
2025/12/19 11:09:29 Assign 2 1
2025/12/19 11:09:29 ==> MatchType int, unboundType{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType error, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 If
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 Val <nil> <nil>
2025/12/19 11:09:29 BinaryOp !=
2025/12/19 11:09:29 Typ error
2025/12/19 11:09:29 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:29 Return 1
2025/12/19 11:09:29 ==> MatchType untyped int (0), unboundType{typ: int}
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 0 0 // func() (_xgo_ret int)
2025/12/19 11:09:29 ==> MatchFuncCall func() (_xgo_ret int) args: 0 flags: 0
2025/12/19 11:09:29 Val Atoi func(s string) (int, error)
2025/12/19 11:09:29 Val y string
2025/12/19 11:09:29 Call 1 0 // func(s string) (int, error)
2025/12/19 11:09:29 ==> MatchFuncCall func(s string) (int, error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType string, string
2025/12/19 11:09:29 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:29 NewVar [_xgo_err]
2025/12/19 11:09:29 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 VarRef _xgo_err error
2025/12/19 11:09:29 Assign 2 1
2025/12/19 11:09:29 ==> MatchType int, unboundType{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType error, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 If
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 Val <nil> <nil>
2025/12/19 11:09:29 BinaryOp !=
2025/12/19 11:09:29 Typ error
2025/12/19 11:09:29 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:29 Return 1
2025/12/19 11:09:29 ==> MatchType untyped int (0), unboundType{typ: int}
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 0 0 // func() (_xgo_ret int)
2025/12/19 11:09:29 ==> MatchFuncCall func() (_xgo_ret int) args: 0 flags: 0
2025/12/19 11:09:29 BinaryOp +
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:29 Return 1
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestErrWrapDefVal (0.00s)
=== RUN   TestErrWrapPanic
2025/12/19 11:09:29 ==> Preload var [ret]
2025/12/19 11:09:29 ==> Load var int [ret]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [ret]
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("Hi"), any
2025/12/19 11:09:29 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:29 NewVar [_xgo_err]
2025/12/19 11:09:29 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 VarRef _xgo_err error
2025/12/19 11:09:29 Assign 2 1
2025/12/19 11:09:29 ==> MatchType int, unboundType{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType error, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 If
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 Val <nil> <nil>
2025/12/19 11:09:29 BinaryOp !=
2025/12/19 11:09:29 Typ error
2025/12/19 11:09:29 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 VarRef _xgo_err error
2025/12/19 11:09:29 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 Val println("Hi") string
2025/12/19 11:09:29 Val /foo/bar.xgo string
2025/12/19 11:09:29 Val 2 int
2025/12/19 11:09:29 Val main.main string
2025/12/19 11:09:29 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:29 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/12/19 11:09:29 ==> MatchType error, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> MatchType untyped string ("println(\"Hi\")"), string
2025/12/19 11:09:29 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/12/19 11:09:29 ==> MatchType untyped int (2), int
2025/12/19 11:09:29 ==> MatchType untyped string ("main.main"), string
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 Val panic func(v interface{})
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 Call 1 0 // func(v interface{})
2025/12/19 11:09:29 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType error, interface{}
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 0 0 // func() (_xgo_ret int)
2025/12/19 11:09:29 ==> MatchFuncCall func() (_xgo_ret int) args: 0 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestErrWrapPanic (0.00s)
=== RUN   TestErrWrapCommand
2025/12/19 11:09:29 ==> Preload func mkdir
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func mkdir
2025/12/19 11:09:29 NewFunc mkdir func(name string) error
2025/12/19 11:09:29 Val nil untyped nil
2025/12/19 11:09:29 Return 1
2025/12/19 11:09:29 ==> MatchType untyped nil, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 Val mkdir func(name string) error
2025/12/19 11:09:29 Val &{0 STRING "foo"} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(name string) error
2025/12/19 11:09:29 ==> MatchFuncCall func(name string) error args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("foo"), string
2025/12/19 11:09:29 NewClosure func()
2025/12/19 11:09:29 NewVar [_xgo_err]
2025/12/19 11:09:29 VarRef _xgo_err error
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType error, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 If
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 Val <nil> <nil>
2025/12/19 11:09:29 BinaryOp !=
2025/12/19 11:09:29 Typ error
2025/12/19 11:09:29 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 VarRef _xgo_err error
2025/12/19 11:09:29 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 Val mkdir "foo" string
2025/12/19 11:09:29 Val /foo/bar.xgo string
2025/12/19 11:09:29 Val 6 int
2025/12/19 11:09:29 Val main.main string
2025/12/19 11:09:29 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:29 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/12/19 11:09:29 ==> MatchType error, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> MatchType untyped string ("mkdir \"foo\""), string
2025/12/19 11:09:29 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/12/19 11:09:29 ==> MatchType untyped int (6), int
2025/12/19 11:09:29 ==> MatchType untyped string ("main.main"), string
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 Val panic func(v interface{})
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 Call 1 0 // func(v interface{})
2025/12/19 11:09:29 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType error, interface{}
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 0 0 // func()
2025/12/19 11:09:29 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestErrWrapCommand (0.00s)
=== RUN   TestErrWrapCall
2025/12/19 11:09:29 ==> Preload func foo
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func foo
2025/12/19 11:09:29 NewFunc foo func() (func(), error)
2025/12/19 11:09:29 Val nil untyped nil
2025/12/19 11:09:29 Val nil untyped nil
2025/12/19 11:09:29 Return 2
2025/12/19 11:09:29 ==> MatchType untyped nil, func()
2025/12/19 11:09:29 ==> MatchType untyped nil, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 Val foo func() (func(), error)
2025/12/19 11:09:29 Call 0 0 // func() (func(), error)
2025/12/19 11:09:29 ==> MatchFuncCall func() (func(), error) args: 0 flags: 0
2025/12/19 11:09:29 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:29 NewVar [_xgo_err]
2025/12/19 11:09:29 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 VarRef _xgo_err error
2025/12/19 11:09:29 Assign 2 1
2025/12/19 11:09:29 ==> MatchType func(), unboundType{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType error, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 If
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 Val <nil> <nil>
2025/12/19 11:09:29 BinaryOp !=
2025/12/19 11:09:29 Typ error
2025/12/19 11:09:29 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 VarRef _xgo_err error
2025/12/19 11:09:29 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 Val foo() string
2025/12/19 11:09:29 Val /foo/bar.xgo string
2025/12/19 11:09:29 Val 6 int
2025/12/19 11:09:29 Val main.main string
2025/12/19 11:09:29 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:29 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/12/19 11:09:29 ==> MatchType error, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> MatchType untyped string ("foo()"), string
2025/12/19 11:09:29 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/12/19 11:09:29 ==> MatchType untyped int (6), int
2025/12/19 11:09:29 ==> MatchType untyped string ("main.main"), string
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 Val panic func(v interface{})
2025/12/19 11:09:29 Val _xgo_err error
2025/12/19 11:09:29 Call 1 0 // func(v interface{})
2025/12/19 11:09:29 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType error, interface{}
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 0 0 // func() (_xgo_ret func())
2025/12/19 11:09:29 ==> MatchFuncCall func() (_xgo_ret func()) args: 0 flags: 0
2025/12/19 11:09:29 Call 0 0 // func()
2025/12/19 11:09:29 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestErrWrapCall (0.00s)
=== RUN   TestMakeAndNew
2025/12/19 11:09:29 ==> Preload var [a]
2025/12/19 11:09:29 ==> Preload var [b]
2025/12/19 11:09:29 ==> Preload var [c]
2025/12/19 11:09:29 ==> Load var *int [a]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [a]
2025/12/19 11:09:29 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:29 Val int int
2025/12/19 11:09:29 Val type int => Typ int
2025/12/19 11:09:29 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType *int, *int
2025/12/19 11:09:29 ==> Load var map[string]int [b]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [b]
2025/12/19 11:09:29 Val make TyInstruction{gogen.makeInstr}
2025/12/19 11:09:29 Typ map[string]int
2025/12/19 11:09:29 Call 1 0 // TyInstruction{gogen.makeInstr}
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.makeInstr} args: 1 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType map[string]int, map[string]int
2025/12/19 11:09:29 ==> Load var []byte [c]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [c]
2025/12/19 11:09:29 Val make TyInstruction{gogen.makeInstr}
2025/12/19 11:09:29 Typ []byte
2025/12/19 11:09:29 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 Call 3 0 // TyInstruction{gogen.makeInstr}
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.makeInstr} args: 3 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType []byte, []byte
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestMakeAndNew (0.00s)
=== RUN   TestVarDecl
2025/12/19 11:09:29 ==> Preload var [a]
2025/12/19 11:09:29 ==> Preload var [x y]
2025/12/19 11:09:29 ==> Load var int [a]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [a]
2025/12/19 11:09:29 ==> Load var <nil> [x y]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [x y]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:29 EndInit 2
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestVarDecl (0.00s)
=== RUN   TestUint128Add
2025/12/19 11:09:29 ==> Preload var [x y]
2025/12/19 11:09:29 ==> Preload var [z]
2025/12/19 11:09:29 ==> Load var github.com/qiniu/x/xgo/ng.Uint128 [x y]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [x y]
2025/12/19 11:09:29 ==> Load var github.com/qiniu/x/xgo/ng.Uint128 [z]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [z]
2025/12/19 11:09:29 Val x github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:29 Val y github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:29 BinaryOp +
2025/12/19 11:09:29 Typ github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:29 Member Gop_Add 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128}
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/12/19 11:09:29 ==> MatchFuncCall func(u github.com/qiniu/x/xgo/ng.Uint128, n uint64) (v github.com/qiniu/x/xgo/ng.Uint128) args: 2 flags: 64
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, uint64
2025/12/19 11:09:29 ==> MatchFuncCall func(u github.com/qiniu/x/xgo/ng.Uint128, n github.com/qiniu/x/xgo/ng.Uint128) (v github.com/qiniu/x/xgo/ng.Uint128) args: 2 flags: 64
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestUint128Add (0.00s)
=== RUN   TestInt128Add
2025/12/19 11:09:29 ==> Preload var [x y]
2025/12/19 11:09:29 ==> Preload var [z]
2025/12/19 11:09:29 ==> Load var github.com/qiniu/x/xgo/ng.Int128 [x y]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [x y]
2025/12/19 11:09:29 ==> Load var github.com/qiniu/x/xgo/ng.Int128 [z]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [z]
2025/12/19 11:09:29 Val x github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:29 Val y github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:29 BinaryOp +
2025/12/19 11:09:29 Typ github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:29 Member Gop_Add 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Int128}
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/12/19 11:09:29 ==> MatchFuncCall func(i github.com/qiniu/x/xgo/ng.Int128, n int64) (v github.com/qiniu/x/xgo/ng.Int128) args: 2 flags: 64
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, int64
2025/12/19 11:09:29 ==> MatchFuncCall func(i github.com/qiniu/x/xgo/ng.Int128, n github.com/qiniu/x/xgo/ng.Int128) (v github.com/qiniu/x/xgo/ng.Int128) args: 2 flags: 64
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestInt128Add (0.00s)
=== RUN   TestBigIntAdd
2025/12/19 11:09:29 ==> Preload var [x y]
2025/12/19 11:09:29 ==> Preload var [z]
2025/12/19 11:09:29 ==> Load var github.com/qiniu/x/xgo/ng.Bigint [x y]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [x y]
2025/12/19 11:09:29 ==> Load var github.com/qiniu/x/xgo/ng.Bigint [z]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [z]
2025/12/19 11:09:29 Val x github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:29 Val y github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:29 BinaryOp +
2025/12/19 11:09:29 Typ github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:29 Member Gop_Add 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Bigint}
2025/12/19 11:09:29 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Bigint, b github.com/qiniu/x/xgo/ng.Bigint) github.com/qiniu/x/xgo/ng.Bigint args: 2 flags: 64
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestBigIntAdd (0.00s)
=== RUN   TestBigIntLit
2025/12/19 11:09:29 ==> Preload var [x]
2025/12/19 11:09:29 ==> Load var <nil> [x]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [x]
2025/12/19 11:09:29 Val NewInt func(x int64) *math/big.Int
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(x int64) *math/big.Int
2025/12/19 11:09:29 ==> MatchFuncCall func(x int64) *math/big.Int args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (1), int64
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint, int
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint, github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> DefaultConv github.com/qiniu/x/xgo/ng.UntypedBigint github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestBigIntLit (0.00s)
=== RUN   TestUint128Lit
2025/12/19 11:09:29 ==> Preload var [x]
2025/12/19 11:09:29 ==> Load var github.com/qiniu/x/xgo/ng.Uint128 [x]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [x]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType untyped int (1), github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Uint128) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (1), int
2025/12/19 11:09:29 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Uint128 true
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestUint128Lit (0.00s)
=== RUN   TestInt128Lit
2025/12/19 11:09:29 ==> Preload var [x]
2025/12/19 11:09:29 ==> Load var github.com/qiniu/x/xgo/ng.Int128 [x]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [x]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType untyped int (1), github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (1), int
2025/12/19 11:09:29 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Int128 true
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestInt128Lit (0.00s)
=== RUN   TestBigRatLit
2025/12/19 11:09:29 ==> Preload var [x]
2025/12/19 11:09:29 ==> Load var <nil> [x]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [x]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val NewInt func(x int64) *math/big.Int
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(x int64) *math/big.Int
2025/12/19 11:09:29 ==> MatchFuncCall func(x int64) *math/big.Int args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (2), int64
2025/12/19 11:09:29 BinaryOp /
2025/12/19 11:09:29 Typ github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 Member Gop_Quo 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.UntypedBigint}
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint (2), unboundFuncParam{typ: untyped int}
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.UntypedBigint true
2025/12/19 11:09:29 Val NewRat func(a int64, b int64) *math/big.Rat
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 Call 2 0 // func(a int64, b int64) *math/big.Rat
2025/12/19 11:09:29 ==> MatchFuncCall func(a int64, b int64) *math/big.Rat args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (1), int64
2025/12/19 11:09:29 ==> MatchType untyped int (2), int64
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, int
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/12/19 11:09:29 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.UntypedBigint args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, int
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/12/19 11:09:29 ==> AssignableConv github.com/qiniu/x/xgo/ng.UntypedBigrat github.com/qiniu/x/xgo/ng.UntypedBigint false
2025/12/19 11:09:29 ==> MatchFuncCall func(x *math/big.Rat) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, *math/big.Rat
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/12/19 11:09:29 ==> DefaultConv github.com/qiniu/x/xgo/ng.UntypedBigrat github.com/qiniu/x/xgo/ng.Bigrat
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestBigRatLit (0.00s)
=== RUN   TestBigRatLitAdd
2025/12/19 11:09:29 ==> Preload var [x]
2025/12/19 11:09:29 ==> Load var <nil> [x]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [x]
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val NewInt func(x int64) *math/big.Int
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(x int64) *math/big.Int
2025/12/19 11:09:29 ==> MatchFuncCall func(x int64) *math/big.Int args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (2), int64
2025/12/19 11:09:29 BinaryOp /
2025/12/19 11:09:29 Typ github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 Member Gop_Quo 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.UntypedBigint}
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint (2), unboundFuncParam{typ: untyped int}
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.UntypedBigint true
2025/12/19 11:09:29 Val NewRat func(a int64, b int64) *math/big.Rat
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 Call 2 0 // func(a int64, b int64) *math/big.Rat
2025/12/19 11:09:29 ==> MatchFuncCall func(a int64, b int64) *math/big.Rat args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (1), int64
2025/12/19 11:09:29 ==> MatchType untyped int (2), int64
2025/12/19 11:09:29 BinaryOp +
2025/12/19 11:09:29 Typ github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/12/19 11:09:29 Member Gop_Add 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.UntypedBigrat}
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (3), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat (0.5), unboundFuncParam{typ: untyped int}
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/12/19 11:09:29 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.UntypedBigrat true
2025/12/19 11:09:29 Val NewRat func(a int64, b int64) *math/big.Rat
2025/12/19 11:09:29 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 Call 2 0 // func(a int64, b int64) *math/big.Rat
2025/12/19 11:09:29 ==> MatchFuncCall func(a int64, b int64) *math/big.Rat args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (7), int64
2025/12/19 11:09:29 ==> MatchType untyped int (2), int64
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, int
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/12/19 11:09:29 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.UntypedBigint args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, int
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/12/19 11:09:29 ==> AssignableConv github.com/qiniu/x/xgo/ng.UntypedBigrat github.com/qiniu/x/xgo/ng.UntypedBigint false
2025/12/19 11:09:29 ==> MatchFuncCall func(x *math/big.Rat) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, *math/big.Rat
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/12/19 11:09:29 ==> DefaultConv github.com/qiniu/x/xgo/ng.UntypedBigrat github.com/qiniu/x/xgo/ng.Bigrat
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestBigRatLitAdd (0.00s)
=== RUN   TestBigRatAdd
2025/12/19 11:09:29 SetDebug: import=true, match=true, instr=true
2025/12/19 11:09:29 ==> Preload var [x]
2025/12/19 11:09:29 ==> Preload var [y]
2025/12/19 11:09:29 ==> Preload var [z]
2025/12/19 11:09:29 ==> Load var <nil> [x]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [x]
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val NewInt func(x int64) *math/big.Int
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(x int64) *math/big.Int
2025/12/19 11:09:29 ==> MatchFuncCall func(x int64) *math/big.Int args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (2), int64
2025/12/19 11:09:29 BinaryOp /
2025/12/19 11:09:29 Typ github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 Member Gop_Quo 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.UntypedBigint}
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint (2), unboundFuncParam{typ: untyped int}
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.UntypedBigint true
2025/12/19 11:09:29 Val NewRat func(a int64, b int64) *math/big.Rat
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 Call 2 0 // func(a int64, b int64) *math/big.Rat
2025/12/19 11:09:29 ==> MatchFuncCall func(a int64, b int64) *math/big.Rat args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (1), int64
2025/12/19 11:09:29 ==> MatchType untyped int (2), int64
2025/12/19 11:09:29 BinaryOp +
2025/12/19 11:09:29 Typ github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/12/19 11:09:29 Member Gop_Add 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.UntypedBigrat}
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (3), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat (0.5), unboundFuncParam{typ: untyped int}
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/12/19 11:09:29 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.UntypedBigrat true
2025/12/19 11:09:29 Val NewRat func(a int64, b int64) *math/big.Rat
2025/12/19 11:09:29 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 Call 2 0 // func(a int64, b int64) *math/big.Rat
2025/12/19 11:09:29 ==> MatchFuncCall func(a int64, b int64) *math/big.Rat args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (7), int64
2025/12/19 11:09:29 ==> MatchType untyped int (2), int64
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, int
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/12/19 11:09:29 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.UntypedBigint args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, int
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/12/19 11:09:29 ==> AssignableConv github.com/qiniu/x/xgo/ng.UntypedBigrat github.com/qiniu/x/xgo/ng.UntypedBigint false
2025/12/19 11:09:29 ==> MatchFuncCall func(x *math/big.Rat) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigrat, *math/big.Rat
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigrat
2025/12/19 11:09:29 ==> DefaultConv github.com/qiniu/x/xgo/ng.UntypedBigrat github.com/qiniu/x/xgo/ng.Bigrat
2025/12/19 11:09:29 ==> Load var <nil> [y]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [y]
2025/12/19 11:09:29 Val x github.com/qiniu/x/xgo/ng.Bigrat
2025/12/19 11:09:29 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp +
2025/12/19 11:09:29 Typ github.com/qiniu/x/xgo/ng.Bigrat
2025/12/19 11:09:29 Member Gop_Add 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Bigrat}
2025/12/19 11:09:29 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Bigrat, b github.com/qiniu/x/xgo/ng.Bigrat) github.com/qiniu/x/xgo/ng.Bigrat args: 2 flags: 64
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.Bigrat, github.com/qiniu/x/xgo/ng.Bigrat
2025/12/19 11:09:29 ==> MatchType untyped int (100), github.com/qiniu/x/xgo/ng.Bigrat
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (100), int
2025/12/19 11:09:29 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigrat true
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> Load var <nil> [z]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [z]
2025/12/19 11:09:29 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:29 Val y github.com/qiniu/x/xgo/ng.Bigrat
2025/12/19 11:09:29 BinaryOp +
2025/12/19 11:09:29 Typ github.com/qiniu/x/xgo/ng.Bigrat
2025/12/19 11:09:29 Member Gop_Add 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Bigrat}
2025/12/19 11:09:29 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Bigrat, b github.com/qiniu/x/xgo/ng.Bigrat) github.com/qiniu/x/xgo/ng.Bigrat args: 2 flags: 64
2025/12/19 11:09:29 ==> MatchType untyped int (100), github.com/qiniu/x/xgo/ng.Bigrat
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigrat args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (100), int
2025/12/19 11:09:29 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigrat true
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.Bigrat, github.com/qiniu/x/xgo/ng.Bigrat
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestBigRatAdd (0.00s)
=== RUN   TestTypeConv
2025/12/19 11:09:29 ==> Preload var [a]
2025/12/19 11:09:29 ==> Preload var [b]
2025/12/19 11:09:29 ==> Preload var [c]
2025/12/19 11:09:29 ==> Preload var [x]
2025/12/19 11:09:29 ==> Preload var [y]
2025/12/19 11:09:29 ==> Load var <nil> [a]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [a]
2025/12/19 11:09:29 Typ struct{}
2025/12/19 11:09:29 Star
2025/12/19 11:09:29 Val nil untyped nil
2025/12/19 11:09:29 Call 1 0 // TypeType{typ: *struct{}}
2025/12/19 11:09:29 ==> MatchFuncCall TypeType{typ: *struct{}} args: 1 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> Load var <nil> [b]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [b]
2025/12/19 11:09:29 Typ interface{}
2025/12/19 11:09:29 Val nil untyped nil
2025/12/19 11:09:29 Call 1 0 // TypeType{typ: interface{}}
2025/12/19 11:09:29 ==> MatchFuncCall TypeType{typ: interface{}} args: 1 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> Load var <nil> [c]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [c]
2025/12/19 11:09:29 Typ func()
2025/12/19 11:09:29 Val nil untyped nil
2025/12/19 11:09:29 Call 1 0 // TypeType{typ: func()}
2025/12/19 11:09:29 ==> MatchFuncCall TypeType{typ: func()} args: 1 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> Load var uint32 [x]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [x]
2025/12/19 11:09:29 Val uint32 uint32
2025/12/19 11:09:29 Val type uint32 => Typ uint32
2025/12/19 11:09:29 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // TypeType{typ: uint32}
2025/12/19 11:09:29 ==> MatchFuncCall TypeType{typ: uint32} args: 1 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType uint32 (0), uint32
2025/12/19 11:09:29 ==> Load var *uint32 [y]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [y]
2025/12/19 11:09:29 Val uint32 uint32
2025/12/19 11:09:29 Val type uint32 => Typ uint32
2025/12/19 11:09:29 Star
2025/12/19 11:09:29 Val nil untyped nil
2025/12/19 11:09:29 Call 1 0 // TypeType{typ: *uint32}
2025/12/19 11:09:29 ==> MatchFuncCall TypeType{typ: *uint32} args: 1 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType *uint32, *uint32
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestTypeConv (0.00s)
=== RUN   TestStar
2025/12/19 11:09:29 ==> Preload var [x]
2025/12/19 11:09:29 ==> Preload var [y]
2025/12/19 11:09:29 ==> Load var *uint32 [x]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [x]
2025/12/19 11:09:29 Val uint32 uint32
2025/12/19 11:09:29 Val type uint32 => Typ uint32
2025/12/19 11:09:29 Star
2025/12/19 11:09:29 Val nil untyped nil
2025/12/19 11:09:29 Call 1 0 // TypeType{typ: *uint32}
2025/12/19 11:09:29 ==> MatchFuncCall TypeType{typ: *uint32} args: 1 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType *uint32, *uint32
2025/12/19 11:09:29 ==> Load var uint32 [y]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [y]
2025/12/19 11:09:29 Val x *uint32
2025/12/19 11:09:29 Star
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType uint32, uint32
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestStar (0.00s)
=== RUN   TestLHS
2025/12/19 11:09:29 ==> Preload type T
2025/12/19 11:09:29 ==> Preload func foo
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load > NewType T
2025/12/19 11:09:29 NewType T
2025/12/19 11:09:29 ==> Load > InitType T
2025/12/19 11:09:29 InitType T struct{a int}
2025/12/19 11:09:29 ==> Load func foo
2025/12/19 11:09:29 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{a int}
2025/12/19 11:09:29 NewFunc foo func() *github.com/goplus/xgo/cl.T
2025/12/19 11:09:29 Val nil untyped nil
2025/12/19 11:09:29 Return 1
2025/12/19 11:09:29 ==> MatchType untyped nil, *github.com/goplus/xgo/cl.T
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.T
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 Val foo func() *github.com/goplus/xgo/cl.T
2025/12/19 11:09:29 Call 0 0 // func() *github.com/goplus/xgo/cl.T
2025/12/19 11:09:29 ==> MatchFuncCall func() *github.com/goplus/xgo/cl.T args: 0 flags: 0
2025/12/19 11:09:29 Member a -1 // *github.com/goplus/xgo/cl.T
2025/12/19 11:09:29 Val &{0 INT 123} *ast.BasicLit
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType untyped int (123), int
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestLHS (0.00s)
=== RUN   TestSend
2025/12/19 11:09:29 ==> Preload var [x]
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load var chan bool [x]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [x]
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 Val x chan bool
2025/12/19 11:09:29 Val true untyped bool
2025/12/19 11:09:29 Send
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestSend (0.00s)
=== RUN   TestIncDec
2025/12/19 11:09:29 ==> Preload var [x]
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load var uint32 [x]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [x]
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 VarRef x uint32
2025/12/19 11:09:29 IncDec ++
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestIncDec (0.00s)
=== RUN   TestAssignOp
2025/12/19 11:09:29 ==> Preload var [x]
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load var uint32 [x]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [x]
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 VarRef x uint32
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 AssignOp += Gop_AddAssign
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType refType{typ: uint32}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:29 ==> MatchType untyped int (3), unboundFuncParam{typ: uint32}
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestAssignOp (0.00s)
=== RUN   TestBigIntAssignOp
2025/12/19 11:09:29 ==> Preload var [x]
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load var github.com/qiniu/x/xgo/ng.Bigint [x]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [x]
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 VarRef x github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 AssignOp += Gop_AddAssign
2025/12/19 11:09:29 ==> MatchFuncCall func(b github.com/qiniu/x/xgo/ng.Bigint) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Bigint}, github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:29 ==> MatchType untyped int (3), github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (3), int
2025/12/19 11:09:29 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigint true
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestBigIntAssignOp (0.00s)
=== RUN   TestBigIntAssignOp2
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [x]
2025/12/19 11:09:29 Val NewInt func(x int64) *math/big.Int
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(x int64) *math/big.Int
2025/12/19 11:09:29 ==> MatchFuncCall func(x int64) *math/big.Int args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (3), int64
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint, int
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint, github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> DefaultConv github.com/qiniu/x/xgo/ng.UntypedBigint github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:29 VarRef x github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 AssignOp *= Gop_MulAssign
2025/12/19 11:09:29 ==> MatchFuncCall func(b github.com/qiniu/x/xgo/ng.Bigint) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Bigint}, github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:29 ==> MatchType untyped int (2), github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (2), int
2025/12/19 11:09:29 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigint true
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestBigIntAssignOp2 (0.00s)
=== RUN   TestBigIntAssignOp3
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [x]
2025/12/19 11:09:29 Val NewInt func(x int64) *math/big.Int
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(x int64) *math/big.Int
2025/12/19 11:09:29 ==> MatchFuncCall func(x int64) *math/big.Int args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (3), int64
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint, int
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint, github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> DefaultConv github.com/qiniu/x/xgo/ng.UntypedBigint github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:29 VarRef x github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:29 Val NewInt func(x int64) *math/big.Int
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(x int64) *math/big.Int
2025/12/19 11:09:29 ==> MatchFuncCall func(x int64) *math/big.Int args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped int (2), int64
2025/12/19 11:09:29 AssignOp *= Gop_MulAssign
2025/12/19 11:09:29 ==> MatchFuncCall func(b github.com/qiniu/x/xgo/ng.Bigint) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Bigint}, github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint (2), github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint (2), int
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/qiniu/x/xgo/ng.UntypedBigint (2), github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> EnsureLoaded github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:29 ==> AssignableConv github.com/qiniu/x/xgo/ng.UntypedBigint github.com/qiniu/x/xgo/ng.Bigint true
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestBigIntAssignOp3 (0.00s)
=== RUN   TestCompositeLit
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [x]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 SliceLit []float64 3 false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [y]
2025/12/19 11:09:29 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "XGo"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 MapLit map[string]int 4
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [z]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 ArrayLit [-1]int 3 false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [a]
2025/12/19 11:09:29 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "XGo"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 FLOAT 5.1} *ast.BasicLit
2025/12/19 11:09:29 MapLit <nil> 4
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestCompositeLit (0.00s)
=== RUN   TestCompositeLit2
2025/12/19 11:09:29 ==> Preload type foo
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load > NewType foo
2025/12/19 11:09:29 NewType foo
2025/12/19 11:09:29 ==> Load > InitType foo
2025/12/19 11:09:29 InitType foo struct{A int}
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [x]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 StructLit struct{a int} 1 false
2025/12/19 11:09:29 UnaryOp & flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 StructLit struct{a int} 1 false
2025/12/19 11:09:29 UnaryOp & flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 StructLit struct{a int} 1 false
2025/12/19 11:09:29 UnaryOp & flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:29 SliceLit []*struct{a int} 3 false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [y]
2025/12/19 11:09:29 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{A int}
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 StructLit github.com/goplus/xgo/cl.foo 1 false
2025/12/19 11:09:29 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:29 StructLit struct{a string} 1 false
2025/12/19 11:09:29 MapLit map[github.com/goplus/xgo/cl.foo]struct{a string} 2
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [z]
2025/12/19 11:09:29 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{A int}
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 StructLit github.com/goplus/xgo/cl.foo 1 false
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 StructLit github.com/goplus/xgo/cl.foo 1 false
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 StructLit github.com/goplus/xgo/cl.foo 1 false
2025/12/19 11:09:29 ArrayLit [-1]github.com/goplus/xgo/cl.foo 3 false
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestCompositeLit2 (0.00s)
=== RUN   TestCompositeLit3
2025/12/19 11:09:29 ==> Preload type Config
2025/12/19 11:09:29 ==> Preload func foo
2025/12/19 11:09:29 ==> Preload func bar
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load > NewType Config
2025/12/19 11:09:29 NewType Config
2025/12/19 11:09:29 ==> Load > InitType Config
2025/12/19 11:09:29 InitType Config struct{A int}
2025/12/19 11:09:29 ==> Load func foo
2025/12/19 11:09:29 ==> LookupParent Config => type github.com/goplus/xgo/cl.Config struct{A int}
2025/12/19 11:09:29 NewFunc foo func(conf *github.com/goplus/xgo/cl.Config)
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func bar
2025/12/19 11:09:29 ==> LookupParent Config => type github.com/goplus/xgo/cl.Config struct{A int}
2025/12/19 11:09:29 NewFunc bar func(conf ...github.com/goplus/xgo/cl.Config)
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 Val foo func(conf *github.com/goplus/xgo/cl.Config)
2025/12/19 11:09:29 Val 0 int
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 StructLit github.com/goplus/xgo/cl.Config 2 true
2025/12/19 11:09:29 UnaryOp & flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:29 Call 1 0 // func(conf *github.com/goplus/xgo/cl.Config)
2025/12/19 11:09:29 ==> MatchFuncCall func(conf *github.com/goplus/xgo/cl.Config) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType *github.com/goplus/xgo/cl.Config, *github.com/goplus/xgo/cl.Config
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.Config
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.Config
2025/12/19 11:09:29 Val bar func(conf ...github.com/goplus/xgo/cl.Config)
2025/12/19 11:09:29 Val 0 int
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 StructLit github.com/goplus/xgo/cl.Config 2 true
2025/12/19 11:09:29 Call 1 0 // func(conf ...github.com/goplus/xgo/cl.Config)
2025/12/19 11:09:29 ==> MatchFuncCall func(conf ...github.com/goplus/xgo/cl.Config) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/goplus/xgo/cl.Config, github.com/goplus/xgo/cl.Config
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.Config
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.Config
2025/12/19 11:09:29 Val foo func(conf *github.com/goplus/xgo/cl.Config)
2025/12/19 11:09:29 StructLit github.com/goplus/xgo/cl.Config 0 false
2025/12/19 11:09:29 UnaryOp & flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:29 Call 1 0 // func(conf *github.com/goplus/xgo/cl.Config)
2025/12/19 11:09:29 ==> MatchFuncCall func(conf *github.com/goplus/xgo/cl.Config) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType *github.com/goplus/xgo/cl.Config, *github.com/goplus/xgo/cl.Config
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.Config
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.Config
2025/12/19 11:09:29 Val bar func(conf ...github.com/goplus/xgo/cl.Config)
2025/12/19 11:09:29 StructLit github.com/goplus/xgo/cl.Config 0 false
2025/12/19 11:09:29 Call 1 0 // func(conf ...github.com/goplus/xgo/cl.Config)
2025/12/19 11:09:29 ==> MatchFuncCall func(conf ...github.com/goplus/xgo/cl.Config) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType github.com/goplus/xgo/cl.Config, github.com/goplus/xgo/cl.Config
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.Config
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.Config
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestCompositeLit3 (0.00s)
=== RUN   TestCompositeLit4
2025/12/19 11:09:29 ==> Preload type Result
2025/12/19 11:09:29 ==> Preload func foo
2025/12/19 11:09:29 ==> Load > NewType Result
2025/12/19 11:09:29 NewType Result
2025/12/19 11:09:29 ==> Load > InitType Result
2025/12/19 11:09:29 InitType Result struct{A int}
2025/12/19 11:09:29 ==> Load func foo
2025/12/19 11:09:29 ==> LookupParent Result => type github.com/goplus/xgo/cl.Result struct{A int}
2025/12/19 11:09:29 NewFunc foo func() *github.com/goplus/xgo/cl.Result
2025/12/19 11:09:29 Val 0 int
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 StructLit github.com/goplus/xgo/cl.Result 2 true
2025/12/19 11:09:29 UnaryOp & flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:29 Return 1
2025/12/19 11:09:29 ==> MatchType *github.com/goplus/xgo/cl.Result, *github.com/goplus/xgo/cl.Result
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestCompositeLit4 (0.00s)
=== RUN   TestCompositeLit5
2025/12/19 11:09:29 ==> Preload type mymap
2025/12/19 11:09:29 ==> Preload var [x]
2025/12/19 11:09:29 ==> Preload var [y]
2025/12/19 11:09:29 ==> Preload var [z]
2025/12/19 11:09:29 ==> Load > NewType mymap
2025/12/19 11:09:29 NewType mymap
2025/12/19 11:09:29 ==> Load > InitType mymap
2025/12/19 11:09:29 InitType mymap map[float64]string
2025/12/19 11:09:29 ==> Load var <nil> [x]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [x]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "world"} *ast.BasicLit
2025/12/19 11:09:29 MapLit <nil> 4
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> Load var map[float64]string [y]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [y]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "world"} *ast.BasicLit
2025/12/19 11:09:29 MapLit map[float64]string 4
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType map[float64]string, map[float64]string
2025/12/19 11:09:29 ==> LookupParent mymap => type github.com/goplus/xgo/cl.mymap map[float64]string
2025/12/19 11:09:29 ==> Load var github.com/goplus/xgo/cl.mymap [z]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [z]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "world"} *ast.BasicLit
2025/12/19 11:09:29 MapLit github.com/goplus/xgo/cl.mymap 4
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType github.com/goplus/xgo/cl.mymap, github.com/goplus/xgo/cl.mymap
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.mymap
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.mymap
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestCompositeLit5 (0.00s)
=== RUN   TestSliceLit
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [x]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 SliceLit <nil> 3 false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [y]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 SliceLit <nil> 1 false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [z]
2025/12/19 11:09:29 SliceLit <nil> 0 false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
2025/12/19 11:09:29 ==> Preload type vector
2025/12/19 11:09:29 ==> Preload var [x]
2025/12/19 11:09:29 ==> Preload var [y]
2025/12/19 11:09:29 ==> Preload var [z]
2025/12/19 11:09:29 ==> Load > NewType vector
2025/12/19 11:09:29 NewType vector
2025/12/19 11:09:29 ==> Load > InitType vector
2025/12/19 11:09:29 InitType vector []float64
2025/12/19 11:09:29 ==> Load var <nil> [x]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [x]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 SliceLit <nil> 3 false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> Load var []float64 [y]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [y]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 SliceLit []float64 3 false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType []float64, []float64
2025/12/19 11:09:29 ==> LookupParent vector => type github.com/goplus/xgo/cl.vector []float64
2025/12/19 11:09:29 ==> Load var github.com/goplus/xgo/cl.vector [z]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [z]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 SliceLit github.com/goplus/xgo/cl.vector 3 false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType github.com/goplus/xgo/cl.vector, github.com/goplus/xgo/cl.vector
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.vector
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.vector
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestSliceLit (0.00s)
=== RUN   TestChan
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [a]
2025/12/19 11:09:29 Val make TyInstruction{gogen.makeInstr}
2025/12/19 11:09:29 Typ chan int
2025/12/19 11:09:29 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:29 Call 2 0 // TyInstruction{gogen.makeInstr}
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.makeInstr} args: 2 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 Val a chan int
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 Send
2025/12/19 11:09:29 ==> Load var int [b]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [b]
2025/12/19 11:09:29 Val a chan int
2025/12/19 11:09:29 UnaryOp <- flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 DefineVarStart [x ok]
2025/12/19 11:09:29 Val a chan int
2025/12/19 11:09:29 UnaryOp <- flags: 2
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 2
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestChan (0.00s)
=== RUN   TestKeyValModeLit
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [a]
2025/12/19 11:09:29 None
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/12/19 11:09:29 None
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 ArrayLit [-1]float64 6 true
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [b]
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/12/19 11:09:29 None
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 6} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 FLOAT 4.5} *ast.BasicLit
2025/12/19 11:09:29 SliceLit []float64 6 true
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestKeyValModeLit (0.00s)
=== RUN   TestStructLit
2025/12/19 11:09:29 ==> Preload type foo
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load > NewType foo
2025/12/19 11:09:29 NewType foo
2025/12/19 11:09:29 ==> Load > InitType foo
2025/12/19 11:09:29 InitType foo struct{A int; B string "tag1:123"}
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [a]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:29 StructLit struct{A int; B string "tag1:123"} 2 false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [b]
2025/12/19 11:09:29 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{A int; B string "tag1:123"}
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:29 StructLit github.com/goplus/xgo/cl.foo 2 false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [c]
2025/12/19 11:09:29 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{A int; B string "tag1:123"}
2025/12/19 11:09:29 Val 1 int
2025/12/19 11:09:29 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:29 StructLit github.com/goplus/xgo/cl.foo 2 true
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestStructLit (0.00s)
=== RUN   TestStructType
2025/12/19 11:09:29 ==> Preload type bar
2025/12/19 11:09:29 ==> Preload type foo
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load > AliasType bar
2025/12/19 11:09:29 ==> Load > NewType foo
2025/12/19 11:09:29 NewType foo
2025/12/19 11:09:29 ==> Lookup (LoadSymbol) foo => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:29 AliasType bar github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 ==> Load > InitType foo
2025/12/19 11:09:29 ==> LookupParent bar => type github.com/goplus/xgo/cl.bar = github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 InitType foo struct{p *github.com/goplus/xgo/cl.foo; A int; B string "tag1:123"}
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 NewType a
2025/12/19 11:09:29 ==> LookupParent a => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:29 InitType a struct{p *github.com/goplus/xgo/cl.a}
2025/12/19 11:09:29 ==> LookupParent a => type a struct{p *github.com/goplus/xgo/cl.a}
2025/12/19 11:09:29 AliasType b github.com/goplus/xgo/cl.a
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestStructType (0.00s)
=== RUN   TestDeferGo
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("Hi"), any
2025/12/19 11:09:29 Go
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val &{0 STRING "XGo"} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("XGo"), any
2025/12/19 11:09:29 Defer
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestDeferGo (0.00s)
=== RUN   TestFor
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [a]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 SliceLit <nil> 3 false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 For
2025/12/19 11:09:29 DefineVarStart [i]
2025/12/19 11:09:29 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 Val i int
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp <
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val i int
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType int, any
2025/12/19 11:09:29 Post
2025/12/19 11:09:29 VarRef i int
2025/12/19 11:09:29 Val i int
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp +
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 End // For
2025/12/19 11:09:29 For
2025/12/19 11:09:29 None
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val &{0 STRING "loop"} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("loop"), any
2025/12/19 11:09:29 End // For
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestFor (0.00s)
=== RUN   TestRangeStmt
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [a]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 SliceLit <nil> 3 false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ForRange [_ x]
2025/12/19 11:09:29 Val a []float64
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 VBlock
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType float64, any
2025/12/19 11:09:29 End // Vblock
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 ForRange [i x]
2025/12/19 11:09:29 Val a []float64
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 VBlock
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val i int
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, any
2025/12/19 11:09:29 ==> MatchType float64, any
2025/12/19 11:09:29 End // Vblock
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 ==> Load var int [i]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [i]
2025/12/19 11:09:29 ==> Load var float64 [x]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [x]
2025/12/19 11:09:29 ForRange []
2025/12/19 11:09:29 VarRef _
2025/12/19 11:09:29 VarRef x float64
2025/12/19 11:09:29 Val a []float64
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 ==> MatchType float64, float64
2025/12/19 11:09:29 VBlock
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val i int
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, any
2025/12/19 11:09:29 ==> MatchType float64, any
2025/12/19 11:09:29 End // Vblock
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 ForRange []
2025/12/19 11:09:29 VarRef i int
2025/12/19 11:09:29 VarRef x float64
2025/12/19 11:09:29 Val a []float64
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 ==> MatchType float64, float64
2025/12/19 11:09:29 VBlock
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val i int
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, any
2025/12/19 11:09:29 ==> MatchType float64, any
2025/12/19 11:09:29 End // Vblock
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 ForRange []
2025/12/19 11:09:29 Val a []float64
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 VBlock
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("Hi"), any
2025/12/19 11:09:29 End // Vblock
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestRangeStmt (0.00s)
=== RUN   TestRangeStmtUDT
2025/12/19 11:09:29 ==> Preload type foo
2025/12/19 11:09:29 ==> Preload method foo.Gop_Enum
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load > NewType foo
2025/12/19 11:09:29 NewType foo
2025/12/19 11:09:29 ==> Load > InitType foo
2025/12/19 11:09:29 InitType foo struct{}
2025/12/19 11:09:29 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:29 ==> Load method *github.com/goplus/xgo/cl.foo.Gop_Enum
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 ForRange [k v]
2025/12/19 11:09:29 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:29 Val foo github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 Val type github.com/goplus/xgo/cl.foo struct{} => Typ github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 VBlock
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val k int
2025/12/19 11:09:29 Val v string
2025/12/19 11:09:29 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, any
2025/12/19 11:09:29 ==> MatchType string, any
2025/12/19 11:09:29 End // Vblock
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 NewFunc Gop_Enum (*github.com/goplus/xgo/cl.foo) func(c func(key int, val string))
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestRangeStmtUDT (0.00s)
=== RUN   TestForPhraseUDT
2025/12/19 11:09:29 ==> Preload type foo
2025/12/19 11:09:29 ==> Preload method foo.Gop_Enum
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load > NewType foo
2025/12/19 11:09:29 NewType foo
2025/12/19 11:09:29 ==> Load > InitType foo
2025/12/19 11:09:29 InitType foo struct{}
2025/12/19 11:09:29 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:29 ==> Load method *github.com/goplus/xgo/cl.foo.Gop_Enum
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 ForRange [_ v]
2025/12/19 11:09:29 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:29 Val foo github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 Val type github.com/goplus/xgo/cl.foo struct{} => Typ github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 VBlock
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val v string
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType string, any
2025/12/19 11:09:29 End // Vblock
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 NewFunc Gop_Enum (*github.com/goplus/xgo/cl.foo) func(c func(val string))
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestForPhraseUDT (0.00s)
=== RUN   TestForPhraseUDT2
2025/12/19 11:09:29 ==> Preload type fooIter
2025/12/19 11:09:29 ==> Preload method fooIter.Next
2025/12/19 11:09:29 ==> Preload type foo
2025/12/19 11:09:29 ==> Preload method foo.Gop_Enum
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load > NewType fooIter
2025/12/19 11:09:29 NewType fooIter
2025/12/19 11:09:29 ==> Load > InitType fooIter
2025/12/19 11:09:29 InitType fooIter struct{}
2025/12/19 11:09:29 ==> LookupParent fooIter => type github.com/goplus/xgo/cl.fooIter struct{}
2025/12/19 11:09:29 ==> Load method github.com/goplus/xgo/cl.fooIter.Next
2025/12/19 11:09:29 ==> Load > NewType foo
2025/12/19 11:09:29 NewType foo
2025/12/19 11:09:29 ==> Load > InitType foo
2025/12/19 11:09:29 InitType foo struct{}
2025/12/19 11:09:29 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:29 ==> Load method *github.com/goplus/xgo/cl.foo.Gop_Enum
2025/12/19 11:09:29 ==> LookupParent fooIter => type github.com/goplus/xgo/cl.fooIter struct{}
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 ForRange [k v]
2025/12/19 11:09:29 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:29 Val foo github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 Val type github.com/goplus/xgo/cl.foo struct{} => Typ github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 VBlock
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val k string
2025/12/19 11:09:29 Val v int
2025/12/19 11:09:29 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType string, any
2025/12/19 11:09:29 ==> MatchType int, any
2025/12/19 11:09:29 End // Vblock
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 Member Gop_Enum 0 // *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 Call 0 0 // func() github.com/goplus/xgo/cl.fooIter
2025/12/19 11:09:29 ==> MatchFuncCall func() github.com/goplus/xgo/cl.fooIter args: 0 flags: 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 NewFunc Next (github.com/goplus/xgo/cl.fooIter) func() (key string, val int, ok bool)
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 NewFunc Gop_Enum (*github.com/goplus/xgo/cl.foo) func() github.com/goplus/xgo/cl.fooIter
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestForPhraseUDT2 (0.00s)
=== RUN   TestForPhraseUDT3
2025/12/19 11:09:29 ==> Preload type foo
2025/12/19 11:09:29 ==> Preload method foo.Gop_Enum
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load > NewType foo
2025/12/19 11:09:29 NewType foo
2025/12/19 11:09:29 ==> Load > InitType foo
2025/12/19 11:09:29 InitType foo struct{}
2025/12/19 11:09:29 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:29 ==> Load method *github.com/goplus/xgo/cl.foo.Gop_Enum
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:29 ForRange [_ v]
2025/12/19 11:09:29 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:29 Val foo github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 Val type github.com/goplus/xgo/cl.foo struct{} => Typ github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 Val append func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 Val v string
2025/12/19 11:09:29 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType unboundType{typ: <nil>}, []unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType string, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType []string, unboundType{typ: <nil>}
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 0 0 // func() (_xgo_ret []string)
2025/12/19 11:09:29 ==> MatchFuncCall func() (_xgo_ret []string) args: 0 flags: 0
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType []string, any
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 NewFunc Gop_Enum (*github.com/goplus/xgo/cl.foo) func(c func(val string))
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestForPhraseUDT3 (0.00s)
=== RUN   TestForPhraseUDT4
2025/12/19 11:09:29 ==> Preload type fooIter
2025/12/19 11:09:29 ==> Preload method fooIter.Next
2025/12/19 11:09:29 ==> Preload type foo
2025/12/19 11:09:29 ==> Preload func newFoo
2025/12/19 11:09:29 ==> Preload method foo.Gop_Enum
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load > NewType fooIter
2025/12/19 11:09:29 NewType fooIter
2025/12/19 11:09:29 ==> Load > InitType fooIter
2025/12/19 11:09:29 ==> Load > NewType foo
2025/12/19 11:09:29 NewType foo
2025/12/19 11:09:29 ==> Lookup (LoadSymbol) foo => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:29 InitType fooIter struct{data *github.com/goplus/xgo/cl.foo; idx int}
2025/12/19 11:09:29 ==> LookupParent fooIter => type github.com/goplus/xgo/cl.fooIter struct{data *github.com/goplus/xgo/cl.foo; idx int}
2025/12/19 11:09:29 ==> Load method *github.com/goplus/xgo/cl.fooIter.Next
2025/12/19 11:09:29 ==> Load > InitType foo
2025/12/19 11:09:29 InitType foo struct{key []int; val []string}
2025/12/19 11:09:29 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{key []int; val []string}
2025/12/19 11:09:29 ==> Load method *github.com/goplus/xgo/cl.foo.Gop_Enum
2025/12/19 11:09:29 ==> LookupParent fooIter => type github.com/goplus/xgo/cl.fooIter struct{data *github.com/goplus/xgo/cl.foo; idx int}
2025/12/19 11:09:29 ==> Load func newFoo
2025/12/19 11:09:29 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{key []int; val []string}
2025/12/19 11:09:29 NewFunc newFoo func() *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{key []int; val []string}
2025/12/19 11:09:29 Val 0 int
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:09:29 SliceLit []int 2 false
2025/12/19 11:09:29 Val 1 int
2025/12/19 11:09:29 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "XGo"} *ast.BasicLit
2025/12/19 11:09:29 SliceLit []string 2 false
2025/12/19 11:09:29 StructLit github.com/goplus/xgo/cl.foo 4 true
2025/12/19 11:09:29 UnaryOp & flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:29 Return 1
2025/12/19 11:09:29 ==> MatchType *github.com/goplus/xgo/cl.foo, *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 ForRange [k v]
2025/12/19 11:09:29 Val newFoo func() *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 Call 0 0 // func() *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 ==> MatchFuncCall func() *github.com/goplus/xgo/cl.foo args: 0 flags: 0
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 VBlock
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val k int
2025/12/19 11:09:29 Val v string
2025/12/19 11:09:29 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, any
2025/12/19 11:09:29 ==> MatchType string, any
2025/12/19 11:09:29 End // Vblock
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 Member Gop_Enum 0 // *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 Call 0 0 // func() *github.com/goplus/xgo/cl.fooIter
2025/12/19 11:09:29 ==> MatchFuncCall func() *github.com/goplus/xgo/cl.fooIter args: 0 flags: 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 NewFunc Next (*github.com/goplus/xgo/cl.fooIter) func() (key int, val string, ok bool)
2025/12/19 11:09:29 If
2025/12/19 11:09:29 Val p *github.com/goplus/xgo/cl.fooIter
2025/12/19 11:09:29 Member idx 2 // *github.com/goplus/xgo/cl.fooIter
2025/12/19 11:09:29 Val len TyInstruction{gogen.lenInstr}
2025/12/19 11:09:29 Val p *github.com/goplus/xgo/cl.fooIter
2025/12/19 11:09:29 Member data 2 // *github.com/goplus/xgo/cl.fooIter
2025/12/19 11:09:29 Member key 2 // *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 Call 1 0 // TyInstruction{gogen.lenInstr}
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.lenInstr} args: 1 flags: 0
2025/12/19 11:09:29 BinaryOp <
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 VarRef key int
2025/12/19 11:09:29 VarRef val string
2025/12/19 11:09:29 VarRef ok bool
2025/12/19 11:09:29 Val p *github.com/goplus/xgo/cl.fooIter
2025/12/19 11:09:29 Member data 2 // *github.com/goplus/xgo/cl.fooIter
2025/12/19 11:09:29 Member key 2 // *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 Val p *github.com/goplus/xgo/cl.fooIter
2025/12/19 11:09:29 Member idx 2 // *github.com/goplus/xgo/cl.fooIter
2025/12/19 11:09:29 Index 1 false
2025/12/19 11:09:29 Val p *github.com/goplus/xgo/cl.fooIter
2025/12/19 11:09:29 Member data 2 // *github.com/goplus/xgo/cl.fooIter
2025/12/19 11:09:29 Member val 2 // *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 Val p *github.com/goplus/xgo/cl.fooIter
2025/12/19 11:09:29 Member idx 2 // *github.com/goplus/xgo/cl.fooIter
2025/12/19 11:09:29 Index 1 false
2025/12/19 11:09:29 Val true untyped bool
2025/12/19 11:09:29 Assign 3 3
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 ==> MatchType string, string
2025/12/19 11:09:29 ==> MatchType untyped bool (true), bool
2025/12/19 11:09:29 Val p *github.com/goplus/xgo/cl.fooIter
2025/12/19 11:09:29 Member idx -1 // *github.com/goplus/xgo/cl.fooIter
2025/12/19 11:09:29 IncDec ++
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 NewFunc Gop_Enum (*github.com/goplus/xgo/cl.foo) func() *github.com/goplus/xgo/cl.fooIter
2025/12/19 11:09:29 ==> LookupParent fooIter => type github.com/goplus/xgo/cl.fooIter struct{data *github.com/goplus/xgo/cl.foo; idx int}
2025/12/19 11:09:29 Val 0 int
2025/12/19 11:09:29 Val p *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 StructLit github.com/goplus/xgo/cl.fooIter 2 true
2025/12/19 11:09:29 UnaryOp & flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:29 Return 1
2025/12/19 11:09:29 ==> MatchType *github.com/goplus/xgo/cl.fooIter, *github.com/goplus/xgo/cl.fooIter
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestForPhraseUDT4 (0.00s)
=== RUN   TestForPhrase
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [sum]
2025/12/19 11:09:29 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ForRange [_ x]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 11} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 13} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 17} *ast.BasicLit
2025/12/19 11:09:29 SliceLit <nil> 7 false
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 If
2025/12/19 11:09:29 Val x int
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp >
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 VarRef sum int
2025/12/19 11:09:29 Val sum int
2025/12/19 11:09:29 Val x int
2025/12/19 11:09:29 BinaryOp +
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 ForRange [i x]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 11} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 13} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 17} *ast.BasicLit
2025/12/19 11:09:29 SliceLit <nil> 7 false
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 VBlock
2025/12/19 11:09:29 VarRef sum int
2025/12/19 11:09:29 Val sum int
2025/12/19 11:09:29 Val i int
2025/12/19 11:09:29 Val x int
2025/12/19 11:09:29 BinaryOp *
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:29 BinaryOp +
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 End // Vblock
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val &{0 STRING "sum(5,7,11,13,17):"} *ast.BasicLit
2025/12/19 11:09:29 Val sum int
2025/12/19 11:09:29 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("sum(5,7,11,13,17):"), any
2025/12/19 11:09:29 ==> MatchType int, any
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestForPhrase (0.00s)
=== RUN   TestMapComprehension
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [y]
2025/12/19 11:09:29 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:29 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 ZeroLit // unboundType{typ: <nil>}
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType unboundType{typ: <nil>}, unboundType{typ: <nil>}
2025/12/19 11:09:29 ForRange [i x]
2025/12/19 11:09:29 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "3"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "5"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "7"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "11"} *ast.BasicLit
2025/12/19 11:09:29 SliceLit <nil> 5 false
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 Val _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 Val x string
2025/12/19 11:09:29 IndexRef 1
2025/12/19 11:09:29 Val i int
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType int, unboundMapElemType{key: string}
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 0 0 // func() (_xgo_ret map[string]int)
2025/12/19 11:09:29 ==> MatchFuncCall func() (_xgo_ret map[string]int) args: 0 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestMapComprehension (0.00s)
=== RUN   TestMapComprehensionCond
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [z]
2025/12/19 11:09:29 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:29 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 ZeroLit // unboundType{typ: <nil>}
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType unboundType{typ: <nil>}, unboundType{typ: <nil>}
2025/12/19 11:09:29 ForRange [k v]
2025/12/19 11:09:29 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "xsw"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "XGo"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:09:29 MapLit <nil> 8
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 If
2025/12/19 11:09:29 Val v int
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp >
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 Val _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 Val v int
2025/12/19 11:09:29 IndexRef 1
2025/12/19 11:09:29 Val k string
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType string, unboundMapElemType{key: int}
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 0 0 // func() (_xgo_ret map[int]string)
2025/12/19 11:09:29 ==> MatchFuncCall func() (_xgo_ret map[int]string) args: 0 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestMapComprehensionCond (0.00s)
=== RUN   TestMapComprehensionCond2
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [z]
2025/12/19 11:09:29 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:29 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 ZeroLit // unboundType{typ: <nil>}
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType unboundType{typ: <nil>}, unboundType{typ: <nil>}
2025/12/19 11:09:29 ForRange [k v]
2025/12/19 11:09:29 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "xsw"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "XGo"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:09:29 MapLit <nil> 8
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 If
2025/12/19 11:09:29 DefineVarStart [t]
2025/12/19 11:09:29 Val v int
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 Val t int
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp >
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 Val _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 Val t int
2025/12/19 11:09:29 IndexRef 1
2025/12/19 11:09:29 Val k string
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType string, unboundMapElemType{key: int}
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 0 0 // func() (_xgo_ret map[int]string)
2025/12/19 11:09:29 ==> MatchFuncCall func() (_xgo_ret map[int]string) args: 0 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestMapComprehensionCond2 (0.00s)
=== RUN   TestExistsComprehension
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [hasFive]
2025/12/19 11:09:29 NewClosure func() (_xgo_ok bool)
2025/12/19 11:09:29 ForRange [_ x]
2025/12/19 11:09:29 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "3"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "5"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "7"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "11"} *ast.BasicLit
2025/12/19 11:09:29 SliceLit <nil> 5 false
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 If
2025/12/19 11:09:29 Val x string
2025/12/19 11:09:29 Val &{0 STRING "5"} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp ==
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 Val true bool
2025/12/19 11:09:29 Return 1
2025/12/19 11:09:29 ==> MatchType untyped bool (true), bool
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 0 0 // func() (_xgo_ok bool)
2025/12/19 11:09:29 ==> MatchFuncCall func() (_xgo_ok bool) args: 0 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestExistsComprehension (0.00s)
=== RUN   TestSelectComprehension
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [y]
2025/12/19 11:09:29 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:29 ForRange [i x]
2025/12/19 11:09:29 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "3"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "5"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "7"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "11"} *ast.BasicLit
2025/12/19 11:09:29 SliceLit <nil> 5 false
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 If
2025/12/19 11:09:29 Val x string
2025/12/19 11:09:29 Val &{0 STRING "5"} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp ==
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 Val i int
2025/12/19 11:09:29 Return 1
2025/12/19 11:09:29 ==> MatchType int, unboundType{typ: <nil>}
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 0 0 // func() (_xgo_ret int)
2025/12/19 11:09:29 ==> MatchFuncCall func() (_xgo_ret int) args: 0 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestSelectComprehension (0.00s)
=== RUN   TestSelectComprehensionTwoValue
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [y ok]
2025/12/19 11:09:29 NewClosure func() (_xgo_ret unboundType{typ: <nil>}, _xgo_ok bool)
2025/12/19 11:09:29 ForRange [i x]
2025/12/19 11:09:29 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "3"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "5"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "7"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "11"} *ast.BasicLit
2025/12/19 11:09:29 SliceLit <nil> 5 false
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 If
2025/12/19 11:09:29 Val x string
2025/12/19 11:09:29 Val &{0 STRING "5"} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp ==
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 Val i int
2025/12/19 11:09:29 Val true bool
2025/12/19 11:09:29 Return 2
2025/12/19 11:09:29 ==> MatchType int, unboundType{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType untyped bool (true), bool
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 0 0 // func() (_xgo_ret int, _xgo_ok bool)
2025/12/19 11:09:29 ==> MatchFuncCall func() (_xgo_ret int, _xgo_ok bool) args: 0 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestSelectComprehensionTwoValue (0.00s)
=== RUN   TestSelectComprehensionRetTwoValue
2025/12/19 11:09:29 ==> Preload func foo
2025/12/19 11:09:29 ==> Load func foo
2025/12/19 11:09:29 NewFunc foo func() (int, bool)
2025/12/19 11:09:29 NewClosure func() (_xgo_ret unboundType{typ: <nil>}, _xgo_ok bool)
2025/12/19 11:09:29 ForRange [i x]
2025/12/19 11:09:29 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "3"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "5"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "7"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "11"} *ast.BasicLit
2025/12/19 11:09:29 SliceLit <nil> 5 false
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 If
2025/12/19 11:09:29 Val x string
2025/12/19 11:09:29 Val &{0 STRING "5"} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp ==
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 Val i int
2025/12/19 11:09:29 Val true bool
2025/12/19 11:09:29 Return 2
2025/12/19 11:09:29 ==> MatchType int, unboundType{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType untyped bool (true), bool
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 0 0 // func() (_xgo_ret int, _xgo_ok bool)
2025/12/19 11:09:29 ==> MatchFuncCall func() (_xgo_ret int, _xgo_ok bool) args: 0 flags: 0
2025/12/19 11:09:29 Return 1
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 ==> MatchType bool, bool
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestSelectComprehensionRetTwoValue (0.00s)
=== RUN   TestListComprehension
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [a]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 SliceLit <nil> 3 false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [b]
2025/12/19 11:09:29 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:29 ForRange [_ x]
2025/12/19 11:09:29 Val a []float64
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 Val append func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 BinaryOp *
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:29 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType unboundType{typ: <nil>}, []unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType []float64, unboundType{typ: <nil>}
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 0 0 // func() (_xgo_ret []float64)
2025/12/19 11:09:29 ==> MatchFuncCall func() (_xgo_ret []float64) args: 0 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestListComprehension (0.00s)
=== RUN   TestListComprehensionMultiLevel
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [arr]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 FLOAT 4.1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 6} *ast.BasicLit
2025/12/19 11:09:29 SliceLit <nil> 6 false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [x]
2025/12/19 11:09:29 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:29 ForRange [_ b]
2025/12/19 11:09:29 Val arr []float64
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 If
2025/12/19 11:09:29 Val b float64
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp >
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType untyped int (2), unboundFuncParam{typ: float64}
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 ForRange [_ a]
2025/12/19 11:09:29 Val arr []float64
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 If
2025/12/19 11:09:29 Val a float64
2025/12/19 11:09:29 Val b float64
2025/12/19 11:09:29 BinaryOp <
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 Val append func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 Val a float64
2025/12/19 11:09:29 Val b float64
2025/12/19 11:09:29 SliceLit <nil> 2 false
2025/12/19 11:09:29 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType unboundType{typ: <nil>}, []unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType []float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType [][]float64, unboundType{typ: <nil>}
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 0 0 // func() (_xgo_ret [][]float64)
2025/12/19 11:09:29 ==> MatchFuncCall func() (_xgo_ret [][]float64) args: 0 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val &{0 STRING "x:"} *ast.BasicLit
2025/12/19 11:09:29 Val x [][]float64
2025/12/19 11:09:29 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("x:"), any
2025/12/19 11:09:29 ==> MatchType [][]float64, any
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestListComprehensionMultiLevel (0.00s)
=== RUN   TestSliceGet
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [a]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 9} *ast.BasicLit
2025/12/19 11:09:29 SliceLit <nil> 5 false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [b]
2025/12/19 11:09:29 Val a []int
2025/12/19 11:09:29 None
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 Slice false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [c]
2025/12/19 11:09:29 Val a []int
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 None
2025/12/19 11:09:29 Slice false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [d]
2025/12/19 11:09:29 Val a []int
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 Slice true
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [e]
2025/12/19 11:09:29 Val &{0 STRING "Hello, XGo"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:09:29 None
2025/12/19 11:09:29 Slice false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestSliceGet (0.00s)
=== RUN   TestIndexGetTwoValue
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [a]
2025/12/19 11:09:29 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "xsw"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "XGo"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:09:29 MapLit <nil> 8
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [x ok]
2025/12/19 11:09:29 Val a map[string]int
2025/12/19 11:09:29 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:29 Index 1 true
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [y]
2025/12/19 11:09:29 Val a map[string]int
2025/12/19 11:09:29 Val &{0 STRING "XGo"} *ast.BasicLit
2025/12/19 11:09:29 Index 1 false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestIndexGetTwoValue (0.00s)
=== RUN   TestIndexGet
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [a]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 SliceLit <nil> 3 false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [b]
2025/12/19 11:09:29 Val a []float64
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Index 1 false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestIndexGet (0.00s)
=== RUN   TestIndexRef
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [a]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 SliceLit <nil> 3 false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 Val a []float64
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 IndexRef 1
2025/12/19 11:09:29 Val &{0 FLOAT 2.1} *ast.BasicLit
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType untyped float (2.1), float64
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestIndexRef (0.00s)
=== RUN   TestIndexArrayPtrIssue784
2025/12/19 11:09:29 ==> Preload type intArr
2025/12/19 11:09:29 ==> Preload func foo
2025/12/19 11:09:29 ==> Load > NewType intArr
2025/12/19 11:09:29 NewType intArr
2025/12/19 11:09:29 ==> Load > InitType intArr
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 InitType intArr [2]int
2025/12/19 11:09:29 ==> Load func foo
2025/12/19 11:09:29 ==> LookupParent intArr => type github.com/goplus/xgo/cl.intArr [2]int
2025/12/19 11:09:29 NewFunc foo func(a *github.com/goplus/xgo/cl.intArr)
2025/12/19 11:09:29 Val a *github.com/goplus/xgo/cl.intArr
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 IndexRef 1
2025/12/19 11:09:29 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType untyped int (10), int
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestIndexArrayPtrIssue784 (0.00s)
=== RUN   TestMemberVal
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [x]
2025/12/19 11:09:29 Val NewReplacer func(oldnew ...string) *strings.Replacer
2025/12/19 11:09:29 Val &{0 STRING "?"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "!"} *ast.BasicLit
2025/12/19 11:09:29 Call 2 0 // func(oldnew ...string) *strings.Replacer
2025/12/19 11:09:29 ==> MatchFuncCall func(oldnew ...string) *strings.Replacer args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("?"), string
2025/12/19 11:09:29 ==> MatchType untyped string ("!"), string
2025/12/19 11:09:29 Member Replace 1 // *strings.Replacer
2025/12/19 11:09:29 Val &{0 STRING "hello, world???"} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(s string) string
2025/12/19 11:09:29 ==> MatchFuncCall func(s string) string args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("hello, world???"), string
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val &{0 STRING "x:"} *ast.BasicLit
2025/12/19 11:09:29 Val x string
2025/12/19 11:09:29 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("x:"), any
2025/12/19 11:09:29 ==> MatchType string, any
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestMemberVal (0.00s)
=== RUN   TestNamedPtrMemberIssue786
2025/12/19 11:09:29 ==> Preload type foo
2025/12/19 11:09:29 ==> Preload type pfoo
2025/12/19 11:09:29 ==> Preload func bar
2025/12/19 11:09:29 ==> Load > NewType foo
2025/12/19 11:09:29 NewType foo
2025/12/19 11:09:29 ==> Load > InitType foo
2025/12/19 11:09:29 InitType foo struct{req int}
2025/12/19 11:09:29 ==> Load > NewType pfoo
2025/12/19 11:09:29 NewType pfoo
2025/12/19 11:09:29 ==> Load > InitType pfoo
2025/12/19 11:09:29 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{req int}
2025/12/19 11:09:29 InitType pfoo *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 ==> Load func bar
2025/12/19 11:09:29 ==> LookupParent pfoo => type github.com/goplus/xgo/cl.pfoo *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:29 NewFunc bar func(p github.com/goplus/xgo/cl.pfoo)
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val p github.com/goplus/xgo/cl.pfoo
2025/12/19 11:09:29 Member req 2 // github.com/goplus/xgo/cl.pfoo
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType int, any
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestNamedPtrMemberIssue786 (0.00s)
=== RUN   TestMember
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [a]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:29 StructLit struct{A int; B string} 2 false
2025/12/19 11:09:29 UnaryOp & flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [x]
2025/12/19 11:09:29 Val a *struct{A int; B string}
2025/12/19 11:09:29 Member A 2 // *struct{A int; B string}
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 Val a *struct{A int; B string}
2025/12/19 11:09:29 Member B -1 // *struct{A int; B string}
2025/12/19 11:09:29 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType untyped string ("Hi"), string
2025/12/19 11:09:29 VarRef Usage func()
2025/12/19 11:09:29 Val nil untyped nil
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType untyped nil, func()
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestMember (0.14s)
=== RUN   TestElem
2025/12/19 11:09:29 ==> Preload func foo
2025/12/19 11:09:29 ==> Load func foo
2025/12/19 11:09:29 NewFunc foo func(a *int, b int)
2025/12/19 11:09:29 VarRef b int
2025/12/19 11:09:29 Val a *int
2025/12/19 11:09:29 Star
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 Val a *int
2025/12/19 11:09:29 ElemRef
2025/12/19 11:09:29 Val b int
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestElem (0.00s)
=== RUN   TestNamedPtrIssue797
2025/12/19 11:09:29 ==> Preload type Bar
2025/12/19 11:09:29 ==> Preload func foo
2025/12/19 11:09:29 ==> Load > NewType Bar
2025/12/19 11:09:29 NewType Bar
2025/12/19 11:09:29 ==> Load > InitType Bar
2025/12/19 11:09:29 InitType Bar *int
2025/12/19 11:09:29 ==> Load func foo
2025/12/19 11:09:29 ==> LookupParent Bar => type github.com/goplus/xgo/cl.Bar *int
2025/12/19 11:09:29 NewFunc foo func(a github.com/goplus/xgo/cl.Bar)
2025/12/19 11:09:29 ==> Load var int [b]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [b]
2025/12/19 11:09:29 Val a github.com/goplus/xgo/cl.Bar
2025/12/19 11:09:29 Star
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestNamedPtrIssue797 (0.00s)
=== RUN   TestMethod
2025/12/19 11:09:29 ==> Preload type M
2025/12/19 11:09:29 ==> Preload method M.Foo
2025/12/19 11:09:29 ==> Preload method M.Bar
2025/12/19 11:09:29 ==> Load > NewType M
2025/12/19 11:09:29 NewType M
2025/12/19 11:09:29 ==> Load > InitType M
2025/12/19 11:09:29 InitType M int
2025/12/19 11:09:29 ==> LookupParent M => type github.com/goplus/xgo/cl.M int
2025/12/19 11:09:29 ==> Load method github.com/goplus/xgo/cl.M.Foo
2025/12/19 11:09:29 ==> LookupParent M => type github.com/goplus/xgo/cl.M int
2025/12/19 11:09:29 ==> Load method github.com/goplus/xgo/cl.M.Bar
2025/12/19 11:09:29 NewFunc Foo (github.com/goplus/xgo/cl.M) func()
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val &{0 STRING "foo"} *ast.BasicLit
2025/12/19 11:09:29 Val m github.com/goplus/xgo/cl.M
2025/12/19 11:09:29 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("foo"), any
2025/12/19 11:09:29 ==> MatchType github.com/goplus/xgo/cl.M, any
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 NewFunc Bar (github.com/goplus/xgo/cl.M) func()
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val &{0 STRING "bar"} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("bar"), any
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestMethod (0.00s)
=== RUN   TestCmdlineNoEOL
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("Hi"), any
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestCmdlineNoEOL (0.00s)
=== RUN   TestImport
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 Val Println func(a ...any) (n int, err error)
2025/12/19 11:09:29 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(a ...any) (n int, err error)
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("Hi"), any
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestImport (0.00s)
=== RUN   TestDotImport
2025/12/19 11:09:29 ==> Preload var [a]
2025/12/19 11:09:29 ==> Load var <nil> [a]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [a]
2025/12/19 11:09:29 Val Round func(x float64) float64
2025/12/19 11:09:29 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(x float64) float64
2025/12/19 11:09:29 ==> MatchFuncCall func(x float64) float64 args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped float (1.2), float64
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestDotImport (0.00s)
=== RUN   TestLocalImport
2025/12/19 11:09:29 ==> Preload var [a]
2025/12/19 11:09:29 ==> Load var <nil> [a]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [a]
2025/12/19 11:09:29 Val TestIntValue int
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestLocalImport (0.00s)
=== RUN   TestImportUnused
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestImportUnused (0.00s)
=== RUN   TestImportForceUsed
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestImportForceUsed (0.00s)
=== RUN   TestAnonymousImport
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("Hello"), any
2025/12/19 11:09:29 Val printf func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val &{0 STRING "Hello XGo\n"} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(format string, a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("Hello XGo\n"), string
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestAnonymousImport (0.00s)
=== RUN   TestVarAndConst
2025/12/19 11:09:29 NewConstDefs
2025/12/19 11:09:29 ==> Preload const [i]
2025/12/19 11:09:29 ==> Preload const [x]
2025/12/19 11:09:29 ==> Preload var [j]
2025/12/19 11:09:29 ==> Load const [i] <nil>
2025/12/19 11:09:29 NewConst [i] 0
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> Load const [x] float64
2025/12/19 11:09:29 NewConst [x] 1
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType untyped int (1), float64
2025/12/19 11:09:29 ==> Load var int [j]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [j]
2025/12/19 11:09:29 Val i untyped int
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType untyped int (1), int
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestVarAndConst (0.00s)
=== RUN   TestDeclStmt
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 NewConstDefs
2025/12/19 11:09:29 ==> Load const [i] <nil>
2025/12/19 11:09:29 NewConst [i] 0
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> Load const [x] float64
2025/12/19 11:09:29 NewConst [x] 1
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType untyped int (1), float64
2025/12/19 11:09:29 ==> Load var int [j]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [j]
2025/12/19 11:09:29 Val i untyped int
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType untyped int (1), int
2025/12/19 11:09:29 Val Println func(a ...any) (n int, err error)
2025/12/19 11:09:29 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(a ...any) (n int, err error)
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("Hi"), any
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestDeclStmt (0.00s)
=== RUN   TestIf
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [x]
2025/12/19 11:09:29 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 If
2025/12/19 11:09:29 DefineVarStart [t]
2025/12/19 11:09:29 Val false untyped bool
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 Val t bool
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 VarRef x int
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType untyped int (3), int
2025/12/19 11:09:29 Else
2025/12/19 11:09:29 If
2025/12/19 11:09:29 Val t bool
2025/12/19 11:09:29 UnaryOp ! flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType bool, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 VarRef x int
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType untyped int (5), int
2025/12/19 11:09:29 Else
2025/12/19 11:09:29 VarRef x int
2025/12/19 11:09:29 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType untyped int (7), int
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val &{0 STRING "x:"} *ast.BasicLit
2025/12/19 11:09:29 Val x int
2025/12/19 11:09:29 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("x:"), any
2025/12/19 11:09:29 ==> MatchType int, any
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestIf (0.00s)
=== RUN   TestSwitch
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [x]
2025/12/19 11:09:29 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 Switch
2025/12/19 11:09:29 DefineVarStart [s]
2025/12/19 11:09:29 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 Val s string
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 Case
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 VarRef x int
2025/12/19 11:09:29 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType untyped int (7), int
2025/12/19 11:09:29 End // Case
2025/12/19 11:09:29 Case
2025/12/19 11:09:29 Val &{0 STRING "world"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "hi"} *ast.BasicLit
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 VarRef x int
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType untyped int (5), int
2025/12/19 11:09:29 End // Case
2025/12/19 11:09:29 Case
2025/12/19 11:09:29 Val &{0 STRING "xsw"} *ast.BasicLit
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 VarRef x int
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType untyped int (3), int
2025/12/19 11:09:29 End // Case
2025/12/19 11:09:29 End // Switch
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val &{0 STRING "x:"} *ast.BasicLit
2025/12/19 11:09:29 Val x int
2025/12/19 11:09:29 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("x:"), any
2025/12/19 11:09:29 ==> MatchType int, any
2025/12/19 11:09:29 DefineVarStart [v]
2025/12/19 11:09:29 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 Switch
2025/12/19 11:09:29 None
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 Case
2025/12/19 11:09:29 Val v string
2025/12/19 11:09:29 Val &{0 STRING "xsw"} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp ==
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 VarRef x int
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType untyped int (3), int
2025/12/19 11:09:29 End // Case
2025/12/19 11:09:29 Case
2025/12/19 11:09:29 Val v string
2025/12/19 11:09:29 Val &{0 STRING "hi"} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp ==
2025/12/19 11:09:29 Val v string
2025/12/19 11:09:29 Val &{0 STRING "world"} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp ==
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 VarRef x int
2025/12/19 11:09:29 Val &{0 INT 9} *ast.BasicLit
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType untyped int (9), int
2025/12/19 11:09:29 End // Case
2025/12/19 11:09:29 Case
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 VarRef x int
2025/12/19 11:09:29 Val &{0 INT 11} *ast.BasicLit
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType untyped int (11), int
2025/12/19 11:09:29 End // Case
2025/12/19 11:09:29 End // Switch
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val &{0 STRING "x:"} *ast.BasicLit
2025/12/19 11:09:29 Val x int
2025/12/19 11:09:29 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("x:"), any
2025/12/19 11:09:29 ==> MatchType int, any
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestSwitch (0.00s)
=== RUN   TestSwitchFallthrough
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [v]
2025/12/19 11:09:29 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 Switch
2025/12/19 11:09:29 Val v string
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 Case
2025/12/19 11:09:29 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val v string
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType string, any
2025/12/19 11:09:29 Fallthrough
2025/12/19 11:09:29 End // Case
2025/12/19 11:09:29 Case
2025/12/19 11:09:29 Val &{0 STRING "hi"} *ast.BasicLit
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val v string
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType string, any
2025/12/19 11:09:29 Fallthrough
2025/12/19 11:09:29 End // Case
2025/12/19 11:09:29 Case
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val v string
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType string, any
2025/12/19 11:09:29 End // Case
2025/12/19 11:09:29 End // Switch
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestSwitchFallthrough (0.00s)
=== RUN   TestBranchStmt
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [a]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:29 SliceLit <nil> 3 false
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 Label label
2025/12/19 11:09:29 For
2025/12/19 11:09:29 DefineVarStart [i]
2025/12/19 11:09:29 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 Val i int
2025/12/19 11:09:29 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp <
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val i int
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType int, any
2025/12/19 11:09:29 Break
2025/12/19 11:09:29 Break label
2025/12/19 11:09:29 Continue
2025/12/19 11:09:29 Continue label
2025/12/19 11:09:29 Goto label
2025/12/19 11:09:29 Post
2025/12/19 11:09:29 VarRef i int
2025/12/19 11:09:29 Val i int
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp +
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 End // For
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestBranchStmt (0.00s)
=== RUN   TestReturn
2025/12/19 11:09:29 ==> Preload func foo
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func foo
2025/12/19 11:09:29 NewFunc foo func(format string, args ...interface{}) (int, error)
2025/12/19 11:09:29 Val printf func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val format string
2025/12/19 11:09:29 Val args []interface{}
2025/12/19 11:09:29 Call 2 1 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 1
2025/12/19 11:09:29 ==> MatchFuncCall func(format string, a ...any) (n int, err error) args: 2 flags: 1
2025/12/19 11:09:29 ==> MatchType string, string
2025/12/19 11:09:29 ==> MatchType []interface{}, []any
2025/12/19 11:09:29 Return 1
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 ==> MatchType error, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestReturn (0.00s)
=== RUN   TestReturnExpr
2025/12/19 11:09:29 ==> Preload func foo
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func foo
2025/12/19 11:09:29 NewFunc foo func(format string, args ...interface{}) (int, error)
2025/12/19 11:09:29 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:29 Val nil untyped nil
2025/12/19 11:09:29 Return 2
2025/12/19 11:09:29 ==> MatchType untyped int (0), int
2025/12/19 11:09:29 ==> MatchType untyped nil, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestReturnExpr (0.00s)
=== RUN   TestClosure
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 NewClosure func(v string)
2025/12/19 11:09:29 Val Println func(a ...any) (n int, err error)
2025/12/19 11:09:29 Val v string
2025/12/19 11:09:29 Call 1 0 // func(a ...any) (n int, err error)
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType string, any
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(v string)
2025/12/19 11:09:29 ==> MatchFuncCall func(v string) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("Hello"), string
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestClosure (0.00s)
=== RUN   TestFunc
2025/12/19 11:09:29 ==> Preload func foo
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func foo
2025/12/19 11:09:29 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:29 NewFunc foo func(format string, a [10]int, args ...interface{})
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestFunc (0.00s)
=== RUN   TestLambdaExpr
2025/12/19 11:09:29 ==> Preload func Map
2025/12/19 11:09:29 ==> Preload func Map2
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func Map
2025/12/19 11:09:29 NewFunc Map func(c []float64, t func(float64) float64)
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func Map2
2025/12/19 11:09:29 NewFunc Map2 func(c []float64, t func(float64) (float64, float64))
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 Val Map func(c []float64, t func(float64) float64)
2025/12/19 11:09:29 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 FLOAT 3.5} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 6} *ast.BasicLit
2025/12/19 11:09:29 SliceLit []float64 3 false
2025/12/19 11:09:29 NewClosure func(x float64) float64
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 BinaryOp *
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:29 Return 1
2025/12/19 11:09:29 ==> MatchType float64, float64
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 2 0 // func(c []float64, t func(float64) float64)
2025/12/19 11:09:29 ==> MatchFuncCall func(c []float64, t func(float64) float64) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType []float64, []float64
2025/12/19 11:09:29 ==> MatchType func(x float64) float64, func(float64) float64
2025/12/19 11:09:29 Val Map2 func(c []float64, t func(float64) (float64, float64))
2025/12/19 11:09:29 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 FLOAT 3.5} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 6} *ast.BasicLit
2025/12/19 11:09:29 SliceLit []float64 3 false
2025/12/19 11:09:29 NewClosure func(x float64) (float64, float64)
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 BinaryOp *
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 BinaryOp +
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:29 Return 2
2025/12/19 11:09:29 ==> MatchType float64, float64
2025/12/19 11:09:29 ==> MatchType float64, float64
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 2 0 // func(c []float64, t func(float64) (float64, float64))
2025/12/19 11:09:29 ==> MatchFuncCall func(c []float64, t func(float64) (float64, float64)) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType []float64, []float64
2025/12/19 11:09:29 ==> MatchType func(x float64) (float64, float64), func(float64) (float64, float64)
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
2025/12/19 11:09:29 ==> Preload type Foo
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load > NewType Foo
2025/12/19 11:09:29 NewType Foo
2025/12/19 11:09:29 ==> Load > InitType Foo
2025/12/19 11:09:29 InitType Foo struct{Plot func(x float64) (float64, float64)}
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [foo]
2025/12/19 11:09:29 ==> LookupParent Foo => type github.com/goplus/xgo/cl.Foo struct{Plot func(x float64) (float64, float64)}
2025/12/19 11:09:29 Val 0 int
2025/12/19 11:09:29 NewClosure func(x float64) (float64, float64)
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp *
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType untyped int (2), unboundFuncParam{typ: float64}
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 BinaryOp *
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:29 Return 2
2025/12/19 11:09:29 ==> MatchType float64, float64
2025/12/19 11:09:29 ==> MatchType float64, float64
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 StructLit github.com/goplus/xgo/cl.Foo 2 true
2025/12/19 11:09:29 UnaryOp & flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
2025/12/19 11:09:29 ==> Preload type Fn
2025/12/19 11:09:29 ==> Preload type Foo
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load > NewType Fn
2025/12/19 11:09:29 NewType Fn
2025/12/19 11:09:29 ==> Load > InitType Fn
2025/12/19 11:09:29 InitType Fn func(x float64) (float64, float64)
2025/12/19 11:09:29 ==> Load > NewType Foo
2025/12/19 11:09:29 NewType Foo
2025/12/19 11:09:29 ==> Load > InitType Foo
2025/12/19 11:09:29 ==> LookupParent Fn => type github.com/goplus/xgo/cl.Fn func(x float64) (float64, float64)
2025/12/19 11:09:29 InitType Foo struct{Plot github.com/goplus/xgo/cl.Fn}
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [foo]
2025/12/19 11:09:29 ==> LookupParent Foo => type github.com/goplus/xgo/cl.Foo struct{Plot github.com/goplus/xgo/cl.Fn}
2025/12/19 11:09:29 Val 0 int
2025/12/19 11:09:29 NewClosure func(x float64) (float64, float64)
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp *
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType untyped int (2), unboundFuncParam{typ: float64}
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 BinaryOp *
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:29 Return 2
2025/12/19 11:09:29 ==> MatchType float64, float64
2025/12/19 11:09:29 ==> MatchType float64, float64
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 StructLit github.com/goplus/xgo/cl.Foo 2 true
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.Fn
2025/12/19 11:09:29 UnaryOp & flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
2025/12/19 11:09:29 ==> Preload type Fn
2025/12/19 11:09:29 ==> Preload func Do
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load > NewType Fn
2025/12/19 11:09:29 NewType Fn
2025/12/19 11:09:29 ==> Load > InitType Fn
2025/12/19 11:09:29 InitType Fn func() (int, error)
2025/12/19 11:09:29 ==> Load func Do
2025/12/19 11:09:29 ==> LookupParent Fn => type github.com/goplus/xgo/cl.Fn func() (int, error)
2025/12/19 11:09:29 NewFunc Do func(fn github.com/goplus/xgo/cl.Fn)
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 Val Do func(fn github.com/goplus/xgo/cl.Fn)
2025/12/19 11:09:29 NewClosure func() (int, error)
2025/12/19 11:09:29 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:29 Val nil untyped nil
2025/12/19 11:09:29 Return 2
2025/12/19 11:09:29 ==> MatchType untyped int (100), int
2025/12/19 11:09:29 ==> MatchType untyped nil, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 1 0 // func(fn github.com/goplus/xgo/cl.Fn)
2025/12/19 11:09:29 ==> MatchFuncCall func(fn github.com/goplus/xgo/cl.Fn) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType func() (int, error), github.com/goplus/xgo/cl.Fn
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.Fn
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
2025/12/19 11:09:29 ==> Preload var [fn]
2025/12/19 11:09:29 ==> Load var func(int) (int, error) [fn]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [fn]
2025/12/19 11:09:29 NewClosure func(x int) (int, error)
2025/12/19 11:09:29 Val x int
2025/12/19 11:09:29 Val x int
2025/12/19 11:09:29 BinaryOp *
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:29 Val nil untyped nil
2025/12/19 11:09:29 Return 2
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 ==> MatchType untyped nil, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType func(x int) (int, error), func(int) (int, error)
2025/12/19 11:09:29 ==> ASTFile
2025/12/19 11:09:29 ==> Preload var [fn]
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load var func(int) (int, error) [fn]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [fn]
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 VarRef fn func(int) (int, error)
2025/12/19 11:09:29 NewClosure func(x int) (int, error)
2025/12/19 11:09:29 Val x int
2025/12/19 11:09:29 Val x int
2025/12/19 11:09:29 BinaryOp *
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:29 Val nil untyped nil
2025/12/19 11:09:29 Return 2
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 ==> MatchType untyped nil, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType func(x int) (int, error), func(int) (int, error)
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestLambdaExpr (0.01s)
=== RUN   TestLambdaExpr2
2025/12/19 11:09:29 ==> Preload func Do
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func Do
2025/12/19 11:09:29 NewFunc Do func(func())
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 Val Do func(func())
2025/12/19 11:09:29 NewClosure func()
2025/12/19 11:09:29 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:29 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("Hi"), any
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 1 0 // func(func())
2025/12/19 11:09:29 ==> MatchFuncCall func(func()) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType func(), func()
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
2025/12/19 11:09:29 ==> Preload func Do
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func Do
2025/12/19 11:09:29 NewFunc Do func(fn func() (int, error))
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 Val Do func(fn func() (int, error))
2025/12/19 11:09:29 NewClosure func() (int, error)
2025/12/19 11:09:29 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:29 Val nil untyped nil
2025/12/19 11:09:29 Return 2
2025/12/19 11:09:29 ==> MatchType untyped int (100), int
2025/12/19 11:09:29 ==> MatchType untyped nil, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 1 0 // func(fn func() (int, error))
2025/12/19 11:09:29 ==> MatchFuncCall func(fn func() (int, error)) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType func() (int, error), func() (int, error)
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
2025/12/19 11:09:29 ==> Preload type Foo
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load > NewType Foo
2025/12/19 11:09:29 NewType Foo
2025/12/19 11:09:29 ==> Load > InitType Foo
2025/12/19 11:09:29 InitType Foo struct{Plot func(x float64) (float64, float64)}
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [foo]
2025/12/19 11:09:29 ==> LookupParent Foo => type github.com/goplus/xgo/cl.Foo struct{Plot func(x float64) (float64, float64)}
2025/12/19 11:09:29 Val 0 int
2025/12/19 11:09:29 NewClosure func(x float64) (float64, float64)
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp *
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType untyped int (2), unboundFuncParam{typ: float64}
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 BinaryOp *
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:29 Return 2
2025/12/19 11:09:29 ==> MatchType float64, float64
2025/12/19 11:09:29 ==> MatchType float64, float64
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 StructLit github.com/goplus/xgo/cl.Foo 2 true
2025/12/19 11:09:29 UnaryOp & flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
2025/12/19 11:09:29 ==> Preload type Fn
2025/12/19 11:09:29 ==> Preload type Foo
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load > NewType Fn
2025/12/19 11:09:29 NewType Fn
2025/12/19 11:09:29 ==> Load > InitType Fn
2025/12/19 11:09:29 InitType Fn func(x float64) (float64, float64)
2025/12/19 11:09:29 ==> Load > NewType Foo
2025/12/19 11:09:29 NewType Foo
2025/12/19 11:09:29 ==> Load > InitType Foo
2025/12/19 11:09:29 ==> LookupParent Fn => type github.com/goplus/xgo/cl.Fn func(x float64) (float64, float64)
2025/12/19 11:09:29 InitType Foo struct{Plot github.com/goplus/xgo/cl.Fn}
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [foo]
2025/12/19 11:09:29 ==> LookupParent Foo => type github.com/goplus/xgo/cl.Foo struct{Plot github.com/goplus/xgo/cl.Fn}
2025/12/19 11:09:29 Val 0 int
2025/12/19 11:09:29 NewClosure func(x float64) (float64, float64)
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp *
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType untyped int (2), unboundFuncParam{typ: float64}
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 Val x float64
2025/12/19 11:09:29 BinaryOp *
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:29 Return 2
2025/12/19 11:09:29 ==> MatchType float64, float64
2025/12/19 11:09:29 ==> MatchType float64, float64
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 StructLit github.com/goplus/xgo/cl.Foo 2 true
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.Fn
2025/12/19 11:09:29 UnaryOp & flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
2025/12/19 11:09:29 ==> Preload type Fn
2025/12/19 11:09:29 ==> Preload func Do
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load > NewType Fn
2025/12/19 11:09:29 NewType Fn
2025/12/19 11:09:29 ==> Load > InitType Fn
2025/12/19 11:09:29 InitType Fn func() (int, error)
2025/12/19 11:09:29 ==> Load func Do
2025/12/19 11:09:29 ==> LookupParent Fn => type github.com/goplus/xgo/cl.Fn func() (int, error)
2025/12/19 11:09:29 NewFunc Do func(fn github.com/goplus/xgo/cl.Fn)
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 Val Do func(fn github.com/goplus/xgo/cl.Fn)
2025/12/19 11:09:29 NewClosure func() (int, error)
2025/12/19 11:09:29 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:29 Val nil untyped nil
2025/12/19 11:09:29 Return 2
2025/12/19 11:09:29 ==> MatchType untyped int (100), int
2025/12/19 11:09:29 ==> MatchType untyped nil, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 1 0 // func(fn github.com/goplus/xgo/cl.Fn)
2025/12/19 11:09:29 ==> MatchFuncCall func(fn github.com/goplus/xgo/cl.Fn) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType func() (int, error), github.com/goplus/xgo/cl.Fn
2025/12/19 11:09:29 ==> EnsureLoaded github.com/goplus/xgo/cl.Fn
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
2025/12/19 11:09:29 ==> Preload var [fn]
2025/12/19 11:09:29 ==> Load var func(int) (int, error) [fn]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [fn]
2025/12/19 11:09:29 NewClosure func(x int) (int, error)
2025/12/19 11:09:29 Val x int
2025/12/19 11:09:29 Val x int
2025/12/19 11:09:29 BinaryOp *
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:29 Val nil untyped nil
2025/12/19 11:09:29 Return 2
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 ==> MatchType untyped nil, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType func(x int) (int, error), func(int) (int, error)
2025/12/19 11:09:29 ==> ASTFile
2025/12/19 11:09:29 ==> Preload var [fn]
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load var func(int) (int, error) [fn]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [fn]
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 VarRef fn func(int) (int, error)
2025/12/19 11:09:29 NewClosure func(x int) (int, error)
2025/12/19 11:09:29 Val x int
2025/12/19 11:09:29 Val x int
2025/12/19 11:09:29 BinaryOp *
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:29 Val nil untyped nil
2025/12/19 11:09:29 Return 2
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 ==> MatchType untyped nil, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType func(x int) (int, error), func(int) (int, error)
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestLambdaExpr2 (0.00s)
=== RUN   TestLambdaExpr3
2025/12/19 11:09:29 ==> Preload func intSeq
2025/12/19 11:09:29 ==> Load func intSeq
2025/12/19 11:09:29 NewFunc intSeq func() func() int
2025/12/19 11:09:29 DefineVarStart [i]
2025/12/19 11:09:29 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 NewClosure func() int
2025/12/19 11:09:29 VarRef i int
2025/12/19 11:09:29 IncDec ++
2025/12/19 11:09:29 Val i int
2025/12/19 11:09:29 Return 1
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Return 1
2025/12/19 11:09:29 ==> MatchType func() int, func() int
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
2025/12/19 11:09:29 ==> Preload func intDouble
2025/12/19 11:09:29 ==> Load func intDouble
2025/12/19 11:09:29 NewFunc intDouble func() func(int) int
2025/12/19 11:09:29 NewClosure func(i int) int
2025/12/19 11:09:29 Val i int
2025/12/19 11:09:29 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp *
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/12/19 11:09:29 Return 1
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Return 1
2025/12/19 11:09:29 ==> MatchType func(i int) int, func(int) int
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestLambdaExpr3 (0.00s)
=== RUN   TestUnnamedMainFunc
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [i]
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestUnnamedMainFunc (0.00s)
=== RUN   TestFuncAsParam
2025/12/19 11:09:29 ==> Preload func bar
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func bar
2025/12/19 11:09:29 NewFunc bar func(foo func(string, ...interface{}) (int, error))
2025/12/19 11:09:29 Val foo func(string, ...interface{}) (int, error)
2025/12/19 11:09:29 Val &{0 STRING "Hello, %v!\n"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "XGo"} *ast.BasicLit
2025/12/19 11:09:29 Call 2 0 // func(string, ...interface{}) (int, error)
2025/12/19 11:09:29 ==> MatchFuncCall func(string, ...interface{}) (int, error) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("Hello, %v!\n"), string
2025/12/19 11:09:29 ==> MatchType untyped string ("XGo"), interface{}
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 Val bar func(foo func(string, ...interface{}) (int, error))
2025/12/19 11:09:29 Val Printf func(format string, a ...any) (n int, err error)
2025/12/19 11:09:29 Call 1 0 // func(foo func(string, ...interface{}) (int, error))
2025/12/19 11:09:29 ==> MatchFuncCall func(foo func(string, ...interface{}) (int, error)) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType func(format string, a ...any) (n int, err error), func(string, ...interface{}) (int, error)
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestFuncAsParam (0.00s)
=== RUN   TestFuncAsParam2
2025/12/19 11:09:29 ==> Preload func foo
2025/12/19 11:09:29 ==> Preload func printf
2025/12/19 11:09:29 ==> Preload func bar
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func foo
2025/12/19 11:09:29 NewFunc foo func(x string) string
2025/12/19 11:09:29 Val NewReplacer func(oldnew ...string) *strings.Replacer
2025/12/19 11:09:29 Val &{0 STRING "?"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "!"} *ast.BasicLit
2025/12/19 11:09:29 Call 2 0 // func(oldnew ...string) *strings.Replacer
2025/12/19 11:09:29 ==> MatchFuncCall func(oldnew ...string) *strings.Replacer args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("?"), string
2025/12/19 11:09:29 ==> MatchType untyped string ("!"), string
2025/12/19 11:09:29 Member Replace 1 // *strings.Replacer
2025/12/19 11:09:29 Val x string
2025/12/19 11:09:29 Call 1 0 // func(s string) string
2025/12/19 11:09:29 ==> MatchFuncCall func(s string) string args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType string, string
2025/12/19 11:09:29 Return 1
2025/12/19 11:09:29 ==> MatchType string, string
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func printf
2025/12/19 11:09:29 NewFunc printf func(format string, args ...interface{}) (n int, err error)
2025/12/19 11:09:29 VarRef n int
2025/12/19 11:09:29 VarRef err error
2025/12/19 11:09:29 Val Printf func(format string, a ...any) (n int, err error)
2025/12/19 11:09:29 Val format string
2025/12/19 11:09:29 Val args []interface{}
2025/12/19 11:09:29 Call 2 3 // func(format string, a ...any) (n int, err error)
2025/12/19 11:09:29 ==> MatchFuncCall func(format string, a ...any) (n int, err error) args: 2 flags: 3
2025/12/19 11:09:29 ==> MatchType string, string
2025/12/19 11:09:29 ==> MatchType []interface{}, []any
2025/12/19 11:09:29 Assign 2 1
2025/12/19 11:09:29 ==> MatchType int, int
2025/12/19 11:09:29 ==> MatchType error, error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func bar
2025/12/19 11:09:29 NewFunc bar func(foo func(string, ...interface{}) (int, error))
2025/12/19 11:09:29 Val foo func(string, ...interface{}) (int, error)
2025/12/19 11:09:29 Val &{0 STRING "Hello, %v!\n"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "XGo"} *ast.BasicLit
2025/12/19 11:09:29 Call 2 0 // func(string, ...interface{}) (int, error)
2025/12/19 11:09:29 ==> MatchFuncCall func(string, ...interface{}) (int, error) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("Hello, %v!\n"), string
2025/12/19 11:09:29 ==> MatchType untyped string ("XGo"), interface{}
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 Val bar func(foo func(string, ...interface{}) (int, error))
2025/12/19 11:09:29 Val printf func(format string, args ...interface{}) (n int, err error)
2025/12/19 11:09:29 Call 1 0 // func(foo func(string, ...interface{}) (int, error))
2025/12/19 11:09:29 ==> MatchFuncCall func(foo func(string, ...interface{}) (int, error)) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType func(format string, args ...interface{}) (n int, err error), func(string, ...interface{}) (int, error)
2025/12/19 11:09:29 Val Println func(a ...any) (n int, err error)
2025/12/19 11:09:29 Val foo func(x string) string
2025/12/19 11:09:29 Val &{0 STRING "Hello, world???"} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(x string) string
2025/12/19 11:09:29 ==> MatchFuncCall func(x string) string args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("Hello, world???"), string
2025/12/19 11:09:29 Call 1 0 // func(a ...any) (n int, err error)
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType string, any
2025/12/19 11:09:29 Val Println func(a ...any) (n int, err error)
2025/12/19 11:09:29 Val printf func(format string, args ...interface{}) (n int, err error)
2025/12/19 11:09:29 Val &{0 STRING "Hello, %v\n"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 STRING "XGo"} *ast.BasicLit
2025/12/19 11:09:29 Call 2 0 // func(format string, args ...interface{}) (n int, err error)
2025/12/19 11:09:29 ==> MatchFuncCall func(format string, args ...interface{}) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("Hello, %v\n"), string
2025/12/19 11:09:29 ==> MatchType untyped string ("XGo"), interface{}
2025/12/19 11:09:29 Call 1 0 // func(a ...any) (n int, err error)
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType int, any
2025/12/19 11:09:29 ==> MatchType error, any
2025/12/19 11:09:29 ==> EnsureLoaded error
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestFuncAsParam2 (0.00s)
=== RUN   TestFuncCall
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 Val Println func(a ...any) (n int, err error)
2025/12/19 11:09:29 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:29 Call 1 0 // func(a ...any) (n int, err error)
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("Hello"), any
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestFuncCall (0.00s)
=== RUN   TestFuncCallEllipsis
2025/12/19 11:09:29 ==> Preload func foo
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func foo
2025/12/19 11:09:29 NewFunc foo func(args ...interface{})
2025/12/19 11:09:29 Val Println func(a ...any) (n int, err error)
2025/12/19 11:09:29 Val args []interface{}
2025/12/19 11:09:29 Call 1 1 // func(a ...any) (n int, err error)
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 1
2025/12/19 11:09:29 ==> MatchType []interface{}, []any
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestFuncCallEllipsis (0.00s)
=== RUN   TestFuncCallCodeOrder
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Preload func foo
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 ==> Load func foo
2025/12/19 11:09:29 NewFunc foo func(args ...interface{})
2025/12/19 11:09:29 Val Println func(a ...any) (n int, err error)
2025/12/19 11:09:29 Val args []interface{}
2025/12/19 11:09:29 Call 1 1 // func(a ...any) (n int, err error)
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 1
2025/12/19 11:09:29 ==> MatchType []interface{}, []any
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Val foo func(args ...interface{})
2025/12/19 11:09:29 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 123} *ast.BasicLit
2025/12/19 11:09:29 Call 2 0 // func(args ...interface{})
2025/12/19 11:09:29 ==> MatchFuncCall func(args ...interface{}) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("Hello"), interface{}
2025/12/19 11:09:29 ==> MatchType untyped int (123), interface{}
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestFuncCallCodeOrder (0.00s)
=== RUN   TestInterfaceMethods
2025/12/19 11:09:29 ==> Preload func foo
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func foo
2025/12/19 11:09:29 NewFunc foo func(v ...interface{Bar()})
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestInterfaceMethods (0.00s)
=== RUN   TestAssignUnderscore
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [_ err]
2025/12/19 11:09:29 Val Println func(a ...any) (n int, err error)
2025/12/19 11:09:29 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:29 Call 1 2 // func(a ...any) (n int, err error)
2025/12/19 11:09:29 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 2
2025/12/19 11:09:29 ==> MatchType untyped string ("Hello"), any
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestAssignUnderscore (0.00s)
=== RUN   TestOperator
2025/12/19 11:09:29 ==> Preload func main
2025/12/19 11:09:29 ==> Load func main
2025/12/19 11:09:29 NewFunc main func()
2025/12/19 11:09:29 DefineVarStart [a]
2025/12/19 11:09:29 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [b]
2025/12/19 11:09:29 Val a string
2025/12/19 11:09:29 Val &{0 STRING "!"} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp +
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType string, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType untyped string ("!"), unboundFuncParam{typ: string}
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [c]
2025/12/19 11:09:29 Val &{0 INT 13} *ast.BasicLit
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 DefineVarStart [d]
2025/12/19 11:09:29 Val c int
2025/12/19 11:09:29 UnaryOp - flags: 0
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
--- PASS: TestOperator (0.00s)
=== RUN   TestImportGopPkg
GenGo ../cl/internal/gop-in-go/foo ...
2025/12/19 11:09:29 ==> Preload func ReverseMap
2025/12/19 11:09:29 ==> Preload func TestReverseMap
2025/12/19 11:09:29 ==> Load func ReverseMap
2025/12/19 11:09:29 NewFunc ReverseMap func(m map[string]int) map[int]string
2025/12/19 11:09:29 SetComments 0
//line cl/internal/gop-in-go/foo/foo.xgo:4:1
2025/12/19 11:09:29 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:29 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 ZeroLit // unboundType{typ: <nil>}
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType unboundType{typ: <nil>}, unboundType{typ: <nil>}
2025/12/19 11:09:29 ForRange [k v]
2025/12/19 11:09:29 Val m map[string]int
2025/12/19 11:09:29 RangeAssignThen
2025/12/19 11:09:29 Val _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:29 Val v int
2025/12/19 11:09:29 IndexRef 1
2025/12/19 11:09:29 Val k string
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29 ==> MatchType string, unboundMapElemType{key: int}
2025/12/19 11:09:29 End // ForRange
2025/12/19 11:09:29 Return 0
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 Call 0 0 // func() (_xgo_ret map[int]string)
2025/12/19 11:09:29 ==> MatchFuncCall func() (_xgo_ret map[int]string) args: 0 flags: 0
2025/12/19 11:09:29 Return 1
2025/12/19 11:09:29 ==> MatchType map[int]string, map[int]string
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> Load func TestReverseMap
2025/12/19 11:09:29 NewFunc TestReverseMap func(t *testing.T)
2025/12/19 11:09:29 SetComments 0
//line cl/internal/gop-in-go/foo/foo_test.xgo:8:1
2025/12/19 11:09:29 DefineVarStart [out]
2025/12/19 11:09:29 Val ReverseMap func(m map[string]int) map[int]string
2025/12/19 11:09:29 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 MapLit map[string]int 2
2025/12/19 11:09:29 Call 1 0 // func(m map[string]int) map[int]string
2025/12/19 11:09:29 ==> MatchFuncCall func(m map[string]int) map[int]string args: 1 flags: 0
2025/12/19 11:09:29 ==> MatchType map[string]int, map[string]int
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 SetComments 0
//line cl/internal/gop-in-go/foo/foo_test.xgo:9:1
2025/12/19 11:09:29 If
2025/12/19 11:09:29 Val len TyInstruction{gogen.lenInstr}
2025/12/19 11:09:29 Val out map[int]string
2025/12/19 11:09:29 Call 1 0 // TyInstruction{gogen.lenInstr}
2025/12/19 11:09:29 ==> MatchFuncCall TyInstruction{gogen.lenInstr} args: 1 flags: 0
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp !=
2025/12/19 11:09:29 Val out map[int]string
2025/12/19 11:09:29 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:29 Index 1 false
2025/12/19 11:09:29 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:29 BinaryOp !=
2025/12/19 11:09:29 BinaryOp ||
2025/12/19 11:09:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped bool, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:29 ==> MatchType untyped bool, unboundFuncParam{typ: untyped bool}
2025/12/19 11:09:29 Then
2025/12/19 11:09:29 SetComments 0
//line cl/internal/gop-in-go/foo/foo_test.xgo:10:1
2025/12/19 11:09:29 Val t *testing.T
2025/12/19 11:09:29 Member Fatal 1 // *testing.T
2025/12/19 11:09:29 Val &{0 STRING "ReverseMap failed:"} *ast.BasicLit
2025/12/19 11:09:29 Val out map[int]string
2025/12/19 11:09:29 Call 2 0 // func(args ...any)
2025/12/19 11:09:29 ==> MatchFuncCall func(args ...any) args: 2 flags: 0
2025/12/19 11:09:29 ==> MatchType untyped string ("ReverseMap failed:"), any
2025/12/19 11:09:29 ==> MatchType map[int]string, any
2025/12/19 11:09:29 SetComments 0
//line cl/internal/gop-in-go/foo/foo_test.xgo:9:1
2025/12/19 11:09:29 End // If
2025/12/19 11:09:29 End // Func
2025/12/19 11:09:29 ==> ASTFile
2025/12/19 11:09:29 WriteFile ../cl/internal/gop-in-go/foo/xgo_autogen.go
2025/12/19 11:09:29 ==> ASTFile _test
2025/12/19 11:09:29 WriteFile ../cl/internal/gop-in-go/foo/xgo_autogen_test.go
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 DefineVarStart [rmap]
2025/12/19 11:09:30 Val ReverseMap func(m map[string]int) map[int]string
2025/12/19 11:09:30 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:30 MapLit map[string]int 4
2025/12/19 11:09:30 Call 1 0 // func(m map[string]int) map[int]string
2025/12/19 11:09:30 ==> MatchFuncCall func(m map[string]int) map[int]string args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType map[string]int, map[string]int
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val rmap map[int]string
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType map[int]string, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestImportGopPkg (0.14s)
=== RUN   TestCallDep
2025/12/19 11:09:30 ==> Preload func TestNew
2025/12/19 11:09:30 ==> Preload type Repo
2025/12/19 11:09:30 ==> Preload func newRepo
2025/12/19 11:09:30 ==> Preload type Result
2025/12/19 11:09:30 ==> Preload func New
2025/12/19 11:09:30 ==> Load func TestNew
2025/12/19 11:09:30 NewFunc TestNew func(t *testing.T)
2025/12/19 11:09:30 DefineVarStart [ret]
2025/12/19 11:09:30 ==> Load func New
2025/12/19 11:09:30 ==> Load > NewType Result
2025/12/19 11:09:30 NewType Result
2025/12/19 11:09:30 ==> Lookup (LoadSymbol) Result => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:30 NewFunc New func() github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 DefineVarStart [repo]
2025/12/19 11:09:30 ==> Load func newRepo
2025/12/19 11:09:30 ==> Load > NewType Repo
2025/12/19 11:09:30 NewType Repo
2025/12/19 11:09:30 ==> Lookup (LoadSymbol) Repo => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:30 NewFunc newRepo func() github.com/goplus/xgo/cl.Repo
2025/12/19 11:09:30 ==> Load > InitType Repo
2025/12/19 11:09:30 InitType Repo struct{Title string}
2025/12/19 11:09:30 Val 0 int
2025/12/19 11:09:30 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:30 StructLit github.com/goplus/xgo/cl.Repo 2 true
2025/12/19 11:09:30 Return 1
2025/12/19 11:09:30 ==> MatchType github.com/goplus/xgo/cl.Repo, github.com/goplus/xgo/cl.Repo
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.Repo
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.Repo
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 Val newRepo func() github.com/goplus/xgo/cl.Repo
2025/12/19 11:09:30 Call 0 0 // func() github.com/goplus/xgo/cl.Repo
2025/12/19 11:09:30 ==> MatchFuncCall func() github.com/goplus/xgo/cl.Repo args: 0 flags: 0
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 ==> Load > InitType Result
2025/12/19 11:09:30 ==> LookupParent Repo => type github.com/goplus/xgo/cl.Repo struct{Title string}
2025/12/19 11:09:30 InitType Result struct{Repo github.com/goplus/xgo/cl.Repo}
2025/12/19 11:09:30 Val 0 int
2025/12/19 11:09:30 Val repo github.com/goplus/xgo/cl.Repo
2025/12/19 11:09:30 StructLit github.com/goplus/xgo/cl.Result 2 true
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.Repo
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.Repo
2025/12/19 11:09:30 Return 1
2025/12/19 11:09:30 ==> MatchType github.com/goplus/xgo/cl.Result, github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 Val New func() github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 Call 0 0 // func() github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 ==> MatchFuncCall func() github.com/goplus/xgo/cl.Result args: 0 flags: 0
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 DefineVarStart [expected]
2025/12/19 11:09:30 ==> LookupParent Result => type github.com/goplus/xgo/cl.Result struct{Repo github.com/goplus/xgo/cl.Repo}
2025/12/19 11:09:30 StructLit github.com/goplus/xgo/cl.Result 0 false
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 If
2025/12/19 11:09:30 Val DeepEqual func(x any, y any) bool
2025/12/19 11:09:30 Val ret github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 Val expected github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 Call 2 0 // func(x any, y any) bool
2025/12/19 11:09:30 ==> MatchFuncCall func(x any, y any) bool args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchType github.com/goplus/xgo/cl.Result, any
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 ==> MatchType github.com/goplus/xgo/cl.Result, any
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 Then
2025/12/19 11:09:30 Val t *testing.T
2025/12/19 11:09:30 Member Fatal 1 // *testing.T
2025/12/19 11:09:30 Val &{0 STRING "Test failed:"} *ast.BasicLit
2025/12/19 11:09:30 Val ret github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 Val expected github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 Call 3 0 // func(args ...any)
2025/12/19 11:09:30 ==> MatchFuncCall func(args ...any) args: 3 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped string ("Test failed:"), any
2025/12/19 11:09:30 ==> MatchType github.com/goplus/xgo/cl.Result, any
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 ==> MatchType github.com/goplus/xgo/cl.Result, any
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 End // If
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
2025/12/19 11:09:30 ==> Preload func TestNew
2025/12/19 11:09:30 ==> Preload type Repo
2025/12/19 11:09:30 ==> Preload func newRepo
2025/12/19 11:09:30 ==> Preload type Result
2025/12/19 11:09:30 ==> Preload func New
2025/12/19 11:09:30 ==> Load func TestNew
2025/12/19 11:09:30 NewFunc TestNew func(t *testing.T)
2025/12/19 11:09:30 DefineVarStart [ret]
2025/12/19 11:09:30 ==> Load func New
2025/12/19 11:09:30 ==> Load > NewType Result
2025/12/19 11:09:30 NewType Result
2025/12/19 11:09:30 ==> Lookup (LoadSymbol) Result => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:30 NewFunc New func() github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 DefineVarStart [repo]
2025/12/19 11:09:30 ==> Load func newRepo
2025/12/19 11:09:30 ==> Load > NewType Repo
2025/12/19 11:09:30 NewType Repo
2025/12/19 11:09:30 ==> Lookup (LoadSymbol) Repo => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:30 NewFunc newRepo func() github.com/goplus/xgo/cl.Repo
2025/12/19 11:09:30 ==> Load > InitType Repo
2025/12/19 11:09:30 InitType Repo struct{Title string}
2025/12/19 11:09:30 Val 0 int
2025/12/19 11:09:30 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:30 StructLit github.com/goplus/xgo/cl.Repo 2 true
2025/12/19 11:09:30 Return 1
2025/12/19 11:09:30 ==> MatchType github.com/goplus/xgo/cl.Repo, github.com/goplus/xgo/cl.Repo
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.Repo
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.Repo
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 Val newRepo func() github.com/goplus/xgo/cl.Repo
2025/12/19 11:09:30 Call 0 0 // func() github.com/goplus/xgo/cl.Repo
2025/12/19 11:09:30 ==> MatchFuncCall func() github.com/goplus/xgo/cl.Repo args: 0 flags: 0
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 ==> Load > InitType Result
2025/12/19 11:09:30 ==> LookupParent Repo => type github.com/goplus/xgo/cl.Repo struct{Title string}
2025/12/19 11:09:30 InitType Result struct{Repo github.com/goplus/xgo/cl.Repo}
2025/12/19 11:09:30 Val 0 int
2025/12/19 11:09:30 Val repo github.com/goplus/xgo/cl.Repo
2025/12/19 11:09:30 StructLit github.com/goplus/xgo/cl.Result 2 true
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.Repo
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.Repo
2025/12/19 11:09:30 Return 1
2025/12/19 11:09:30 ==> MatchType github.com/goplus/xgo/cl.Result, github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 Val New func() github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 Call 0 0 // func() github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 ==> MatchFuncCall func() github.com/goplus/xgo/cl.Result args: 0 flags: 0
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 DefineVarStart [expected]
2025/12/19 11:09:30 ==> LookupParent Result => type github.com/goplus/xgo/cl.Result struct{Repo github.com/goplus/xgo/cl.Repo}
2025/12/19 11:09:30 StructLit github.com/goplus/xgo/cl.Result 0 false
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 If
2025/12/19 11:09:30 Val DeepEqual func(x any, y any) bool
2025/12/19 11:09:30 Val ret github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 Val expected github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 Call 2 0 // func(x any, y any) bool
2025/12/19 11:09:30 ==> MatchFuncCall func(x any, y any) bool args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchType github.com/goplus/xgo/cl.Result, any
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 ==> MatchType github.com/goplus/xgo/cl.Result, any
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 Then
2025/12/19 11:09:30 Val t *testing.T
2025/12/19 11:09:30 Member Fatal 1 // *testing.T
2025/12/19 11:09:30 Val &{0 STRING "Test failed:"} *ast.BasicLit
2025/12/19 11:09:30 Val ret github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 Val expected github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 Call 3 0 // func(args ...any)
2025/12/19 11:09:30 ==> MatchFuncCall func(args ...any) args: 3 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped string ("Test failed:"), any
2025/12/19 11:09:30 ==> MatchType github.com/goplus/xgo/cl.Result, any
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 ==> MatchType github.com/goplus/xgo/cl.Result, any
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.Result
2025/12/19 11:09:30 End // If
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestCallDep (0.00s)
=== RUN   TestGoFuncInstr
2025/12/19 11:09:30 ==> Preload func test
2025/12/19 11:09:30 ==> Load func test
2025/12/19 11:09:30 NewFunc test func(s string, p uintptr, q uintptr, rest ...uintptr) int
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestGoFuncInstr (0.00s)
=== RUN   TestGoTypeInstr
2025/12/19 11:09:30 ==> Preload type S
2025/12/19 11:09:30 ==> Load > NewType S
2025/12/19 11:09:30 NewType S
2025/12/19 11:09:30 ==> Load > InitType S
2025/12/19 11:09:30 InitType S struct{x int}
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestGoTypeInstr (0.00s)
=== RUN   TestNoEntrypoint
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val &{0 STRING "init"} *ast.BasicLit
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped string ("init"), any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
2025/12/19 11:09:30 ==> Preload func init
2025/12/19 11:09:30 ==> Load func init
2025/12/19 11:09:30 NewFunc init func()
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val &{0 STRING "init"} *ast.BasicLit
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped string ("init"), any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestNoEntrypoint (0.00s)
=== RUN   TestParentExpr
2025/12/19 11:09:30 ==> Preload var [t1]
2025/12/19 11:09:30 ==> Preload var [t2]
2025/12/19 11:09:30 ==> Load var *int [t1]
2025/12/19 11:09:30 NewVarDefs
2025/12/19 11:09:30 NewVar [t1]
2025/12/19 11:09:30 ==> Load var chan int [t2]
2025/12/19 11:09:30 NewVarDefs
2025/12/19 11:09:30 NewVar [t2]
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestParentExpr (0.00s)
=== RUN   TestCommandStyle
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 SliceLit <nil> 0 false
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType []interface{}, any
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 MapLit <nil> 0
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType map[string]interface{}, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestCommandStyle (0.00s)
=== RUN   TestTypeLoader
2025/12/19 11:09:30 ==> Preload method Point.String
2025/12/19 11:09:30 ==> Preload type Point
2025/12/19 11:09:30 ==> Load > NewType Point
2025/12/19 11:09:30 NewType Point
2025/12/19 11:09:30 ==> Load > InitType Point
2025/12/19 11:09:30 InitType Point struct{X int; Y int}
2025/12/19 11:09:30 ==> LookupParent Point => type github.com/goplus/xgo/cl.Point struct{X int; Y int}
2025/12/19 11:09:30 ==> Load method *github.com/goplus/xgo/cl.Point.String
2025/12/19 11:09:30 NewFunc String (*github.com/goplus/xgo/cl.Point) func() string
2025/12/19 11:09:30 Val Sprintf func(format string, a ...any) string
2025/12/19 11:09:30 Val &{0 STRING "%v-%v"} *ast.BasicLit
2025/12/19 11:09:30 Val p *github.com/goplus/xgo/cl.Point
2025/12/19 11:09:30 Member X 2 // *github.com/goplus/xgo/cl.Point
2025/12/19 11:09:30 Val p *github.com/goplus/xgo/cl.Point
2025/12/19 11:09:30 Member Y 2 // *github.com/goplus/xgo/cl.Point
2025/12/19 11:09:30 Call 3 0 // func(format string, a ...any) string
2025/12/19 11:09:30 ==> MatchFuncCall func(format string, a ...any) string args: 3 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped string ("%v-%v"), string
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 Return 1
2025/12/19 11:09:30 ==> MatchType string, string
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestTypeLoader (0.00s)
=== RUN   TestCallPrintln
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 Val print func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 0 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 0 flags: 0
2025/12/19 11:09:30 Val print func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped string ("hello"), any
2025/12/19 11:09:30 Val print func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped string ("hello"), any
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 0 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 0 flags: 0
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped string ("hello"), any
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped string ("hello"), any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestCallPrintln (0.00s)
=== RUN   TestAnyAlias
2025/12/19 11:09:30 ==> Preload var [a]
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load var interface{} [a]
2025/12/19 11:09:30 NewVarDefs
2025/12/19 11:09:30 NewVar [a]
2025/12/19 11:09:30 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 ==> MatchType untyped int (100), interface{}
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val a interface{}
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType interface{}, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestAnyAlias (0.00s)
=== RUN   TestMainEntry
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
2025/12/19 11:09:30 ==> Preload func test
2025/12/19 11:09:30 ==> Load func test
2025/12/19 11:09:30 NewFunc test func()
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped string ("hello"), any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped string ("hello"), any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestMainEntry (0.00s)
=== RUN   TestCommandNotExpr
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val true untyped bool
2025/12/19 11:09:30 UnaryOp ! flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped bool (true), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped bool (false), any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 DefineVarStart [a]
2025/12/19 11:09:30 Val true untyped bool
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val a bool
2025/12/19 11:09:30 UnaryOp ! flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType bool, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType bool, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 NewClosure func() bool
2025/12/19 11:09:30 Val true untyped bool
2025/12/19 11:09:30 Return 1
2025/12/19 11:09:30 ==> MatchType untyped bool (true), bool
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 Call 0 0 // func() bool
2025/12/19 11:09:30 ==> MatchFuncCall func() bool args: 0 flags: 0
2025/12/19 11:09:30 UnaryOp ! flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType bool, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType bool, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestCommandNotExpr (0.00s)
=== RUN   TestCommentLine
2025/12/19 11:09:30 ==> Preload type Point
2025/12/19 11:09:30 ==> Preload method Point.Test
2025/12/19 11:09:30 ==> Preload func testPoint
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load > NewType Point
2025/12/19 11:09:30 NewType Point
2025/12/19 11:09:30 ==> Load > InitType Point
2025/12/19 11:09:30 InitType Point struct{x int; y int}
2025/12/19 11:09:30 ==> LookupParent Point => type github.com/goplus/xgo/cl.Point struct{x int; y int}
2025/12/19 11:09:30 ==> Load method *github.com/goplus/xgo/cl.Point.Test
2025/12/19 11:09:30 ==> Load func testPoint
2025/12/19 11:09:30 NewFunc testPoint func()
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:13:1
2025/12/19 11:09:30 ==> LookupParent Point => type github.com/goplus/xgo/cl.Point struct{x int; y int}
2025/12/19 11:09:30 ==> Load var github.com/goplus/xgo/cl.Point [pt]
2025/12/19 11:09:30 NewVarDefs
2025/12/19 11:09:30 NewVar [pt]
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:14:1
2025/12/19 11:09:30 Val pt github.com/goplus/xgo/cl.Point
2025/12/19 11:09:30 Member Test 1 // github.com/goplus/xgo/cl.Point
2025/12/19 11:09:30 Call 0 0 // func()
2025/12/19 11:09:30 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:17:1
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped string ("hello"), any
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:18:1
2025/12/19 11:09:30 Val testPoint func()
2025/12/19 11:09:30 Call 0 0 // func()
2025/12/19 11:09:30 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc Test (*github.com/goplus/xgo/cl.Point) func()
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:8:1
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val pt *github.com/goplus/xgo/cl.Point
2025/12/19 11:09:30 Member x 2 // *github.com/goplus/xgo/cl.Point
2025/12/19 11:09:30 Val pt *github.com/goplus/xgo/cl.Point
2025/12/19 11:09:30 Member y 2 // *github.com/goplus/xgo/cl.Point
2025/12/19 11:09:30 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestCommentLine (0.00s)
=== RUN   TestCommentLineRoot
2025/12/19 11:09:30 ==> Preload type Point
2025/12/19 11:09:30 ==> Preload method Point.Test
2025/12/19 11:09:30 ==> Preload func testPoint
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load > NewType Point
2025/12/19 11:09:30 NewType Point
2025/12/19 11:09:30 ==> Load > InitType Point
2025/12/19 11:09:30 InitType Point struct{x int; y int}
2025/12/19 11:09:30 ==> LookupParent Point => type github.com/goplus/xgo/cl.Point struct{x int; y int}
2025/12/19 11:09:30 ==> Load method *github.com/goplus/xgo/cl.Point.Test
2025/12/19 11:09:30 ==> Load func testPoint
2025/12/19 11:09:30 NewFunc testPoint func()
2025/12/19 11:09:30 SetComments 0
//line ../bar.xgo:13:1
2025/12/19 11:09:30 ==> LookupParent Point => type github.com/goplus/xgo/cl.Point struct{x int; y int}
2025/12/19 11:09:30 ==> Load var github.com/goplus/xgo/cl.Point [pt]
2025/12/19 11:09:30 NewVarDefs
2025/12/19 11:09:30 NewVar [pt]
2025/12/19 11:09:30 SetComments 0
//line ../bar.xgo:14:1
2025/12/19 11:09:30 Val pt github.com/goplus/xgo/cl.Point
2025/12/19 11:09:30 Member Test 1 // github.com/goplus/xgo/cl.Point
2025/12/19 11:09:30 Call 0 0 // func()
2025/12/19 11:09:30 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 SetComments 0
//line ../bar.xgo:17:1
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped string ("hello"), any
2025/12/19 11:09:30 SetComments 0
//line ../bar.xgo:18:1
2025/12/19 11:09:30 Val testPoint func()
2025/12/19 11:09:30 Call 0 0 // func()
2025/12/19 11:09:30 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc Test (*github.com/goplus/xgo/cl.Point) func()
2025/12/19 11:09:30 SetComments 0
//line ../bar.xgo:8:1
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val pt *github.com/goplus/xgo/cl.Point
2025/12/19 11:09:30 Member x 2 // *github.com/goplus/xgo/cl.Point
2025/12/19 11:09:30 Val pt *github.com/goplus/xgo/cl.Point
2025/12/19 11:09:30 Member y 2 // *github.com/goplus/xgo/cl.Point
2025/12/19 11:09:30 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestCommentLineRoot (0.00s)
=== RUN   TestRangeScope
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 DefineVarStart [ar]
2025/12/19 11:09:30 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:30 SliceLit []int 2 false
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 ForRange [k v]
2025/12/19 11:09:30 Val ar []int
2025/12/19 11:09:30 RangeAssignThen
2025/12/19 11:09:30 VBlock
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val k int
2025/12/19 11:09:30 Val v int
2025/12/19 11:09:30 Val ar []int
2025/12/19 11:09:30 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 3 flags: 0
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 ==> MatchType []int, any
2025/12/19 11:09:30 ==> Load var int [k v ar]
2025/12/19 11:09:30 NewVarDefs
2025/12/19 11:09:30 NewVar [k v ar]
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val ar int
2025/12/19 11:09:30 Val k int
2025/12/19 11:09:30 Val v int
2025/12/19 11:09:30 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 3 flags: 0
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 End // Vblock
2025/12/19 11:09:30 End // ForRange
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestRangeScope (0.00s)
=== RUN   TestSelectScope
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 DefineVarStart [c1]
2025/12/19 11:09:30 Val make TyInstruction{gogen.makeInstr}
2025/12/19 11:09:30 Typ chan int
2025/12/19 11:09:30 Call 1 0 // TyInstruction{gogen.makeInstr}
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.makeInstr} args: 1 flags: 0
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 DefineVarStart [c2]
2025/12/19 11:09:30 Val make TyInstruction{gogen.makeInstr}
2025/12/19 11:09:30 Typ chan int
2025/12/19 11:09:30 Call 1 0 // TyInstruction{gogen.makeInstr}
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.makeInstr} args: 1 flags: 0
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 NewClosure func()
2025/12/19 11:09:30 Val c1 chan int
2025/12/19 11:09:30 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:30 Send
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 Call 0 0 // func()
2025/12/19 11:09:30 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:30 Go
2025/12/19 11:09:30 Select
2025/12/19 11:09:30 CommCase
2025/12/19 11:09:30 DefineVarStart [i]
2025/12/19 11:09:30 Val c1 chan int
2025/12/19 11:09:30 UnaryOp <- flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 0
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 Then
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val i int
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 End // CommCase
2025/12/19 11:09:30 CommCase
2025/12/19 11:09:30 DefineVarStart [i]
2025/12/19 11:09:30 Val c2 chan int
2025/12/19 11:09:30 UnaryOp <- flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 0
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 Then
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val i int
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 End // CommCase
2025/12/19 11:09:30 End // Select
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestSelectScope (0.00s)
=== RUN   TestCommentVar
2025/12/19 11:09:30 ==> Preload var [a]
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load var int [a]
2025/12/19 11:09:30 NewVarDefs
2025/12/19 11:09:30 NewVar [a]
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:4:1
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val a int
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:6:1
2025/12/19 11:09:30 ==> Load var int [b]
2025/12/19 11:09:30 NewVarDefs
2025/12/19 11:09:30 NewVar [b]
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:8:1
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val b int
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:10:1
2025/12/19 11:09:30 ==> Load var int [c]
2025/12/19 11:09:30 NewVarDefs
2025/12/19 11:09:30 NewVar [c]
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:11:1
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val c int
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
2025/12/19 11:09:30 ==> Preload func demo
2025/12/19 11:09:30 ==> Load func demo
2025/12/19 11:09:30 NewFunc demo func()
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:3:1
2025/12/19 11:09:30 ==> Load var int [a]
2025/12/19 11:09:30 NewVarDefs
2025/12/19 11:09:30 NewVar [a]
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:5:1
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val a int
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:7:1
2025/12/19 11:09:30 ==> Load var int [b]
2025/12/19 11:09:30 NewVarDefs
2025/12/19 11:09:30 NewVar [b]
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:9:1
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val b int
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:11:1
2025/12/19 11:09:30 ==> Load var int [c]
2025/12/19 11:09:30 NewVarDefs
2025/12/19 11:09:30 NewVar [c]
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:12:1
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val c int
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestCommentVar (0.00s)
=== RUN   TestForPhraseScope
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 DefineVarStart [sum]
2025/12/19 11:09:30 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 ForRange [_ x]
2025/12/19 11:09:30 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 11} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 13} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 17} *ast.BasicLit
2025/12/19 11:09:30 SliceLit <nil> 7 false
2025/12/19 11:09:30 RangeAssignThen
2025/12/19 11:09:30 VBlock
2025/12/19 11:09:30 VarRef sum int
2025/12/19 11:09:30 Val sum int
2025/12/19 11:09:30 Val x int
2025/12/19 11:09:30 BinaryOp +
2025/12/19 11:09:30 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:30 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 ==> MatchType int, int
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val x int
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 DefineVarStart [x]
2025/12/19 11:09:30 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val x int
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 End // Vblock
2025/12/19 11:09:30 End // ForRange
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 DefineVarStart [sum]
2025/12/19 11:09:30 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 ForRange [_ x]
2025/12/19 11:09:30 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 11} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 13} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 17} *ast.BasicLit
2025/12/19 11:09:30 SliceLit <nil> 7 false
2025/12/19 11:09:30 RangeAssignThen
2025/12/19 11:09:30 If
2025/12/19 11:09:30 Val x int
2025/12/19 11:09:30 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:30 BinaryOp >
2025/12/19 11:09:30 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:30 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/12/19 11:09:30 Then
2025/12/19 11:09:30 VarRef sum int
2025/12/19 11:09:30 Val sum int
2025/12/19 11:09:30 Val x int
2025/12/19 11:09:30 BinaryOp +
2025/12/19 11:09:30 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:30 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 ==> MatchType int, int
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val x int
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 DefineVarStart [x]
2025/12/19 11:09:30 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val x int
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 End // If
2025/12/19 11:09:30 End // ForRange
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestForPhraseScope (0.00s)
=== RUN   TestAddress
2025/12/19 11:09:30 ==> Preload type foo
2025/12/19 11:09:30 ==> Preload method foo.ptr
2025/12/19 11:09:30 ==> Preload method foo.clone
2025/12/19 11:09:30 ==> Preload type nested
2025/12/19 11:09:30 ==> Preload func _
2025/12/19 11:09:30 ==> Load > NewType foo
2025/12/19 11:09:30 NewType foo
2025/12/19 11:09:30 ==> Load > InitType foo
2025/12/19 11:09:30 InitType foo struct{c int}
2025/12/19 11:09:30 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{c int}
2025/12/19 11:09:30 ==> Load method github.com/goplus/xgo/cl.foo.ptr
2025/12/19 11:09:30 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{c int}
2025/12/19 11:09:30 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{c int}
2025/12/19 11:09:30 ==> Load method github.com/goplus/xgo/cl.foo.clone
2025/12/19 11:09:30 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{c int}
2025/12/19 11:09:30 ==> Load > NewType nested
2025/12/19 11:09:30 NewType nested
2025/12/19 11:09:30 ==> Load > InitType nested
2025/12/19 11:09:30 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{c int}
2025/12/19 11:09:30 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{c int}
2025/12/19 11:09:30 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:30 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{c int}
2025/12/19 11:09:30 InitType nested struct{f github.com/goplus/xgo/cl.foo; a [2]github.com/goplus/xgo/cl.foo; s []github.com/goplus/xgo/cl.foo}
2025/12/19 11:09:30 ==> Load func _
2025/12/19 11:09:30 NewFunc _ func()
2025/12/19 11:09:30 DefineVarStart [getNested]
2025/12/19 11:09:30 ==> LookupParent nested => type github.com/goplus/xgo/cl.nested struct{f github.com/goplus/xgo/cl.foo; a [2]github.com/goplus/xgo/cl.foo; s []github.com/goplus/xgo/cl.foo}
2025/12/19 11:09:30 NewClosure func() github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 ==> LookupParent nested => type github.com/goplus/xgo/cl.nested struct{f github.com/goplus/xgo/cl.foo; a [2]github.com/goplus/xgo/cl.foo; s []github.com/goplus/xgo/cl.foo}
2025/12/19 11:09:30 StructLit github.com/goplus/xgo/cl.nested 0 false
2025/12/19 11:09:30 Return 1
2025/12/19 11:09:30 ==> MatchType github.com/goplus/xgo/cl.nested, github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 VarRef _
2025/12/19 11:09:30 Val getNested func() github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 Call 0 0 // func() github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 ==> MatchFuncCall func() github.com/goplus/xgo/cl.nested args: 0 flags: 0
2025/12/19 11:09:30 Member f 2 // github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 Member c 2 // github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 VarRef _
2025/12/19 11:09:30 Val getNested func() github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 Call 0 0 // func() github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 ==> MatchFuncCall func() github.com/goplus/xgo/cl.nested args: 0 flags: 0
2025/12/19 11:09:30 Member a 2 // github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:30 Index 1 false
2025/12/19 11:09:30 Member c 2 // github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 VarRef _
2025/12/19 11:09:30 Val getNested func() github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 Call 0 0 // func() github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 ==> MatchFuncCall func() github.com/goplus/xgo/cl.nested args: 0 flags: 0
2025/12/19 11:09:30 Member s 2 // github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:30 Index 1 false
2025/12/19 11:09:30 Member c 2 // github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 VarRef _
2025/12/19 11:09:30 Val getNested func() github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 Call 0 0 // func() github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 ==> MatchFuncCall func() github.com/goplus/xgo/cl.nested args: 0 flags: 0
2025/12/19 11:09:30 Member f 2 // github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 Member ptr 1 // github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 Call 0 0 // func() *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 ==> MatchFuncCall func() *github.com/goplus/xgo/cl.foo args: 0 flags: 0
2025/12/19 11:09:30 Member c 2 // *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 VarRef _
2025/12/19 11:09:30 Val getNested func() github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 Call 0 0 // func() github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 ==> MatchFuncCall func() github.com/goplus/xgo/cl.nested args: 0 flags: 0
2025/12/19 11:09:30 Member f 2 // github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 Member clone 1 // github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 Call 0 0 // func() github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 ==> MatchFuncCall func() github.com/goplus/xgo/cl.foo args: 0 flags: 0
2025/12/19 11:09:30 Member c 2 // github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 VarRef _
2025/12/19 11:09:30 Val getNested func() github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 Call 0 0 // func() github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 ==> MatchFuncCall func() github.com/goplus/xgo/cl.nested args: 0 flags: 0
2025/12/19 11:09:30 Member f 2 // github.com/goplus/xgo/cl.nested
2025/12/19 11:09:30 Member clone 1 // github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 Call 0 0 // func() github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 ==> MatchFuncCall func() github.com/goplus/xgo/cl.foo args: 0 flags: 0
2025/12/19 11:09:30 Member ptr 1 // github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 Call 0 0 // func() *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 ==> MatchFuncCall func() *github.com/goplus/xgo/cl.foo args: 0 flags: 0
2025/12/19 11:09:30 Member c 2 // *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc ptr (github.com/goplus/xgo/cl.foo) func() *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 Val f github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 UnaryOp & flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:30 Return 1
2025/12/19 11:09:30 ==> MatchType *github.com/goplus/xgo/cl.foo, *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc clone (github.com/goplus/xgo/cl.foo) func() github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 Val f github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 Return 1
2025/12/19 11:09:30 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestAddress (0.00s)
=== RUN   TestSliceLitAssign
2025/12/19 11:09:30 ==> Preload var [n]
2025/12/19 11:09:30 ==> Preload var [a]
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load var <nil> [n]
2025/12/19 11:09:30 NewVarDefs
2025/12/19 11:09:30 NewVar [n]
2025/12/19 11:09:30 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 ==> Load var []interface{} [a]
2025/12/19 11:09:30 NewVarDefs
2025/12/19 11:09:30 NewVar [a]
2025/12/19 11:09:30 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:30 SliceLit []interface{} 3 false
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 ==> MatchType []interface{}, []interface{}
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 VarRef n int
2025/12/19 11:09:30 VarRef a []interface{}
2025/12/19 11:09:30 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:30 SliceLit []interface{} 3 false
2025/12/19 11:09:30 Assign 2 2
2025/12/19 11:09:30 ==> MatchType untyped int (100), int
2025/12/19 11:09:30 ==> MatchType []interface{}, []interface{}
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val a []interface{}
2025/12/19 11:09:30 Val n int
2025/12/19 11:09:30 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchType []interface{}, any
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestSliceLitAssign (0.00s)
=== RUN   TestSliceLitReturn
2025/12/19 11:09:30 ==> Preload func anyslice
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load func anyslice
2025/12/19 11:09:30 NewFunc anyslice func() (int, []interface{})
2025/12/19 11:09:30 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:30 SliceLit []interface{} 3 false
2025/12/19 11:09:30 Return 2
2025/12/19 11:09:30 ==> MatchType untyped int (100), int
2025/12/19 11:09:30 ==> MatchType []interface{}, []interface{}
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 DefineVarStart [n a]
2025/12/19 11:09:30 Val anyslice func() (int, []interface{})
2025/12/19 11:09:30 Call 0 2 // func() (int, []interface{})
2025/12/19 11:09:30 ==> MatchFuncCall func() (int, []interface{}) args: 0 flags: 2
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val n int
2025/12/19 11:09:30 Val a []interface{}
2025/12/19 11:09:30 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 ==> MatchType []interface{}, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestSliceLitReturn (0.00s)
=== RUN   TestCompositeLitAssign
2025/12/19 11:09:30 ==> Preload var [a]
2025/12/19 11:09:30 ==> Preload var [b]
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load var map[interface{}]interface{} [a]
2025/12/19 11:09:30 NewVarDefs
2025/12/19 11:09:30 NewVar [a]
2025/12/19 11:09:30 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "A"} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "B"} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "C"} *ast.BasicLit
2025/12/19 11:09:30 MapLit map[interface{}]interface{} 6
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 ==> MatchType map[interface{}]interface{}, map[interface{}]interface{}
2025/12/19 11:09:30 ==> Load var map[interface{}]string [b]
2025/12/19 11:09:30 NewVarDefs
2025/12/19 11:09:30 NewVar [b]
2025/12/19 11:09:30 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "A"} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "B"} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "C"} *ast.BasicLit
2025/12/19 11:09:30 MapLit map[interface{}]string 6
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 ==> MatchType map[interface{}]string, map[interface{}]string
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val a map[interface{}]interface{}
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType map[interface{}]interface{}, any
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val b map[interface{}]string
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType map[interface{}]string, any
2025/12/19 11:09:30 ==> Load var int [n]
2025/12/19 11:09:30 NewVarDefs
2025/12/19 11:09:30 NewVar [n]
2025/12/19 11:09:30 VarRef n int
2025/12/19 11:09:30 VarRef a map[interface{}]interface{}
2025/12/19 11:09:30 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "A"} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "B"} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "C"} *ast.BasicLit
2025/12/19 11:09:30 MapLit map[interface{}]interface{} 6
2025/12/19 11:09:30 Assign 2 2
2025/12/19 11:09:30 ==> MatchType untyped int (1), int
2025/12/19 11:09:30 ==> MatchType map[interface{}]interface{}, map[interface{}]interface{}
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val a map[interface{}]interface{}
2025/12/19 11:09:30 Val n int
2025/12/19 11:09:30 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchType map[interface{}]interface{}, any
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 VarRef n int
2025/12/19 11:09:30 VarRef b map[interface{}]string
2025/12/19 11:09:30 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "A"} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "B"} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "C"} *ast.BasicLit
2025/12/19 11:09:30 MapLit map[interface{}]string 6
2025/12/19 11:09:30 Assign 2 2
2025/12/19 11:09:30 ==> MatchType untyped int (1), int
2025/12/19 11:09:30 ==> MatchType map[interface{}]string, map[interface{}]string
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val b map[interface{}]string
2025/12/19 11:09:30 Val n int
2025/12/19 11:09:30 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchType map[interface{}]string, any
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestCompositeLitAssign (0.00s)
=== RUN   TestCompositeLitStruct
2025/12/19 11:09:30 ==> Preload type T
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load > NewType T
2025/12/19 11:09:30 NewType T
2025/12/19 11:09:30 ==> Load > InitType T
2025/12/19 11:09:30 InitType T struct{s []interface{}; m map[interface{}]interface{}; fn func(int) int}
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{s []interface{}; m map[interface{}]interface{}; fn func(int) int}
2025/12/19 11:09:30 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:30 SliceLit []interface{} 3 false
2025/12/19 11:09:30 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "A"} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "B"} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "C"} *ast.BasicLit
2025/12/19 11:09:30 MapLit map[interface{}]interface{} 6
2025/12/19 11:09:30 NewClosure func(x int) int
2025/12/19 11:09:30 Val x int
2025/12/19 11:09:30 Return 1
2025/12/19 11:09:30 ==> MatchType int, int
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 StructLit github.com/goplus/xgo/cl.T 3 false
2025/12/19 11:09:30 UnaryOp & flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType *github.com/goplus/xgo/cl.T, any
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.T
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{s []interface{}; m map[interface{}]interface{}; fn func(int) int}
2025/12/19 11:09:30 Val 0 int
2025/12/19 11:09:30 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:30 SliceLit []interface{} 3 false
2025/12/19 11:09:30 Val 1 int
2025/12/19 11:09:30 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "A"} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "B"} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "C"} *ast.BasicLit
2025/12/19 11:09:30 MapLit map[interface{}]interface{} 6
2025/12/19 11:09:30 Val 2 int
2025/12/19 11:09:30 NewClosure func(x int) int
2025/12/19 11:09:30 Val x int
2025/12/19 11:09:30 Return 1
2025/12/19 11:09:30 ==> MatchType int, int
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 StructLit github.com/goplus/xgo/cl.T 6 true
2025/12/19 11:09:30 UnaryOp & flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType *github.com/goplus/xgo/cl.T, any
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.T
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestCompositeLitStruct (0.00s)
=== RUN   TestCompositeLitEx
2025/12/19 11:09:30 ==> Preload var [a]
2025/12/19 11:09:30 ==> Preload var [m]
2025/12/19 11:09:30 ==> Preload var [f]
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load var [][]interface{} [a]
2025/12/19 11:09:30 NewVarDefs
2025/12/19 11:09:30 NewVar [a]
2025/12/19 11:09:30 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:30 SliceLit []interface{} 3 false
2025/12/19 11:09:30 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:30 SliceLit []interface{} 2 false
2025/12/19 11:09:30 SliceLit [][]interface{} 2 false
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 ==> MatchType [][]interface{}, [][]interface{}
2025/12/19 11:09:30 ==> Load var map[interface{}][]interface{} [m]
2025/12/19 11:09:30 NewVarDefs
2025/12/19 11:09:30 NewVar [m]
2025/12/19 11:09:30 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:30 SliceLit []interface{} 3 false
2025/12/19 11:09:30 MapLit map[interface{}][]interface{} 2
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 ==> MatchType map[interface{}][]interface{}, map[interface{}][]interface{}
2025/12/19 11:09:30 ==> Load var map[interface{}]func(int) int [f]
2025/12/19 11:09:30 NewVarDefs
2025/12/19 11:09:30 NewVar [f]
2025/12/19 11:09:30 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:30 NewClosure func(x int) int
2025/12/19 11:09:30 Val x int
2025/12/19 11:09:30 Return 1
2025/12/19 11:09:30 ==> MatchType int, int
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 MapLit map[interface{}]func(int) int 2
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 ==> MatchType map[interface{}]func(int) int, map[interface{}]func(int) int
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val a [][]interface{}
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType [][]interface{}, any
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val m map[interface{}][]interface{}
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType map[interface{}][]interface{}, any
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val f map[interface{}]func(int) int
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType map[interface{}]func(int) int, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestCompositeLitEx (0.00s)
=== RUN   TestErrWrapNoArgs
2025/12/19 11:09:30 ==> Preload func foo
2025/12/19 11:09:30 ==> Preload func Bar
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load func foo
2025/12/19 11:09:30 NewFunc foo func(v ...int) (func(), error)
2025/12/19 11:09:30 Val nil untyped nil
2025/12/19 11:09:30 Val nil untyped nil
2025/12/19 11:09:30 Return 2
2025/12/19 11:09:30 ==> MatchType untyped nil, func()
2025/12/19 11:09:30 ==> MatchType untyped nil, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> Load func Bar
2025/12/19 11:09:30 NewFunc Bar func() (int, error)
2025/12/19 11:09:30 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:30 Val nil untyped nil
2025/12/19 11:09:30 Return 2
2025/12/19 11:09:30 ==> MatchType untyped int (100), int
2025/12/19 11:09:30 ==> MatchType untyped nil, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 Val foo func(v ...int) (func(), error)
2025/12/19 11:09:30 Call 0 0 // func(v ...int) (func(), error)
2025/12/19 11:09:30 ==> MatchFuncCall func(v ...int) (func(), error) args: 0 flags: 0
2025/12/19 11:09:30 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:30 NewVar [_xgo_err]
2025/12/19 11:09:30 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:30 VarRef _xgo_err error
2025/12/19 11:09:30 Assign 2 1
2025/12/19 11:09:30 ==> MatchType func(), unboundType{typ: <nil>}
2025/12/19 11:09:30 ==> MatchType error, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 If
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 Val <nil> <nil>
2025/12/19 11:09:30 BinaryOp !=
2025/12/19 11:09:30 Typ error
2025/12/19 11:09:30 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:30 Then
2025/12/19 11:09:30 VarRef _xgo_err error
2025/12/19 11:09:30 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 Val foo string
2025/12/19 11:09:30 Val /foo/bar.xgo string
2025/12/19 11:09:30 Val 8 int
2025/12/19 11:09:30 Val main.main string
2025/12/19 11:09:30 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:30 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/12/19 11:09:30 ==> MatchType error, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> MatchType untyped string ("foo"), string
2025/12/19 11:09:30 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/12/19 11:09:30 ==> MatchType untyped int (8), int
2025/12/19 11:09:30 ==> MatchType untyped string ("main.main"), string
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 Val panic func(v interface{})
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 Call 1 0 // func(v interface{})
2025/12/19 11:09:30 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType error, interface{}
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 End // If
2025/12/19 11:09:30 Return 0
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 Call 0 0 // func() (_xgo_ret func())
2025/12/19 11:09:30 ==> MatchFuncCall func() (_xgo_ret func()) args: 0 flags: 0
2025/12/19 11:09:30 Call 0 0 // func()
2025/12/19 11:09:30 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:30 Val foo func(v ...int) (func(), error)
2025/12/19 11:09:30 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:30 Call 1 0 // func(v ...int) (func(), error)
2025/12/19 11:09:30 ==> MatchFuncCall func(v ...int) (func(), error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped int (1), int
2025/12/19 11:09:30 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:30 NewVar [_xgo_err]
2025/12/19 11:09:30 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:30 VarRef _xgo_err error
2025/12/19 11:09:30 Assign 2 1
2025/12/19 11:09:30 ==> MatchType func(), unboundType{typ: <nil>}
2025/12/19 11:09:30 ==> MatchType error, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 If
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 Val <nil> <nil>
2025/12/19 11:09:30 BinaryOp !=
2025/12/19 11:09:30 Typ error
2025/12/19 11:09:30 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:30 Then
2025/12/19 11:09:30 VarRef _xgo_err error
2025/12/19 11:09:30 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 Val foo(1) string
2025/12/19 11:09:30 Val /foo/bar.xgo string
2025/12/19 11:09:30 Val 9 int
2025/12/19 11:09:30 Val main.main string
2025/12/19 11:09:30 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:30 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/12/19 11:09:30 ==> MatchType error, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> MatchType untyped string ("foo(1)"), string
2025/12/19 11:09:30 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/12/19 11:09:30 ==> MatchType untyped int (9), int
2025/12/19 11:09:30 ==> MatchType untyped string ("main.main"), string
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 Val panic func(v interface{})
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 Call 1 0 // func(v interface{})
2025/12/19 11:09:30 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType error, interface{}
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 End // If
2025/12/19 11:09:30 Return 0
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 Call 0 0 // func() (_xgo_ret func())
2025/12/19 11:09:30 ==> MatchFuncCall func() (_xgo_ret func()) args: 0 flags: 0
2025/12/19 11:09:30 Call 0 0 // func()
2025/12/19 11:09:30 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val foo func(v ...int) (func(), error)
2025/12/19 11:09:30 Call 0 0 // func(v ...int) (func(), error)
2025/12/19 11:09:30 ==> MatchFuncCall func(v ...int) (func(), error) args: 0 flags: 0
2025/12/19 11:09:30 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:30 NewVar [_xgo_err]
2025/12/19 11:09:30 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:30 VarRef _xgo_err error
2025/12/19 11:09:30 Assign 2 1
2025/12/19 11:09:30 ==> MatchType func(), unboundType{typ: <nil>}
2025/12/19 11:09:30 ==> MatchType error, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 If
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 Val <nil> <nil>
2025/12/19 11:09:30 BinaryOp !=
2025/12/19 11:09:30 Typ error
2025/12/19 11:09:30 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:30 Then
2025/12/19 11:09:30 VarRef _xgo_err error
2025/12/19 11:09:30 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 Val foo string
2025/12/19 11:09:30 Val /foo/bar.xgo string
2025/12/19 11:09:30 Val 10 int
2025/12/19 11:09:30 Val main.main string
2025/12/19 11:09:30 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:30 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/12/19 11:09:30 ==> MatchType error, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> MatchType untyped string ("foo"), string
2025/12/19 11:09:30 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/12/19 11:09:30 ==> MatchType untyped int (10), int
2025/12/19 11:09:30 ==> MatchType untyped string ("main.main"), string
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 Val panic func(v interface{})
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 Call 1 0 // func(v interface{})
2025/12/19 11:09:30 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType error, interface{}
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 End // If
2025/12/19 11:09:30 Return 0
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 Call 0 0 // func() (_xgo_ret func())
2025/12/19 11:09:30 ==> MatchFuncCall func() (_xgo_ret func()) args: 0 flags: 0
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType func(), any
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val Bar func() (int, error)
2025/12/19 11:09:30 Call 0 0 // func() (int, error)
2025/12/19 11:09:30 ==> MatchFuncCall func() (int, error) args: 0 flags: 0
2025/12/19 11:09:30 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:30 NewVar [_xgo_err]
2025/12/19 11:09:30 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:30 VarRef _xgo_err error
2025/12/19 11:09:30 Assign 2 1
2025/12/19 11:09:30 ==> MatchType int, unboundType{typ: <nil>}
2025/12/19 11:09:30 ==> MatchType error, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 If
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 Val <nil> <nil>
2025/12/19 11:09:30 BinaryOp !=
2025/12/19 11:09:30 Typ error
2025/12/19 11:09:30 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:30 Then
2025/12/19 11:09:30 VarRef _xgo_err error
2025/12/19 11:09:30 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 Val bar string
2025/12/19 11:09:30 Val /foo/bar.xgo string
2025/12/19 11:09:30 Val 11 int
2025/12/19 11:09:30 Val main.main string
2025/12/19 11:09:30 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:30 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/12/19 11:09:30 ==> MatchType error, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> MatchType untyped string ("bar"), string
2025/12/19 11:09:30 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/12/19 11:09:30 ==> MatchType untyped int (11), int
2025/12/19 11:09:30 ==> MatchType untyped string ("main.main"), string
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 Val panic func(v interface{})
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 Call 1 0 // func(v interface{})
2025/12/19 11:09:30 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType error, interface{}
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 End // If
2025/12/19 11:09:30 Return 0
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 Call 0 0 // func() (_xgo_ret int)
2025/12/19 11:09:30 ==> MatchFuncCall func() (_xgo_ret int) args: 0 flags: 0
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestErrWrapNoArgs (0.00s)
=== RUN   TestCommentFunc
2025/12/19 11:09:30 ==> Preload func add
2025/12/19 11:09:30 ==> Preload func addSafe
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load func add
2025/12/19 11:09:30 NewFunc add func(x string, y string) (int, error)
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:7:1
2025/12/19 11:09:30 Val Atoi func(s string) (int, error)
2025/12/19 11:09:30 Val x string
2025/12/19 11:09:30 Call 1 0 // func(s string) (int, error)
2025/12/19 11:09:30 ==> MatchFuncCall func(s string) (int, error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType string, string
2025/12/19 11:09:30 CallInlineClosureStart 0 false
2025/12/19 11:09:30 NewVar [_autoGo_1]
2025/12/19 11:09:30 NewVar [_xgo_err]
2025/12/19 11:09:30 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:30 VarRef _xgo_err error
2025/12/19 11:09:30 Assign 2 1
2025/12/19 11:09:30 ==> MatchType int, unboundType{typ: <nil>}
2025/12/19 11:09:30 ==> MatchType error, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 If
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 Val <nil> <nil>
2025/12/19 11:09:30 BinaryOp !=
2025/12/19 11:09:30 Typ error
2025/12/19 11:09:30 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:30 Then
2025/12/19 11:09:30 VarRef _xgo_err error
2025/12/19 11:09:30 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 Val strconv.atoi(x) string
2025/12/19 11:09:30 Val /foo/bar.xgo string
2025/12/19 11:09:30 Val 7 int
2025/12/19 11:09:30 Val main.add string
2025/12/19 11:09:30 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:30 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/12/19 11:09:30 ==> MatchType error, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> MatchType untyped string ("strconv.atoi(x)"), string
2025/12/19 11:09:30 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/12/19 11:09:30 ==> MatchType untyped int (7), int
2025/12/19 11:09:30 ==> MatchType untyped string ("main.add"), string
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 ReturnErr true
2025/12/19 11:09:30 End // If
2025/12/19 11:09:30 Return 0
2025/12/19 11:09:30 Goto _autoGo_2
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 Label _autoGo_2
2025/12/19 11:09:30 Val Atoi func(s string) (int, error)
2025/12/19 11:09:30 Val y string
2025/12/19 11:09:30 Call 1 0 // func(s string) (int, error)
2025/12/19 11:09:30 ==> MatchFuncCall func(s string) (int, error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType string, string
2025/12/19 11:09:30 CallInlineClosureStart 0 false
2025/12/19 11:09:30 NewVar [_autoGo_3]
2025/12/19 11:09:30 NewVar [_xgo_err]
2025/12/19 11:09:30 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:30 VarRef _xgo_err error
2025/12/19 11:09:30 Assign 2 1
2025/12/19 11:09:30 ==> MatchType int, unboundType{typ: <nil>}
2025/12/19 11:09:30 ==> MatchType error, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 If
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 Val <nil> <nil>
2025/12/19 11:09:30 BinaryOp !=
2025/12/19 11:09:30 Typ error
2025/12/19 11:09:30 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:30 Then
2025/12/19 11:09:30 VarRef _xgo_err error
2025/12/19 11:09:30 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 Val strconv.atoi(y) string
2025/12/19 11:09:30 Val /foo/bar.xgo string
2025/12/19 11:09:30 Val 7 int
2025/12/19 11:09:30 Val main.add string
2025/12/19 11:09:30 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:30 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/12/19 11:09:30 ==> MatchType error, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> MatchType untyped string ("strconv.atoi(y)"), string
2025/12/19 11:09:30 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/12/19 11:09:30 ==> MatchType untyped int (7), int
2025/12/19 11:09:30 ==> MatchType untyped string ("main.add"), string
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 ReturnErr true
2025/12/19 11:09:30 End // If
2025/12/19 11:09:30 Return 0
2025/12/19 11:09:30 Goto _autoGo_4
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 Label _autoGo_4
2025/12/19 11:09:30 BinaryOp +
2025/12/19 11:09:30 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:30 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:30 Val nil untyped nil
2025/12/19 11:09:30 Return 2
2025/12/19 11:09:30 ==> MatchType int, int
2025/12/19 11:09:30 ==> MatchType untyped nil, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> Load func addSafe
2025/12/19 11:09:30 NewFunc addSafe func(x string, y string) int
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:11:1
2025/12/19 11:09:30 Val Atoi func(s string) (int, error)
2025/12/19 11:09:30 Val x string
2025/12/19 11:09:30 Call 1 0 // func(s string) (int, error)
2025/12/19 11:09:30 ==> MatchFuncCall func(s string) (int, error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType string, string
2025/12/19 11:09:30 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:30 NewVar [_xgo_err]
2025/12/19 11:09:30 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:30 VarRef _xgo_err error
2025/12/19 11:09:30 Assign 2 1
2025/12/19 11:09:30 ==> MatchType int, unboundType{typ: <nil>}
2025/12/19 11:09:30 ==> MatchType error, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 If
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 Val <nil> <nil>
2025/12/19 11:09:30 BinaryOp !=
2025/12/19 11:09:30 Typ error
2025/12/19 11:09:30 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:30 Then
2025/12/19 11:09:30 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:30 Return 1
2025/12/19 11:09:30 ==> MatchType untyped int (0), unboundType{typ: int}
2025/12/19 11:09:30 End // If
2025/12/19 11:09:30 Return 0
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 Call 0 0 // func() (_xgo_ret int)
2025/12/19 11:09:30 ==> MatchFuncCall func() (_xgo_ret int) args: 0 flags: 0
2025/12/19 11:09:30 Val Atoi func(s string) (int, error)
2025/12/19 11:09:30 Val y string
2025/12/19 11:09:30 Call 1 0 // func(s string) (int, error)
2025/12/19 11:09:30 ==> MatchFuncCall func(s string) (int, error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType string, string
2025/12/19 11:09:30 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:30 NewVar [_xgo_err]
2025/12/19 11:09:30 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:30 VarRef _xgo_err error
2025/12/19 11:09:30 Assign 2 1
2025/12/19 11:09:30 ==> MatchType int, unboundType{typ: <nil>}
2025/12/19 11:09:30 ==> MatchType error, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 If
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 Val <nil> <nil>
2025/12/19 11:09:30 BinaryOp !=
2025/12/19 11:09:30 Typ error
2025/12/19 11:09:30 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:30 Then
2025/12/19 11:09:30 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:30 Return 1
2025/12/19 11:09:30 ==> MatchType untyped int (0), unboundType{typ: int}
2025/12/19 11:09:30 End // If
2025/12/19 11:09:30 Return 0
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 Call 0 0 // func() (_xgo_ret int)
2025/12/19 11:09:30 ==> MatchFuncCall func() (_xgo_ret int) args: 0 flags: 0
2025/12/19 11:09:30 BinaryOp +
2025/12/19 11:09:30 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:30 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:30 Return 1
2025/12/19 11:09:30 ==> MatchType int, int
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:14:1
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val add func(x string, y string) (int, error)
2025/12/19 11:09:30 Val &{0 STRING "100"} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "23"} *ast.BasicLit
2025/12/19 11:09:30 Call 2 0 // func(x string, y string) (int, error)
2025/12/19 11:09:30 ==> MatchFuncCall func(x string, y string) (int, error) args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped string ("100"), string
2025/12/19 11:09:30 ==> MatchType untyped string ("23"), string
2025/12/19 11:09:30 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:30 NewVar [_xgo_err]
2025/12/19 11:09:30 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:30 VarRef _xgo_err error
2025/12/19 11:09:30 Assign 2 1
2025/12/19 11:09:30 ==> MatchType int, unboundType{typ: <nil>}
2025/12/19 11:09:30 ==> MatchType error, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 If
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 Val <nil> <nil>
2025/12/19 11:09:30 BinaryOp !=
2025/12/19 11:09:30 Typ error
2025/12/19 11:09:30 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:30 Then
2025/12/19 11:09:30 VarRef _xgo_err error
2025/12/19 11:09:30 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 Val add("100", "23") string
2025/12/19 11:09:30 Val /foo/bar.xgo string
2025/12/19 11:09:30 Val 14 int
2025/12/19 11:09:30 Val main.main string
2025/12/19 11:09:30 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:30 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/12/19 11:09:30 ==> MatchType error, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 ==> MatchType untyped string ("add(\"100\", \"23\")"), string
2025/12/19 11:09:30 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/12/19 11:09:30 ==> MatchType untyped int (14), int
2025/12/19 11:09:30 ==> MatchType untyped string ("main.main"), string
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 Val panic func(v interface{})
2025/12/19 11:09:30 Val _xgo_err error
2025/12/19 11:09:30 Call 1 0 // func(v interface{})
2025/12/19 11:09:30 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType error, interface{}
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 End // If
2025/12/19 11:09:30 Return 0
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 Call 0 0 // func() (_xgo_ret int)
2025/12/19 11:09:30 ==> MatchFuncCall func() (_xgo_ret int) args: 0 flags: 0
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:16:1
2025/12/19 11:09:30 DefineVarStart [sum err]
2025/12/19 11:09:30 Val add func(x string, y string) (int, error)
2025/12/19 11:09:30 Val &{0 STRING "10"} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "abc"} *ast.BasicLit
2025/12/19 11:09:30 Call 2 2 // func(x string, y string) (int, error)
2025/12/19 11:09:30 ==> MatchFuncCall func(x string, y string) (int, error) args: 2 flags: 2
2025/12/19 11:09:30 ==> MatchType untyped string ("10"), string
2025/12/19 11:09:30 ==> MatchType untyped string ("abc"), string
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:17:1
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val sum int
2025/12/19 11:09:30 Val err error
2025/12/19 11:09:30 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 ==> MatchType error, any
2025/12/19 11:09:30 ==> EnsureLoaded error
2025/12/19 11:09:30 SetComments 0
//line /foo/bar.xgo:19:1
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val addSafe func(x string, y string) int
2025/12/19 11:09:30 Val &{0 STRING "10"} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "abc"} *ast.BasicLit
2025/12/19 11:09:30 Call 2 0 // func(x string, y string) int
2025/12/19 11:09:30 ==> MatchFuncCall func(x string, y string) int args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped string ("10"), string
2025/12/19 11:09:30 ==> MatchType untyped string ("abc"), string
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType int, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestCommentFunc (0.00s)
=== RUN   TestTestspx
=== RUN   TestTestspx/basic
2025/12/19 11:09:30 Parsing /app/cl/_testspx/basic
2025/12/19 11:09:30 ==> ClassFile /app/cl/_testspx/basic/Game.tgmx
2025/12/19 11:09:30 ==> InitClass Game isProj: true
2025/12/19 11:09:30 ==> ClassFile /app/cl/_testspx/basic/Kai.tspx
2025/12/19 11:09:30 ==> InitClass Kai isProj: false
2025/12/19 11:09:30 ==> Preload type Game
2025/12/19 11:09:30 ==> Preload method Game.onInit
2025/12/19 11:09:30 ==> Preload method Game.MainEntry
2025/12/19 11:09:30 ==> Preload type Kai
2025/12/19 11:09:30 ==> Preload method Kai.onMsg
2025/12/19 11:09:30 ==> Preload method Kai.Main
2025/12/19 11:09:30 ==> Load > NewType Game
2025/12/19 11:09:30 NewType Game
2025/12/19 11:09:30 ==> Load > NewType Kai
2025/12/19 11:09:30 NewType Kai
2025/12/19 11:09:30 ==> Load > InitType Game
2025/12/19 11:09:30 InitType Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:30 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:30 ==> Load method *Game.onInit
2025/12/19 11:09:30 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:30 ==> Load method *Game.MainEntry
2025/12/19 11:09:30 ==> Load > InitType Kai
2025/12/19 11:09:30 ==> LookupParent Game => type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:30 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:30 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:30 ==> Load method *Kai.onMsg
2025/12/19 11:09:30 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *Game}
2025/12/19 11:09:30 ==> Load method *Kai.Main
2025/12/19 11:09:30 NewFunc onInit (*Game) func()
2025/12/19 11:09:30 For
2025/12/19 11:09:30 None
2025/12/19 11:09:30 Then
2025/12/19 11:09:30 Val Sched func()
2025/12/19 11:09:30 Call 0 0 // func()
2025/12/19 11:09:30 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:30 Val SchedNow func()
2025/12/19 11:09:30 Call 0 0 // func()
2025/12/19 11:09:30 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:30 End // For
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:30 Val this *Game
2025/12/19 11:09:30 Member initGameApp 1 // *Game
2025/12/19 11:09:30 Call 0 0 // func(args ...string)
2025/12/19 11:09:30 ==> MatchFuncCall func(args ...string) args: 0 flags: 0
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc Main (*Game) func()
2025/12/19 11:09:30 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/12/19 11:09:30 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:30 Val this *Game
2025/12/19 11:09:30 Call 1 0 // func(game any)
2025/12/19 11:09:30 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType *Game, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc onMsg (*Kai) func(msg string)
2025/12/19 11:09:30 For
2025/12/19 11:09:30 None
2025/12/19 11:09:30 Then
2025/12/19 11:09:30 Val this *Kai
2025/12/19 11:09:30 Member say 1 // *Kai
2025/12/19 11:09:30 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:30 Call 1 0 // func(msg string, secs ...float64)
2025/12/19 11:09:30 ==> MatchFuncCall func(msg string, secs ...float64) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped string ("Hi"), string
2025/12/19 11:09:30 End // For
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc Main (*Kai) func()
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:30 Val Game Game
2025/12/19 11:09:30 Val type Game struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ Game
2025/12/19 11:09:30 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:30 Member Main 0 // *Game
2025/12/19 11:09:30 Call 0 0 // func()
2025/12/19 11:09:30 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
=== RUN   TestTestspx/init
2025/12/19 11:09:30 Parsing /app/cl/_testspx/init
2025/12/19 11:09:30 ==> ClassFile /app/cl/_testspx/init/init.tspx
2025/12/19 11:09:30 ==> InitClass init isProj: false
2025/12/19 11:09:30 ==> Preload type _init
2025/12/19 11:09:30 ==> Preload method _init.Main
2025/12/19 11:09:30 ==> Load > NewType _init
2025/12/19 11:09:30 NewType _init
2025/12/19 11:09:30 ==> Load > InitType _init
2025/12/19 11:09:30 ==> Load > NewType MyGame
2025/12/19 11:09:30 NewType MyGame
2025/12/19 11:09:30 ==> Lookup (LoadSymbol) MyGame => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:30 ==> Load > InitType MyGame
2025/12/19 11:09:30 InitType MyGame struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:30 InitType _init struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *MyGame}
2025/12/19 11:09:30 ==> LookupParent _init => type _init struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *MyGame}
2025/12/19 11:09:30 ==> Load method *_init.Main
2025/12/19 11:09:30 NewFunc Main (*MyGame) func()
2025/12/19 11:09:30 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/12/19 11:09:30 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:30 Val this *MyGame
2025/12/19 11:09:30 Call 1 0 // func(game any)
2025/12/19 11:09:30 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType *MyGame, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc Main (*_init) func()
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:30 Val MyGame MyGame
2025/12/19 11:09:30 Val type MyGame struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ MyGame
2025/12/19 11:09:30 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:30 Member Main 0 // *MyGame
2025/12/19 11:09:30 Call 0 0 // func()
2025/12/19 11:09:30 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
=== RUN   TestTestspx/multiworks
2025/12/19 11:09:30 Parsing /app/cl/_testspx/multiworks
2025/12/19 11:09:30 ==> ClassFile /app/cl/_testspx/multiworks/foo_prompt.gox
2025/12/19 11:09:30 ==> Import github.com/goplus/xgo/cl/internal/mcp
2025/12/19 11:09:30 ==> NewTemplateRecvMethod Game Main
2025/12/19 11:09:30 ==> InitClass foo isProj: false
2025/12/19 11:09:30 ==> ClassFile /app/cl/_testspx/multiworks/hello_tool.gox
2025/12/19 11:09:30 ==> InitClass hello isProj: false
2025/12/19 11:09:30 ==> ClassFile /app/cl/_testspx/multiworks/main_mcp.gox
2025/12/19 11:09:30 ==> InitClass main isProj: true
2025/12/19 11:09:30 ==> Preload type foo
2025/12/19 11:09:30 ==> Preload method foo.Main
2025/12/19 11:09:30 ==> Preload type Tool_hello
2025/12/19 11:09:30 ==> Preload method Tool_hello.Main
2025/12/19 11:09:30 ==> Preload type Game
2025/12/19 11:09:30 ==> Preload method Game.MainEntry
2025/12/19 11:09:30 ==> Load > NewType foo
2025/12/19 11:09:30 NewType foo
2025/12/19 11:09:30 ==> Load > NewType Tool_hello
2025/12/19 11:09:30 NewType Tool_hello
2025/12/19 11:09:30 ==> Load > NewType Game
2025/12/19 11:09:30 NewType Game
2025/12/19 11:09:30 ==> Load > InitType Game
2025/12/19 11:09:30 InitType Game struct{github.com/goplus/xgo/cl/internal/mcp.Game; foo *foo}
2025/12/19 11:09:30 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/mcp.Game; foo *foo}
2025/12/19 11:09:30 ==> Load method *Game.MainEntry
2025/12/19 11:09:30 ==> Load > InitType foo
2025/12/19 11:09:30 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/mcp.Game; foo *foo}
2025/12/19 11:09:30 InitType foo struct{github.com/goplus/xgo/cl/internal/mcp.Prompt; *Game}
2025/12/19 11:09:30 ==> LookupParent foo => type foo struct{github.com/goplus/xgo/cl/internal/mcp.Prompt; *Game}
2025/12/19 11:09:30 ==> Load method *foo.Main
2025/12/19 11:09:30 ==> Load > InitType Tool_hello
2025/12/19 11:09:30 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/mcp.Game; foo *foo}
2025/12/19 11:09:30 InitType Tool_hello struct{github.com/goplus/xgo/cl/internal/mcp.Tool; *Game}
2025/12/19 11:09:30 ==> LookupParent Tool_hello => type Tool_hello struct{github.com/goplus/xgo/cl/internal/mcp.Tool; *Game}
2025/12/19 11:09:30 ==> Load method *Tool_hello.Main
2025/12/19 11:09:30 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:30 Val this *Game
2025/12/19 11:09:30 Member server 1 // *Game
2025/12/19 11:09:30 Val &{0 STRING "protos"} *ast.BasicLit
2025/12/19 11:09:30 Call 1 0 // func(name string)
2025/12/19 11:09:30 ==> MatchFuncCall func(name string) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped string ("protos"), string
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc Main (*Game) func()
2025/12/19 11:09:30 Typ github.com/goplus/xgo/cl/internal/mcp.Game
2025/12/19 11:09:30 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/mcp.Game}
2025/12/19 11:09:30 DefineVarStart [_xgo_obj0]
2025/12/19 11:09:30 Val 1 int
2025/12/19 11:09:30 Val this *Game
2025/12/19 11:09:30 StructLit Tool_hello 2 true
2025/12/19 11:09:30 UnaryOp & flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 DefineVarStart [_xgo_lst1]
2025/12/19 11:09:30 Val _xgo_obj0 *Tool_hello
2025/12/19 11:09:30 SliceLit []github.com/goplus/xgo/cl/internal/mcp.ToolProto 1 false
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/mcp.ToolProto
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 DefineVarStart [_xgo_obj1]
2025/12/19 11:09:30 Val 1 int
2025/12/19 11:09:30 Val this *Game
2025/12/19 11:09:30 StructLit foo 2 true
2025/12/19 11:09:30 UnaryOp & flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 Val this *Game
2025/12/19 11:09:30 Member foo -1 // *Game
2025/12/19 11:09:30 Val _xgo_obj1 *foo
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 ==> MatchType *foo, *foo
2025/12/19 11:09:30 DefineVarStart [_xgo_lst2]
2025/12/19 11:09:30 Val _xgo_obj1 *foo
2025/12/19 11:09:30 SliceLit []github.com/goplus/xgo/cl/internal/mcp.PromptProto 1 false
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/mcp.PromptProto
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 Val this *Game
2025/12/19 11:09:30 Val <nil> <nil>
2025/12/19 11:09:30 Val _xgo_lst1 []github.com/goplus/xgo/cl/internal/mcp.ToolProto
2025/12/19 11:09:30 Val _xgo_lst2 []github.com/goplus/xgo/cl/internal/mcp.PromptProto
2025/12/19 11:09:30 Call 4 0 // func(game interface{initGame()}, resources []github.com/goplus/xgo/cl/internal/mcp.ResourceProto, tools []github.com/goplus/xgo/cl/internal/mcp.ToolProto, prompts []github.com/goplus/xgo/cl/internal/mcp.PromptProto)
2025/12/19 11:09:30 ==> MatchFuncCall func(game interface{initGame()}, resources []github.com/goplus/xgo/cl/internal/mcp.ResourceProto, tools []github.com/goplus/xgo/cl/internal/mcp.ToolProto, prompts []github.com/goplus/xgo/cl/internal/mcp.PromptProto) args: 4 flags: 0
2025/12/19 11:09:30 ==> MatchType *Game, interface{initGame()}
2025/12/19 11:09:30 ==> MatchType untyped nil, []github.com/goplus/xgo/cl/internal/mcp.ResourceProto
2025/12/19 11:09:30 ==> MatchType []github.com/goplus/xgo/cl/internal/mcp.ToolProto, []github.com/goplus/xgo/cl/internal/mcp.ToolProto
2025/12/19 11:09:30 ==> MatchType []github.com/goplus/xgo/cl/internal/mcp.PromptProto, []github.com/goplus/xgo/cl/internal/mcp.PromptProto
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc Main (*foo) func(_xgo_arg0 *github.com/goplus/xgo/cl/internal/mcp.Tool) string
2025/12/19 11:09:30 Val this *foo
2025/12/19 11:09:30 Member Prompt 0 // *foo
2025/12/19 11:09:30 Member Main 0 // github.com/goplus/xgo/cl/internal/mcp.Prompt
2025/12/19 11:09:30 Val _xgo_arg0 *github.com/goplus/xgo/cl/internal/mcp.Tool
2025/12/19 11:09:30 Call 1 0 // func(*github.com/goplus/xgo/cl/internal/mcp.Tool) string
2025/12/19 11:09:30 ==> MatchFuncCall func(*github.com/goplus/xgo/cl/internal/mcp.Tool) string args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType *github.com/goplus/xgo/cl/internal/mcp.Tool, *github.com/goplus/xgo/cl/internal/mcp.Tool
2025/12/19 11:09:30 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:30 Return 1
2025/12/19 11:09:30 ==> MatchType untyped string ("Hi"), string
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc Main (*Tool_hello) func(_xgo_arg0 string) int
2025/12/19 11:09:30 Val this *Tool_hello
2025/12/19 11:09:30 Member Tool 0 // *Tool_hello
2025/12/19 11:09:30 Member Main 0 // github.com/goplus/xgo/cl/internal/mcp.Tool
2025/12/19 11:09:30 Val _xgo_arg0 string
2025/12/19 11:09:30 Call 1 0 // func(name string) int
2025/12/19 11:09:30 ==> MatchFuncCall func(name string) int args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType string, string
2025/12/19 11:09:30 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:30 UnaryOp - flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:30 Return 1
2025/12/19 11:09:30 ==> MatchType untyped int (-1), int
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:30 Val Game Game
2025/12/19 11:09:30 Val type Game struct{github.com/goplus/xgo/cl/internal/mcp.Game; foo *foo} => Typ Game
2025/12/19 11:09:30 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:30 Member Main 0 // *Game
2025/12/19 11:09:30 Call 0 0 // func()
2025/12/19 11:09:30 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
=== RUN   TestTestspx/newobj
2025/12/19 11:09:30 Parsing /app/cl/_testspx/newobj
2025/12/19 11:09:30 ==> ClassFile /app/cl/_testspx/newobj/Kai_spx.gox
2025/12/19 11:09:30 ==> Import github.com/goplus/xgo/cl/internal/spx3
2025/12/19 11:09:30 ==> NewTemplateRecvMethod Game Main
2025/12/19 11:09:30 ==> InitClass Kai isProj: false
2025/12/19 11:09:30 ==> ClassFile /app/cl/_testspx/newobj/main_spx.gox
2025/12/19 11:09:30 ==> InitClass main isProj: true
2025/12/19 11:09:30 ==> Preload type Kai
2025/12/19 11:09:30 ==> Preload method Kai.Main
2025/12/19 11:09:30 ==> Preload type Game
2025/12/19 11:09:30 ==> Preload method Game.MainEntry
2025/12/19 11:09:30 ==> Load > NewType Kai
2025/12/19 11:09:30 NewType Kai
2025/12/19 11:09:30 ==> Load > NewType Game
2025/12/19 11:09:30 NewType Game
2025/12/19 11:09:30 ==> Load > InitType Game
2025/12/19 11:09:30 InitType Game struct{github.com/goplus/xgo/cl/internal/spx3.Game}
2025/12/19 11:09:30 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx3.Game}
2025/12/19 11:09:30 ==> Load method *Game.MainEntry
2025/12/19 11:09:30 ==> Load > InitType Kai
2025/12/19 11:09:30 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx3.Game}
2025/12/19 11:09:30 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx3.Sprite; *Game}
2025/12/19 11:09:30 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx3.Sprite; *Game}
2025/12/19 11:09:30 ==> Load method *Kai.Main
2025/12/19 11:09:30 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx3.Sprite; *Game}
2025/12/19 11:09:30 NewFunc Classfname (*Kai) func() string
2025/12/19 11:09:30 Val Kai string
2025/12/19 11:09:30 Return 1
2025/12/19 11:09:30 ==> MatchType untyped string ("Kai"), string
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx3.Sprite; *Game}
2025/12/19 11:09:30 NewFunc Classclone (*Kai) func() github.com/goplus/xgo/cl/internal/spx3.Handler
2025/12/19 11:09:30 DefineVarStart [_xgo_ret]
2025/12/19 11:09:30 Val this *Kai
2025/12/19 11:09:30 Elem
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 Val _xgo_ret Kai
2025/12/19 11:09:30 UnaryOp & flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:30 Return 1
2025/12/19 11:09:30 ==> MatchType *Kai, github.com/goplus/xgo/cl/internal/spx3.Handler
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx3.Handler
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:30 DefineVarStart [a]
2025/12/19 11:09:30 Val this *Game
2025/12/19 11:09:30 Member new 2 // *Game
2025/12/19 11:09:30 Val New func() *github.com/goplus/xgo/cl/internal/spx3.Game
2025/12/19 11:09:30 Call 0 0 // func() *github.com/goplus/xgo/cl/internal/spx3.Game
2025/12/19 11:09:30 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx3.Game args: 0 flags: 0
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 Val a *github.com/goplus/xgo/cl/internal/spx3.Game
2025/12/19 11:09:30 Member run 1 // *github.com/goplus/xgo/cl/internal/spx3.Game
2025/12/19 11:09:30 Call 0 0 // func()
2025/12/19 11:09:30 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:30 DefineVarStart [b]
2025/12/19 11:09:30 Val this *Game
2025/12/19 11:09:30 Member new 1 // *Game
2025/12/19 11:09:30 Val New func() *github.com/goplus/xgo/cl/internal/spx3.Game
2025/12/19 11:09:30 Val this *Game
2025/12/19 11:09:30 Member Sprite 2 // *Game
2025/12/19 11:09:30 Val Sprite github.com/goplus/xgo/cl/internal/spx3.Sprite
2025/12/19 11:09:30 Val type github.com/goplus/xgo/cl/internal/spx3.Sprite struct{} => Typ github.com/goplus/xgo/cl/internal/spx3.Sprite
2025/12/19 11:09:30 Call 1 0 // func() *github.com/goplus/xgo/cl/internal/spx3.Game
2025/12/19 11:09:30 ==> MatchFuncCall func() *github.com/goplus/xgo/cl/internal/spx3.Game args: 1 flags: 0
2025/12/19 11:09:30 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:30 Val this *Game
2025/12/19 11:09:30 Member Sprite 2 // *Game
2025/12/19 11:09:30 Val Sprite github.com/goplus/xgo/cl/internal/spx3.Sprite
2025/12/19 11:09:30 Val type github.com/goplus/xgo/cl/internal/spx3.Sprite struct{} => Typ github.com/goplus/xgo/cl/internal/spx3.Sprite
2025/12/19 11:09:30 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 Val this *Game
2025/12/19 11:09:30 Member echo 1 // *Game
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val b *github.com/goplus/xgo/cl/internal/spx3.Sprite
2025/12/19 11:09:30 Member name 2 // *github.com/goplus/xgo/cl/internal/spx3.Sprite
2025/12/19 11:09:30 Call 0 0 // func() string
2025/12/19 11:09:30 ==> MatchFuncCall func() string args: 0 flags: 0
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType string, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc Main (*Game) func()
2025/12/19 11:09:30 Typ github.com/goplus/xgo/cl/internal/spx3.Game
2025/12/19 11:09:30 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx3.Game}
2025/12/19 11:09:30 DefineVarStart [_xgo_obj0]
2025/12/19 11:09:30 Val 1 int
2025/12/19 11:09:30 Val this *Game
2025/12/19 11:09:30 StructLit Kai 2 true
2025/12/19 11:09:30 UnaryOp & flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 Val this *Game
2025/12/19 11:09:30 Val _xgo_obj0 *Kai
2025/12/19 11:09:30 Call 2 0 // func(game interface{initGame()}, workers ...github.com/goplus/xgo/cl/internal/spx3.Handler)
2025/12/19 11:09:30 ==> MatchFuncCall func(game interface{initGame()}, workers ...github.com/goplus/xgo/cl/internal/spx3.Handler) args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchType *Game, interface{initGame()}
2025/12/19 11:09:30 ==> MatchType *Kai, github.com/goplus/xgo/cl/internal/spx3.Handler
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx3.Handler
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc Main (*Kai) func(_xgo_arg0 string)
2025/12/19 11:09:30 Val this *Kai
2025/12/19 11:09:30 Member Sprite 0 // *Kai
2025/12/19 11:09:30 Member Main 0 // github.com/goplus/xgo/cl/internal/spx3.Sprite
2025/12/19 11:09:30 Val _xgo_arg0 string
2025/12/19 11:09:30 Call 1 0 // func(name string)
2025/12/19 11:09:30 ==> MatchFuncCall func(name string) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType string, string
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:30 Val Game Game
2025/12/19 11:09:30 Val type Game struct{github.com/goplus/xgo/cl/internal/spx3.Game} => Typ Game
2025/12/19 11:09:30 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:30 Member Main 0 // *Game
2025/12/19 11:09:30 Call 0 0 // func()
2025/12/19 11:09:30 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
=== RUN   TestTestspx/nogame
2025/12/19 11:09:30 Parsing /app/cl/_testspx/nogame
2025/12/19 11:09:30 ==> ClassFile /app/cl/_testspx/nogame/bar.tspx
2025/12/19 11:09:30 ==> InitClass bar isProj: false
2025/12/19 11:09:30 ==> Preload type bar
2025/12/19 11:09:30 ==> Preload method bar.Main
2025/12/19 11:09:30 ==> Load > NewType bar
2025/12/19 11:09:30 NewType bar
2025/12/19 11:09:30 ==> Load > InitType bar
2025/12/19 11:09:30 ==> Load > NewType MyGame
2025/12/19 11:09:30 NewType MyGame
2025/12/19 11:09:30 ==> Lookup (LoadSymbol) MyGame => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:30 ==> Load > InitType MyGame
2025/12/19 11:09:30 InitType MyGame struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:30 InitType bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *MyGame}
2025/12/19 11:09:30 ==> LookupParent bar => type bar struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *MyGame}
2025/12/19 11:09:30 ==> Load method *bar.Main
2025/12/19 11:09:30 NewFunc Main (*MyGame) func()
2025/12/19 11:09:30 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/12/19 11:09:30 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:30 Val this *MyGame
2025/12/19 11:09:30 Call 1 0 // func(game any)
2025/12/19 11:09:30 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType *MyGame, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc Main (*bar) func()
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:30 Val MyGame MyGame
2025/12/19 11:09:30 Val type MyGame struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ MyGame
2025/12/19 11:09:30 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:30 Member Main 0 // *MyGame
2025/12/19 11:09:30 Call 0 0 // func()
2025/12/19 11:09:30 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
=== RUN   TestTestspx/singlework
2025/12/19 11:09:30 Parsing /app/cl/_testspx/singlework
2025/12/19 11:09:30 ==> ClassFile /app/cl/_testspx/singlework/Kai_spx.gox
2025/12/19 11:09:30 ==> InitClass Kai isProj: false
2025/12/19 11:09:30 ==> ClassFile /app/cl/_testspx/singlework/main_spx.gox
2025/12/19 11:09:30 ==> InitClass main isProj: true
2025/12/19 11:09:30 ==> Preload type Kai
2025/12/19 11:09:30 ==> Preload method Kai.Main
2025/12/19 11:09:30 ==> Preload type Game
2025/12/19 11:09:30 ==> Preload method Game.MainEntry
2025/12/19 11:09:30 ==> Load > NewType Kai
2025/12/19 11:09:30 NewType Kai
2025/12/19 11:09:30 ==> Load > NewType Game
2025/12/19 11:09:30 NewType Game
2025/12/19 11:09:30 ==> Load > InitType Game
2025/12/19 11:09:30 ==> LookupParent Kai => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:30 InitType Game struct{github.com/goplus/xgo/cl/internal/spx3.Game; Kai Kai}
2025/12/19 11:09:30 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx3.Game; Kai Kai}
2025/12/19 11:09:30 ==> Load method *Game.MainEntry
2025/12/19 11:09:30 ==> Load > InitType Kai
2025/12/19 11:09:30 ==> LookupParent Game => type Game struct{github.com/goplus/xgo/cl/internal/spx3.Game; Kai Kai}
2025/12/19 11:09:30 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx3.Sprite; *Game}
2025/12/19 11:09:30 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx3.Sprite; *Game}
2025/12/19 11:09:30 ==> Load method *Kai.Main
2025/12/19 11:09:30 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx3.Sprite; *Game}
2025/12/19 11:09:30 NewFunc Classfname (*Kai) func() string
2025/12/19 11:09:30 Val Kai string
2025/12/19 11:09:30 Return 1
2025/12/19 11:09:30 ==> MatchType untyped string ("Kai"), string
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> LookupParent Kai => type Kai struct{github.com/goplus/xgo/cl/internal/spx3.Sprite; *Game}
2025/12/19 11:09:30 NewFunc Classclone (*Kai) func() github.com/goplus/xgo/cl/internal/spx3.Handler
2025/12/19 11:09:30 DefineVarStart [_xgo_ret]
2025/12/19 11:09:30 Val this *Kai
2025/12/19 11:09:30 Elem
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 Val _xgo_ret Kai
2025/12/19 11:09:30 UnaryOp & flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:30 Return 1
2025/12/19 11:09:30 ==> MatchType *Kai, github.com/goplus/xgo/cl/internal/spx3.Handler
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx3.Handler
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc MainEntry (*Game) func()
2025/12/19 11:09:30 Val this *Game
2025/12/19 11:09:30 Member run 1 // *Game
2025/12/19 11:09:30 Call 0 0 // func()
2025/12/19 11:09:30 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc Main (*Game) func()
2025/12/19 11:09:30 Typ github.com/goplus/xgo/cl/internal/spx3.Game
2025/12/19 11:09:30 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx3.Game}
2025/12/19 11:09:30 DefineVarStart [_xgo_obj0]
2025/12/19 11:09:30 Val 1 int
2025/12/19 11:09:30 Val this *Game
2025/12/19 11:09:30 StructLit Kai 2 true
2025/12/19 11:09:30 UnaryOp & flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 Val this *Game
2025/12/19 11:09:30 Val _xgo_obj0 *Kai
2025/12/19 11:09:30 Call 2 0 // func(game interface{initGame()}, workers ...github.com/goplus/xgo/cl/internal/spx3.Handler)
2025/12/19 11:09:30 ==> MatchFuncCall func(game interface{initGame()}, workers ...github.com/goplus/xgo/cl/internal/spx3.Handler) args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchType *Game, interface{initGame()}
2025/12/19 11:09:30 ==> MatchType *Kai, github.com/goplus/xgo/cl/internal/spx3.Handler
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/spx3.Handler
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc Main (*Kai) func(_xgo_arg0 string)
2025/12/19 11:09:30 Val this *Kai
2025/12/19 11:09:30 Member Sprite 0 // *Kai
2025/12/19 11:09:30 Member Main 0 // github.com/goplus/xgo/cl/internal/spx3.Sprite
2025/12/19 11:09:30 Val _xgo_arg0 string
2025/12/19 11:09:30 Call 1 0 // func(name string)
2025/12/19 11:09:30 ==> MatchFuncCall func(name string) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType string, string
2025/12/19 11:09:30 Val this *Kai
2025/12/19 11:09:30 Member echo 1 // *Kai
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val this *Kai
2025/12/19 11:09:30 Member jwt 2 // *Kai
2025/12/19 11:09:30 Val Token func(v string) string
2025/12/19 11:09:30 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:30 Call 1 0 // func(v string) string
2025/12/19 11:09:30 ==> MatchFuncCall func(v string) string args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType untyped string ("Hi"), string
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType string, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:30 Val Game Game
2025/12/19 11:09:30 Val type Game struct{github.com/goplus/xgo/cl/internal/spx3.Game; Kai Kai} => Typ Game
2025/12/19 11:09:30 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:30 Member Main 0 // *Game
2025/12/19 11:09:30 Call 0 0 // func()
2025/12/19 11:09:30 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
--- PASS: TestTestspx (0.14s)
    --- PASS: TestTestspx/basic (0.00s)
    --- PASS: TestTestspx/init (0.00s)
    --- PASS: TestTestspx/multiworks (0.05s)
    --- PASS: TestTestspx/newobj (0.08s)
    --- PASS: TestTestspx/nogame (0.00s)
    --- PASS: TestTestspx/singlework (0.00s)
=== RUN   TestTestgop
=== RUN   TestTestgop/append1
2025/12/19 11:09:30 Parsing /app/cl/_testgop/append1
2025/12/19 11:09:30 ==> Preload type foo
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load > NewType foo
2025/12/19 11:09:30 NewType foo
2025/12/19 11:09:30 ==> Load > InitType foo
2025/12/19 11:09:30 InitType foo struct{a []int}
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 DefineVarStart [a]
2025/12/19 11:09:30 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:30 SliceLit <nil> 3 false
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 Val a []int
2025/12/19 11:09:30 VarRef a []int
2025/12/19 11:09:30 Val append func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val &{0 INT 4} *ast.BasicLit
2025/12/19 11:09:30 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchType []int, []unboundFuncParam{typ: <nil>}
2025/12/19 11:09:30 ==> MatchType untyped int (4), unboundFuncParam{typ: int}
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 ==> MatchType []int, []int
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val a []int
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType []int, any
2025/12/19 11:09:30 DefineVarStart [f]
2025/12/19 11:09:30 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{a []int}
2025/12/19 11:09:30 Val 0 int
2025/12/19 11:09:30 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:30 SliceLit []int 3 false
2025/12/19 11:09:30 StructLit github.com/goplus/xgo/cl.foo 2 true
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 Val f github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 Member a 2 // github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 Val f github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 Member a -1 // github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 Val append func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val &{0 INT 4} *ast.BasicLit
2025/12/19 11:09:30 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/12/19 11:09:30 ==> MatchType []int, []unboundFuncParam{typ: <nil>}
2025/12/19 11:09:30 ==> MatchType untyped int (4), unboundFuncParam{typ: int}
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 ==> MatchType []int, []int
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val f github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType github.com/goplus/xgo/cl.foo, any
2025/12/19 11:09:30 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/12/19 11:09:30 DefineVarStart [f2]
2025/12/19 11:09:30 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:30 ArrayLit [2]chan int 0 false
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 Val f2 [2]chan int
2025/12/19 11:09:30 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:30 Index 1 false
2025/12/19 11:09:30 Val &{0 INT 4} *ast.BasicLit
2025/12/19 11:09:30 Send
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
=== RUN   TestTestgop/append2
2025/12/19 11:09:30 Parsing /app/cl/_testgop/append2
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 DefineVarStart [a]
2025/12/19 11:09:30 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:30 SliceLit <nil> 3 false
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 Val a []int
2025/12/19 11:09:30 VarRef a []int
2025/12/19 11:09:30 Val append func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val &{0 INT 4} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:30 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 3 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 3 flags: 0
2025/12/19 11:09:30 ==> MatchType []int, []unboundFuncParam{typ: <nil>}
2025/12/19 11:09:30 ==> MatchType untyped int (4), unboundFuncParam{typ: int}
2025/12/19 11:09:30 ==> MatchType untyped int (5), unboundFuncParam{typ: int}
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 ==> MatchType []int, []int
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val a []int
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType []int, any
2025/12/19 11:09:30 DefineVarStart [b]
2025/12/19 11:09:30 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 INT 8} *ast.BasicLit
2025/12/19 11:09:30 SliceLit <nil> 2 false
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 Val a []int
2025/12/19 11:09:30 VarRef a []int
2025/12/19 11:09:30 Val append func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val b []int
2025/12/19 11:09:30 Call 2 1 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 1
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 1
2025/12/19 11:09:30 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 1
2025/12/19 11:09:30 ==> MatchType []int, []unboundFuncParam{typ: <nil>}
2025/12/19 11:09:30 ==> MatchType []int, []unboundFuncParam{typ: int}
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 ==> MatchType []int, []int
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val a []int
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType []int, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
=== RUN   TestTestgop/cap
2025/12/19 11:09:30 Parsing /app/cl/_testgop/cap
2025/12/19 11:09:30 ==> Preload func main
2025/12/19 11:09:30 ==> Load func main
2025/12/19 11:09:30 NewFunc main func()
2025/12/19 11:09:30 DefineVarStart [a]
2025/12/19 11:09:30 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "world"} *ast.BasicLit
2025/12/19 11:09:30 Val &{0 STRING "123"} *ast.BasicLit
2025/12/19 11:09:30 SliceLit <nil> 3 false
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 Val a []string
2025/12/19 11:09:30 Member capitalize 2 // []string
2025/12/19 11:09:30 Val Capitalize func(a []string) []string
2025/12/19 11:09:30 Call 1 0 // func(a []string) []string
2025/12/19 11:09:30 ==> MatchFuncCall func(a []string) []string args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType []string, []string
2025/12/19 11:09:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:30 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:30 ==> MatchType []string, any
2025/12/19 11:09:30 End // Func
2025/12/19 11:09:30 ==> ASTFile
=== RUN   TestTestgop/domaintext-html
2025/12/19 11:09:30 Parsing /app/cl/_testgop/domaintext-html
2025/12/19 11:09:30 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:30 ==> NewOverloadFunc NewRange
2025/12/19 11:09:31 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:31 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:31 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:31 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:31 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:31 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:31 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:31 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:31 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:31 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:31 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:31 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_And
xgo: downloading golang.org/x/net v0.34.0
2025/12/19 11:09:32 ==> Preload func main
2025/12/19 11:09:32 ==> Load func main
2025/12/19 11:09:32 NewFunc main func()
2025/12/19 11:09:32 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:32 Val Parse func(r io.Reader) (*golang.org/x/net/html.Node, error)
2025/12/19 11:09:32 Val NewReader func(s string) *strings.Reader
2025/12/19 11:09:32 Val &{0 STRING `<html><body><h1>hello</h1></body></html>`} *ast.BasicLit
2025/12/19 11:09:32 Call 1 0 // func(s string) *strings.Reader
2025/12/19 11:09:32 ==> MatchFuncCall func(s string) *strings.Reader args: 1 flags: 0
2025/12/19 11:09:32 ==> MatchType untyped string ("<html><body><h1>hello</h1></body></html>"), string
2025/12/19 11:09:32 Call 1 0 // func(r io.Reader) (*golang.org/x/net/html.Node, error)
2025/12/19 11:09:32 ==> MatchFuncCall func(r io.Reader) (*golang.org/x/net/html.Node, error) args: 1 flags: 0
2025/12/19 11:09:32 ==> MatchType *strings.Reader, io.Reader
2025/12/19 11:09:32 ==> EnsureLoaded io.Reader
2025/12/19 11:09:32 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:32 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:32 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:32 ==> MatchType *golang.org/x/net/html.Node, any
2025/12/19 11:09:32 ==> MatchType error, any
2025/12/19 11:09:32 ==> EnsureLoaded error
2025/12/19 11:09:32 End // Func
2025/12/19 11:09:32 ==> ASTFile
=== RUN   TestTestgop/domaintext-huh
2025/12/19 11:09:32 Parsing /app/cl/_testgop/domaintext-huh
2025/12/19 11:09:32 ==> Preload func main
2025/12/19 11:09:32 ==> Load func main
2025/12/19 11:09:32 NewFunc main func()
2025/12/19 11:09:32 DefineVarStart [form]
2025/12/19 11:09:32 Val New func(string, string, int) github.com/goplus/xgo/cl/internal/huh.Form
2025/12/19 11:09:32 Val <form id="test">
</form>
 string
2025/12/19 11:09:32 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:09:32 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:32 Call 3 0 // func(string, string, int) github.com/goplus/xgo/cl/internal/huh.Form
2025/12/19 11:09:32 ==> MatchFuncCall func(string, string, int) github.com/goplus/xgo/cl/internal/huh.Form args: 3 flags: 0
2025/12/19 11:09:32 ==> MatchType untyped string ("<form id=\"test\">\n</form>\n"), string
2025/12/19 11:09:32 ==> MatchType untyped string ("1"), string
2025/12/19 11:09:32 ==> MatchType untyped int (2), int
2025/12/19 11:09:32 EndInit 1
2025/12/19 11:09:32 Val form github.com/goplus/xgo/cl/internal/huh.Form
2025/12/19 11:09:32 Member run 1 // github.com/goplus/xgo/cl/internal/huh.Form
2025/12/19 11:09:32 Call 0 0 // func()
2025/12/19 11:09:32 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:32 End // Func
2025/12/19 11:09:32 ==> ASTFile
=== RUN   TestTestgop/domaintext-json
2025/12/19 11:09:32 Parsing /app/cl/_testgop/domaintext-json
2025/12/19 11:09:32 ==> Preload func main
2025/12/19 11:09:32 ==> Load func main
2025/12/19 11:09:32 NewFunc main func()
2025/12/19 11:09:32 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:32 Val New func(text string) (ret any, err error)
2025/12/19 11:09:32 Val &{0 STRING `{"a":1, "b":2}`} *ast.BasicLit
2025/12/19 11:09:32 Call 1 0 // func(text string) (ret any, err error)
2025/12/19 11:09:32 ==> MatchFuncCall func(text string) (ret any, err error) args: 1 flags: 0
2025/12/19 11:09:32 ==> MatchType untyped string ("{\"a\":1, \"b\":2}"), string
2025/12/19 11:09:32 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:32 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:32 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:32 ==> MatchType any, any
2025/12/19 11:09:32 ==> MatchType error, any
2025/12/19 11:09:32 ==> EnsureLoaded error
2025/12/19 11:09:32 End // Func
2025/12/19 11:09:32 ==> ASTFile
=== RUN   TestTestgop/domaintext-md
2025/12/19 11:09:32 Parsing /app/cl/_testgop/domaintext-md
2025/12/19 11:09:33 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:33 ==> NewOverloadFunc NewRange
2025/12/19 11:09:33 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:33 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:33 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:33 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:33 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:33 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:33 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:33 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:33 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:33 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:33 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:33 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_Rcast
xgo: downloading github.com/xushiwei/markdown v0.1.0
2025/12/19 11:09:39 ==> Preload func main
2025/12/19 11:09:39 ==> Load func main
2025/12/19 11:09:39 NewFunc main func()
2025/12/19 11:09:39 DefineVarStart [md]
2025/12/19 11:09:39 Val New func(text string) *github.com/xushiwei/markdown.Markdown
2025/12/19 11:09:39 Val &{0 STRING `
# Title

Hello world
`} *ast.BasicLit
2025/12/19 11:09:39 Call 1 0 // func(text string) *github.com/xushiwei/markdown.Markdown
2025/12/19 11:09:39 ==> MatchFuncCall func(text string) *github.com/xushiwei/markdown.Markdown args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped string ("\n# Title\n\nHello world\n"), string
2025/12/19 11:09:39 EndInit 1
2025/12/19 11:09:39 Val md *github.com/xushiwei/markdown.Markdown
2025/12/19 11:09:39 Member convert 1 // *github.com/xushiwei/markdown.Markdown
2025/12/19 11:09:39 Val Stdout *os.File
2025/12/19 11:09:39 Call 1 0 // func(writer io.Writer, opts ...github.com/yuin/goldmark/parser.ParseOption) error
2025/12/19 11:09:39 ==> MatchFuncCall func(writer io.Writer, opts ...github.com/yuin/goldmark/parser.ParseOption) error args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType *os.File, io.Writer
2025/12/19 11:09:39 ==> EnsureLoaded io.Writer
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> ASTFile
=== RUN   TestTestgop/domaintext-regexp
2025/12/19 11:09:39 Parsing /app/cl/_testgop/domaintext-regexp
2025/12/19 11:09:39 ==> Preload func main
2025/12/19 11:09:39 ==> Load func main
2025/12/19 11:09:39 NewFunc main func()
2025/12/19 11:09:39 DefineVarStart [re err]
2025/12/19 11:09:39 Val New func(text string) (*regexp.Regexp, error)
2025/12/19 11:09:39 Val &{0 STRING `^[a-z]+\[[0-9]+\]$`} *ast.BasicLit
2025/12/19 11:09:39 Call 1 0 // func(text string) (*regexp.Regexp, error)
2025/12/19 11:09:39 ==> MatchFuncCall func(text string) (*regexp.Regexp, error) args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped string ("^[a-z]+\\[[0-9]+\\]$"), string
2025/12/19 11:09:39 EndInit 1
2025/12/19 11:09:39 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 Val re *regexp.Regexp
2025/12/19 11:09:39 Member matchString 1 // *regexp.Regexp
2025/12/19 11:09:39 Val &{0 STRING "adam[23]"} *ast.BasicLit
2025/12/19 11:09:39 Call 1 0 // func(s string) bool
2025/12/19 11:09:39 ==> MatchFuncCall func(s string) bool args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped string ("adam[23]"), string
2025/12/19 11:09:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType bool, any
2025/12/19 11:09:39 VarRef _
2025/12/19 11:09:39 Val err error
2025/12/19 11:09:39 Assign 1 1
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> ASTFile
=== RUN   TestTestgop/domaintext-tpl
2025/12/19 11:09:39 Parsing /app/cl/_testgop/domaintext-tpl
2025/12/19 11:09:39 ==> Preload func main
2025/12/19 11:09:39 ==> Load func main
2025/12/19 11:09:39 NewFunc main func()
2025/12/19 11:09:39 DefineVarStart [cl err]
2025/12/19 11:09:39 Val NewEx func(src any, filename string, line int, col int, params ...any) (ret github.com/goplus/xgo/tpl.Compiler, err error)
2025/12/19 11:09:39 Val &{0 STRING `expr = INT % ("+" | "-")`} *ast.BasicLit
2025/12/19 11:09:39 Val cl/_testgop/domaintext-tpl/in.xgo string
2025/12/19 11:09:39 Val 1 int
2025/12/19 11:09:39 Val 15 int
2025/12/19 11:09:39 Call 4 0 // func(src any, filename string, line int, col int, params ...any) (ret github.com/goplus/xgo/tpl.Compiler, err error)
2025/12/19 11:09:39 ==> MatchFuncCall func(src any, filename string, line int, col int, params ...any) (ret github.com/goplus/xgo/tpl.Compiler, err error) args: 4 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped string ("expr = INT % (\"+\" | \"-\")"), any
2025/12/19 11:09:39 ==> MatchType untyped string ("cl/_testgop/domaintext-tpl/in.xgo"), string
2025/12/19 11:09:39 ==> MatchType untyped int (1), int
2025/12/19 11:09:39 ==> MatchType untyped int (15), int
2025/12/19 11:09:39 EndInit 1
2025/12/19 11:09:39 Val cl github.com/goplus/xgo/tpl.Compiler
2025/12/19 11:09:39 Member parseExpr 1 // github.com/goplus/xgo/tpl.Compiler
2025/12/19 11:09:39 Val &{0 STRING "1+2"} *ast.BasicLit
2025/12/19 11:09:39 Val nil untyped nil
2025/12/19 11:09:39 Call 2 0 // func(x string, conf *github.com/goplus/xgo/tpl.Config) (result any, err error)
2025/12/19 11:09:39 ==> MatchFuncCall func(x string, conf *github.com/goplus/xgo/tpl.Config) (result any, err error) args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped string ("1+2"), string
2025/12/19 11:09:39 ==> MatchType untyped nil, *github.com/goplus/xgo/tpl.Config
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/tpl.Config
2025/12/19 11:09:39 VarRef _
2025/12/19 11:09:39 Val err error
2025/12/19 11:09:39 Assign 1 1
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> ASTFile
=== RUN   TestTestgop/domaintpl
2025/12/19 11:09:39 Parsing /app/cl/_testgop/domaintpl
2025/12/19 11:09:39 ==> Preload func main
2025/12/19 11:09:39 ==> Load func main
2025/12/19 11:09:39 NewFunc main func()
2025/12/19 11:09:39 Val NewEx func(src any, filename string, line int, col int, params ...any) (ret github.com/goplus/xgo/tpl.Compiler, err error)
2025/12/19 11:09:39 Val &{0 STRING `
file = stmts => {
	return self
}

stmts = *(stmt ";") => {
	return [n.([]any)[0] for n in self]
}

stmt = varStmt | constStmt | outputStmt | inputStmt | ifStmt | whileStmt | untilStmt | assignStmt

varStmt = "DECLARE" namelist ":" typeExpr

constStmt = "CONSTANT" IDENT "<-" expr

assignStmt = IDENT "<-" expr

outputStmt = "OUTPUT" exprlist

inputStmt = "INPUT" namelist

ifStmt = "IF" expr "THEN" ";" stmts ?("ELSE" ";" stmts) "ENDIF"

whileStmt = "WHILE" expr "DO" ";" stmts "ENDWHILE"

untilStmt = "REPEAT" ";" stmts "UNTIL" expr

typeExpr = "INTEGER" | "REAL" | "STRING" | "BOOLEAN"

expr = binaryExpr2 % ("<" | "<=" | ">" | ">=" | "=" | "<>")

binaryExpr2 = binaryExpr1 % ("+" | "-")

binaryExpr1 = operand % ("*" | "/")

operand = basicLit | ident | parenExpr | unaryExpr

unaryExpr = "-" operand

basicLit = INT | FLOAT | STRING

ident = IDENT

parenExpr = "(" expr ")"

exprlist = expr % ","

namelist = IDENT % ","
`} *ast.BasicLit
2025/12/19 11:09:39 Val cl/_testgop/domaintpl/in.xgo string
2025/12/19 11:09:39 Val 1 int
2025/12/19 11:09:39 Val 4 int
2025/12/19 11:09:39 Val file string
2025/12/19 11:09:39 NewClosure func(self interface{}) interface{}
2025/12/19 11:09:39 Val self interface{}
2025/12/19 11:09:39 Return 1
2025/12/19 11:09:39 ==> MatchType interface{}, interface{}
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 Val stmts string
2025/12/19 11:09:39 NewClosure func(self []interface{}) interface{}
2025/12/19 11:09:39 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:39 ForRange [_ n]
2025/12/19 11:09:39 Val self []interface{}
2025/12/19 11:09:39 RangeAssignThen
2025/12/19 11:09:39 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:39 Val append func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 Val _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:39 Val n interface{}
2025/12/19 11:09:39 TypeAssert []interface{} false
2025/12/19 11:09:39 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:39 Index 1 false
2025/12/19 11:09:39 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType unboundType{typ: <nil>}, []unboundFuncParam{typ: <nil>}
2025/12/19 11:09:39 ==> MatchType interface{}, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:39 Assign 1 1
2025/12/19 11:09:39 ==> MatchType []interface{}, unboundType{typ: <nil>}
2025/12/19 11:09:39 End // ForRange
2025/12/19 11:09:39 Return 0
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 Call 0 0 // func() (_xgo_ret []interface{})
2025/12/19 11:09:39 ==> MatchFuncCall func() (_xgo_ret []interface{}) args: 0 flags: 0
2025/12/19 11:09:39 Return 1
2025/12/19 11:09:39 ==> MatchType []interface{}, interface{}
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 Call 8 0 // func(src any, filename string, line int, col int, params ...any) (ret github.com/goplus/xgo/tpl.Compiler, err error)
2025/12/19 11:09:39 ==> MatchFuncCall func(src any, filename string, line int, col int, params ...any) (ret github.com/goplus/xgo/tpl.Compiler, err error) args: 8 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped string ("\nfile = stmts => {\n\treturn self\n}\n\nstmts = *(stmt \";\") => {\...), any
2025/12/19 11:09:39 ==> MatchType untyped string ("cl/_testgop/domaintpl/in.xgo"), string
2025/12/19 11:09:39 ==> MatchType untyped int (1), int
2025/12/19 11:09:39 ==> MatchType untyped int (4), int
2025/12/19 11:09:39 ==> MatchType untyped string ("file"), any
2025/12/19 11:09:39 ==> MatchType func(self interface{}) interface{}, any
2025/12/19 11:09:39 ==> MatchType untyped string ("stmts"), any
2025/12/19 11:09:39 ==> MatchType func(self []interface{}) interface{}, any
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> ASTFile
=== RUN   TestTestgop/enumlines-rdr
2025/12/19 11:09:39 Parsing /app/cl/_testgop/enumlines-rdr
2025/12/19 11:09:39 ==> Preload var [r]
2025/12/19 11:09:39 ==> Preload func main
2025/12/19 11:09:39 ==> Load var io.Reader [r]
2025/12/19 11:09:39 NewVarDefs
2025/12/19 11:09:39 NewVar [r]
2025/12/19 11:09:39 ==> Load func main
2025/12/19 11:09:39 NewFunc main func()
2025/12/19 11:09:39 ForRange [_ line]
2025/12/19 11:09:39 Val lines func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 Val r io.Reader
2025/12/19 11:09:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall func(r io.Reader) github.com/qiniu/x/osx.LineReader args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType io.Reader, io.Reader
2025/12/19 11:09:39 ==> EnsureLoaded io.Reader
2025/12/19 11:09:39 ==> EnsureLoaded io.Reader
2025/12/19 11:09:39 RangeAssignThen
2025/12/19 11:09:39 VBlock
2025/12/19 11:09:39 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 Val line string
2025/12/19 11:09:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType string, any
2025/12/19 11:09:39 End // Vblock
2025/12/19 11:09:39 End // ForRange
2025/12/19 11:09:39 Member Gop_Enum 0 // github.com/qiniu/x/osx.LineReader
2025/12/19 11:09:39 Call 0 0 // func() github.com/qiniu/x/osx.LineIter
2025/12/19 11:09:39 ==> MatchFuncCall func() github.com/qiniu/x/osx.LineIter args: 0 flags: 0
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> ASTFile
=== RUN   TestTestgop/enumlines-stdin
2025/12/19 11:09:39 Parsing /app/cl/_testgop/enumlines-stdin
2025/12/19 11:09:39 ==> Preload func main
2025/12/19 11:09:39 ==> Load func main
2025/12/19 11:09:39 NewFunc main func()
2025/12/19 11:09:39 ForRange [_ line]
2025/12/19 11:09:39 Val Stdin *os.File
2025/12/19 11:09:39 RangeAssignThen
2025/12/19 11:09:39 VBlock
2025/12/19 11:09:39 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 Val line string
2025/12/19 11:09:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType string, any
2025/12/19 11:09:39 End // Vblock
2025/12/19 11:09:39 End // ForRange
2025/12/19 11:09:39 Member Gop_Enum 0 // *os.File
2025/12/19 11:09:39 Val EnumLines func(r io.Reader) github.com/qiniu/x/osx.LineIter
2025/12/19 11:09:39 Call 1 0 // func(r io.Reader) github.com/qiniu/x/osx.LineIter
2025/12/19 11:09:39 ==> MatchFuncCall func(r io.Reader) github.com/qiniu/x/osx.LineIter args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType *os.File, io.Reader
2025/12/19 11:09:39 ==> EnsureLoaded io.Reader
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> ASTFile
=== RUN   TestTestgop/errwrap1
2025/12/19 11:09:39 Parsing /app/cl/_testgop/errwrap1
2025/12/19 11:09:39 ==> Preload func F
2025/12/19 11:09:39 ==> Preload func F2
2025/12/19 11:09:39 ==> Preload func main
2025/12/19 11:09:39 ==> Load func F
2025/12/19 11:09:39 NewFunc F func() (a int8, b int16, err error)
2025/12/19 11:09:39 VarRef a int8
2025/12/19 11:09:39 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:39 Assign 1 1
2025/12/19 11:09:39 ==> MatchType untyped int (1), int8
2025/12/19 11:09:39 Return 0
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> Load func F2
2025/12/19 11:09:39 NewFunc F2 func() (err error)
2025/12/19 11:09:39 DefineVarStart [c d]
2025/12/19 11:09:39 Val F func() (a int8, b int16, err error)
2025/12/19 11:09:39 Call 0 0 // func() (a int8, b int16, err error)
2025/12/19 11:09:39 ==> MatchFuncCall func() (a int8, b int16, err error) args: 0 flags: 0
2025/12/19 11:09:39 NewClosure func() (_xgo_ret unboundType{typ: <nil>}, _xgo_ret2 unboundType{typ: <nil>})
2025/12/19 11:09:39 NewVar [_xgo_err]
2025/12/19 11:09:39 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:39 VarRef _xgo_ret2 unboundType{typ: <nil>}
2025/12/19 11:09:39 VarRef _xgo_err error
2025/12/19 11:09:39 Assign 3 1
2025/12/19 11:09:39 ==> MatchType int8, unboundType{typ: <nil>}
2025/12/19 11:09:39 ==> MatchType int16, unboundType{typ: <nil>}
2025/12/19 11:09:39 ==> MatchType error, error
2025/12/19 11:09:39 ==> EnsureLoaded error
2025/12/19 11:09:39 ==> EnsureLoaded error
2025/12/19 11:09:39 If
2025/12/19 11:09:39 Val _xgo_err error
2025/12/19 11:09:39 Val <nil> <nil>
2025/12/19 11:09:39 BinaryOp !=
2025/12/19 11:09:39 Typ error
2025/12/19 11:09:39 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:39 Then
2025/12/19 11:09:39 VarRef _xgo_err error
2025/12/19 11:09:39 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:39 Val _xgo_err error
2025/12/19 11:09:39 Val F() string
2025/12/19 11:09:39 Val cl/_testgop/errwrap1/in.xgo string
2025/12/19 11:09:39 Val 7 int
2025/12/19 11:09:39 Val main.F2 string
2025/12/19 11:09:39 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:39 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/12/19 11:09:39 ==> MatchType error, error
2025/12/19 11:09:39 ==> EnsureLoaded error
2025/12/19 11:09:39 ==> EnsureLoaded error
2025/12/19 11:09:39 ==> MatchType untyped string ("F()"), string
2025/12/19 11:09:39 ==> MatchType untyped string ("cl/_testgop/errwrap1/in.xgo"), string
2025/12/19 11:09:39 ==> MatchType untyped int (7), int
2025/12/19 11:09:39 ==> MatchType untyped string ("main.F2"), string
2025/12/19 11:09:39 Assign 1 1
2025/12/19 11:09:39 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/12/19 11:09:39 ==> EnsureLoaded error
2025/12/19 11:09:39 Val panic func(v interface{})
2025/12/19 11:09:39 Val _xgo_err error
2025/12/19 11:09:39 Call 1 0 // func(v interface{})
2025/12/19 11:09:39 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType error, interface{}
2025/12/19 11:09:39 ==> EnsureLoaded error
2025/12/19 11:09:39 End // If
2025/12/19 11:09:39 Return 0
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 Call 0 0 // func() (_xgo_ret int8, _xgo_ret2 int16)
2025/12/19 11:09:39 ==> MatchFuncCall func() (_xgo_ret int8, _xgo_ret2 int16) args: 0 flags: 0
2025/12/19 11:09:39 EndInit 1
2025/12/19 11:09:39 VarRef _
2025/12/19 11:09:39 Val c int8
2025/12/19 11:09:39 Assign 1 1
2025/12/19 11:09:39 VarRef _
2025/12/19 11:09:39 Val d int16
2025/12/19 11:09:39 Assign 1 1
2025/12/19 11:09:39 Return 0
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> Load func main
2025/12/19 11:09:39 NewFunc main func()
2025/12/19 11:09:39 Val F2 func() (err error)
2025/12/19 11:09:39 Call 0 0 // func() (err error)
2025/12/19 11:09:39 ==> MatchFuncCall func() (err error) args: 0 flags: 0
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> ASTFile
=== RUN   TestTestgop/errwrap2
2025/12/19 11:09:39 Parsing /app/cl/_testgop/errwrap2
2025/12/19 11:09:39 ==> Preload func F
2025/12/19 11:09:39 ==> Preload func F2
2025/12/19 11:09:39 ==> Preload func main
2025/12/19 11:09:39 ==> Load func F
2025/12/19 11:09:39 NewFunc F func() (a int8, b int16, err error)
2025/12/19 11:09:39 VarRef a int8
2025/12/19 11:09:39 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:39 Assign 1 1
2025/12/19 11:09:39 ==> MatchType untyped int (1), int8
2025/12/19 11:09:39 Return 0
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> Load func F2
2025/12/19 11:09:39 NewFunc F2 func() (err error)
2025/12/19 11:09:39 DefineVarStart [c d]
2025/12/19 11:09:39 Val F func() (a int8, b int16, err error)
2025/12/19 11:09:39 Call 0 0 // func() (a int8, b int16, err error)
2025/12/19 11:09:39 ==> MatchFuncCall func() (a int8, b int16, err error) args: 0 flags: 0
2025/12/19 11:09:39 CallInlineClosureStart 0 false
2025/12/19 11:09:39 NewVar [_autoGo_1]
2025/12/19 11:09:39 NewVar [_autoGo_2]
2025/12/19 11:09:39 NewVar [_xgo_err]
2025/12/19 11:09:39 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:39 VarRef _xgo_ret2 unboundType{typ: <nil>}
2025/12/19 11:09:39 VarRef _xgo_err error
2025/12/19 11:09:39 Assign 3 1
2025/12/19 11:09:39 ==> MatchType int8, unboundType{typ: <nil>}
2025/12/19 11:09:39 ==> MatchType int16, unboundType{typ: <nil>}
2025/12/19 11:09:39 ==> MatchType error, error
2025/12/19 11:09:39 ==> EnsureLoaded error
2025/12/19 11:09:39 ==> EnsureLoaded error
2025/12/19 11:09:39 If
2025/12/19 11:09:39 Val _xgo_err error
2025/12/19 11:09:39 Val <nil> <nil>
2025/12/19 11:09:39 BinaryOp !=
2025/12/19 11:09:39 Typ error
2025/12/19 11:09:39 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:39 Then
2025/12/19 11:09:39 VarRef _xgo_err error
2025/12/19 11:09:39 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:39 Val _xgo_err error
2025/12/19 11:09:39 Val F() string
2025/12/19 11:09:39 Val cl/_testgop/errwrap2/in.xgo string
2025/12/19 11:09:39 Val 7 int
2025/12/19 11:09:39 Val main.F2 string
2025/12/19 11:09:39 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:39 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/12/19 11:09:39 ==> MatchType error, error
2025/12/19 11:09:39 ==> EnsureLoaded error
2025/12/19 11:09:39 ==> EnsureLoaded error
2025/12/19 11:09:39 ==> MatchType untyped string ("F()"), string
2025/12/19 11:09:39 ==> MatchType untyped string ("cl/_testgop/errwrap2/in.xgo"), string
2025/12/19 11:09:39 ==> MatchType untyped int (7), int
2025/12/19 11:09:39 ==> MatchType untyped string ("main.F2"), string
2025/12/19 11:09:39 Assign 1 1
2025/12/19 11:09:39 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/12/19 11:09:39 ==> EnsureLoaded error
2025/12/19 11:09:39 Val _xgo_err error
2025/12/19 11:09:39 ReturnErr true
2025/12/19 11:09:39 End // If
2025/12/19 11:09:39 Return 0
2025/12/19 11:09:39 Goto _autoGo_3
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 Label _autoGo_3
2025/12/19 11:09:39 EndInit 2
2025/12/19 11:09:39 VarRef _
2025/12/19 11:09:39 Val c int8
2025/12/19 11:09:39 Assign 1 1
2025/12/19 11:09:39 VarRef _
2025/12/19 11:09:39 Val d int16
2025/12/19 11:09:39 Assign 1 1
2025/12/19 11:09:39 Return 0
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> Load func main
2025/12/19 11:09:39 NewFunc main func()
2025/12/19 11:09:39 Val F2 func() (err error)
2025/12/19 11:09:39 Call 0 0 // func() (err error)
2025/12/19 11:09:39 ==> MatchFuncCall func() (err error) args: 0 flags: 0
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> ASTFile
=== RUN   TestTestgop/fatal
2025/12/19 11:09:39 Parsing /app/cl/_testgop/fatal
2025/12/19 11:09:39 ==> Preload func main
2025/12/19 11:09:39 ==> Load func main
2025/12/19 11:09:39 NewFunc main func()
2025/12/19 11:09:39 DefineVarStart [f err]
2025/12/19 11:09:39 Val Open func(name string) (*os.File, error)
2025/12/19 11:09:39 Val &{0 STRING "hello.txt"} *ast.BasicLit
2025/12/19 11:09:39 Call 1 2 // func(name string) (*os.File, error)
2025/12/19 11:09:39 ==> MatchFuncCall func(name string) (*os.File, error) args: 1 flags: 2
2025/12/19 11:09:39 ==> MatchType untyped string ("hello.txt"), string
2025/12/19 11:09:39 EndInit 1
2025/12/19 11:09:39 If
2025/12/19 11:09:39 Val err error
2025/12/19 11:09:39 Val nil untyped nil
2025/12/19 11:09:39 BinaryOp !=
2025/12/19 11:09:39 Typ error
2025/12/19 11:09:39 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:39 Then
2025/12/19 11:09:39 Val errorln func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 Val &{0 STRING "[WARN] an error"} *ast.BasicLit
2025/12/19 11:09:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall func(args ...any) args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped string ("[WARN] an error"), any
2025/12/19 11:09:39 Val fatal func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 Val Concat func(parts ...string) string
2025/12/19 11:09:39 Val &{0 STRING "open file failed: "} *ast.BasicLit
2025/12/19 11:09:39 Val err error
2025/12/19 11:09:39 Member string 2 // error
2025/12/19 11:09:39 Member error 2 // error
2025/12/19 11:09:39 Call 0 0 // func() string
2025/12/19 11:09:39 ==> MatchFuncCall func() string args: 0 flags: 0
2025/12/19 11:09:39 Call 2 0 // func(parts ...string) string
2025/12/19 11:09:39 ==> MatchFuncCall func(parts ...string) string args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped string ("open file failed: "), string
2025/12/19 11:09:39 ==> MatchType string, string
2025/12/19 11:09:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall func(args ...any) args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType string, any
2025/12/19 11:09:39 End // If
2025/12/19 11:09:39 Val f *os.File
2025/12/19 11:09:39 Member close 1 // *os.File
2025/12/19 11:09:39 Call 0 0 // func() error
2025/12/19 11:09:39 ==> MatchFuncCall func() error args: 0 flags: 0
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> ASTFile
=== RUN   TestTestgop/implicit-cast-2439
2025/12/19 11:09:39 Parsing /app/cl/_testgop/implicit-cast-2439
2025/12/19 11:09:39 ==> Preload type BasePtr
2025/12/19 11:09:39 ==> Preload type Base
2025/12/19 11:09:39 ==> Preload func Walk
2025/12/19 11:09:39 ==> Preload func WalkPtr
2025/12/19 11:09:39 ==> Preload type T
2025/12/19 11:09:39 ==> Preload func f
2025/12/19 11:09:39 ==> Preload func main
2025/12/19 11:09:39 ==> Load > NewType BasePtr
2025/12/19 11:09:39 NewType BasePtr
2025/12/19 11:09:39 ==> Load > InitType BasePtr
2025/12/19 11:09:39 InitType BasePtr struct{}
2025/12/19 11:09:39 ==> Load > NewType Base
2025/12/19 11:09:39 NewType Base
2025/12/19 11:09:39 ==> Load > InitType Base
2025/12/19 11:09:39 ==> LookupParent BasePtr => type github.com/goplus/xgo/cl.BasePtr struct{}
2025/12/19 11:09:39 InitType Base struct{*github.com/goplus/xgo/cl.BasePtr}
2025/12/19 11:09:39 ==> Load func Walk
2025/12/19 11:09:39 ==> LookupParent Base => type github.com/goplus/xgo/cl.Base struct{*github.com/goplus/xgo/cl.BasePtr}
2025/12/19 11:09:39 NewFunc Walk func(p *github.com/goplus/xgo/cl.Base)
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> Load func WalkPtr
2025/12/19 11:09:39 ==> LookupParent BasePtr => type github.com/goplus/xgo/cl.BasePtr struct{}
2025/12/19 11:09:39 NewFunc WalkPtr func(p *github.com/goplus/xgo/cl.BasePtr)
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> Load > NewType T
2025/12/19 11:09:39 NewType T
2025/12/19 11:09:39 ==> Load > InitType T
2025/12/19 11:09:39 ==> LookupParent Base => type github.com/goplus/xgo/cl.Base struct{*github.com/goplus/xgo/cl.BasePtr}
2025/12/19 11:09:39 InitType T struct{github.com/goplus/xgo/cl.Base}
2025/12/19 11:09:39 ==> Load func f
2025/12/19 11:09:39 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{github.com/goplus/xgo/cl.Base}
2025/12/19 11:09:39 NewFunc f func() *github.com/goplus/xgo/cl.T
2025/12/19 11:09:39 StructLit github.com/goplus/xgo/cl.T 0 false
2025/12/19 11:09:39 UnaryOp & flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:39 Return 1
2025/12/19 11:09:39 ==> MatchType *github.com/goplus/xgo/cl.T, *github.com/goplus/xgo/cl.T
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl.T
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl.T
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> Load func main
2025/12/19 11:09:39 NewFunc main func()
2025/12/19 11:09:39 Val Walk func(p *github.com/goplus/xgo/cl.Base)
2025/12/19 11:09:39 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:39 Val T github.com/goplus/xgo/cl.T
2025/12/19 11:09:39 Val type github.com/goplus/xgo/cl.T struct{github.com/goplus/xgo/cl.Base} => Typ github.com/goplus/xgo/cl.T
2025/12/19 11:09:39 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:39 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:39 Call 1 0 // func(p *github.com/goplus/xgo/cl.Base)
2025/12/19 11:09:39 ==> MatchFuncCall func(p *github.com/goplus/xgo/cl.Base) args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType *github.com/goplus/xgo/cl.T, *github.com/goplus/xgo/cl.Base
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl.T
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl.Base
2025/12/19 11:09:39 Val WalkPtr func(p *github.com/goplus/xgo/cl.BasePtr)
2025/12/19 11:09:39 Val f func() *github.com/goplus/xgo/cl.T
2025/12/19 11:09:39 Call 0 0 // func() *github.com/goplus/xgo/cl.T
2025/12/19 11:09:39 ==> MatchFuncCall func() *github.com/goplus/xgo/cl.T args: 0 flags: 0
2025/12/19 11:09:39 Call 1 0 // func(p *github.com/goplus/xgo/cl.BasePtr)
2025/12/19 11:09:39 ==> MatchFuncCall func(p *github.com/goplus/xgo/cl.BasePtr) args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType *github.com/goplus/xgo/cl.T, *github.com/goplus/xgo/cl.BasePtr
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl.T
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl.BasePtr
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> ASTFile
=== RUN   TestTestgop/kwargs1
2025/12/19 11:09:39 Parsing /app/cl/_testgop/kwargs1
2025/12/19 11:09:39 ==> Preload type Options
2025/12/19 11:09:39 ==> Preload func PlaySound
2025/12/19 11:09:39 ==> Preload func main
2025/12/19 11:09:39 ==> Load > NewType Options
2025/12/19 11:09:39 NewType Options
2025/12/19 11:09:39 ==> Load > InitType Options
2025/12/19 11:09:39 InitType Options struct{Loop bool; async bool}
2025/12/19 11:09:39 ==> Load func PlaySound
2025/12/19 11:09:39 ==> LookupParent Options => type github.com/goplus/xgo/cl.Options struct{Loop bool; async bool}
2025/12/19 11:09:39 NewFunc PlaySound func(path string, options *github.com/goplus/xgo/cl.Options)
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> Load func main
2025/12/19 11:09:39 NewFunc main func()
2025/12/19 11:09:39 Val PlaySound func(path string, options *github.com/goplus/xgo/cl.Options)
2025/12/19 11:09:39 Val &{0 STRING "1.mp3"} *ast.BasicLit
2025/12/19 11:09:39 Val 0 int
2025/12/19 11:09:39 Val true untyped bool
2025/12/19 11:09:39 StructLit github.com/goplus/xgo/cl.Options 2 true
2025/12/19 11:09:39 UnaryOp & flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:39 Call 2 0 // func(path string, options *github.com/goplus/xgo/cl.Options)
2025/12/19 11:09:39 ==> MatchFuncCall func(path string, options *github.com/goplus/xgo/cl.Options) args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped string ("1.mp3"), string
2025/12/19 11:09:39 ==> MatchType *github.com/goplus/xgo/cl.Options, *github.com/goplus/xgo/cl.Options
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/12/19 11:09:39 Val PlaySound func(path string, options *github.com/goplus/xgo/cl.Options)
2025/12/19 11:09:39 Val &{0 STRING "2.mp3"} *ast.BasicLit
2025/12/19 11:09:39 Val 0 int
2025/12/19 11:09:39 Val false untyped bool
2025/12/19 11:09:39 Val 1 int
2025/12/19 11:09:39 Val true untyped bool
2025/12/19 11:09:39 StructLit github.com/goplus/xgo/cl.Options 4 true
2025/12/19 11:09:39 UnaryOp & flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:39 Call 2 0 // func(path string, options *github.com/goplus/xgo/cl.Options)
2025/12/19 11:09:39 ==> MatchFuncCall func(path string, options *github.com/goplus/xgo/cl.Options) args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped string ("2.mp3"), string
2025/12/19 11:09:39 ==> MatchType *github.com/goplus/xgo/cl.Options, *github.com/goplus/xgo/cl.Options
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> ASTFile
=== RUN   TestTestgop/kwargs2
2025/12/19 11:09:39 Parsing /app/cl/_testgop/kwargs2
2025/12/19 11:09:39 ==> Preload type Options
2025/12/19 11:09:39 ==> Preload func PlaySound
2025/12/19 11:09:39 ==> Preload func main
2025/12/19 11:09:39 ==> Load > NewType Options
2025/12/19 11:09:39 NewType Options
2025/12/19 11:09:39 ==> Load > InitType Options
2025/12/19 11:09:39 InitType Options struct{Loop bool; async bool}
2025/12/19 11:09:39 ==> Load func PlaySound
2025/12/19 11:09:39 ==> LookupParent Options => type github.com/goplus/xgo/cl.Options struct{Loop bool; async bool}
2025/12/19 11:09:39 NewFunc PlaySound func(path string, options github.com/goplus/xgo/cl.Options)
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> Load func main
2025/12/19 11:09:39 NewFunc main func()
2025/12/19 11:09:39 Val PlaySound func(path string, options github.com/goplus/xgo/cl.Options)
2025/12/19 11:09:39 Val &{0 STRING "1.mp3"} *ast.BasicLit
2025/12/19 11:09:39 Val 0 int
2025/12/19 11:09:39 Val true untyped bool
2025/12/19 11:09:39 StructLit github.com/goplus/xgo/cl.Options 2 true
2025/12/19 11:09:39 Call 2 0 // func(path string, options github.com/goplus/xgo/cl.Options)
2025/12/19 11:09:39 ==> MatchFuncCall func(path string, options github.com/goplus/xgo/cl.Options) args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped string ("1.mp3"), string
2025/12/19 11:09:39 ==> MatchType github.com/goplus/xgo/cl.Options, github.com/goplus/xgo/cl.Options
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/12/19 11:09:39 Val PlaySound func(path string, options github.com/goplus/xgo/cl.Options)
2025/12/19 11:09:39 Val &{0 STRING "2.mp3"} *ast.BasicLit
2025/12/19 11:09:39 Val 0 int
2025/12/19 11:09:39 Val false untyped bool
2025/12/19 11:09:39 Val 1 int
2025/12/19 11:09:39 Val true untyped bool
2025/12/19 11:09:39 StructLit github.com/goplus/xgo/cl.Options 4 true
2025/12/19 11:09:39 Call 2 0 // func(path string, options github.com/goplus/xgo/cl.Options)
2025/12/19 11:09:39 ==> MatchFuncCall func(path string, options github.com/goplus/xgo/cl.Options) args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped string ("2.mp3"), string
2025/12/19 11:09:39 ==> MatchType github.com/goplus/xgo/cl.Options, github.com/goplus/xgo/cl.Options
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> ASTFile
=== RUN   TestTestgop/kwargs3
2025/12/19 11:09:39 Parsing /app/cl/_testgop/kwargs3
2025/12/19 11:09:39 ==> Preload type Options
2025/12/19 11:09:39 ==> Preload func PlaySound
2025/12/19 11:09:39 ==> Preload func main
2025/12/19 11:09:39 ==> Load > NewType Options
2025/12/19 11:09:39 NewType Options
2025/12/19 11:09:39 ==> Load > InitType Options
2025/12/19 11:09:39 InitType Options map[string]bool
2025/12/19 11:09:39 ==> Load func PlaySound
2025/12/19 11:09:39 ==> LookupParent Options => type github.com/goplus/xgo/cl.Options map[string]bool
2025/12/19 11:09:39 NewFunc PlaySound func(options github.com/goplus/xgo/cl.Options, paths ...string)
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> Load func main
2025/12/19 11:09:39 NewFunc main func()
2025/12/19 11:09:39 Val PlaySound func(options github.com/goplus/xgo/cl.Options, paths ...string)
2025/12/19 11:09:39 Val &{0 STRING "loop"} *ast.BasicLit
2025/12/19 11:09:39 Val false untyped bool
2025/12/19 11:09:39 MapLit github.com/goplus/xgo/cl.Options 2
2025/12/19 11:09:39 Val &{0 STRING "1.mp3"} *ast.BasicLit
2025/12/19 11:09:39 Val &{0 STRING "foo.wav"} *ast.BasicLit
2025/12/19 11:09:39 Call 3 0 // func(options github.com/goplus/xgo/cl.Options, paths ...string)
2025/12/19 11:09:39 ==> MatchFuncCall func(options github.com/goplus/xgo/cl.Options, paths ...string) args: 3 flags: 0
2025/12/19 11:09:39 ==> MatchType github.com/goplus/xgo/cl.Options, github.com/goplus/xgo/cl.Options
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/12/19 11:09:39 ==> MatchType untyped string ("1.mp3"), string
2025/12/19 11:09:39 ==> MatchType untyped string ("foo.wav"), string
2025/12/19 11:09:39 Val PlaySound func(options github.com/goplus/xgo/cl.Options, paths ...string)
2025/12/19 11:09:39 Val &{0 STRING "loop"} *ast.BasicLit
2025/12/19 11:09:39 Val true untyped bool
2025/12/19 11:09:39 Val &{0 STRING "async"} *ast.BasicLit
2025/12/19 11:09:39 Val true untyped bool
2025/12/19 11:09:39 MapLit github.com/goplus/xgo/cl.Options 4
2025/12/19 11:09:39 Val &{0 STRING "2.mp3"} *ast.BasicLit
2025/12/19 11:09:39 Call 2 0 // func(options github.com/goplus/xgo/cl.Options, paths ...string)
2025/12/19 11:09:39 ==> MatchFuncCall func(options github.com/goplus/xgo/cl.Options, paths ...string) args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType github.com/goplus/xgo/cl.Options, github.com/goplus/xgo/cl.Options
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl.Options
2025/12/19 11:09:39 ==> MatchType untyped string ("2.mp3"), string
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> ASTFile
=== RUN   TestTestgop/kwargs4
2025/12/19 11:09:39 Parsing /app/cl/_testgop/kwargs4
2025/12/19 11:09:39 ==> Preload func PlaySound
2025/12/19 11:09:39 ==> Preload func main
2025/12/19 11:09:39 ==> Load func PlaySound
2025/12/19 11:09:39 NewFunc PlaySound func(path string, options *github.com/goplus/xgo/cl/internal/testutil.Options)
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> Load func main
2025/12/19 11:09:39 NewFunc main func()
2025/12/19 11:09:39 Val PlaySound func(path string, options *github.com/goplus/xgo/cl/internal/testutil.Options)
2025/12/19 11:09:39 Val &{0 STRING "1.mp3"} *ast.BasicLit
2025/12/19 11:09:39 Val 0 int
2025/12/19 11:09:39 Val true untyped bool
2025/12/19 11:09:39 StructLit github.com/goplus/xgo/cl/internal/testutil.Options 2 true
2025/12/19 11:09:39 UnaryOp & flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:39 Call 2 0 // func(path string, options *github.com/goplus/xgo/cl/internal/testutil.Options)
2025/12/19 11:09:39 ==> MatchFuncCall func(path string, options *github.com/goplus/xgo/cl/internal/testutil.Options) args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped string ("1.mp3"), string
2025/12/19 11:09:39 ==> MatchType *github.com/goplus/xgo/cl/internal/testutil.Options, *github.com/goplus/xgo/cl/internal/testutil.Options
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/testutil.Options
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/testutil.Options
2025/12/19 11:09:39 Val PlaySound func(path string, options *github.com/goplus/xgo/cl/internal/testutil.Options)
2025/12/19 11:09:39 Val &{0 STRING "2.mp3"} *ast.BasicLit
2025/12/19 11:09:39 Val 0 int
2025/12/19 11:09:39 Val false untyped bool
2025/12/19 11:09:39 Val 1 int
2025/12/19 11:09:39 Val true untyped bool
2025/12/19 11:09:39 StructLit github.com/goplus/xgo/cl/internal/testutil.Options 4 true
2025/12/19 11:09:39 UnaryOp & flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:39 Call 2 0 // func(path string, options *github.com/goplus/xgo/cl/internal/testutil.Options)
2025/12/19 11:09:39 ==> MatchFuncCall func(path string, options *github.com/goplus/xgo/cl/internal/testutil.Options) args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped string ("2.mp3"), string
2025/12/19 11:09:39 ==> MatchType *github.com/goplus/xgo/cl/internal/testutil.Options, *github.com/goplus/xgo/cl/internal/testutil.Options
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/testutil.Options
2025/12/19 11:09:39 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/testutil.Options
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> ASTFile
=== RUN   TestTestgop/optparam
2025/12/19 11:09:39 Parsing /app/cl/_testgop/optparam
2025/12/19 11:09:39 ==> Preload func basic
2025/12/19 11:09:39 ==> Preload func multiple
2025/12/19 11:09:39 ==> Preload func allOptional
2025/12/19 11:09:39 ==> Preload func withVariadic
2025/12/19 11:09:39 ==> Preload type Server
2025/12/19 11:09:39 ==> Preload method Server.handle
2025/12/19 11:09:39 ==> Preload func main
2025/12/19 11:09:39 ==> Load func basic
2025/12/19 11:09:39 NewFunc basic func(a int, b int)
2025/12/19 11:09:39 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 Val a int
2025/12/19 11:09:39 Val b int
2025/12/19 11:09:39 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType int, any
2025/12/19 11:09:39 ==> MatchType int, any
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> Load func multiple
2025/12/19 11:09:39 NewFunc multiple func(name string, age int, active bool)
2025/12/19 11:09:39 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 Val name string
2025/12/19 11:09:39 Val age int
2025/12/19 11:09:39 Val active bool
2025/12/19 11:09:39 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 3 flags: 0
2025/12/19 11:09:39 ==> MatchType string, any
2025/12/19 11:09:39 ==> MatchType int, any
2025/12/19 11:09:39 ==> MatchType bool, any
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> Load func allOptional
2025/12/19 11:09:39 NewFunc allOptional func(x int, y string)
2025/12/19 11:09:39 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 Val x int
2025/12/19 11:09:39 Val y string
2025/12/19 11:09:39 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType int, any
2025/12/19 11:09:39 ==> MatchType string, any
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> Load func withVariadic
2025/12/19 11:09:39 NewFunc withVariadic func(a int, b ...string)
2025/12/19 11:09:39 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 Val a int
2025/12/19 11:09:39 Val b []string
2025/12/19 11:09:39 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType int, any
2025/12/19 11:09:39 ==> MatchType []string, any
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> Load > NewType Server
2025/12/19 11:09:39 NewType Server
2025/12/19 11:09:39 ==> Load > InitType Server
2025/12/19 11:09:39 InitType Server struct{}
2025/12/19 11:09:39 ==> LookupParent Server => type github.com/goplus/xgo/cl.Server struct{}
2025/12/19 11:09:39 ==> Load method *github.com/goplus/xgo/cl.Server.handle
2025/12/19 11:09:39 ==> Load func main
2025/12/19 11:09:39 NewFunc main func()
2025/12/19 11:09:39 Val basic func(a int, b int)
2025/12/19 11:09:39 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:39 Val &{0 INT 20} *ast.BasicLit
2025/12/19 11:09:39 Call 2 0 // func(a int, b int)
2025/12/19 11:09:39 ==> MatchFuncCall func(a int, b int) args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped int (10), int
2025/12/19 11:09:39 ==> MatchType untyped int (20), int
2025/12/19 11:09:39 Val multiple func(name string, age int, active bool)
2025/12/19 11:09:39 Val &{0 STRING "Alice"} *ast.BasicLit
2025/12/19 11:09:39 Val &{0 INT 30} *ast.BasicLit
2025/12/19 11:09:39 Val true untyped bool
2025/12/19 11:09:39 Call 3 0 // func(name string, age int, active bool)
2025/12/19 11:09:39 ==> MatchFuncCall func(name string, age int, active bool) args: 3 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped string ("Alice"), string
2025/12/19 11:09:39 ==> MatchType untyped int (30), int
2025/12/19 11:09:39 ==> MatchType untyped bool (true), bool
2025/12/19 11:09:39 Val allOptional func(x int, y string)
2025/12/19 11:09:39 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:39 Val &{0 STRING "test"} *ast.BasicLit
2025/12/19 11:09:39 Call 2 0 // func(x int, y string)
2025/12/19 11:09:39 ==> MatchFuncCall func(x int, y string) args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped int (100), int
2025/12/19 11:09:39 ==> MatchType untyped string ("test"), string
2025/12/19 11:09:39 Val withVariadic func(a int, b ...string)
2025/12/19 11:09:39 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:39 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:39 Val &{0 STRING "world"} *ast.BasicLit
2025/12/19 11:09:39 Call 3 0 // func(a int, b ...string)
2025/12/19 11:09:39 ==> MatchFuncCall func(a int, b ...string) args: 3 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped int (5), int
2025/12/19 11:09:39 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:39 ==> MatchType untyped string ("world"), string
2025/12/19 11:09:39 DefineVarStart [s]
2025/12/19 11:09:39 ==> LookupParent Server => type github.com/goplus/xgo/cl.Server struct{}
2025/12/19 11:09:39 StructLit github.com/goplus/xgo/cl.Server 0 false
2025/12/19 11:09:39 EndInit 1
2025/12/19 11:09:39 Val s github.com/goplus/xgo/cl.Server
2025/12/19 11:09:39 Member handle 1 // github.com/goplus/xgo/cl.Server
2025/12/19 11:09:39 Val &{0 STRING "request"} *ast.BasicLit
2025/12/19 11:09:39 Val &{0 INT 42} *ast.BasicLit
2025/12/19 11:09:39 Call 2 0 // func(req string, opts int)
2025/12/19 11:09:39 ==> MatchFuncCall func(req string, opts int) args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped string ("request"), string
2025/12/19 11:09:39 ==> MatchType untyped int (42), int
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 NewFunc handle (*github.com/goplus/xgo/cl.Server) func(req string, opts int)
2025/12/19 11:09:39 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 Val req string
2025/12/19 11:09:39 Val opts int
2025/12/19 11:09:39 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType string, any
2025/12/19 11:09:39 ==> MatchType int, any
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> ASTFile
=== RUN   TestTestgop/optparam2
2025/12/19 11:09:39 Parsing /app/cl/_testgop/optparam2
2025/12/19 11:09:39 ==> Preload func returnValue
2025/12/19 11:09:39 ==> Preload func useInExpression
2025/12/19 11:09:39 ==> Preload func simpleNested
2025/12/19 11:09:39 ==> Preload func main
2025/12/19 11:09:39 ==> Load func returnValue
2025/12/19 11:09:39 NewFunc returnValue func(x int) int
2025/12/19 11:09:39 Val x int
2025/12/19 11:09:39 Return 1
2025/12/19 11:09:39 ==> MatchType int, int
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> Load func useInExpression
2025/12/19 11:09:39 NewFunc useInExpression func(a int, b int) int
2025/12/19 11:09:39 DefineVarStart [result]
2025/12/19 11:09:39 Val a int
2025/12/19 11:09:39 Val b int
2025/12/19 11:09:39 BinaryOp +
2025/12/19 11:09:39 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:39 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:39 EndInit 1
2025/12/19 11:09:39 Val result int
2025/12/19 11:09:39 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:39 BinaryOp *
2025/12/19 11:09:39 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:39 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/12/19 11:09:39 Return 1
2025/12/19 11:09:39 ==> MatchType int, int
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> Load func simpleNested
2025/12/19 11:09:39 NewFunc simpleNested func(outer int)
2025/12/19 11:09:39 DefineVarStart [f]
2025/12/19 11:09:39 NewClosure func()
2025/12/19 11:09:39 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 Val outer int
2025/12/19 11:09:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType int, any
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 EndInit 1
2025/12/19 11:09:39 Val f func()
2025/12/19 11:09:39 Call 0 0 // func()
2025/12/19 11:09:39 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> Load func main
2025/12/19 11:09:39 NewFunc main func()
2025/12/19 11:09:39 Val returnValue func(x int) int
2025/12/19 11:09:39 Val &{0 INT 42} *ast.BasicLit
2025/12/19 11:09:39 Call 1 0 // func(x int) int
2025/12/19 11:09:39 ==> MatchFuncCall func(x int) int args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped int (42), int
2025/12/19 11:09:39 Val useInExpression func(a int, b int) int
2025/12/19 11:09:39 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:39 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:39 Call 2 0 // func(a int, b int) int
2025/12/19 11:09:39 ==> MatchFuncCall func(a int, b int) int args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped int (10), int
2025/12/19 11:09:39 ==> MatchType untyped int (5), int
2025/12/19 11:09:39 Val simpleNested func(outer int)
2025/12/19 11:09:39 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:39 Call 1 0 // func(outer int)
2025/12/19 11:09:39 ==> MatchFuncCall func(outer int) args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped int (100), int
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> ASTFile
=== RUN   TestTestgop/rangeexpr
2025/12/19 11:09:39 Parsing /app/cl/_testgop/rangeexpr
2025/12/19 11:09:39 ==> Preload func main
2025/12/19 11:09:39 ==> Load func main
2025/12/19 11:09:39 NewFunc main func()
2025/12/19 11:09:39 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:39 ForRange [_ x]
2025/12/19 11:09:39 Val newRange func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:39 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:39 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:39 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall func(start int, end int, step int) *github.com/qiniu/x/xgo.IntRange args: 3 flags: 0
2025/12/19 11:09:39 ==> MatchType untyped int (0), int
2025/12/19 11:09:39 ==> MatchType untyped int (3), int
2025/12/19 11:09:39 ==> MatchType untyped int (1), int
2025/12/19 11:09:39 RangeAssignThen
2025/12/19 11:09:39 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:39 Val append func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 Val _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:39 Val x int
2025/12/19 11:09:39 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType unboundType{typ: <nil>}, []unboundFuncParam{typ: <nil>}
2025/12/19 11:09:39 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:39 Assign 1 1
2025/12/19 11:09:39 ==> MatchType []int, unboundType{typ: <nil>}
2025/12/19 11:09:39 End // ForRange
2025/12/19 11:09:39 Member Gop_Enum 0 // *github.com/qiniu/x/xgo.IntRange
2025/12/19 11:09:39 Call 0 0 // func() *github.com/qiniu/x/xgo.intRangeIter
2025/12/19 11:09:39 ==> MatchFuncCall func() *github.com/qiniu/x/xgo.intRangeIter args: 0 flags: 0
2025/12/19 11:09:39 Return 0
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 Call 0 0 // func() (_xgo_ret []int)
2025/12/19 11:09:39 ==> MatchFuncCall func() (_xgo_ret []int) args: 0 flags: 0
2025/12/19 11:09:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType []int, any
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> ASTFile
=== RUN   TestTestgop/repeatuntil
2025/12/19 11:09:39 Parsing /app/cl/_testgop/repeatuntil
2025/12/19 11:09:39 ==> Preload func RepeatUntil
2025/12/19 11:09:39 ==> Preload func main
2025/12/19 11:09:39 ==> Load func RepeatUntil
2025/12/19 11:09:39 NewFunc RepeatUntil func(cond func() bool, body func())
2025/12/19 11:09:39 For
2025/12/19 11:09:39 Val cond func() bool
2025/12/19 11:09:39 Call 0 0 // func() bool
2025/12/19 11:09:39 ==> MatchFuncCall func() bool args: 0 flags: 0
2025/12/19 11:09:39 UnaryOp ! flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType bool, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:39 Then
2025/12/19 11:09:39 Val body func()
2025/12/19 11:09:39 Call 0 0 // func()
2025/12/19 11:09:39 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:39 End // For
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> Load func main
2025/12/19 11:09:39 NewFunc main func()
2025/12/19 11:09:39 DefineVarStart [x]
2025/12/19 11:09:39 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:39 EndInit 1
2025/12/19 11:09:39 Val RepeatUntil func(cond func() bool, body func())
2025/12/19 11:09:39 Val x int
2025/12/19 11:09:39 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:39 BinaryOp >=
2025/12/19 11:09:39 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:39 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/12/19 11:09:39 NewClosure func() bool
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 NewClosure func()
2025/12/19 11:09:39 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 Val x int
2025/12/19 11:09:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType int, any
2025/12/19 11:09:39 VarRef x int
2025/12/19 11:09:39 IncDec ++
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 Call 2 0 // func(cond func() bool, body func())
2025/12/19 11:09:39 ==> MatchFuncCall func(cond func() bool, body func()) args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType func() bool, func() bool
2025/12/19 11:09:39 ==> MatchType func(), func()
2025/12/19 11:09:39 Val RepeatUntil func(cond func() bool, body func())
2025/12/19 11:09:39 NewClosure func() bool
2025/12/19 11:09:39 Val false untyped bool
2025/12/19 11:09:39 Return 1
2025/12/19 11:09:39 ==> MatchType untyped bool (false), bool
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 NewClosure func()
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 Call 2 0 // func(cond func() bool, body func())
2025/12/19 11:09:39 ==> MatchFuncCall func(cond func() bool, body func()) args: 2 flags: 0
2025/12/19 11:09:39 ==> MatchType func() bool, func() bool
2025/12/19 11:09:39 ==> MatchType func(), func()
2025/12/19 11:09:39 End // Func
2025/12/19 11:09:39 ==> ASTFile
=== RUN   TestTestgop/unit
2025/12/19 11:09:39 Parsing /app/cl/_testgop/unit
2025/12/19 11:09:40 ==> Preload func Wait
2025/12/19 11:09:40 ==> Preload func Step
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func Wait
2025/12/19 11:09:40 NewFunc Wait func(time.Duration)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load func Step
2025/12/19 11:09:40 NewFunc Step func(github.com/goplus/xgo/cl/internal/unit.Distance)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 Val Wait func(time.Duration)
2025/12/19 11:09:40 ValWithUnit 0.5 time.Duration s
2025/12/19 11:09:40 Val &{0xc0006722c0 time.Duration 500 0xc000672260} *internal.Elem
2025/12/19 11:09:40 Call 1 0 // func(time.Duration)
2025/12/19 11:09:40 ==> MatchFuncCall func(time.Duration) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType time.Duration (500), time.Duration
2025/12/19 11:09:40 Val Wait func(time.Duration)
2025/12/19 11:09:40 ValWithUnit 1 time.Duration m
2025/12/19 11:09:40 Val &{0xc000672340 time.Duration 60000000000 0xc000672300} *internal.Elem
2025/12/19 11:09:40 Call 1 0 // func(time.Duration)
2025/12/19 11:09:40 ==> MatchFuncCall func(time.Duration) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType time.Duration (60000000000), time.Duration
2025/12/19 11:09:40 Val Step func(github.com/goplus/xgo/cl/internal/unit.Distance)
2025/12/19 11:09:40 ValWithUnit 1 github.com/goplus/xgo/cl/internal/unit.Distance m
2025/12/19 11:09:40 Val &{0xc0006723c0 github.com/goplus/xgo/cl/internal/unit.Distance 1000 0xc0006723a0} *internal.Elem
2025/12/19 11:09:40 Call 1 0 // func(github.com/goplus/xgo/cl/internal/unit.Distance)
2025/12/19 11:09:40 ==> MatchFuncCall func(github.com/goplus/xgo/cl/internal/unit.Distance) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl/internal/unit.Distance (1000), github.com/goplus/xgo/cl/internal/unit.Distance
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/unit.Distance
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/unit.Distance
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestTestgop (9.87s)
    --- PASS: TestTestgop/append1 (0.00s)
    --- PASS: TestTestgop/append2 (0.00s)
    --- PASS: TestTestgop/cap (0.00s)
    --- PASS: TestTestgop/domaintext-html (2.29s)
    --- PASS: TestTestgop/domaintext-huh (0.04s)
    --- PASS: TestTestgop/domaintext-json (0.16s)
    --- PASS: TestTestgop/domaintext-md (6.52s)
    --- PASS: TestTestgop/domaintext-regexp (0.14s)
    --- PASS: TestTestgop/domaintext-tpl (0.38s)
    --- PASS: TestTestgop/domaintpl (0.00s)
    --- PASS: TestTestgop/enumlines-rdr (0.12s)
    --- PASS: TestTestgop/enumlines-stdin (0.00s)
    --- PASS: TestTestgop/errwrap1 (0.00s)
    --- PASS: TestTestgop/errwrap2 (0.00s)
    --- PASS: TestTestgop/fatal (0.00s)
    --- PASS: TestTestgop/implicit-cast-2439 (0.00s)
    --- PASS: TestTestgop/kwargs1 (0.00s)
    --- PASS: TestTestgop/kwargs2 (0.00s)
    --- PASS: TestTestgop/kwargs3 (0.00s)
    --- PASS: TestTestgop/kwargs4 (0.04s)
    --- PASS: TestTestgop/optparam (0.00s)
    --- PASS: TestTestgop/optparam2 (0.00s)
    --- PASS: TestTestgop/rangeexpr (0.00s)
    --- PASS: TestTestgop/repeatuntil (0.00s)
    --- PASS: TestTestgop/unit (0.15s)
=== RUN   TestTestc
=== RUN   TestTestc/hello
2025/12/19 11:09:40 Parsing /app/cl/_testc/hello
2025/12/19 11:09:40 PkgHash: unexpected package - github.com/goplus/lib/c
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 Val Printf func(format *int8, __llgo_va_list ...any) int32
2025/12/19 11:09:40 Val Str func(string) *int8
2025/12/19 11:09:40 Val Hello, world!
 string
2025/12/19 11:09:40 Call 1 0 // func(string) *int8
2025/12/19 11:09:40 ==> MatchFuncCall func(string) *int8 args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("Hello, world!\n"), string
2025/12/19 11:09:40 Call 1 0 // func(format *int8, __llgo_va_list ...any) int32
2025/12/19 11:09:40 ==> MatchFuncCall func(format *int8, __llgo_va_list ...any) int32 args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType *int8, *int8
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestTestc (0.02s)
    --- PASS: TestTestc/hello (0.02s)
=== RUN   TestTestpy
=== RUN   TestTestpy/hello
2025/12/19 11:09:40 Parsing /app/cl/_testpy/hello
2025/12/19 11:09:40 PkgHash: unexpected package - github.com/goplus/lib/py/std
2025/12/19 11:09:40 PkgHash: unexpected package - github.com/goplus/lib/c
2025/12/19 11:09:40 PkgHash: unexpected package - github.com/goplus/lib/py
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 Val Print func(__llgo_va_list ...interface{}) *github.com/goplus/lib/py.Object
2025/12/19 11:09:40 PkgHash: unexpected package - github.com/goplus/lib/py
2025/12/19 11:09:40 PkgHash: unexpected package - github.com/goplus/lib/c
2025/12/19 11:09:40 Val Str func(s string) *github.com/goplus/lib/py.Object
2025/12/19 11:09:40 Val Hello, World! string
2025/12/19 11:09:40 Call 1 0 // func(s string) *github.com/goplus/lib/py.Object
2025/12/19 11:09:40 ==> MatchFuncCall func(s string) *github.com/goplus/lib/py.Object args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("Hello, World!"), string
2025/12/19 11:09:40 Call 1 0 // func(__llgo_va_list ...interface{}) *github.com/goplus/lib/py.Object
2025/12/19 11:09:40 ==> MatchFuncCall func(__llgo_va_list ...interface{}) *github.com/goplus/lib/py.Object args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType *github.com/goplus/lib/py.Object, interface{}
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
=== RUN   TestTestpy/pycall
2025/12/19 11:09:40 Parsing /app/cl/_testpy/pycall
2025/12/19 11:09:40 PkgHash: unexpected package - github.com/goplus/lib/py/math
2025/12/19 11:09:40 PkgHash: unexpected package - github.com/goplus/lib/c
2025/12/19 11:09:40 PkgHash: unexpected package - github.com/goplus/lib/py
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 DefineVarStart [x]
2025/12/19 11:09:40 Val Sqrt func(x *github.com/goplus/lib/py.Object) *github.com/goplus/lib/py.Object
2025/12/19 11:09:40 Val Float func(v float64) *github.com/goplus/lib/py.Object
2025/12/19 11:09:40 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(v float64) *github.com/goplus/lib/py.Object
2025/12/19 11:09:40 ==> MatchFuncCall func(v float64) *github.com/goplus/lib/py.Object args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (2), float64
2025/12/19 11:09:40 Call 1 0 // func(x *github.com/goplus/lib/py.Object) *github.com/goplus/lib/py.Object
2025/12/19 11:09:40 ==> MatchFuncCall func(x *github.com/goplus/lib/py.Object) *github.com/goplus/lib/py.Object args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType *github.com/goplus/lib/py.Object, *github.com/goplus/lib/py.Object
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val Printf func(format *int8, __llgo_va_list ...any) int32
2025/12/19 11:09:40 Val Str func(string) *int8
2025/12/19 11:09:40 Val sqrt(2) = %f
 string
2025/12/19 11:09:40 Call 1 0 // func(string) *int8
2025/12/19 11:09:40 ==> MatchFuncCall func(string) *int8 args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("sqrt(2) = %f\n"), string
2025/12/19 11:09:40 Val x *github.com/goplus/lib/py.Object
2025/12/19 11:09:40 Member float64 2 // *github.com/goplus/lib/py.Object
2025/12/19 11:09:40 Call 0 0 // func() float64
2025/12/19 11:09:40 ==> MatchFuncCall func() float64 args: 0 flags: 0
2025/12/19 11:09:40 Call 2 0 // func(format *int8, __llgo_va_list ...any) int32
2025/12/19 11:09:40 ==> MatchFuncCall func(format *int8, __llgo_va_list ...any) int32 args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType *int8, *int8
2025/12/19 11:09:40 ==> MatchType float64, any
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestTestpy (0.17s)
    --- PASS: TestTestpy/hello (0.12s)
    --- PASS: TestTestpy/pycall (0.05s)
=== RUN   TestArrowOp
2025/12/19 11:09:40 ==> Preload type foo
2025/12/19 11:09:40 ==> Preload method foo.->
2025/12/19 11:09:40 ==> Preload method foo.<>
2025/12/19 11:09:40 ==> Load > NewType foo
2025/12/19 11:09:40 NewType foo
2025/12/19 11:09:40 ==> Load > InitType foo
2025/12/19 11:09:40 InitType foo struct{}
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.foo.->
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.foo.<>
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 NewFunc Gop_PointTo (github.com/goplus/xgo/cl.foo) func(b github.com/goplus/xgo/cl.foo)
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "a -> b"} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("a -> b"), any
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc Gop_PointBi (github.com/goplus/xgo/cl.foo) func(b github.com/goplus/xgo/cl.foo)
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "a <> b"} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("a <> b"), any
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestArrowOp (0.00s)
=== RUN   TestMapLit
2025/12/19 11:09:40 ==> Preload func foo
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func foo
2025/12/19 11:09:40 NewFunc foo func(map[string]string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 Val foo func(map[string]string)
2025/12/19 11:09:40 MapLit map[string]string 0
2025/12/19 11:09:40 Call 1 0 // func(map[string]string)
2025/12/19 11:09:40 ==> MatchFuncCall func(map[string]string) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType map[string]string, map[string]string
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestMapLit (0.00s)
=== RUN   TestMayBuiltinDelete
2025/12/19 11:09:40 ==> Preload func Delete
2025/12/19 11:09:40 ==> Preload func Foo
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func Delete
2025/12/19 11:09:40 NewFunc Delete func(a int)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load func Foo
2025/12/19 11:09:40 NewFunc Foo func(m map[string]int)
2025/12/19 11:09:40 Val Delete func(a int)
2025/12/19 11:09:40 Val m map[string]int
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 Call 2 0 // func(a int)
2025/12/19 11:09:40 ==> MatchFuncCall func(a int) args: 2 flags: 0
2025/12/19 11:09:40 Val delete TemplateSignature{func(m unboundProxyParam{typ: map[TemplateParamType{name: Key}]TemplateParamType{name: Elem}}, key TemplateParamType{name: Key})}
2025/12/19 11:09:40 Val m map[string]int
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 Call 2 0 // TemplateSignature{func(m unboundProxyParam{typ: map[TemplateParamType{name: Key}]TemplateParamType{name: Elem}}, key TemplateParamType{name: Key})}
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(m unboundProxyParam{typ: map[TemplateParamType{name: Key}]TemplateParamType{name: Elem}}, key TemplateParamType{name: Key})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType map[string]int, unboundProxyParam{typ: map[unboundFuncParam{typ: <nil>}]unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType untyped string ("a"), unboundFuncParam{typ: string}
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 Val Delete func(a int)
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(a int)
2025/12/19 11:09:40 ==> MatchFuncCall func(a int) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (10), int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestMayBuiltinDelete (0.00s)
=== RUN   TestVargCommand
2025/12/19 11:09:40 ==> Preload type foo
2025/12/19 11:09:40 ==> Preload method foo.Ls
2025/12/19 11:09:40 ==> Preload var [f]
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load > NewType foo
2025/12/19 11:09:40 NewType foo
2025/12/19 11:09:40 ==> Load > InitType foo
2025/12/19 11:09:40 InitType foo int
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo int
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.foo.Ls
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo int
2025/12/19 11:09:40 ==> Load var github.com/goplus/xgo/cl.foo [f]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [f]
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 Val f github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Member ls 1 // github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Call 0 0 // func(args ...string)
2025/12/19 11:09:40 ==> MatchFuncCall func(args ...string) args: 0 flags: 0
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc Ls (github.com/goplus/xgo/cl.foo) func(args ...string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestVargCommand (0.00s)
=== RUN   TestCommandInPkg
2025/12/19 11:09:40 ==> Preload func Ls
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func Ls
2025/12/19 11:09:40 NewFunc Ls func(args ...string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 Val Ls func(args ...string)
2025/12/19 11:09:40 Call 0 0 // func(args ...string)
2025/12/19 11:09:40 ==> MatchFuncCall func(args ...string) args: 0 flags: 0
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestCommandInPkg (0.00s)
=== RUN   TestFuncAlias
2025/12/19 11:09:40 ==> Preload func Foo
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func Foo
2025/12/19 11:09:40 NewFunc Foo func(a ...int)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 Val Foo func(a ...int)
2025/12/19 11:09:40 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(a ...int)
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...int) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 Val Foo func(a ...int)
2025/12/19 11:09:40 Call 0 0 // func(a ...int)
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...int) args: 0 flags: 0
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestFuncAlias (0.00s)
=== RUN   TestOverloadOp
2025/12/19 11:09:40 ==> Preload type foo
2025/12/19 11:09:40 ==> Preload method foo.+
2025/12/19 11:09:40 ==> Preload method foo.-
2025/12/19 11:09:40 ==> Preload func -
2025/12/19 11:09:40 ==> Preload func ++
2025/12/19 11:09:40 ==> Preload method foo.!=
2025/12/19 11:09:40 ==> Preload var [a b]
2025/12/19 11:09:40 ==> Preload var [c]
2025/12/19 11:09:40 ==> Preload var [d]
2025/12/19 11:09:40 ==> Preload var [e]
2025/12/19 11:09:40 ==> Load > NewType foo
2025/12/19 11:09:40 NewType foo
2025/12/19 11:09:40 ==> Load > InitType foo
2025/12/19 11:09:40 InitType foo struct{}
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.foo.+
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.foo.-
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.foo.!=
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load func -
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load func ++
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load var github.com/goplus/xgo/cl.foo [a b]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [a b]
2025/12/19 11:09:40 ==> Load var <nil> [c]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [c]
2025/12/19 11:09:40 Val a github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Val b github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 BinaryOp -
2025/12/19 11:09:40 Typ github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Member Gop_Sub 0 // TypeType{typ: github.com/goplus/xgo/cl.foo}
2025/12/19 11:09:40 ==> MatchFuncCall func(github.com/goplus/xgo/cl.foo, b github.com/goplus/xgo/cl.foo) github.com/goplus/xgo/cl.foo args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ==> Load var <nil> [d]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [d]
2025/12/19 11:09:40 Val a github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 UnaryOp - flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func() args: 1 flags: 32
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ==> Load var <nil> [e]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [e]
2025/12/19 11:09:40 Val a github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Val b github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 BinaryOp !=
2025/12/19 11:09:40 Typ github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Member Gop_NE 0 // TypeType{typ: github.com/goplus/xgo/cl.foo}
2025/12/19 11:09:40 ==> MatchFuncCall func(github.com/goplus/xgo/cl.foo, b github.com/goplus/xgo/cl.foo) bool args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 NewFunc Gop_Add (*github.com/goplus/xgo/cl.foo) func(b *github.com/goplus/xgo/cl.foo) *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "a + b"} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("a + b"), any
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 StructLit github.com/goplus/xgo/cl.foo 0 false
2025/12/19 11:09:40 UnaryOp & flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType *github.com/goplus/xgo/cl.foo, *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc Gop_Sub (github.com/goplus/xgo/cl.foo) func(b github.com/goplus/xgo/cl.foo) github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "a - b"} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("a - b"), any
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 StructLit github.com/goplus/xgo/cl.foo 0 false
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc Gop_NE (github.com/goplus/xgo/cl.foo) func(b github.com/goplus/xgo/cl.foo) bool
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "a!=b"} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("a!=b"), any
2025/12/19 11:09:40 Val true untyped bool
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType untyped bool (true), bool
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc Gop_Neg (github.com/goplus/xgo/cl.foo) func()
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "-a"} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("-a"), any
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc Gop_Inc (github.com/goplus/xgo/cl.foo) func()
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "a++"} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("a++"), any
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestOverloadOp (0.00s)
=== RUN   TestOverloadOp2
2025/12/19 11:09:40 ==> Preload type foo
2025/12/19 11:09:40 ==> Preload method foo.mulInt
2025/12/19 11:09:40 ==> Preload method foo.mulFoo
2025/12/19 11:09:40 ==> Preload func intMulFoo
2025/12/19 11:09:40 NewConstDefs
2025/12/19 11:09:40 ==> Preload const [Gopo__foo__Gop_Mul]
2025/12/19 11:09:40 ==> Preload var [a b]
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load > NewType foo
2025/12/19 11:09:40 NewType foo
2025/12/19 11:09:40 ==> Load > InitType foo
2025/12/19 11:09:40 InitType foo struct{}
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.foo.mulInt
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.foo.mulFoo
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load func intMulFoo
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 NewFunc intMulFoo func(a int, b github.com/goplus/xgo/cl.foo) (ret github.com/goplus/xgo/cl.foo)
2025/12/19 11:09:40 Return 0
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load const [Gopo__foo__Gop_Mul] <nil>
2025/12/19 11:09:40 NewConst [Gopo__foo__Gop_Mul] 0
2025/12/19 11:09:40 Val &{0 STRING ".mulInt,.mulFoo,intMulFoo"} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ==> NewOverloadMethod foo Gop_Mul
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load var github.com/goplus/xgo/cl.foo [a b]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [a b]
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val a github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp *
2025/12/19 11:09:40 Typ github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Member Gop_Mul 0 // TypeType{typ: github.com/goplus/xgo/cl.foo}
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.foo, b int) (ret github.com/goplus/xgo/cl.foo) args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 ==> MatchType untyped int (10), int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.foo, any
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val a github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Val b github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 BinaryOp *
2025/12/19 11:09:40 Typ github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Member Gop_Mul 0 // TypeType{typ: github.com/goplus/xgo/cl.foo}
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.foo, b int) (ret github.com/goplus/xgo/cl.foo) args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.foo, int
2025/12/19 11:09:40 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.foo, b github.com/goplus/xgo/cl.foo) (ret github.com/goplus/xgo/cl.foo) args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.foo, any
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 Val a github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 BinaryOp *
2025/12/19 11:09:40 Typ github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Member Gop_Mul 0 // TypeType{typ: github.com/goplus/xgo/cl.foo}
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.foo, b int) (ret github.com/goplus/xgo/cl.foo) args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchType untyped int (10), github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 ==> AssignableConv untyped int github.com/goplus/xgo/cl.foo false
2025/12/19 11:09:40 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.foo, b github.com/goplus/xgo/cl.foo) (ret github.com/goplus/xgo/cl.foo) args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchType untyped int (10), github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 ==> AssignableConv untyped int github.com/goplus/xgo/cl.foo false
2025/12/19 11:09:40 ==> MatchFuncCall func(a int, b github.com/goplus/xgo/cl.foo) (ret github.com/goplus/xgo/cl.foo) args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchType untyped int (10), int
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.foo, any
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc mulInt (github.com/goplus/xgo/cl.foo) func(b int) (ret github.com/goplus/xgo/cl.foo)
2025/12/19 11:09:40 Return 0
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc mulFoo (github.com/goplus/xgo/cl.foo) func(b github.com/goplus/xgo/cl.foo) (ret github.com/goplus/xgo/cl.foo)
2025/12/19 11:09:40 Return 0
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestOverloadOp2 (0.00s)
=== RUN   TestOverloadMethod
2025/12/19 11:09:40 ==> Preload type foo
2025/12/19 11:09:40 ==> Preload method foo.mulInt
2025/12/19 11:09:40 ==> Preload method foo.mulFoo
2025/12/19 11:09:40 NewConstDefs
2025/12/19 11:09:40 ==> Preload const [Gopo_foo_mul]
2025/12/19 11:09:40 ==> Preload var [a b]
2025/12/19 11:09:40 ==> Preload var [c]
2025/12/19 11:09:40 ==> Preload var [d]
2025/12/19 11:09:40 ==> Load > NewType foo
2025/12/19 11:09:40 NewType foo
2025/12/19 11:09:40 ==> Load > InitType foo
2025/12/19 11:09:40 InitType foo struct{}
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.foo.mulInt
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.foo.mulFoo
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load const [Gopo_foo_mul] <nil>
2025/12/19 11:09:40 NewConst [Gopo_foo_mul] 0
2025/12/19 11:09:40 Val &{0 STRING ".mulInt,.mulFoo"} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ==> NewOverloadMethod foo mul
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load var github.com/goplus/xgo/cl.foo [a b]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [a b]
2025/12/19 11:09:40 ==> Load var <nil> [c]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [c]
2025/12/19 11:09:40 Val a github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Member mul 1 // github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(b int) *github.com/goplus/xgo/cl.foo args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ==> Load var <nil> [d]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [d]
2025/12/19 11:09:40 Val a github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Member mul 1 // github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Val c *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(b int) *github.com/goplus/xgo/cl.foo args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType *github.com/goplus/xgo/cl.foo, int
2025/12/19 11:09:40 ==> MatchFuncCall func(b *github.com/goplus/xgo/cl.foo) *github.com/goplus/xgo/cl.foo args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType *github.com/goplus/xgo/cl.foo, *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 NewFunc mulInt (*github.com/goplus/xgo/cl.foo) func(b int) *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "mulInt"} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("mulInt"), any
2025/12/19 11:09:40 Val a *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType *github.com/goplus/xgo/cl.foo, *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc mulFoo (*github.com/goplus/xgo/cl.foo) func(b *github.com/goplus/xgo/cl.foo) *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "mulFoo"} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("mulFoo"), any
2025/12/19 11:09:40 Val a *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType *github.com/goplus/xgo/cl.foo, *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestOverloadMethod (0.00s)
=== RUN   TestOverloadFunc
2025/12/19 11:09:40 ==> Preload func add__0
2025/12/19 11:09:40 ==> Preload func add__1
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func add__0
2025/12/19 11:09:40 NewFunc add__0 func(a int, b int) int
2025/12/19 11:09:40 Val a int
2025/12/19 11:09:40 Val b int
2025/12/19 11:09:40 BinaryOp +
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType int, int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load func add__1
2025/12/19 11:09:40 NewFunc add__1 func(a string, b string) string
2025/12/19 11:09:40 Val a string
2025/12/19 11:09:40 Val b string
2025/12/19 11:09:40 BinaryOp +
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType string, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType string, unboundFuncParam{typ: string}
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType string, string
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> NewOverloadFunc add
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val add func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a int, b int) int args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 ==> MatchType untyped int (7), int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val add func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "World"} *ast.BasicLit
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a int, b int) int args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("Hello"), int
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, b string) string args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("Hello"), string
2025/12/19 11:09:40 ==> MatchType untyped string ("World"), string
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType string, any
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestOverloadFunc (0.00s)
=== RUN   TestOverloadFunc2
2025/12/19 11:09:40 ==> Preload func mulInt
2025/12/19 11:09:40 ==> Preload func mulFloat
2025/12/19 11:09:40 NewConstDefs
2025/12/19 11:09:40 ==> Preload const [Gopo_mul]
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func mulInt
2025/12/19 11:09:40 NewFunc mulInt func(a int, b int) int
2025/12/19 11:09:40 Val a int
2025/12/19 11:09:40 Val b int
2025/12/19 11:09:40 BinaryOp *
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType int, int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load func mulFloat
2025/12/19 11:09:40 NewFunc mulFloat func(a float64, b float64) float64
2025/12/19 11:09:40 Val a float64
2025/12/19 11:09:40 Val b float64
2025/12/19 11:09:40 BinaryOp *
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType float64, float64
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load const [Gopo_mul] <nil>
2025/12/19 11:09:40 NewConst [Gopo_mul] 0
2025/12/19 11:09:40 Val &{0 STRING "mulInt,mulFloat"} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ==> NewOverloadFunc mul
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val mul func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a int, b int) int args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 ==> MatchType untyped int (7), int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val mul func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a int, b int) int args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped float (1.2), int
2025/12/19 11:09:40 ==> MatchFuncCall func(a float64, b float64) float64 args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped float (1.2), float64
2025/12/19 11:09:40 ==> MatchType untyped float (3.14), float64
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType float64, any
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestOverloadFunc2 (0.00s)
=== RUN   TestOverloadFunc3
2025/12/19 11:09:40 ==> Preload func addInt
2025/12/19 11:09:40 ==> Preload func addFloat
2025/12/19 11:09:40 ==> Preload func add__0
2025/12/19 11:09:40 NewConstDefs
2025/12/19 11:09:40 ==> Preload const [Gopo_add]
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func add__0
2025/12/19 11:09:40 NewFunc add__0 func(a string, b string) string
2025/12/19 11:09:40 Val a string
2025/12/19 11:09:40 Val b string
2025/12/19 11:09:40 BinaryOp +
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType string, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType string, unboundFuncParam{typ: string}
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType string, string
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load func addInt
2025/12/19 11:09:40 NewFunc addInt func(a int, b int) int
2025/12/19 11:09:40 Val a int
2025/12/19 11:09:40 Val b int
2025/12/19 11:09:40 BinaryOp +
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType int, int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load func addFloat
2025/12/19 11:09:40 NewFunc addFloat func(a float64, b float64) float64
2025/12/19 11:09:40 Val a float64
2025/12/19 11:09:40 Val b float64
2025/12/19 11:09:40 BinaryOp *
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType float64, float64
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load const [Gopo_add] <nil>
2025/12/19 11:09:40 NewConst [Gopo_add] 0
2025/12/19 11:09:40 Val &{0 STRING ",addInt,addFloat"} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ==> NewOverloadFunc add
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val add func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, b string) string args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), string
2025/12/19 11:09:40 ==> MatchFuncCall func(a int, b int) int args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 ==> MatchType untyped int (7), int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val add func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, b string) string args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped float (1.2), string
2025/12/19 11:09:40 ==> MatchFuncCall func(a int, b int) int args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped float (1.2), int
2025/12/19 11:09:40 ==> MatchFuncCall func(a float64, b float64) float64 args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped float (1.2), float64
2025/12/19 11:09:40 ==> MatchType untyped float (3.14), float64
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType float64, any
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestOverloadFunc3 (0.00s)
=== RUN   TestOverload
2025/12/19 11:09:40 ==> Import github.com/goplus/xgo/cl/internal/overload/foo
2025/12/19 11:09:40 ==> NewOverloadMethod N OnKey
2025/12/19 11:09:40 ==> NewOverloadFunc OnKey
2025/12/19 11:09:40 ==> NewOverloadFunc Test
2025/12/19 11:09:40 ==> Preload type Mesh
2025/12/19 11:09:40 ==> Preload method Mesh.Name
2025/12/19 11:09:40 ==> Preload var [m1]
2025/12/19 11:09:40 ==> Preload var [m2]
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load > NewType Mesh
2025/12/19 11:09:40 NewType Mesh
2025/12/19 11:09:40 ==> Load > InitType Mesh
2025/12/19 11:09:40 InitType Mesh struct{}
2025/12/19 11:09:40 ==> LookupParent Mesh => type github.com/goplus/xgo/cl.Mesh struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.Mesh.Name
2025/12/19 11:09:40 ==> Load var <nil> [m1]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [m1]
2025/12/19 11:09:40 ==> LookupParent Mesh => type github.com/goplus/xgo/cl.Mesh struct{}
2025/12/19 11:09:40 StructLit github.com/goplus/xgo/cl.Mesh 0 false
2025/12/19 11:09:40 UnaryOp & flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ==> Load var <nil> [m2]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [m2]
2025/12/19 11:09:40 ==> LookupParent Mesh => type github.com/goplus/xgo/cl.Mesh struct{}
2025/12/19 11:09:40 StructLit github.com/goplus/xgo/cl.Mesh 0 false
2025/12/19 11:09:40 UnaryOp & flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:40 NewClosure func()
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:40 ==> MatchType func(), func()
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:40 ==> MatchType func(key string), func()
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 NewClosure func()
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType func(), func()
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "2"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "2"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType func(key string), func()
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 NewClosure func()
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, int
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []string 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []string 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 2 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 NewClosure func()
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchType func(), func()
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, int
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []string 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []string 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 2 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 2 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 NewClosure func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchType func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher), func()
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchType func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher), func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []string 2 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 2 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType untyped nil, []string
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:40 NewClosure func() int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 ==> MatchType func() int, int
2025/12/19 11:09:40 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 ==> MatchType untyped int (200), int
2025/12/19 11:09:40 DefineVarStart [n]
2025/12/19 11:09:40 StructLit github.com/goplus/xgo/cl/internal/overload/foo.N 0 false
2025/12/19 11:09:40 UnaryOp & flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/12/19 11:09:40 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:40 NewClosure func()
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:40 ==> MatchType func(), func()
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/12/19 11:09:40 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:40 ==> MatchType func(key string), func()
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/12/19 11:09:40 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 NewClosure func()
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType func(), func()
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/12/19 11:09:40 Val &{0 STRING "2"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "2"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType func(key string), func()
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 NewClosure func()
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, int
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []string 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []string 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 2 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 NewClosure func()
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchType func(), func()
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, int
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []string 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []string 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 2 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 2 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 NewClosure func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchType func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher), func()
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchType func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher), func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []string 2 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 2 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl/internal/overload/foo.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl/internal/overload/foo.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType untyped nil, []string
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl/internal/overload/foo.N
2025/12/19 11:09:40 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:40 NewClosure func() int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 ==> MatchType func() int, int
2025/12/19 11:09:40 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key github.com/goplus/xgo/cl/internal/overload/foo.Mesher)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl/internal/overload/foo.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl/internal/overload/foo.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 ==> MatchType untyped int (200), int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc Name (*github.com/goplus/xgo/cl.Mesh) func() string
2025/12/19 11:09:40 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestOverload (0.05s)
=== RUN   TestMixedOverload
2025/12/19 11:09:40 ==> Preload type Mesh
2025/12/19 11:09:40 ==> Preload method Mesh.Name
2025/12/19 11:09:40 ==> Preload var [m1]
2025/12/19 11:09:40 ==> Preload var [m2]
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Preload type Mesher
2025/12/19 11:09:40 ==> Preload type N
2025/12/19 11:09:40 ==> Preload method N.OnKey__0
2025/12/19 11:09:40 ==> Preload method N.OnKey__1
2025/12/19 11:09:40 ==> Preload method N.OnKey__2
2025/12/19 11:09:40 ==> Preload method N.OnKey__3
2025/12/19 11:09:40 ==> Preload method N.OnKey__4
2025/12/19 11:09:40 ==> Preload method N.OnKey__5
2025/12/19 11:09:40 ==> Preload method N.OnKey__6
2025/12/19 11:09:40 ==> Preload method N.OnKey__7
2025/12/19 11:09:40 ==> Preload method N.OnKey__8
2025/12/19 11:09:40 ==> Preload func OnKey__0
2025/12/19 11:09:40 ==> Preload func OnKey__1
2025/12/19 11:09:40 ==> Preload func OnKey__2
2025/12/19 11:09:40 ==> Preload func OnKey__3
2025/12/19 11:09:40 ==> Preload func OnKey__4
2025/12/19 11:09:40 ==> Preload func OnKey__5
2025/12/19 11:09:40 ==> Preload func OnKey__6
2025/12/19 11:09:40 ==> Preload func OnKey__7
2025/12/19 11:09:40 ==> Preload func OnKey__8
2025/12/19 11:09:40 ==> Preload func OnKey__9
2025/12/19 11:09:40 ==> Preload func OnKey__a
2025/12/19 11:09:40 ==> Load > NewType Mesher
2025/12/19 11:09:40 ==> Load > InitType Mesher
2025/12/19 11:09:40 ==> Load func OnKey__1
2025/12/19 11:09:40 ==> Load func OnKey__6
2025/12/19 11:09:40 ==> Load func OnKey__0
2025/12/19 11:09:40 ==> Load func OnKey__4
2025/12/19 11:09:40 ==> LookupParent Mesher => type github.com/goplus/xgo/cl.Mesher interface{Name() string}
2025/12/19 11:09:40 ==> Load func OnKey__7
2025/12/19 11:09:40 ==> LookupParent Mesher => type github.com/goplus/xgo/cl.Mesher interface{Name() string}
2025/12/19 11:09:40 ==> Load > NewType N
2025/12/19 11:09:40 ==> Load > InitType N
2025/12/19 11:09:40 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.N.OnKey__0
2025/12/19 11:09:40 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.N.OnKey__1
2025/12/19 11:09:40 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.N.OnKey__2
2025/12/19 11:09:40 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.N.OnKey__3
2025/12/19 11:09:40 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.N.OnKey__4
2025/12/19 11:09:40 ==> LookupParent Mesher => type github.com/goplus/xgo/cl.Mesher interface{Name() string}
2025/12/19 11:09:40 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.N.OnKey__5
2025/12/19 11:09:40 ==> LookupParent Mesher => type github.com/goplus/xgo/cl.Mesher interface{Name() string}
2025/12/19 11:09:40 ==> LookupParent Mesher => type github.com/goplus/xgo/cl.Mesher interface{Name() string}
2025/12/19 11:09:40 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.N.OnKey__6
2025/12/19 11:09:40 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.N.OnKey__7
2025/12/19 11:09:40 ==> LookupParent Mesher => type github.com/goplus/xgo/cl.Mesher interface{Name() string}
2025/12/19 11:09:40 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.N.OnKey__8
2025/12/19 11:09:40 ==> Load func OnKey__2
2025/12/19 11:09:40 ==> Load func OnKey__3
2025/12/19 11:09:40 ==> Load func OnKey__5
2025/12/19 11:09:40 ==> LookupParent Mesher => type github.com/goplus/xgo/cl.Mesher interface{Name() string}
2025/12/19 11:09:40 ==> LookupParent Mesher => type github.com/goplus/xgo/cl.Mesher interface{Name() string}
2025/12/19 11:09:40 ==> Load func OnKey__8
2025/12/19 11:09:40 ==> Load func OnKey__9
2025/12/19 11:09:40 ==> Load func OnKey__a
2025/12/19 11:09:40 ==> NewOverloadMethod N OnKey
2025/12/19 11:09:40 ==> NewOverloadFunc OnKey
2025/12/19 11:09:40 ==> Load > NewType Mesh
2025/12/19 11:09:40 NewType Mesh
2025/12/19 11:09:40 ==> Load > InitType Mesh
2025/12/19 11:09:40 InitType Mesh struct{}
2025/12/19 11:09:40 ==> LookupParent Mesh => type github.com/goplus/xgo/cl.Mesh struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.Mesh.Name
2025/12/19 11:09:40 ==> Load var <nil> [m1]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [m1]
2025/12/19 11:09:40 ==> LookupParent Mesh => type github.com/goplus/xgo/cl.Mesh struct{}
2025/12/19 11:09:40 StructLit github.com/goplus/xgo/cl.Mesh 0 false
2025/12/19 11:09:40 UnaryOp & flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ==> Load var <nil> [m2]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [m2]
2025/12/19 11:09:40 ==> LookupParent Mesh => type github.com/goplus/xgo/cl.Mesh struct{}
2025/12/19 11:09:40 StructLit github.com/goplus/xgo/cl.Mesh 0 false
2025/12/19 11:09:40 UnaryOp & flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:40 NewClosure func()
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:40 ==> MatchType func(), func()
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:40 ==> MatchType func(key string), func()
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 NewClosure func()
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType func(), func()
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "2"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "2"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType func(key string), func()
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 NewClosure func()
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, int
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, b string, v ...int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []string 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []string 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl.Mesher 2 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 NewClosure func()
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchType func(), func()
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, int
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, b string, v ...int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []string 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []string 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl.Mesher 2 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl.Mesher 2 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 NewClosure func(key github.com/goplus/xgo/cl.Mesher)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchType func(key github.com/goplus/xgo/cl.Mesher), func()
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchType func(key github.com/goplus/xgo/cl.Mesher), func(key github.com/goplus/xgo/cl.Mesher)
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []string 2 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl.Mesher 2 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType untyped nil, []string
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:40 NewClosure func() int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 ==> MatchType func() int, int
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, b string, v ...int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), string
2025/12/19 11:09:40 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 ==> MatchType untyped int (200), int
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 NewClosure func() string
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 NewClosure func() string
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 NewClosure func() string
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 NewClosure func(x int) int
2025/12/19 11:09:40 Val x int
2025/12/19 11:09:40 Val x int
2025/12/19 11:09:40 BinaryOp *
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType int, int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewClosure func(x int) int
2025/12/19 11:09:40 Val x int
2025/12/19 11:09:40 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp *
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType int, int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 4 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 4 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 4 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 4 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 4 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 4 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 4 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 4 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 4 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 4 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int, y int) args: 4 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 4 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("a"), string
2025/12/19 11:09:40 ==> MatchType untyped string ("b"), string
2025/12/19 11:09:40 ==> MatchType func(x int) int, func(x int) int
2025/12/19 11:09:40 ==> MatchType func(x int) int, func(x int) int
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 NewClosure func() string
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:40 Call 5 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int, y int) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("a"), string
2025/12/19 11:09:40 ==> MatchType func() string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, b string, v ...int) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("a"), string
2025/12/19 11:09:40 ==> MatchType func() string, string
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:40 Call 5 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int, y int) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("a"), string
2025/12/19 11:09:40 ==> MatchType untyped string ("b"), string
2025/12/19 11:09:40 ==> MatchType untyped int (1), func(x int) int
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, b string, v ...int) args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("a"), string
2025/12/19 11:09:40 ==> MatchType untyped string ("b"), string
2025/12/19 11:09:40 ==> MatchType untyped int (1), int
2025/12/19 11:09:40 ==> MatchType untyped int (2), int
2025/12/19 11:09:40 ==> MatchType untyped int (3), int
2025/12/19 11:09:40 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 NewClosure func() string
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 3 false
2025/12/19 11:09:40 Call 3 1 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchFuncCall func(x int, y int) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchType untyped string ("a"), string
2025/12/19 11:09:40 ==> MatchType func() string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, b string, v ...int) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchType untyped string ("a"), string
2025/12/19 11:09:40 ==> MatchType func() string, string
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 3 false
2025/12/19 11:09:40 Call 3 1 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchFuncCall func(x int, y int) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchType untyped string ("a"), string
2025/12/19 11:09:40 ==> MatchType untyped string ("b"), string
2025/12/19 11:09:40 ==> MatchType []int, []func(x int) int
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, b string, v ...int) args: 3 flags: 1
2025/12/19 11:09:40 ==> MatchType untyped string ("a"), string
2025/12/19 11:09:40 ==> MatchType untyped string ("b"), string
2025/12/19 11:09:40 ==> MatchType []int, []int
2025/12/19 11:09:40 DefineVarStart [n]
2025/12/19 11:09:40 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/12/19 11:09:40 StructLit github.com/goplus/xgo/cl.N 0 false
2025/12/19 11:09:40 UnaryOp & flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:40 NewClosure func()
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:40 ==> MatchType func(), func()
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:40 ==> MatchType func(key string), func()
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 NewClosure func()
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType func(), func()
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Val &{0 STRING "2"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "2"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType func(key string), func()
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 NewClosure func()
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, int
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []string 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []string 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl.Mesher 2 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 NewClosure func()
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchType func(), func()
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []*github.com/goplus/xgo/cl.Mesh, int
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []string 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []string 2 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl.Mesher 2 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl.Mesher 2 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 NewClosure func(key github.com/goplus/xgo/cl.Mesher)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchType func(key github.com/goplus/xgo/cl.Mesher), func()
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchType func(key github.com/goplus/xgo/cl.Mesher), func(key github.com/goplus/xgo/cl.Mesher)
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []string 2 false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val m1 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 Val m2 *github.com/goplus/xgo/cl.Mesh
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl.Mesher 2 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType []github.com/goplus/xgo/cl.Mesher, []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 1 false
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []github.com/goplus/xgo/cl.Mesher 1 false
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> AssignableConv untyped string github.com/goplus/xgo/cl.Mesher false
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit []string 1 false
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType untyped nil, []string
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:40 NewClosure func() int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 ==> MatchType func() int, int
2025/12/19 11:09:40 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []github.com/goplus/xgo/cl.Mesher, fn func(key github.com/goplus/xgo/cl.Mesher)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), []github.com/goplus/xgo/cl.Mesher
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, b []github.com/goplus/xgo/cl.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 ==> MatchType untyped int (200), int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc Name (*github.com/goplus/xgo/cl.Mesh) func() string
2025/12/19 11:09:40 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestMixedOverload (0.01s)
=== RUN   TestMixedOverloadOp
2025/12/19 11:09:40 ==> Preload var [a b]
2025/12/19 11:09:40 ==> Preload var [c]
2025/12/19 11:09:40 ==> Preload var [d]
2025/12/19 11:09:40 ==> Preload var [e]
2025/12/19 11:09:40 ==> Preload type foo
2025/12/19 11:09:40 ==> Preload method foo.Gop_Add
2025/12/19 11:09:40 ==> Preload method foo.Gop_Sub
2025/12/19 11:09:40 ==> Preload method foo.Gop_NE
2025/12/19 11:09:40 ==> Preload method foo.Gop_Neg
2025/12/19 11:09:40 ==> Preload method foo.Gop_Inc
2025/12/19 11:09:40 ==> Load > NewType foo
2025/12/19 11:09:40 ==> Load > InitType foo
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.foo.Gop_Add
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.foo.Gop_Sub
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.foo.Gop_NE
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.foo.Gop_Neg
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.foo.Gop_Inc
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{}
2025/12/19 11:09:40 ==> Load var github.com/goplus/xgo/cl.foo [a b]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [a b]
2025/12/19 11:09:40 ==> Load var <nil> [c]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [c]
2025/12/19 11:09:40 Val a github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Val b github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 BinaryOp -
2025/12/19 11:09:40 Typ github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Member Gop_Sub 0 // TypeType{typ: github.com/goplus/xgo/cl.foo}
2025/12/19 11:09:40 ==> MatchFuncCall func(github.com/goplus/xgo/cl.foo, b github.com/goplus/xgo/cl.foo) github.com/goplus/xgo/cl.foo args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ==> Load var <nil> [d]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [d]
2025/12/19 11:09:40 Val a github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 UnaryOp - flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func() *github.com/goplus/xgo/cl.foo args: 1 flags: 32
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ==> Load var <nil> [e]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [e]
2025/12/19 11:09:40 Val a github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Val b github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 BinaryOp !=
2025/12/19 11:09:40 Typ github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Member Gop_NE 0 // TypeType{typ: github.com/goplus/xgo/cl.foo}
2025/12/19 11:09:40 ==> MatchFuncCall func(github.com/goplus/xgo/cl.foo, b github.com/goplus/xgo/cl.foo) bool args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.foo, github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestMixedOverloadOp (0.00s)
=== RUN   TestMixedVector3
2025/12/19 11:09:40 ==> Preload var [a]
2025/12/19 11:09:40 ==> Preload var [b]
2025/12/19 11:09:40 ==> Preload var [c]
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Preload type Vector3
2025/12/19 11:09:40 ==> Preload method Vector3.Gop_Add__0
2025/12/19 11:09:40 ==> Preload method Vector3.Gop_Add__1
2025/12/19 11:09:40 ==> Preload method Vector3.Gop_Add__2
2025/12/19 11:09:40 ==> Preload method Vector3.Gop_AddAssign
2025/12/19 11:09:40 ==> Preload method Vector3.Gop_Rcast__0
2025/12/19 11:09:40 ==> Preload method Vector3.Gop_Rcast__1
2025/12/19 11:09:40 ==> Preload func Vector3_Cast__0
2025/12/19 11:09:40 ==> Preload func Vector3_Cast__1
2025/12/19 11:09:40 ==> Preload func Vector3_Init__0
2025/12/19 11:09:40 ==> Preload func Vector3_Init__1
2025/12/19 11:09:40 ==> Load > NewType Vector3
2025/12/19 11:09:40 ==> Load > InitType Vector3
2025/12/19 11:09:40 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.Vector3.Gop_Add__0
2025/12/19 11:09:40 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/12/19 11:09:40 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.Vector3.Gop_Add__1
2025/12/19 11:09:40 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/12/19 11:09:40 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.Vector3.Gop_Add__2
2025/12/19 11:09:40 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/12/19 11:09:40 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/12/19 11:09:40 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.Vector3.Gop_AddAssign
2025/12/19 11:09:40 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/12/19 11:09:40 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.Vector3.Gop_Rcast__0
2025/12/19 11:09:40 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.Vector3.Gop_Rcast__1
2025/12/19 11:09:40 ==> Load func Vector3_Cast__0
2025/12/19 11:09:40 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/12/19 11:09:40 ==> Load func Vector3_Cast__1
2025/12/19 11:09:40 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/12/19 11:09:40 ==> Load func Vector3_Init__0
2025/12/19 11:09:40 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/12/19 11:09:40 ==> Load func Vector3_Init__1
2025/12/19 11:09:40 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/12/19 11:09:40 ==> NewOverloadMethod Vector3 Gop_Add
2025/12/19 11:09:40 ==> NewOverloadMethod Vector3 Gop_Rcast
2025/12/19 11:09:40 ==> NewOverloadFunc Vector3_Cast
2025/12/19 11:09:40 ==> NewOverloadFunc Vector3_Init
2025/12/19 11:09:40 ==> LookupParent Vector3 => type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64}
2025/12/19 11:09:40 ==> Load var github.com/goplus/xgo/cl.Vector3 [a]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [a]
2025/12/19 11:09:40 ==> Load var int [b]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [b]
2025/12/19 11:09:40 ==> Load var float64 [c]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [c]
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 VarRef _
2025/12/19 11:09:40 Val a github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 Val b int
2025/12/19 11:09:40 BinaryOp +
2025/12/19 11:09:40 Typ github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 Member Gop_Add 0 // TypeType{typ: github.com/goplus/xgo/cl.Vector3}
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.Vector3, n int) github.com/goplus/xgo/cl.Vector3 args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.Vector3, github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 ==> MatchType int, int
2025/12/19 11:09:40 Assign 1 1
2025/12/19 11:09:40 VarRef _
2025/12/19 11:09:40 Val a github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp +
2025/12/19 11:09:40 Typ github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 Member Gop_Add 0 // TypeType{typ: github.com/goplus/xgo/cl.Vector3}
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.Vector3, n int) github.com/goplus/xgo/cl.Vector3 args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.Vector3, github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 Assign 1 1
2025/12/19 11:09:40 VarRef _
2025/12/19 11:09:40 Val a github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 Val c float64
2025/12/19 11:09:40 BinaryOp +
2025/12/19 11:09:40 Typ github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 Member Gop_Add 0 // TypeType{typ: github.com/goplus/xgo/cl.Vector3}
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.Vector3, n int) github.com/goplus/xgo/cl.Vector3 args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.Vector3, github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 ==> MatchType float64, int
2025/12/19 11:09:40 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.Vector3, n float64) github.com/goplus/xgo/cl.Vector3 args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.Vector3, github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 ==> MatchType float64, float64
2025/12/19 11:09:40 Assign 1 1
2025/12/19 11:09:40 VarRef _
2025/12/19 11:09:40 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:40 Val a github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 BinaryOp +
2025/12/19 11:09:40 Typ github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 Member Gop_Add 0 // TypeType{typ: github.com/goplus/xgo/cl.Vector3}
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.Vector3, n int) github.com/goplus/xgo/cl.Vector3 args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchType untyped int (100), github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int) github.com/goplus/xgo/cl.Vector3 args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 ==> AssignableConv untyped int github.com/goplus/xgo/cl.Vector3 true
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.Vector3, int
2025/12/19 11:09:40 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.Vector3, n float64) github.com/goplus/xgo/cl.Vector3 args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchType untyped int (100), github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int) github.com/goplus/xgo/cl.Vector3 args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 ==> AssignableConv untyped int github.com/goplus/xgo/cl.Vector3 true
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.Vector3, float64
2025/12/19 11:09:40 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.Vector3, n github.com/goplus/xgo/cl.Vector3) github.com/goplus/xgo/cl.Vector3 args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchType untyped int (100), github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int) github.com/goplus/xgo/cl.Vector3 args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 ==> AssignableConv untyped int github.com/goplus/xgo/cl.Vector3 true
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.Vector3, github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 Assign 1 1
2025/12/19 11:09:40 VarRef _
2025/12/19 11:09:40 Val Vector3 github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 Val type github.com/goplus/xgo/cl.Vector3 struct{x float64; y float64; z float64} => Typ github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 Val b int
2025/12/19 11:09:40 Call 1 0 // TypeType{typ: github.com/goplus/xgo/cl.Vector3}
2025/12/19 11:09:40 ==> MatchFuncCall TypeType{typ: github.com/goplus/xgo/cl.Vector3} args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int) github.com/goplus/xgo/cl.Vector3 args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, int
2025/12/19 11:09:40 Val a github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 BinaryOp +
2025/12/19 11:09:40 Typ github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 Member Gop_Add 0 // TypeType{typ: github.com/goplus/xgo/cl.Vector3}
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.Vector3, n int) github.com/goplus/xgo/cl.Vector3 args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.Vector3, github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.Vector3, int
2025/12/19 11:09:40 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.Vector3, n float64) github.com/goplus/xgo/cl.Vector3 args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.Vector3, github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.Vector3, float64
2025/12/19 11:09:40 ==> MatchFuncCall func(a github.com/goplus/xgo/cl.Vector3, n github.com/goplus/xgo/cl.Vector3) github.com/goplus/xgo/cl.Vector3 args: 2 flags: 64
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.Vector3, github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.Vector3, github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 Assign 1 1
2025/12/19 11:09:40 VarRef _
2025/12/19 11:09:40 Val b int
2025/12/19 11:09:40 Val int int
2025/12/19 11:09:40 Val type int => Typ int
2025/12/19 11:09:40 Val a github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 Call 1 0 // TypeType{typ: int}
2025/12/19 11:09:40 ==> MatchFuncCall TypeType{typ: int} args: 1 flags: 0
2025/12/19 11:09:40 Val &{a github.com/goplus/xgo/cl.Vector3 <nil> a} *internal.Elem
2025/12/19 11:09:40 Member Gop_Rcast__0 0 // github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 Call 0 0 // func() int
2025/12/19 11:09:40 ==> MatchFuncCall func() int args: 0 flags: 0
2025/12/19 11:09:40 BinaryOp +
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:40 Assign 1 1
2025/12/19 11:09:40 VarRef a github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 Val b int
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall func(n github.com/goplus/xgo/cl.Vector3) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: github.com/goplus/xgo/cl.Vector3}, *github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 ==> MatchType int, github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int) github.com/goplus/xgo/cl.Vector3 args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, int
2025/12/19 11:09:40 ==> AssignableConv int github.com/goplus/xgo/cl.Vector3 true
2025/12/19 11:09:40 VarRef a github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 Val c float64
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall func(n github.com/goplus/xgo/cl.Vector3) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: github.com/goplus/xgo/cl.Vector3}, *github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 ==> MatchType float64, github.com/goplus/xgo/cl.Vector3
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(x int) github.com/goplus/xgo/cl.Vector3 args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType float64, int
2025/12/19 11:09:40 ==> MatchFuncCall func(x float64) github.com/goplus/xgo/cl.Vector3 args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType float64, float64
2025/12/19 11:09:40 ==> AssignableConv float64 github.com/goplus/xgo/cl.Vector3 true
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestMixedVector3 (0.00s)
=== RUN   TestMixedInterfaceOverload
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Preload type N
2025/12/19 11:09:40 ==> Preload method N.OnKey__0
2025/12/19 11:09:40 ==> Preload method N.OnKey__1
2025/12/19 11:09:40 ==> Preload method N.OnKey__2
2025/12/19 11:09:40 ==> Preload method N.OnKey__3
2025/12/19 11:09:40 ==> Preload type I
2025/12/19 11:09:40 ==> Load > NewType N
2025/12/19 11:09:40 ==> Load > InitType N
2025/12/19 11:09:40 ==> LookupParent N => type github.com/goplus/xgo/cl.N[T interface{}] struct{v T}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.N[T interface{}].OnKey__0
2025/12/19 11:09:40 ==> LookupParent N => type github.com/goplus/xgo/cl.N[T interface{}] struct{v T}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.N[T interface{}].OnKey__1
2025/12/19 11:09:40 ==> LookupParent N => type github.com/goplus/xgo/cl.N[T interface{}] struct{v T}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.N[T interface{}].OnKey__2
2025/12/19 11:09:40 ==> LookupParent N => type github.com/goplus/xgo/cl.N[T interface{}] struct{v T}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.N[T interface{}].OnKey__3
2025/12/19 11:09:40 ==> Load > NewType I
2025/12/19 11:09:40 ==> Load > InitType I
2025/12/19 11:09:40 ==> NewOverloadMethod I OnKey
2025/12/19 11:09:40 ==> NewOverloadMethod N OnKey
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 DefineVarStart [n]
2025/12/19 11:09:40 ==> LookupParent N => type github.com/goplus/xgo/cl.N[T interface{}] struct{v T}
2025/12/19 11:09:40 StructLit github.com/goplus/xgo/cl.N[int] 0 false
2025/12/19 11:09:40 UnaryOp & flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl.N[int]
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl.N[int]
2025/12/19 11:09:40 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:09:40 NewClosure func()
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("1"), string
2025/12/19 11:09:40 ==> MatchType func(), func()
2025/12/19 11:09:40 DefineVarStart [keys]
2025/12/19 11:09:40 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "2"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl.N[int]
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl.N[int]
2025/12/19 11:09:40 Val keys []string
2025/12/19 11:09:40 Val keys []string
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val key string
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType string, any
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType func(key string), func()
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl.N[int]
2025/12/19 11:09:40 Member onKey 1 // *github.com/goplus/xgo/cl.N[int]
2025/12/19 11:09:40 Val keys []string
2025/12/19 11:09:40 NewClosure func()
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val keys []string
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, any
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType func(), func()
2025/12/19 11:09:40 ==> LookupParent I => type github.com/goplus/xgo/cl.I interface{OnKey__0(a string, fn func()); OnKey__1(a string, fn func(key string)); OnKey__2(a []string, fn func()); OnKey__3(a []string, fn func(key string))}
2025/12/19 11:09:40 ==> Load var github.com/goplus/xgo/cl.I [i]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [i]
2025/12/19 11:09:40 Val n *github.com/goplus/xgo/cl.N[int]
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ==> MatchType *github.com/goplus/xgo/cl.N[int], github.com/goplus/xgo/cl.I
2025/12/19 11:09:40 Val i github.com/goplus/xgo/cl.I
2025/12/19 11:09:40 Member onKey 1 // github.com/goplus/xgo/cl.I
2025/12/19 11:09:40 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val key string
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType string, any
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("1"), string
2025/12/19 11:09:40 ==> MatchType func(key string), func()
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("1"), string
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 Val i github.com/goplus/xgo/cl.I
2025/12/19 11:09:40 Member onKey 1 // github.com/goplus/xgo/cl.I
2025/12/19 11:09:40 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "2"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "2"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 NewClosure func(key string)
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val key string
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType string, any
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, string
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType func(key string), func()
2025/12/19 11:09:40 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType []string, []string
2025/12/19 11:09:40 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestMixedInterfaceOverload (0.00s)
=== RUN   TestMixedOverloadCommand
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Preload func Test__0
2025/12/19 11:09:40 ==> Preload func Test__1
2025/12/19 11:09:40 ==> Preload type N
2025/12/19 11:09:40 ==> Preload method N.Test__0
2025/12/19 11:09:40 ==> Preload method N.Test__1
2025/12/19 11:09:40 ==> Load func Test__0
2025/12/19 11:09:40 ==> Load func Test__1
2025/12/19 11:09:40 ==> Load > NewType N
2025/12/19 11:09:40 ==> Load > InitType N
2025/12/19 11:09:40 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.N.Test__0
2025/12/19 11:09:40 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.N.Test__1
2025/12/19 11:09:40 ==> NewOverloadFunc Test
2025/12/19 11:09:40 ==> NewOverloadMethod N Test
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 Val Test func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 0 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:40 Val Test func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func() args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(n int) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 ==> LookupParent N => type github.com/goplus/xgo/cl.N struct{}
2025/12/19 11:09:40 ==> Load var github.com/goplus/xgo/cl.N [n]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [n]
2025/12/19 11:09:40 Val n github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Member test 1 // github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 0 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:40 Val n github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Member test 1 // github.com/goplus/xgo/cl.N
2025/12/19 11:09:40 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func() args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(n int) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestMixedOverloadCommand (0.00s)
=== RUN   TestOverloadNamed
2025/12/19 11:09:40 ==> Import github.com/goplus/xgo/cl/internal/overload/bar
2025/12/19 11:09:40 ==> NewOverloadFunc Gopt_Player_Gopx_OnCmd
2025/12/19 11:09:40 ==> NewTemplateRecvMethod Player Gopx_OnCmd
2025/12/19 11:09:40 ==> AliasMethod github.com/goplus/xgo/cl/internal/overload/bar.Player Gopx_OnCmd => OnCmd
2025/12/19 11:09:40 ==> NewOverloadFunc Gopx_Var_Cast
2025/12/19 11:09:40 ==> AliasFunc Gopx_Var_Cast => Var_Cast
2025/12/19 11:09:40 ==> NewOverloadNamed Var
2025/12/19 11:09:40 ==> Preload var [a]
2025/12/19 11:09:40 ==> Preload var [b]
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load var github.com/goplus/xgo/cl/internal/overload/bar.Var__0[int] [a]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [a]
2025/12/19 11:09:40 ==> Load var github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any] [b]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [b]
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 DefineVarStart [c]
2025/12/19 11:09:40 Val Var func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()}) => Typ func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val string string
2025/12/19 11:09:40 Val type string => Typ string
2025/12/19 11:09:40 Call 1 0 // TypeType{typ: func(__xgo_overload_args__ interface{_()})}
2025/12/19 11:09:40 ==> MatchFuncCall TypeType{typ: func(__xgo_overload_args__ interface{_()})} args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 8
2025/12/19 11:09:40 ==> MatchFuncCall func[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T] args: 1 flags: 8
2025/12/19 11:09:40 boundTypeParams: bar.Gopx_Var_Cast__0 sig: func[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T] args: 1 flags: 8
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 DefineVarStart [d]
2025/12/19 11:09:40 Val Var func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()}) => Typ func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val M map[string]any
2025/12/19 11:09:40 Val type github.com/goplus/xgo/cl/internal/overload/bar.M = map[string]any => Typ map[string]any
2025/12/19 11:09:40 Call 1 0 // TypeType{typ: func(__xgo_overload_args__ interface{_()})}
2025/12/19 11:09:40 ==> MatchFuncCall TypeType{typ: func(__xgo_overload_args__ interface{_()})} args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 8
2025/12/19 11:09:40 ==> MatchFuncCall func[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T] args: 1 flags: 8
2025/12/19 11:09:40 boundTypeParams: bar.Gopx_Var_Cast__0 sig: func[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T] args: 1 flags: 8
2025/12/19 11:09:40 ==> MatchFuncCall func[T map[string]any]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[T] args: 1 flags: 8
2025/12/19 11:09:40 boundTypeParams: bar.Gopx_Var_Cast__1 sig: func[T map[string]any]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[T] args: 1 flags: 8
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestOverloadNamed (0.03s)
=== RUN   TestMixedOverloadNamed
2025/12/19 11:09:40 ==> Preload var [a]
2025/12/19 11:09:40 ==> Preload var [b]
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Preload type M
2025/12/19 11:09:40 ==> Preload type basetype
2025/12/19 11:09:40 ==> Preload type Var__0
2025/12/19 11:09:40 ==> Preload type Var__1
2025/12/19 11:09:40 ==> Preload func Gopx_Var_Cast__0
2025/12/19 11:09:40 ==> Preload func Gopx_Var_Cast__1
2025/12/19 11:09:40 ==> Load func Gopx_Var_Cast__0
2025/12/19 11:09:40 ==> Load > NewType basetype
2025/12/19 11:09:40 ==> Lookup (LoadSymbol) basetype => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:40 ==> Load > InitType basetype
2025/12/19 11:09:40 ==> Load > NewType Var__0
2025/12/19 11:09:40 ==> Lookup (LoadSymbol) Var__0 => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Var__0
2025/12/19 11:09:40 ==> Load > InitType Var__0
2025/12/19 11:09:40 ==> LookupParent basetype => type github.com/goplus/xgo/cl.basetype interface{interface{string | int | bool | float64}}
2025/12/19 11:09:40 ==> Load func Gopx_Var_Cast__1
2025/12/19 11:09:40 ==> Load > NewType Var__1
2025/12/19 11:09:40 ==> Lookup (LoadSymbol) Var__1 => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Var__1
2025/12/19 11:09:40 ==> Load > InitType Var__1
2025/12/19 11:09:40 ==> Load > AliasType M
2025/12/19 11:09:40 ==> NewOverloadFunc Gopx_Var_Cast
2025/12/19 11:09:40 ==> AliasFunc Gopx_Var_Cast => Var_Cast
2025/12/19 11:09:40 ==> NewOverloadNamed Var
2025/12/19 11:09:40 ==> LookupParent Var => type github.com/goplus/xgo/cl.Var = func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> Load var github.com/goplus/xgo/cl.Var__0[int] [a]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [a]
2025/12/19 11:09:40 ==> LookupParent Var => type github.com/goplus/xgo/cl.Var = func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> LookupParent M => type github.com/goplus/xgo/cl.M = map[string]interface{}
2025/12/19 11:09:40 ==> Load var github.com/goplus/xgo/cl.Var__1[map[string]interface{}] [b]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [b]
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 DefineVarStart [c]
2025/12/19 11:09:40 Val Var func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val type github.com/goplus/xgo/cl.Var = func(__xgo_overload_args__ interface{_()}) => Typ func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val string string
2025/12/19 11:09:40 Val type string => Typ string
2025/12/19 11:09:40 Call 1 0 // TypeType{typ: func(__xgo_overload_args__ interface{_()})}
2025/12/19 11:09:40 ==> MatchFuncCall TypeType{typ: func(__xgo_overload_args__ interface{_()})} args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 8
2025/12/19 11:09:40 ==> MatchFuncCall func[T github.com/goplus/xgo/cl.basetype]() *github.com/goplus/xgo/cl.Var__0[T] args: 1 flags: 8
2025/12/19 11:09:40 boundTypeParams: Gopx_Var_Cast__0 sig: func[T github.com/goplus/xgo/cl.basetype]() *github.com/goplus/xgo/cl.Var__0[T] args: 1 flags: 8
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 DefineVarStart [d]
2025/12/19 11:09:40 Val Var func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val type github.com/goplus/xgo/cl.Var = func(__xgo_overload_args__ interface{_()}) => Typ func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val M map[string]interface{}
2025/12/19 11:09:40 Val type github.com/goplus/xgo/cl.M = map[string]interface{} => Typ map[string]interface{}
2025/12/19 11:09:40 Call 1 0 // TypeType{typ: func(__xgo_overload_args__ interface{_()})}
2025/12/19 11:09:40 ==> MatchFuncCall TypeType{typ: func(__xgo_overload_args__ interface{_()})} args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 8
2025/12/19 11:09:40 ==> MatchFuncCall func[T github.com/goplus/xgo/cl.basetype]() *github.com/goplus/xgo/cl.Var__0[T] args: 1 flags: 8
2025/12/19 11:09:40 boundTypeParams: Gopx_Var_Cast__0 sig: func[T github.com/goplus/xgo/cl.basetype]() *github.com/goplus/xgo/cl.Var__0[T] args: 1 flags: 8
2025/12/19 11:09:40 ==> MatchFuncCall func[T map[string]interface{}]() *github.com/goplus/xgo/cl.Var__1[T] args: 1 flags: 8
2025/12/19 11:09:40 boundTypeParams: Gopx_Var_Cast__1 sig: func[T map[string]interface{}]() *github.com/goplus/xgo/cl.Var__1[T] args: 1 flags: 8
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestMixedOverloadNamed (0.00s)
=== RUN   TestStringLitBasic
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "$"} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("$"), any
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestStringLitBasic (0.00s)
=== RUN   TestStringLitVar
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 DefineVarStart [x]
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "Hi, "} *ast.BasicLit
2025/12/19 11:09:40 Val Concat func(parts ...string) string
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 Val x int
2025/12/19 11:09:40 Member string 2 // int
2025/12/19 11:09:40 Val Itoa func(i int) string
2025/12/19 11:09:40 Call 1 0 // func(i int) string
2025/12/19 11:09:40 ==> MatchFuncCall func(i int) string args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, int
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 Call 3 0 // func(parts ...string) string
2025/12/19 11:09:40 ==> MatchFuncCall func(parts ...string) string args: 3 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("a"), string
2025/12/19 11:09:40 ==> MatchType string, string
2025/12/19 11:09:40 ==> MatchType untyped string ("b"), string
2025/12/19 11:09:40 BinaryOp +
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("Hi, "), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType string, unboundFuncParam{typ: untyped string}
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType string, any
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestStringLitVar (0.00s)
=== RUN   TestFileOpen
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 ForRange [_ line]
2025/12/19 11:09:40 Val open func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "foo.txt"} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(name string) (*os.File, error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("foo.txt"), string
2025/12/19 11:09:40 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:40 NewVar [_xgo_err]
2025/12/19 11:09:40 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:40 VarRef _xgo_err error
2025/12/19 11:09:40 Assign 2 1
2025/12/19 11:09:40 ==> MatchType *os.File, unboundType{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType error, error
2025/12/19 11:09:40 ==> EnsureLoaded error
2025/12/19 11:09:40 ==> EnsureLoaded error
2025/12/19 11:09:40 If
2025/12/19 11:09:40 Val _xgo_err error
2025/12/19 11:09:40 Val <nil> <nil>
2025/12/19 11:09:40 BinaryOp !=
2025/12/19 11:09:40 Typ error
2025/12/19 11:09:40 Member Gop_NE 0 // TypeType{typ: error}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 VarRef _xgo_err error
2025/12/19 11:09:40 Val NewFrame func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:40 Val _xgo_err error
2025/12/19 11:09:40 Val open("foo.txt") string
2025/12/19 11:09:40 Val /foo/bar.xgo string
2025/12/19 11:09:40 Val 2 int
2025/12/19 11:09:40 Val main.main string
2025/12/19 11:09:40 Call 5 0 // func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame
2025/12/19 11:09:40 ==> MatchFuncCall func(err error, code string, file string, line int, fn string, args ...interface{}) *github.com/qiniu/x/errors.Frame args: 5 flags: 0
2025/12/19 11:09:40 ==> MatchType error, error
2025/12/19 11:09:40 ==> EnsureLoaded error
2025/12/19 11:09:40 ==> EnsureLoaded error
2025/12/19 11:09:40 ==> MatchType untyped string ("open(\"foo.txt\")"), string
2025/12/19 11:09:40 ==> MatchType untyped string ("/foo/bar.xgo"), string
2025/12/19 11:09:40 ==> MatchType untyped int (2), int
2025/12/19 11:09:40 ==> MatchType untyped string ("main.main"), string
2025/12/19 11:09:40 Assign 1 1
2025/12/19 11:09:40 ==> MatchType *github.com/qiniu/x/errors.Frame, error
2025/12/19 11:09:40 ==> EnsureLoaded error
2025/12/19 11:09:40 Val panic func(v interface{})
2025/12/19 11:09:40 Val _xgo_err error
2025/12/19 11:09:40 Call 1 0 // func(v interface{})
2025/12/19 11:09:40 ==> MatchFuncCall func(v interface{}) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType error, interface{}
2025/12/19 11:09:40 ==> EnsureLoaded error
2025/12/19 11:09:40 End // If
2025/12/19 11:09:40 Return 0
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 Call 0 0 // func() (_xgo_ret *os.File)
2025/12/19 11:09:40 ==> MatchFuncCall func() (_xgo_ret *os.File) args: 0 flags: 0
2025/12/19 11:09:40 RangeAssignThen
2025/12/19 11:09:40 VBlock
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val line string
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType string, any
2025/12/19 11:09:40 End // Vblock
2025/12/19 11:09:40 End // ForRange
2025/12/19 11:09:40 Member Gop_Enum 0 // *os.File
2025/12/19 11:09:40 Val EnumLines func(r io.Reader) github.com/qiniu/x/osx.LineIter
2025/12/19 11:09:40 Call 1 0 // func(r io.Reader) github.com/qiniu/x/osx.LineIter
2025/12/19 11:09:40 ==> MatchFuncCall func(r io.Reader) github.com/qiniu/x/osx.LineIter args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType *os.File, io.Reader
2025/12/19 11:09:40 ==> EnsureLoaded io.Reader
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestFileOpen (0.00s)
=== RUN   TestMixedGo
2025/12/19 11:09:40 ==> Preload var [a]
2025/12/19 11:09:40 ==> Preload var [b]
2025/12/19 11:09:40 ==> Preload var [c]
2025/12/19 11:09:40 ==> Preload var [d]
2025/12/19 11:09:40 ==> Preload var [e]
2025/12/19 11:09:40 ==> Preload var [x]
2025/12/19 11:09:40 NewConstDefs
2025/12/19 11:09:40 ==> Preload const [n]
2025/12/19 11:09:40 ==> Preload func f
2025/12/19 11:09:40 ==> Preload type foo
2025/12/19 11:09:40 ==> Preload method foo._
2025/12/19 11:09:40 ==> Preload method foo.Str
2025/12/19 11:09:40 ==> Preload method foo.Bar
2025/12/19 11:09:40 ==> Preload type foo2
2025/12/19 11:09:40 ==> Preload type foo3
2025/12/19 11:09:40 ==> Load > NewType foo
2025/12/19 11:09:40 ==> Load > InitType foo
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{v int}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.foo._
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{v int}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.foo.Str
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{v int}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.foo.Bar
2025/12/19 11:09:40 ==> Load > NewType foo3
2025/12/19 11:09:40 ==> Load > InitType foo3
2025/12/19 11:09:40 ==> Load > AliasType foo2
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo struct{v int}
2025/12/19 11:09:40 ==> Lookup (LoadSymbol) foo2 => type github.com/goplus/xgo/cl.foo2 = github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 ==> Load const [n] <nil>
2025/12/19 11:09:40 NewConst [n] 0
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val n untyped int
2025/12/19 11:09:40 ==> Load var [10]int [a]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [a]
2025/12/19 11:09:40 ==> Load var string [b]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [b]
2025/12/19 11:09:40 ==> Load func f
2025/12/19 11:09:40 Val f func(v int) string
2025/12/19 11:09:40 Val n untyped int
2025/12/19 11:09:40 Call 1 0 // func(v int) string
2025/12/19 11:09:40 ==> MatchFuncCall func(v int) string args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (10), int
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ==> MatchType string, string
2025/12/19 11:09:40 ==> LookupParent foo2 => type github.com/goplus/xgo/cl.foo2 = github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 ==> Load var github.com/goplus/xgo/cl.foo [c]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [c]
2025/12/19 11:09:40 ==> Load var int [d]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [d]
2025/12/19 11:09:40 Val c github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Member v 2 // github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ==> MatchType int, int
2025/12/19 11:09:40 ==> Load var <nil> [e]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [e]
2025/12/19 11:09:40 ==> LookupParent foo3 => type github.com/goplus/xgo/cl.foo3 struct{v int}
2025/12/19 11:09:40 StructLit github.com/goplus/xgo/cl.foo3 0 false
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ==> Load var string [x]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [x]
2025/12/19 11:09:40 Val c github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Member str 2 // github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Call 0 0 // func() string
2025/12/19 11:09:40 ==> MatchFuncCall func() string args: 0 flags: 0
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ==> MatchType string, string
2025/12/19 11:09:40 ==> ASTFile
2025/12/19 11:09:40 ==> Preload type T
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Preload type Point
2025/12/19 11:09:40 ==> Load > NewType Point
2025/12/19 11:09:40 ==> Load > InitType Point
2025/12/19 11:09:40 ==> Load > NewType T
2025/12/19 11:09:40 NewType T
2025/12/19 11:09:40 ==> Load > InitType T
2025/12/19 11:09:40 InitType T struct{}
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/12/19 11:09:40 StructLit github.com/goplus/xgo/cl.T 0 false
2025/12/19 11:09:40 UnaryOp & flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:40 ==> LookupParent Point => type github.com/goplus/xgo/cl.Point struct{X int; Y int}
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 20} *ast.BasicLit
2025/12/19 11:09:40 StructLit github.com/goplus/xgo/cl.Point 2 false
2025/12/19 11:09:40 UnaryOp & flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType *github.com/goplus/xgo/cl.T, any
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 ==> MatchType *github.com/goplus/xgo/cl.Point, any
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Point
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestMixedGo (0.00s)
=== RUN   TestTypeAsParamsFunc
2025/12/19 11:09:40 ==> Preload var [tbl]
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Preload type basetype
2025/12/19 11:09:40 ==> Preload func Gopx_Row__0
2025/12/19 11:09:40 ==> Preload func Gopx_Row__1
2025/12/19 11:09:40 ==> Preload func Gopx_Col
2025/12/19 11:09:40 ==> Preload type Table
2025/12/19 11:09:40 ==> Preload func Gopt_Table_Gopx_Col__0
2025/12/19 11:09:40 ==> Preload func Gopt_Table_Gopx_Col__1
2025/12/19 11:09:40 ==> Load > NewType Table
2025/12/19 11:09:40 ==> Load > InitType Table
2025/12/19 11:09:40 ==> Load func Gopt_Table_Gopx_Col__1
2025/12/19 11:09:40 ==> LookupParent Table => type github.com/goplus/xgo/cl.Table struct{}
2025/12/19 11:09:40 ==> Load > NewType basetype
2025/12/19 11:09:40 ==> Load > InitType basetype
2025/12/19 11:09:40 ==> Load func Gopx_Row__0
2025/12/19 11:09:40 ==> LookupParent basetype => type github.com/goplus/xgo/cl.basetype interface{interface{int | string}}
2025/12/19 11:09:40 ==> Load func Gopx_Row__1
2025/12/19 11:09:40 ==> Load func Gopt_Table_Gopx_Col__0
2025/12/19 11:09:40 ==> LookupParent basetype => type github.com/goplus/xgo/cl.basetype interface{interface{int | string}}
2025/12/19 11:09:40 ==> LookupParent Table => type github.com/goplus/xgo/cl.Table struct{}
2025/12/19 11:09:40 ==> Load func Gopx_Col
2025/12/19 11:09:40 ==> AliasFunc Gopx_Col => Col
2025/12/19 11:09:40 ==> NewOverloadFunc Gopt_Table_Gopx_Col
2025/12/19 11:09:40 ==> NewTemplateRecvMethod Table Gopx_Col
2025/12/19 11:09:40 ==> AliasMethod github.com/goplus/xgo/cl.Table Gopx_Col => Col
2025/12/19 11:09:40 ==> NewOverloadFunc Gopx_Row
2025/12/19 11:09:40 ==> AliasFunc Gopx_Row => Row
2025/12/19 11:09:40 ==> LookupParent Table => type github.com/goplus/xgo/cl.Table struct{}
2025/12/19 11:09:40 ==> Load var *github.com/goplus/xgo/cl.Table [tbl]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [tbl]
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 Val Col func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val string string
2025/12/19 11:09:40 Val type string => Typ string
2025/12/19 11:09:40 Val &{0 STRING "name"} *ast.BasicLit
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyTypeAsParams args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func[T interface{}](name string) args: 2 flags: 8
2025/12/19 11:09:40 boundTypeParams: Gopx_Col sig: func[T interface{}](name string) args: 2 flags: 8
2025/12/19 11:09:40 ==> MatchType untyped string ("name"), string
2025/12/19 11:09:40 Val Col func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val int int
2025/12/19 11:09:40 Val type int => Typ int
2025/12/19 11:09:40 Val &{0 STRING "age"} *ast.BasicLit
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyTypeAsParams args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func[T interface{}](name string) args: 2 flags: 8
2025/12/19 11:09:40 boundTypeParams: Gopx_Col sig: func[T interface{}](name string) args: 2 flags: 8
2025/12/19 11:09:40 ==> MatchType untyped string ("age"), string
2025/12/19 11:09:40 Val Row func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val string string
2025/12/19 11:09:40 Val type string => Typ string
2025/12/19 11:09:40 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyTypeAsParams args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 8
2025/12/19 11:09:40 ==> MatchFuncCall func[T github.com/goplus/xgo/cl.basetype](name string) args: 2 flags: 8
2025/12/19 11:09:40 boundTypeParams: Gopx_Row__0 sig: func[T github.com/goplus/xgo/cl.basetype](name string) args: 2 flags: 8
2025/12/19 11:09:40 ==> MatchType untyped int (100), string
2025/12/19 11:09:40 ==> MatchFuncCall func[Array interface{}](v int) args: 2 flags: 8
2025/12/19 11:09:40 boundTypeParams: Gopx_Row__1 sig: func[Array interface{}](v int) args: 2 flags: 8
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 Val tbl *github.com/goplus/xgo/cl.Table
2025/12/19 11:09:40 Member col 1 // *github.com/goplus/xgo/cl.Table
2025/12/19 11:09:40 Val string string
2025/12/19 11:09:40 Val type string => Typ string
2025/12/19 11:09:40 Val &{0 STRING "foo"} *ast.BasicLit
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyTypeAsParams args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 8
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 24
2025/12/19 11:09:40 ==> MatchFuncCall func[T github.com/goplus/xgo/cl.basetype](p *github.com/goplus/xgo/cl.Table, name string) args: 3 flags: 24
2025/12/19 11:09:40 boundTypeParams: Gopt_Table_Gopx_Col__0 sig: func[T github.com/goplus/xgo/cl.basetype](p *github.com/goplus/xgo/cl.Table, name string) args: 3 flags: 24
2025/12/19 11:09:40 ==> MatchType *github.com/goplus/xgo/cl.Table, *github.com/goplus/xgo/cl.Table
2025/12/19 11:09:40 ==> MatchType untyped string ("foo"), string
2025/12/19 11:09:40 Val tbl *github.com/goplus/xgo/cl.Table
2025/12/19 11:09:40 Member col 1 // *github.com/goplus/xgo/cl.Table
2025/12/19 11:09:40 Val int int
2025/12/19 11:09:40 Val type int => Typ int
2025/12/19 11:09:40 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyTypeAsParams args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 8
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 24
2025/12/19 11:09:40 ==> MatchFuncCall func[T github.com/goplus/xgo/cl.basetype](p *github.com/goplus/xgo/cl.Table, name string) args: 3 flags: 24
2025/12/19 11:09:40 boundTypeParams: Gopt_Table_Gopx_Col__0 sig: func[T github.com/goplus/xgo/cl.basetype](p *github.com/goplus/xgo/cl.Table, name string) args: 3 flags: 24
2025/12/19 11:09:40 ==> MatchType *github.com/goplus/xgo/cl.Table, *github.com/goplus/xgo/cl.Table
2025/12/19 11:09:40 ==> MatchType untyped int (100), string
2025/12/19 11:09:40 ==> MatchFuncCall func[Array interface{}](p *github.com/goplus/xgo/cl.Table, v int) args: 3 flags: 24
2025/12/19 11:09:40 boundTypeParams: Gopt_Table_Gopx_Col__1 sig: func[Array interface{}](p *github.com/goplus/xgo/cl.Table, v int) args: 3 flags: 24
2025/12/19 11:09:40 ==> MatchType *github.com/goplus/xgo/cl.Table, *github.com/goplus/xgo/cl.Table
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestTypeAsParamsFunc (0.00s)
=== RUN   TestYaptest
2025/12/19 11:09:40 ==> Preload var [c]
2025/12/19 11:09:40 ==> Preload var [a]
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Import github.com/goplus/xgo/cl/internal/test
2025/12/19 11:09:40 ==> NewTemplateRecvMethod Case MatchAny
2025/12/19 11:09:40 ==> NewTemplateRecvMethod Case MatchTBase
2025/12/19 11:09:40 ==> NewOverloadFunc Gopt_Case_Match
2025/12/19 11:09:40 ==> NewTemplateRecvMethod Case Match
2025/12/19 11:09:40 ==> Preload type Class
2025/12/19 11:09:40 ==> Load > NewType Class
2025/12/19 11:09:40 ==> Load > InitType Class
2025/12/19 11:09:40 ==> LookupParent Class => type github.com/goplus/xgo/cl.Class struct{github.com/goplus/xgo/cl/internal/test.Case}
2025/12/19 11:09:40 ==> Load var github.com/goplus/xgo/cl.Class [c]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [c]
2025/12/19 11:09:40 ==> Load var int [a]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [a]
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 Val c github.com/goplus/xgo/cl.Class
2025/12/19 11:09:40 Member match 1 // github.com/goplus/xgo/cl.Class
2025/12/19 11:09:40 Val a int
2025/12/19 11:09:40 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 16
2025/12/19 11:09:40 ==> MatchFuncCall func[T github.com/goplus/xgo/cl/internal/test.basetype](t github.com/goplus/xgo/cl/internal/test.CaseT, got T, expected T, name ...string) args: 3 flags: 16
2025/12/19 11:09:40 ==> InferFunc func(t github.com/goplus/xgo/cl/internal/test.CaseT, got int, expected int, name ...string)
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.Class, github.com/goplus/xgo/cl/internal/test.CaseT
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Class
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/test.CaseT
2025/12/19 11:09:40 ==> MatchType int, int
2025/12/19 11:09:40 ==> MatchType untyped string ("b"), int
2025/12/19 11:09:40 ==> MatchFuncCall func(t github.com/goplus/xgo/cl/internal/test.CaseT, got any, expected any, name ...string) args: 3 flags: 16
2025/12/19 11:09:40 ==> MatchType github.com/goplus/xgo/cl.Class, github.com/goplus/xgo/cl/internal/test.CaseT
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.Class
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl/internal/test.CaseT
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 ==> MatchType untyped string ("b"), any
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestYaptest (0.21s)
=== RUN   TestRangeExpr
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 For
2025/12/19 11:09:40 DefineVarStart [i]
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 For
2025/12/19 11:09:40 DefineVarStart [i]
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 DefineVarStart [i]
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 For
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 Assign 1 1
2025/12/19 11:09:40 ==> MatchType untyped int (0), int
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 For
2025/12/19 11:09:40 DefineVarStart [i]
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 For
2025/12/19 11:09:40 DefineVarStart [i]
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 DefineVarStart [i]
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 For
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 Assign 1 1
2025/12/19 11:09:40 ==> MatchType untyped int (1), int
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestRangeExpr (0.00s)
=== RUN   TestRangeExpr2
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 For
2025/12/19 11:09:40 DefineVarStart [i]
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 For
2025/12/19 11:09:40 DefineVarStart [i]
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 DefineVarStart [i]
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 For
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 Assign 1 1
2025/12/19 11:09:40 ==> MatchType untyped int (1), int
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestRangeExpr2 (0.00s)
=== RUN   TestRangeExpr3
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 For
2025/12/19 11:09:40 DefineVarStart [i]
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 For
2025/12/19 11:09:40 DefineVarStart [i]
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 DefineVarStart [i]
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 For
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 Assign 1 1
2025/12/19 11:09:40 ==> MatchType untyped int (1), int
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestRangeExpr3 (0.00s)
=== RUN   TestRangeExpr4
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 For
2025/12/19 11:09:40 DefineVarStart [i]
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 For
2025/12/19 11:09:40 DefineVarStart [i]
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 DefineVarStart [i]
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 For
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 Assign 1 1
2025/12/19 11:09:40 ==> MatchType untyped int (0), int
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestRangeExpr4 (0.00s)
=== RUN   TestRangeExpr5
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 For
2025/12/19 11:09:40 DefineVarStart [_xgo_k]
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val _xgo_k int
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("Hi"), any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef _xgo_k int
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestRangeExpr5 (0.00s)
=== RUN   TestRangeExpr6
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 For
2025/12/19 11:09:40 DefineVarStart [_xgo_k]
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val _xgo_k int
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("Hi"), any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef _xgo_k int
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestRangeExpr6 (0.00s)
=== RUN   TestRangeExpr8
2025/12/19 11:09:40 ==> Preload type T
2025/12/19 11:09:40 ==> Preload method T.start
2025/12/19 11:09:40 ==> Preload method T.end
2025/12/19 11:09:40 ==> Preload method T.step
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load > NewType T
2025/12/19 11:09:40 NewType T
2025/12/19 11:09:40 ==> Load > InitType T
2025/12/19 11:09:40 InitType T struct{}
2025/12/19 11:09:40 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.T.start
2025/12/19 11:09:40 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.T.end
2025/12/19 11:09:40 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.T.step
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 DefineVarStart [t]
2025/12/19 11:09:40 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/12/19 11:09:40 StructLit github.com/goplus/xgo/cl.T 0 false
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 For
2025/12/19 11:09:40 DefineVarStart [i _xgo_end _xgo_step]
2025/12/19 11:09:40 Val t github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Member start 1 // github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Call 0 0 // func() int
2025/12/19 11:09:40 ==> MatchFuncCall func() int args: 0 flags: 0
2025/12/19 11:09:40 Val t github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Member end 1 // github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Call 0 0 // func() int
2025/12/19 11:09:40 ==> MatchFuncCall func() int args: 0 flags: 0
2025/12/19 11:09:40 Val t github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Member step 1 // github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Call 0 0 // func() int
2025/12/19 11:09:40 ==> MatchFuncCall func() int args: 0 flags: 0
2025/12/19 11:09:40 EndInit 3
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Val _xgo_end int
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val _xgo_step int
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc start (github.com/goplus/xgo/cl.T) func() int
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType untyped int (0), int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc end (github.com/goplus/xgo/cl.T) func() int
2025/12/19 11:09:40 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType untyped int (3), int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc step (github.com/goplus/xgo/cl.T) func() int
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType untyped int (1), int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
2025/12/19 11:09:40 ==> Preload type T
2025/12/19 11:09:40 ==> Preload method T.start
2025/12/19 11:09:40 ==> Preload method T.end
2025/12/19 11:09:40 ==> Preload method T.step
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load > NewType T
2025/12/19 11:09:40 NewType T
2025/12/19 11:09:40 ==> Load > InitType T
2025/12/19 11:09:40 InitType T struct{}
2025/12/19 11:09:40 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.T.start
2025/12/19 11:09:40 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.T.end
2025/12/19 11:09:40 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.T.step
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 DefineVarStart [t]
2025/12/19 11:09:40 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/12/19 11:09:40 StructLit github.com/goplus/xgo/cl.T 0 false
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 For
2025/12/19 11:09:40 DefineVarStart [i _xgo_end _xgo_step]
2025/12/19 11:09:40 Val t github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Member start 1 // github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Call 0 0 // func() int
2025/12/19 11:09:40 ==> MatchFuncCall func() int args: 0 flags: 0
2025/12/19 11:09:40 Val t github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Member end 1 // github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Call 0 0 // func() int
2025/12/19 11:09:40 ==> MatchFuncCall func() int args: 0 flags: 0
2025/12/19 11:09:40 Val t github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Member step 1 // github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Call 0 0 // func() int
2025/12/19 11:09:40 ==> MatchFuncCall func() int args: 0 flags: 0
2025/12/19 11:09:40 EndInit 3
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Val _xgo_end int
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val _xgo_step int
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc start (github.com/goplus/xgo/cl.T) func() int
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType untyped int (0), int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc end (github.com/goplus/xgo/cl.T) func() int
2025/12/19 11:09:40 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType untyped int (3), int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc step (github.com/goplus/xgo/cl.T) func() int
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType untyped int (1), int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestRangeExpr8 (0.00s)
=== RUN   TestRangeExpr9
2025/12/19 11:09:40 ==> Preload type T
2025/12/19 11:09:40 ==> Preload method T.start
2025/12/19 11:09:40 ==> Preload method T.end
2025/12/19 11:09:40 ==> Preload method T.step
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load > NewType T
2025/12/19 11:09:40 NewType T
2025/12/19 11:09:40 ==> Load > InitType T
2025/12/19 11:09:40 InitType T struct{}
2025/12/19 11:09:40 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.T.start
2025/12/19 11:09:40 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.T.end
2025/12/19 11:09:40 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.T.step
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 DefineVarStart [t]
2025/12/19 11:09:40 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/12/19 11:09:40 StructLit github.com/goplus/xgo/cl.T 0 false
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 DefineVarStart [i]
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 For
2025/12/19 11:09:40 DefineVarStart [_xgo_k _xgo_end _xgo_step]
2025/12/19 11:09:40 Val t github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Member start 1 // github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Call 0 0 // func() int
2025/12/19 11:09:40 ==> MatchFuncCall func() int args: 0 flags: 0
2025/12/19 11:09:40 Val t github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Member end 1 // github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Call 0 0 // func() int
2025/12/19 11:09:40 ==> MatchFuncCall func() int args: 0 flags: 0
2025/12/19 11:09:40 Val t github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Member step 1 // github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Call 0 0 // func() int
2025/12/19 11:09:40 ==> MatchFuncCall func() int args: 0 flags: 0
2025/12/19 11:09:40 EndInit 3
2025/12/19 11:09:40 Val _xgo_k int
2025/12/19 11:09:40 Val _xgo_end int
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val _xgo_k int
2025/12/19 11:09:40 Assign 1 1
2025/12/19 11:09:40 ==> MatchType int, int
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef _xgo_k int
2025/12/19 11:09:40 Val _xgo_step int
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc start (github.com/goplus/xgo/cl.T) func() int
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType untyped int (0), int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc end (github.com/goplus/xgo/cl.T) func() int
2025/12/19 11:09:40 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType untyped int (3), int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc step (github.com/goplus/xgo/cl.T) func() int
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType untyped int (1), int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
2025/12/19 11:09:40 ==> Preload type T
2025/12/19 11:09:40 ==> Preload method T.start
2025/12/19 11:09:40 ==> Preload method T.end
2025/12/19 11:09:40 ==> Preload method T.step
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load > NewType T
2025/12/19 11:09:40 NewType T
2025/12/19 11:09:40 ==> Load > InitType T
2025/12/19 11:09:40 InitType T struct{}
2025/12/19 11:09:40 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.T.start
2025/12/19 11:09:40 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.T.end
2025/12/19 11:09:40 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/12/19 11:09:40 ==> Load method github.com/goplus/xgo/cl.T.step
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 DefineVarStart [t]
2025/12/19 11:09:40 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{}
2025/12/19 11:09:40 StructLit github.com/goplus/xgo/cl.T 0 false
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 DefineVarStart [i]
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 For
2025/12/19 11:09:40 DefineVarStart [_xgo_k _xgo_end _xgo_step]
2025/12/19 11:09:40 Val t github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Member start 1 // github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Call 0 0 // func() int
2025/12/19 11:09:40 ==> MatchFuncCall func() int args: 0 flags: 0
2025/12/19 11:09:40 Val t github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Member end 1 // github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Call 0 0 // func() int
2025/12/19 11:09:40 ==> MatchFuncCall func() int args: 0 flags: 0
2025/12/19 11:09:40 Val t github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Member step 1 // github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Call 0 0 // func() int
2025/12/19 11:09:40 ==> MatchFuncCall func() int args: 0 flags: 0
2025/12/19 11:09:40 EndInit 3
2025/12/19 11:09:40 Val _xgo_k int
2025/12/19 11:09:40 Val _xgo_end int
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val _xgo_k int
2025/12/19 11:09:40 Assign 1 1
2025/12/19 11:09:40 ==> MatchType int, int
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef _xgo_k int
2025/12/19 11:09:40 Val _xgo_step int
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc start (github.com/goplus/xgo/cl.T) func() int
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType untyped int (0), int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc end (github.com/goplus/xgo/cl.T) func() int
2025/12/19 11:09:40 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType untyped int (3), int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc step (github.com/goplus/xgo/cl.T) func() int
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType untyped int (1), int
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestRangeExpr9 (0.00s)
=== RUN   TestRangeExpr10
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 For
2025/12/19 11:09:40 DefineVarStart [_xgo_k]
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val _xgo_k int
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("Hi"), any
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef _xgo_k int
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestRangeExpr10 (0.00s)
=== RUN   Test_RangeExpressionIf_Issue1243
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 For
2025/12/19 11:09:40 DefineVarStart [i]
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp <
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType untyped int (10), unboundFuncParam{typ: int}
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 If
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp %
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:40 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 BinaryOp ==
2025/12/19 11:09:40 Then
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType int, any
2025/12/19 11:09:40 End // If
2025/12/19 11:09:40 Post
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 AssignOp += Gop_AddAssign
2025/12/19 11:09:40 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:09:40 ==> MatchType untyped int (1), unboundFuncParam{typ: int}
2025/12/19 11:09:40 End // For
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: Test_RangeExpressionIf_Issue1243 (0.00s)
=== RUN   TestStaticMethod
2025/12/19 11:09:40 ==> Preload type foo
2025/12/19 11:09:40 ==> Preload static method foo.New
2025/12/19 11:09:40 ==> Preload static method foo._add
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func Gops_foo_New
2025/12/19 11:09:40 ==> Load > NewType foo
2025/12/19 11:09:40 NewType foo
2025/12/19 11:09:40 ==> Lookup (LoadSymbol) foo => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:40 NewFunc Gops_foo_New func(a int) *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:40 Val foo github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Val %!v(PANIC=String method: nil underlying) => Typ github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:40 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType *github.com/goplus/xgo/cl.foo, *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 ==> Load > InitType foo
2025/12/19 11:09:40 InitType foo int
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load func Gops__foo___add
2025/12/19 11:09:40 ==> LookupParent foo => type github.com/goplus/xgo/cl.foo int
2025/12/19 11:09:40 NewFunc Gops__foo___add func() *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:40 Val foo github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Val type github.com/goplus/xgo/cl.foo int => Typ github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:40 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType *github.com/goplus/xgo/cl.foo, *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> NewStaticMethod foo _add
2025/12/19 11:09:40 ==> NewStaticMethod foo New
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 DefineVarStart [a]
2025/12/19 11:09:40 Val foo github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Val type github.com/goplus/xgo/cl.foo int => Typ github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 Member new 1 // TypeType{typ: github.com/goplus/xgo/cl.foo}
2025/12/19 11:09:40 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(a int) *github.com/goplus/xgo/cl.foo
2025/12/19 11:09:40 ==> MatchFuncCall func(a int) *github.com/goplus/xgo/cl.foo args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (100), int
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestStaticMethod (0.00s)
=== RUN   TestOverlodOptions
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Preload type PlayOptions
2025/12/19 11:09:40 ==> Preload type Game
2025/12/19 11:09:40 ==> Preload method Game.Play__0
2025/12/19 11:09:40 ==> Preload method Game.Play__1
2025/12/19 11:09:40 ==> Load > NewType PlayOptions
2025/12/19 11:09:40 ==> Load > InitType PlayOptions
2025/12/19 11:09:40 ==> Load > NewType Game
2025/12/19 11:09:40 ==> Load > InitType Game
2025/12/19 11:09:40 ==> LookupParent Game => type github.com/goplus/xgo/cl.Game struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.Game.Play__0
2025/12/19 11:09:40 ==> LookupParent PlayOptions => type github.com/goplus/xgo/cl.PlayOptions struct{Action int; Wait bool; Loop bool}
2025/12/19 11:09:40 ==> LookupParent Game => type github.com/goplus/xgo/cl.Game struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.Game.Play__1
2025/12/19 11:09:40 ==> LookupParent PlayOptions => type github.com/goplus/xgo/cl.PlayOptions struct{Action int; Wait bool; Loop bool}
2025/12/19 11:09:40 ==> NewOverloadMethod Game Play
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 DefineVarStart [g]
2025/12/19 11:09:40 ==> LookupParent Game => type github.com/goplus/xgo/cl.Game struct{}
2025/12/19 11:09:40 StructLit github.com/goplus/xgo/cl.Game 0 false
2025/12/19 11:09:40 UnaryOp & flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val g *github.com/goplus/xgo/cl.Game
2025/12/19 11:09:40 Member play 1 // *github.com/goplus/xgo/cl.Game
2025/12/19 11:09:40 Val &{0 STRING "work"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "work"} *ast.BasicLit
2025/12/19 11:09:40 Val 0 int
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 Val 2 int
2025/12/19 11:09:40 Val true untyped bool
2025/12/19 11:09:40 StructLit github.com/goplus/xgo/cl.PlayOptions 4 true
2025/12/19 11:09:40 UnaryOp & flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(options *github.com/goplus/xgo/cl.PlayOptions) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(name string, options *github.com/goplus/xgo/cl.PlayOptions) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("work"), string
2025/12/19 11:09:40 ==> MatchType *github.com/goplus/xgo/cl.PlayOptions, *github.com/goplus/xgo/cl.PlayOptions
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.PlayOptions
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.PlayOptions
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestOverlodOptions (0.00s)
=== RUN   TestEmbedField
2025/12/19 11:09:40 ==> Preload type Info
2025/12/19 11:09:40 ==> Preload type T
2025/12/19 11:09:40 ==> Preload func demo
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load > NewType Info
2025/12/19 11:09:40 NewType Info
2025/12/19 11:09:40 ==> Load > InitType Info
2025/12/19 11:09:40 InitType Info struct{id int}
2025/12/19 11:09:40 ==> Load > NewType T
2025/12/19 11:09:40 NewType T
2025/12/19 11:09:40 ==> Load > InitType T
2025/12/19 11:09:40 ==> LookupParent Info => type github.com/goplus/xgo/cl.Info struct{id int}
2025/12/19 11:09:40 InitType T struct{github.com/goplus/xgo/cl.Info; id string}
2025/12/19 11:09:40 ==> Load func demo
2025/12/19 11:09:40 ==> LookupParent T => type github.com/goplus/xgo/cl.T struct{github.com/goplus/xgo/cl.Info; id string}
2025/12/19 11:09:40 NewFunc demo func(t *github.com/goplus/xgo/cl.T)
2025/12/19 11:09:40 Val t *github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Member id -1 // *github.com/goplus/xgo/cl.T
2025/12/19 11:09:40 Val &{0 STRING "0"} *ast.BasicLit
2025/12/19 11:09:40 Assign 1 1
2025/12/19 11:09:40 ==> MatchType untyped string ("0"), string
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestEmbedField (0.00s)
=== RUN   TestOverloadUntyped
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Preload type specialObj
2025/12/19 11:09:40 ==> Preload type SpriteName
2025/12/19 11:09:40 ==> Preload type SpriteImpl
2025/12/19 11:09:40 ==> Preload method SpriteImpl.turn
2025/12/19 11:09:40 ==> Preload method SpriteImpl.TurnTo__0
2025/12/19 11:09:40 ==> Preload method SpriteImpl.TurnTo__1
2025/12/19 11:09:40 ==> Preload method SpriteImpl.TurnTo__2
2025/12/19 11:09:40 ==> Preload method SpriteImpl.TurnTo__3
2025/12/19 11:09:40 ==> Load > NewType specialObj
2025/12/19 11:09:40 ==> Load > InitType specialObj
2025/12/19 11:09:40 ==> Load > NewType SpriteName
2025/12/19 11:09:40 ==> Load > InitType SpriteName
2025/12/19 11:09:40 ==> Load > NewType SpriteImpl
2025/12/19 11:09:40 ==> Load > InitType SpriteImpl
2025/12/19 11:09:40 ==> LookupParent SpriteImpl => type github.com/goplus/xgo/cl.SpriteImpl struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.SpriteImpl.turn
2025/12/19 11:09:40 ==> LookupParent SpriteImpl => type github.com/goplus/xgo/cl.SpriteImpl struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.SpriteImpl.TurnTo__0
2025/12/19 11:09:40 ==> LookupParent SpriteImpl => type github.com/goplus/xgo/cl.SpriteImpl struct{}
2025/12/19 11:09:40 ==> LookupParent SpriteImpl => type github.com/goplus/xgo/cl.SpriteImpl struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.SpriteImpl.TurnTo__1
2025/12/19 11:09:40 ==> LookupParent SpriteName => type github.com/goplus/xgo/cl.SpriteName string
2025/12/19 11:09:40 ==> LookupParent SpriteImpl => type github.com/goplus/xgo/cl.SpriteImpl struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.SpriteImpl.TurnTo__2
2025/12/19 11:09:40 ==> LookupParent specialObj => type github.com/goplus/xgo/cl.specialObj int
2025/12/19 11:09:40 ==> LookupParent SpriteImpl => type github.com/goplus/xgo/cl.SpriteImpl struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.SpriteImpl.TurnTo__3
2025/12/19 11:09:40 ==> NewOverloadMethod SpriteImpl TurnTo
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 DefineVarStart [p]
2025/12/19 11:09:40 ==> LookupParent SpriteImpl => type github.com/goplus/xgo/cl.SpriteImpl struct{}
2025/12/19 11:09:40 StructLit github.com/goplus/xgo/cl.SpriteImpl 0 false
2025/12/19 11:09:40 UnaryOp & flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val p *github.com/goplus/xgo/cl.SpriteImpl
2025/12/19 11:09:40 Member turnTo 1 // *github.com/goplus/xgo/cl.SpriteImpl
2025/12/19 11:09:40 Val &{0 FLOAT 180.0} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(sprite *github.com/goplus/xgo/cl.SpriteImpl) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped float (180), *github.com/goplus/xgo/cl.SpriteImpl
2025/12/19 11:09:40 ==> MatchFuncCall func(sprite github.com/goplus/xgo/cl.SpriteName) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped float (180), github.com/goplus/xgo/cl.SpriteName
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.SpriteName
2025/12/19 11:09:40 ==> AssignableConv untyped int github.com/goplus/xgo/cl.SpriteName false
2025/12/19 11:09:40 ==> MatchFuncCall func(obj github.com/goplus/xgo/cl.specialObj) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped float (180), github.com/goplus/xgo/cl.specialObj
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.specialObj
2025/12/19 11:09:40 Val p *github.com/goplus/xgo/cl.SpriteImpl
2025/12/19 11:09:40 Member turnTo 1 // *github.com/goplus/xgo/cl.SpriteImpl
2025/12/19 11:09:40 Val &{0 FLOAT 180.1} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(sprite *github.com/goplus/xgo/cl.SpriteImpl) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped float (180.1), *github.com/goplus/xgo/cl.SpriteImpl
2025/12/19 11:09:40 ==> MatchFuncCall func(sprite github.com/goplus/xgo/cl.SpriteName) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped float (180.1), github.com/goplus/xgo/cl.SpriteName
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.SpriteName
2025/12/19 11:09:40 ==> AssignableConv untyped float github.com/goplus/xgo/cl.SpriteName false
2025/12/19 11:09:40 ==> MatchFuncCall func(obj github.com/goplus/xgo/cl.specialObj) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped float (180.1), github.com/goplus/xgo/cl.specialObj
2025/12/19 11:09:40 ==> EnsureLoaded github.com/goplus/xgo/cl.specialObj
2025/12/19 11:09:40 ==> MatchFuncCall func(degree float64) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped float (180.1), float64
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestOverloadUntyped (0.00s)
=== RUN   TestOverloadUntyped2
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Preload type SpriteImpl
2025/12/19 11:09:40 ==> Preload method SpriteImpl.Rand__0
2025/12/19 11:09:40 ==> Preload method SpriteImpl.Rand__1
2025/12/19 11:09:40 ==> Load > NewType SpriteImpl
2025/12/19 11:09:40 ==> Load > InitType SpriteImpl
2025/12/19 11:09:40 ==> LookupParent SpriteImpl => type github.com/goplus/xgo/cl.SpriteImpl struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.SpriteImpl.Rand__0
2025/12/19 11:09:40 ==> LookupParent SpriteImpl => type github.com/goplus/xgo/cl.SpriteImpl struct{}
2025/12/19 11:09:40 ==> Load method *github.com/goplus/xgo/cl.SpriteImpl.Rand__1
2025/12/19 11:09:40 ==> NewOverloadMethod SpriteImpl Rand
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 DefineVarStart [p]
2025/12/19 11:09:40 ==> LookupParent SpriteImpl => type github.com/goplus/xgo/cl.SpriteImpl struct{}
2025/12/19 11:09:40 StructLit github.com/goplus/xgo/cl.SpriteImpl 0 false
2025/12/19 11:09:40 UnaryOp & flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val p *github.com/goplus/xgo/cl.SpriteImpl
2025/12/19 11:09:40 Member rand 1 // *github.com/goplus/xgo/cl.SpriteImpl
2025/12/19 11:09:40 Val &{0 FLOAT 1.0} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 FLOAT 2.0} *ast.BasicLit
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(from int, to int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped float (1), int
2025/12/19 11:09:40 ==> MatchType untyped float (2), int
2025/12/19 11:09:40 Val p *github.com/goplus/xgo/cl.SpriteImpl
2025/12/19 11:09:40 Member rand 1 // *github.com/goplus/xgo/cl.SpriteImpl
2025/12/19 11:09:40 Val float64 float64
2025/12/19 11:09:40 Val type float64 => Typ float64
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // TypeType{typ: float64}
2025/12/19 11:09:40 ==> MatchFuncCall TypeType{typ: float64} args: 1 flags: 0
2025/12/19 11:09:40 Val float64 float64
2025/12/19 11:09:40 Val type float64 => Typ float64
2025/12/19 11:09:40 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // TypeType{typ: float64}
2025/12/19 11:09:40 ==> MatchFuncCall TypeType{typ: float64} args: 1 flags: 0
2025/12/19 11:09:40 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(from int, to int) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType float64 (1), int
2025/12/19 11:09:40 ==> MatchFuncCall func(from float64, to float64) args: 2 flags: 0
2025/12/19 11:09:40 ==> MatchType float64 (1), float64
2025/12/19 11:09:40 ==> MatchType float64 (2), float64
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestOverloadUntyped2 (0.00s)
=== RUN   TestSliceType
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 DefineVarStart [a]
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 2 false
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 Val a []interface{}
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 IndexRef 1
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:40 SliceLit <nil> 3 false
2025/12/19 11:09:40 Assign 1 1
2025/12/19 11:09:40 ==> MatchType []int, interface{}
2025/12/19 11:09:40 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val a []interface{}
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType []interface{}, any
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestSliceType (0.00s)
=== RUN   TestMapLitType
2025/12/19 11:09:40 ==> Preload var [a]
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load var interface{} [a]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [a]
2025/12/19 11:09:40 Val &{0 STRING "Monday"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 STRING "Tuesday"} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:40 MapLit <nil> 4
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ==> MatchType map[string]int, interface{}
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 Val a interface{}
2025/12/19 11:09:40 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType interface{}, any
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> ASTFile
--- PASS: TestMapLitType (0.00s)
=== RUN   TestErrTplLit
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:1:1
2025/12/19 11:09:40 Val NewEx func(src any, filename string, line int, col int, params ...any) (ret github.com/goplus/xgo/tpl.Compiler, err error)
2025/12/19 11:09:40 Val &{0 STRING `a = INT => { return }`} *ast.BasicLit
2025/12/19 11:09:40 Val bar.xgo string
2025/12/19 11:09:40 Val 1 int
2025/12/19 11:09:40 Val 4 int
2025/12/19 11:09:40 Val a string
2025/12/19 11:09:40 NewClosure func(self interface{}) interface{}
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:1:1
2025/12/19 11:09:40 Return 0
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:1:1
2025/12/19 11:09:40 Call 6 0 // func(src any, filename string, line int, col int, params ...any) (ret github.com/goplus/xgo/tpl.Compiler, err error)
2025/12/19 11:09:40 ==> MatchFuncCall func(src any, filename string, line int, col int, params ...any) (ret github.com/goplus/xgo/tpl.Compiler, err error) args: 6 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped string ("a = INT => { return }"), any
2025/12/19 11:09:40 ==> MatchType untyped string ("bar.xgo"), string
2025/12/19 11:09:40 ==> MatchType untyped int (1), int
2025/12/19 11:09:40 ==> MatchType untyped int (4), int
2025/12/19 11:09:40 ==> MatchType untyped string ("a"), any
2025/12/19 11:09:40 ==> MatchType func(self interface{}) interface{}, any
2025/12/19 11:09:40 End // Func
--- PASS: TestErrTplLit (0.00s)
=== RUN   TestErrSendStmt
2025/12/19 11:09:40 ==> Preload var [a]
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load var chan int [a]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [a]
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:40 Val a chan int
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
--- PASS: TestErrSendStmt (0.00s)
=== RUN   TestErrVargCommand
2025/12/19 11:09:40 ==> Preload func Ls
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func Ls
2025/12/19 11:09:40 NewFunc Ls func(int)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:5:1
2025/12/19 11:09:40 Val Ls func(int)
2025/12/19 11:09:40 Call 0 0 // func(int)
2025/12/19 11:09:40 ==> MatchFuncCall func(int) args: 0 flags: 0
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload type foo
2025/12/19 11:09:40 ==> Preload method foo.Ls
2025/12/19 11:09:40 ==> Preload var [f]
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load > NewType foo
2025/12/19 11:09:40 NewType foo
2025/12/19 11:09:40 ==> Load > InitType foo
2025/12/19 11:09:40 InitType foo int
2025/12/19 11:09:40 ==> LookupParent foo => type foo int
2025/12/19 11:09:40 ==> Load method foo.Ls
2025/12/19 11:09:40 ==> LookupParent foo => type foo int
2025/12/19 11:09:40 ==> Load var foo [f]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [f]
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:8:1
2025/12/19 11:09:40 Val f foo
2025/12/19 11:09:40 Member ls 1 // foo
2025/12/19 11:09:40 Call 0 0 // func(int)
2025/12/19 11:09:40 ==> MatchFuncCall func(int) args: 0 flags: 0
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 NewFunc Ls (foo) func(int)
2025/12/19 11:09:40 End // Func
--- PASS: TestErrVargCommand (0.00s)
=== RUN   TestErrUnsafe
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
--- PASS: TestErrUnsafe (0.00s)
=== RUN   TestErrLambdaExpr
2025/12/19 11:09:40 ==> Preload func foo
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func foo
2025/12/19 11:09:40 NewFunc foo func(func(int, int))
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:7:1
2025/12/19 11:09:40 Val foo func(func(int, int))
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload func foo
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func foo
2025/12/19 11:09:40 NewFunc foo func(func(int, int))
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:7:1
2025/12/19 11:09:40 Val foo func(func(int, int))
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload type Foo
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load > NewType Foo
2025/12/19 11:09:40 NewType Foo
2025/12/19 11:09:40 ==> Load > InitType Foo
2025/12/19 11:09:40 InitType Foo struct{Plot int}
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:5:1
2025/12/19 11:09:40 DefineVarStart [foo]
2025/12/19 11:09:40 ==> LookupParent Foo => type Foo struct{Plot int}
2025/12/19 11:09:40 Val 0 int
2025/12/19 11:09:40 ResetInit
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload type Foo
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load > NewType Foo
2025/12/19 11:09:40 NewType Foo
2025/12/19 11:09:40 ==> Load > InitType Foo
2025/12/19 11:09:40 InitType Foo struct{Plot int}
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:5:1
2025/12/19 11:09:40 DefineVarStart [foo]
2025/12/19 11:09:40 ==> LookupParent Foo => type Foo struct{Plot int}
2025/12/19 11:09:40 Val 0 int
2025/12/19 11:09:40 ResetInit
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload func foo
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func foo
2025/12/19 11:09:40 NewFunc foo func(int)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:40 Val foo func(int)
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload func foo
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func foo
2025/12/19 11:09:40 NewFunc foo func(func())
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:40 Val foo func(func())
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload type Foo
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load > NewType Foo
2025/12/19 11:09:40 NewType Foo
2025/12/19 11:09:40 ==> Load > InitType Foo
2025/12/19 11:09:40 InitType Foo struct{Plot func() int}
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:5:1
2025/12/19 11:09:40 DefineVarStart [foo]
2025/12/19 11:09:40 ==> LookupParent Foo => type Foo struct{Plot func() int}
2025/12/19 11:09:40 Val 0 int
2025/12/19 11:09:40 ResetInit
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload var [foo]
2025/12/19 11:09:40 ==> Load var func() [foo]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [foo]
2025/12/19 11:09:40 ResetInit
2025/12/19 11:09:40 ==> Preload var [foo]
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load var func() [foo]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [foo]
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:40 VarRef foo func()
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload var [foo foo1]
2025/12/19 11:09:40 ==> Load var func() [foo foo1]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [foo foo1]
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 ResetInit
2025/12/19 11:09:40 ==> Preload var [foo]
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load var func() [foo]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [foo]
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:40 VarRef _
2025/12/19 11:09:40 VarRef foo func()
2025/12/19 11:09:40 Val nil untyped nil
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload func intSeq
2025/12/19 11:09:40 ==> Load func intSeq
2025/12/19 11:09:40 NewFunc intSeq func() int
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:40 DefineVarStart [i]
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload func intSeq
2025/12/19 11:09:40 ==> Load func intSeq
2025/12/19 11:09:40 NewFunc intSeq func() func() string
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:40 DefineVarStart [i]
2025/12/19 11:09:40 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:40 NewClosure func() string
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:5:1
2025/12/19 11:09:40 VarRef i int
2025/12/19 11:09:40 IncDec ++
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:6:1
2025/12/19 11:09:40 Val i int
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType int, string
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:40 Return 1
2025/12/19 11:09:40 ==> MatchType func() string, func() string
2025/12/19 11:09:40 End // Func
--- PASS: TestErrLambdaExpr (0.00s)
=== RUN   TestErrErrWrap
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
--- PASS: TestErrErrWrap (0.00s)
=== RUN   TestErrVar
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Preload var [a]
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load var <nil> [a]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [a]
2025/12/19 11:09:40 Val Println func(a ...any) (n int, err error)
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 Call 1 0 // func(a ...any) (n int, err error)
2025/12/19 11:09:40 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:40 ==> MatchType untyped int (1), any
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ResetInit
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Preload var [a]
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Load var <nil> [a]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [a]
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:40 EndInit 2
2025/12/19 11:09:40 ResetInit
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:40 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload func foo
2025/12/19 11:09:40 ==> Load func foo
2025/12/19 11:09:40 NewFunc foo func(v map[int]invalid type)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload var [bar]
2025/12/19 11:09:40 ==> Preload func foo
2025/12/19 11:09:40 ==> Load var <nil> [bar]
2025/12/19 11:09:40 NewVarDefs
2025/12/19 11:09:40 NewVar [bar]
2025/12/19 11:09:40 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:40 EndInit 1
2025/12/19 11:09:40 ==> Load func foo
2025/12/19 11:09:40 ==> LookupParent bar => var bar int
2025/12/19 11:09:40 NewFunc foo func(v map[int]invalid type)
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:40 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:40 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:40 DefineVarStart [foo]
2025/12/19 11:09:40 ResetInit
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:40 DefineVarStart [foo]
2025/12/19 11:09:40 ResetInit
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
2025/12/19 11:09:40 ==> Preload func main
2025/12/19 11:09:40 ==> Load func main
2025/12/19 11:09:40 NewFunc main func()
2025/12/19 11:09:40 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:40 ResetStmt
2025/12/19 11:09:40 End // Func
--- PASS: TestErrVar (0.01s)
=== RUN   TestErrImport
2025/12/19 11:09:41 ==> Preload func foo
2025/12/19 11:09:41 ==> Load func foo
2025/12/19 11:09:41 NewFunc foo func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:8:1
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func foo
2025/12/19 11:09:41 ==> Load func foo
2025/12/19 11:09:41 NewFunc foo func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:5:1
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func foo
2025/12/19 11:09:41 ==> Load func foo
2025/12/19 11:09:41 NewFunc foo func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:5:1
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func foo
2025/12/19 11:09:41 ==> Load func foo
2025/12/19 11:09:41 NewFunc foo func(t *invalid type)
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func foo
2025/12/19 11:09:41 ==> Load func foo
2025/12/19 11:09:41 NewFunc foo func(t invalid type)
2025/12/19 11:09:41 End // Func
--- PASS: TestErrImport (0.32s)
=== RUN   TestErrConst
2025/12/19 11:09:41 ==> Preload var [a]
2025/12/19 11:09:41 NewConstDefs
2025/12/19 11:09:41 ==> Preload const [a]
2025/12/19 11:09:41 ==> Load var int [a]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [a]
2025/12/19 11:09:41 NewConstDefs
2025/12/19 11:09:41 ==> Preload const [a]
2025/12/19 11:09:41 ==> Preload const [b c]
2025/12/19 11:09:41 ==> Load const [a] <nil>
2025/12/19 11:09:41 NewConst [a] 0
2025/12/19 11:09:41 Val iota untyped int
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> Load const [b c]
2025/12/19 11:09:41 Val iota untyped int
--- PASS: TestErrConst (0.00s)
=== RUN   TestErrNewVar
2025/12/19 11:09:41 ==> Preload var [a]
2025/12/19 11:09:41 ==> Preload var [a]
2025/12/19 11:09:41 ==> Load var int [a]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [a]
--- PASS: TestErrNewVar (0.00s)
=== RUN   TestErrDefineVar
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType untyped string ("Hi"), int
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
--- PASS: TestErrDefineVar (0.00s)
=== RUN   TestErrAssignMismatchT
2025/12/19 11:09:41 ==> Preload var [a]
2025/12/19 11:09:41 ==> Load var string [a]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [a]
2025/12/19 11:09:41 SliceLit []string 0 false
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType []string, string
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ==> Preload var [a]
2025/12/19 11:09:41 ==> Load var string [a]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [a]
2025/12/19 11:09:41 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:41 ArrayLit [2]string 0 false
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType [2]string, string
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ==> Preload var [a]
2025/12/19 11:09:41 ==> Load var string [a]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [a]
2025/12/19 11:09:41 MapLit map[int]string 0
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType map[int]string, string
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ==> Preload type T
2025/12/19 11:09:41 ==> Preload var [a]
2025/12/19 11:09:41 ==> Load > NewType T
2025/12/19 11:09:41 NewType T
2025/12/19 11:09:41 ==> Load > InitType T
2025/12/19 11:09:41 InitType T struct{}
2025/12/19 11:09:41 ==> Load var string [a]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [a]
2025/12/19 11:09:41 ==> LookupParent T => type T struct{}
2025/12/19 11:09:41 StructLit T 0 false
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType T, string
2025/12/19 11:09:41 ==> EnsureLoaded T
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ==> Preload var [a]
2025/12/19 11:09:41 ==> Load var string [a]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [a]
2025/12/19 11:09:41 NewClosure func()
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType func(), string
2025/12/19 11:09:41 ResetInit
--- PASS: TestErrAssignMismatchT (0.00s)
=== RUN   TestErrAssign
2025/12/19 11:09:41 ==> Preload func bar
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func bar
2025/12/19 11:09:41 NewFunc bar func() (n int, err error)
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 Return 0
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:7:1
2025/12/19 11:09:41 DefineVarStart [x]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:8:1
2025/12/19 11:09:41 VarRef x int
2025/12/19 11:09:41 Val bar func() (n int, err error)
2025/12/19 11:09:41 Call 0 0 // func() (n int, err error)
2025/12/19 11:09:41 ==> MatchFuncCall func() (n int, err error) args: 0 flags: 0
2025/12/19 11:09:41 Assign 1 1
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [x]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 VarRef x int
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:41 Assign 1 2
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
--- PASS: TestErrAssign (0.00s)
=== RUN   TestErrReturn
2025/12/19 11:09:41 ==> Preload func foo
2025/12/19 11:09:41 ==> Load func foo
2025/12/19 11:09:41 NewFunc foo func() (int, error)
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Return 1
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func foo
2025/12/19 11:09:41 ==> Load func foo
2025/12/19 11:09:41 NewFunc foo func() (int, error)
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:41 Return 3
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func foo
2025/12/19 11:09:41 ==> Load func foo
2025/12/19 11:09:41 NewFunc foo func() (int, error)
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:41 Return 2
2025/12/19 11:09:41 ==> MatchType untyped int (1), int
2025/12/19 11:09:41 ==> MatchType untyped string ("Hi"), error
2025/12/19 11:09:41 ==> EnsureLoaded error
2025/12/19 11:09:41 ==> AssignableConv untyped string error false
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func bar
2025/12/19 11:09:41 ==> Preload func foo
2025/12/19 11:09:41 ==> Load func bar
2025/12/19 11:09:41 NewFunc bar func() (v byte)
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 Return 0
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Load func foo
2025/12/19 11:09:41 NewFunc foo func() (int, error)
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:8:1
2025/12/19 11:09:41 Val bar func() (v byte)
2025/12/19 11:09:41 Call 0 0 // func() (v byte)
2025/12/19 11:09:41 ==> MatchFuncCall func() (v byte) args: 0 flags: 0
2025/12/19 11:09:41 Return 1
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func bar
2025/12/19 11:09:41 ==> Preload func foo
2025/12/19 11:09:41 ==> Load func bar
2025/12/19 11:09:41 NewFunc bar func() (n int, err error)
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 Return 0
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Load func foo
2025/12/19 11:09:41 NewFunc foo func() (v byte)
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:8:1
2025/12/19 11:09:41 Val bar func() (n int, err error)
2025/12/19 11:09:41 Call 0 0 // func() (n int, err error)
2025/12/19 11:09:41 ==> MatchFuncCall func() (n int, err error) args: 0 flags: 0
2025/12/19 11:09:41 Return 1
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func bar
2025/12/19 11:09:41 ==> Preload func foo
2025/12/19 11:09:41 ==> Load func bar
2025/12/19 11:09:41 NewFunc bar func() (n int, v byte)
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 Return 0
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Load func foo
2025/12/19 11:09:41 NewFunc foo func() (int, error)
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:8:1
2025/12/19 11:09:41 Val bar func() (n int, v byte)
2025/12/19 11:09:41 Call 0 0 // func() (n int, v byte)
2025/12/19 11:09:41 ==> MatchFuncCall func() (n int, v byte) args: 0 flags: 0
2025/12/19 11:09:41 Return 1
2025/12/19 11:09:41 ==> MatchType int, int
2025/12/19 11:09:41 ==> MatchType byte, error
2025/12/19 11:09:41 ==> EnsureLoaded error
2025/12/19 11:09:41 ==> AssignableConv byte error false
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func foo
2025/12/19 11:09:41 ==> Load func foo
2025/12/19 11:09:41 NewFunc foo func() byte
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 Return 0
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
--- PASS: TestErrReturn (0.00s)
=== RUN   TestErrForRange
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 ==> Load var []string [b]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [b]
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 ForRange []
2025/12/19 11:09:41 VarRef _
2025/12/19 11:09:41 VarRef a int
2025/12/19 11:09:41 Val b []string
2025/12/19 11:09:41 RangeAssignThen
2025/12/19 11:09:41 ==> MatchType string, int
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // ForRange
2025/12/19 11:09:41 End // Func
--- PASS: TestErrForRange (0.00s)
=== RUN   TestErrInitFunc
2025/12/19 11:09:41 ==> Preload func init
2025/12/19 11:09:41 ==> Load func init
--- PASS: TestErrInitFunc (0.00s)
=== RUN   TestErrRecv
2025/12/19 11:09:41 ==> Preload type a
2025/12/19 11:09:41 ==> Preload method a.foo
2025/12/19 11:09:41 ==> Load > NewType a
2025/12/19 11:09:41 NewType a
2025/12/19 11:09:41 ==> Load > InitType a
2025/12/19 11:09:41 InitType a *int
2025/12/19 11:09:41 ==> LookupParent a => type a *int
2025/12/19 11:09:41 ==> Load method a.foo
2025/12/19 11:09:41 ==> Preload method error.foo
2025/12/19 11:09:41 ==> Load method error.foo
--- PASS: TestErrRecv (0.00s)
=== RUN   TestErrEnvOp
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val &{<nil> invalid type <nil> <nil>} *internal.Elem
2025/12/19 11:09:41 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType invalid type, any
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 Val &{<nil> invalid type <nil> <nil>} *internal.Elem
2025/12/19 11:09:41 End // Func
--- PASS: TestErrEnvOp (0.00s)
=== RUN   TestErrStringLit
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 SliceLit <nil> 0 false
2025/12/19 11:09:41 Member string 2 // []interface{}
2025/12/19 11:09:41 Member error 2 // []interface{}
2025/12/19 11:09:41 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType []interface{}, any
2025/12/19 11:09:41 End // Func
--- PASS: TestErrStringLit (0.00s)
=== RUN   TestErrStructLit
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [x]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [x]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 StructLit struct{x int; y string} 1 false
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [x]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val x int
2025/12/19 11:09:41 StructLit struct{x int; y string} 2 false
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
--- PASS: TestErrStructLit (0.00s)
=== RUN   TestErrArray
2025/12/19 11:09:41 ==> Preload var [n]
2025/12/19 11:09:41 ==> Preload var [a]
2025/12/19 11:09:41 ==> Load var int [n]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [n]
2025/12/19 11:09:41 Val n int
--- PASS: TestErrArray (0.00s)
=== RUN   TestErrArrayLit
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [b]
2025/12/19 11:09:41 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:41 Val a string
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 ArrayLit [10]int 2 true
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [b]
2025/12/19 11:09:41 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 9} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 None
2025/12/19 11:09:41 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:41 ArrayLit [10]int 4 true
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [b]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:41 ArrayLit [1]int 2 false
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [b]
2025/12/19 11:09:41 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 12} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:41 ArrayLit [10]int 2 true
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [b]
2025/12/19 11:09:41 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:41 Val a string
2025/12/19 11:09:41 Val &{0 STRING "!"} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp +
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType string, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped string ("!"), unboundFuncParam{typ: string}
2025/12/19 11:09:41 ArrayLit [10]int 1 false
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [b]
2025/12/19 11:09:41 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:41 Val a string
2025/12/19 11:09:41 ArrayLit [10]int 2 true
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
--- PASS: TestErrArrayLit (0.00s)
=== RUN   TestErrSliceLit
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [b]
2025/12/19 11:09:41 Val a string
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 SliceLit []int 2 true
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [b]
2025/12/19 11:09:41 Val a string
2025/12/19 11:09:41 SliceLit []int 1 false
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [b]
2025/12/19 11:09:41 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:41 Val a string
2025/12/19 11:09:41 SliceLit []int 2 true
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
--- PASS: TestErrSliceLit (0.00s)
=== RUN   TestErrMapLit
2025/12/19 11:09:41 ==> Preload func foo
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func foo
2025/12/19 11:09:41 NewFunc foo func(map[string]string)
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 Val foo func(map[string]string)
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:41 MapLit map[string]string 2
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp +
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped int (2), unboundFuncParam{typ: untyped int}
2025/12/19 11:09:41 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:41 MapLit map[string]int 2
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [b]
2025/12/19 11:09:41 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 STRING "Go"} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 STRING "+"} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp +
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped string ("Go"), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped string ("+"), unboundFuncParam{typ: untyped string}
2025/12/19 11:09:41 MapLit map[string]int 2
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload var [v]
2025/12/19 11:09:41 ==> Load var interface{} [v]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [v]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:41 None
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 MapLit <nil> 4
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ==> Preload var [v]
2025/12/19 11:09:41 ==> Load var map[int]int [v]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [v]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:41 None
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 MapLit map[int]int 4
2025/12/19 11:09:41 ResetInit
--- PASS: TestErrMapLit (0.00s)
=== RUN   TestErrSlice
2025/12/19 11:09:41 ==> Preload var [a]
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load var *byte [a]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [a]
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [x]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 DefineVarStart [b]
2025/12/19 11:09:41 Val a *byte
2025/12/19 11:09:41 Val x int
2025/12/19 11:09:41 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:41 Slice false
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val true untyped bool
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [b]
2025/12/19 11:09:41 Val a bool
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:41 Slice false
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [b]
2025/12/19 11:09:41 Val a string
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:41 Slice true
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
--- PASS: TestErrSlice (0.00s)
=== RUN   TestErrIndex
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [b ok]
2025/12/19 11:09:41 Val a string
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Index 1 true
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val true untyped bool
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [b]
2025/12/19 11:09:41 Val a bool
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Index 1 false
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
--- PASS: TestErrIndex (0.00s)
=== RUN   TestErrIndexRef
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 Val a string
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 IndexRef 1
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
--- PASS: TestErrIndexRef (0.00s)
=== RUN   TestErrStar
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 Val a string
2025/12/19 11:09:41 ElemRef
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [b]
2025/12/19 11:09:41 Val a string
2025/12/19 11:09:41 Star
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
--- PASS: TestErrStar (0.00s)
=== RUN   TestErrMember
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [b]
2025/12/19 11:09:41 Val a string
2025/12/19 11:09:41 Member x 2 // string
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
--- PASS: TestErrMember (0.00s)
=== RUN   TestErrMemberRef
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 Val a string
2025/12/19 11:09:41 Member x -1 // string
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload type aaa
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load > NewType aaa
2025/12/19 11:09:41 NewType aaa
2025/12/19 11:09:41 ==> Load > InitType aaa
2025/12/19 11:09:41 InitType aaa byte
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val aaa aaa
2025/12/19 11:09:41 Val type aaa byte => Typ aaa
2025/12/19 11:09:41 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:41 Call 1 0 // TypeType{typ: aaa}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: aaa} args: 1 flags: 0
2025/12/19 11:09:41 ==> EnsureLoaded aaa
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:5:1
2025/12/19 11:09:41 Val a aaa
2025/12/19 11:09:41 Member x -1 // aaa
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload type aaa
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load > NewType aaa
2025/12/19 11:09:41 NewType aaa
2025/12/19 11:09:41 ==> Load > InitType aaa
2025/12/19 11:09:41 InitType aaa struct{x int; y string}
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 ==> LookupParent aaa => type aaa struct{x int; y string}
2025/12/19 11:09:41 StructLit aaa 0 false
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:5:1
2025/12/19 11:09:41 Val a aaa
2025/12/19 11:09:41 Member z -1 // aaa
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 StructLit struct{x int; y string} 0 false
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 Val a struct{x int; y string}
2025/12/19 11:09:41 Member z -1 // struct{x int; y string}
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
--- PASS: TestErrMemberRef (0.00s)
=== RUN   TestErrLabel
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:1:1
2025/12/19 11:09:41 DefineVarStart [x]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 Label foo
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [i]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 Label foo
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:5:1
2025/12/19 11:09:41 VarRef i int
2025/12/19 11:09:41 IncDec ++
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:1:1
2025/12/19 11:09:41 DefineVarStart [x]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:1:1
2025/12/19 11:09:41 DefineVarStart [x]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 Break
2025/12/19 11:09:41 End // Func
--- PASS: TestErrLabel (0.00s)
=== RUN   TestErrBranchStmt
2025/12/19 11:09:41 ==> Preload func foo
2025/12/19 11:09:41 ==> Load func foo
2025/12/19 11:09:41 NewFunc foo func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 End // Func
--- PASS: TestErrBranchStmt (0.00s)
=== RUN   TestErrNoEntrypoint
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:1:1
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:1:1
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func init
2025/12/19 11:09:41 ==> Load func init
2025/12/19 11:09:41 NewFunc init func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
--- PASS: TestErrNoEntrypoint (0.00s)
=== RUN   TestErrTypeRedefine
2025/12/19 11:09:41 ==> Preload method Point.String
2025/12/19 11:09:41 ==> Preload type Point
2025/12/19 11:09:41 ==> Preload type Point
2025/12/19 11:09:41 ==> Load > NewType Point
2025/12/19 11:09:41 NewType Point
2025/12/19 11:09:41 ==> Load > InitType Point
2025/12/19 11:09:41 InitType Point struct{X int; Y int}
2025/12/19 11:09:41 ==> LookupParent Point => type Point struct{X int; Y int}
2025/12/19 11:09:41 ==> Load method *Point.String
2025/12/19 11:09:41 NewFunc String (*Point) func() string
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 Val Sprintf func(format string, a ...any) string
2025/12/19 11:09:41 Val &{0 STRING "%v-%v"} *ast.BasicLit
2025/12/19 11:09:41 Val p *Point
2025/12/19 11:09:41 Member X 2 // *Point
2025/12/19 11:09:41 Val p *Point
2025/12/19 11:09:41 Member Y 2 // *Point
2025/12/19 11:09:41 Call 3 0 // func(format string, a ...any) string
2025/12/19 11:09:41 ==> MatchFuncCall func(format string, a ...any) string args: 3 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped string ("%v-%v"), string
2025/12/19 11:09:41 ==> MatchType int, any
2025/12/19 11:09:41 ==> MatchType int, any
2025/12/19 11:09:41 Return 1
2025/12/19 11:09:41 ==> MatchType string, string
2025/12/19 11:09:41 End // Func
--- PASS: TestErrTypeRedefine (0.00s)
=== RUN   TestErrSwitchDuplicate
2025/12/19 11:09:41 ==> Preload var [n]
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load var int [n]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [n]
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 Switch
2025/12/19 11:09:41 Val n int
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 End // Switch
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload var [n]
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load var int [n]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [n]
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 Switch
2025/12/19 11:09:41 Val n int
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Val int int
2025/12/19 11:09:41 Val type int => Typ int
2025/12/19 11:09:41 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:41 Call 1 0 // TypeType{typ: int}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: int} args: 1 flags: 0
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 End // Switch
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload var [n]
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load var int [n]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [n]
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 Switch
2025/12/19 11:09:41 Val n int
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Val &{0 INT 50} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 50} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp +
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (50), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped int (50), unboundFuncParam{typ: untyped int}
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 End // Switch
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload var [n]
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load var interface{} [n]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [n]
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 Switch
2025/12/19 11:09:41 Val n interface{}
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Val uint uint
2025/12/19 11:09:41 Val type uint => Typ uint
2025/12/19 11:09:41 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:41 Call 1 0 // TypeType{typ: uint}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: uint} args: 1 flags: 0
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Val int int
2025/12/19 11:09:41 Val type int => Typ int
2025/12/19 11:09:41 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:41 Call 1 0 // TypeType{typ: int}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: int} args: 1 flags: 0
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:5:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 End // Switch
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload var [n]
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load var interface{} [n]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [n]
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 Switch
2025/12/19 11:09:41 Val n interface{}
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Val &{0 FLOAT 100.0} *ast.BasicLit
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Val &{0 FLOAT 100.0} *ast.BasicLit
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 End // Switch
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload var [n]
2025/12/19 11:09:41 NewConstDefs
2025/12/19 11:09:41 ==> Preload const [v]
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load var interface{} [n]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [n]
2025/12/19 11:09:41 ==> Load const [v] <nil>
2025/12/19 11:09:41 NewConst [v] 0
2025/12/19 11:09:41 Val &{0 FLOAT 100.0} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 Switch
2025/12/19 11:09:41 Val n interface{}
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Val &{0 FLOAT 100.0} *ast.BasicLit
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Val v untyped float
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:5:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 End // Switch
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload var [n]
2025/12/19 11:09:41 NewConstDefs
2025/12/19 11:09:41 ==> Preload const [v]
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load var interface{} [n]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [n]
2025/12/19 11:09:41 ==> Load const [v] <nil>
2025/12/19 11:09:41 NewConst [v] 0
2025/12/19 11:09:41 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 Switch
2025/12/19 11:09:41 Val n interface{}
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Val v untyped string
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:5:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 End // Switch
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload var [n]
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load var int [n]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [n]
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 Switch
2025/12/19 11:09:41 Val n int
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Val &{0 INT 50} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 50} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp +
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (50), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped int (50), unboundFuncParam{typ: untyped int}
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:5:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 End // Switch
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload var [n]
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load var interface{} [n]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [n]
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 Switch
2025/12/19 11:09:41 Val n interface{}
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 End // Switch
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload var [n]
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load var interface{} [n]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [n]
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 Switch
2025/12/19 11:09:41 Val n interface{}
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 Case
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:5:1
2025/12/19 11:09:41 End // Case
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 End // Switch
2025/12/19 11:09:41 End // Func
--- PASS: TestErrSwitchDuplicate (0.01s)
=== RUN   TestErrTypeSwitchDuplicate
2025/12/19 11:09:41 ==> Preload var [n]
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load var interface{} [n]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [n]
2025/12/19 11:09:41 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType untyped int (100), interface{}
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 TypeSwitch
2025/12/19 11:09:41 Val n interface{}
2025/12/19 11:09:41 TypeAssertThen
2025/12/19 11:09:41 TypeCase
2025/12/19 11:09:41 Val int int
2025/12/19 11:09:41 Val type int => Typ int
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 End // TypeCase
2025/12/19 11:09:41 TypeCase
2025/12/19 11:09:41 Val int int
2025/12/19 11:09:41 Val type int => Typ int
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 End // TypeCase
2025/12/19 11:09:41 TypeCase
2025/12/19 11:09:41 Val int int
2025/12/19 11:09:41 Val type int => Typ int
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:5:1
2025/12/19 11:09:41 End // TypeCase
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 End // TypeSwitch
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload var [n]
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load var interface{} [n]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [n]
2025/12/19 11:09:41 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType untyped int (100), interface{}
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 TypeSwitch
2025/12/19 11:09:41 Val n interface{}
2025/12/19 11:09:41 TypeAssertThen
2025/12/19 11:09:41 TypeCase
2025/12/19 11:09:41 Val nil untyped nil
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 End // TypeCase
2025/12/19 11:09:41 TypeCase
2025/12/19 11:09:41 Val nil untyped nil
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 End // TypeCase
2025/12/19 11:09:41 TypeCase
2025/12/19 11:09:41 Val nil untyped nil
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:5:1
2025/12/19 11:09:41 End // TypeCase
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 End // TypeSwitch
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload var [n]
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load var interface{} [n]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [n]
2025/12/19 11:09:41 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType untyped int (100), interface{}
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 TypeSwitch
2025/12/19 11:09:41 Val n interface{}
2025/12/19 11:09:41 TypeAssertThen
2025/12/19 11:09:41 TypeCase
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 End // TypeCase
2025/12/19 11:09:41 TypeCase
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 End // TypeCase
2025/12/19 11:09:41 TypeCase
2025/12/19 11:09:41 Then
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:5:1
2025/12/19 11:09:41 End // TypeCase
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 End // TypeSwitch
2025/12/19 11:09:41 End // Func
--- PASS: TestErrTypeSwitchDuplicate (0.00s)
=== RUN   TestErrAutoProperty
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:4:1
2025/12/19 11:09:41 DefineVarStart [n err]
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
--- PASS: TestErrAutoProperty (0.00s)
=== RUN   TestFiledsNameRedecl
2025/12/19 11:09:41 ==> Preload type Id
2025/12/19 11:09:41 ==> Preload type A
2025/12/19 11:09:41 ==> Load > NewType Id
2025/12/19 11:09:41 NewType Id
2025/12/19 11:09:41 ==> Load > InitType Id
2025/12/19 11:09:41 InitType Id struct{}
2025/12/19 11:09:41 ==> Load > NewType A
2025/12/19 11:09:41 NewType A
2025/12/19 11:09:41 ==> Load > InitType A
2025/12/19 11:09:41 ==> LookupParent Id => type Id struct{}
2025/12/19 11:09:41 InitType A struct{Id int; name string}
--- PASS: TestFiledsNameRedecl (0.00s)
=== RUN   TestErrImportPkg
--- PASS: TestErrImportPkg (0.02s)
=== RUN   TestErrClassFileGopx
2025/12/19 11:09:41 ==> Preload type Rect
2025/12/19 11:09:41 ==> Preload type A
2025/12/19 11:09:41 ==> Preload method Rect.Main
2025/12/19 11:09:41 ==> Load > NewType Rect
2025/12/19 11:09:41 NewType Rect
2025/12/19 11:09:41 ==> Load > NewType A
2025/12/19 11:09:41 NewType A
2025/12/19 11:09:41 ==> Load > InitType A
2025/12/19 11:09:41 InitType A struct{}
2025/12/19 11:09:41 ==> Load > InitType Rect
2025/12/19 11:09:41 ==> LookupParent A => type A struct{}
2025/12/19 11:09:41 ==> LookupParent A => type A struct{}
2025/12/19 11:09:41 InitType Rect struct{A; i int}
2025/12/19 11:09:41 ==> LookupParent Rect => type Rect struct{A; i int}
2025/12/19 11:09:41 ==> Load method *Rect.Main
2025/12/19 11:09:41 NewFunc Main (*Rect) func()
2025/12/19 11:09:41 SetComments 0
//line Rect.gox:8:1
2025/12/19 11:09:41 Val this *Rect
2025/12/19 11:09:41 Member println 1 // *Rect
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:41 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped string ("hello"), any
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:41 Val Rect Rect
2025/12/19 11:09:41 Val type Rect struct{A; i int} => Typ Rect
2025/12/19 11:09:41 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:41 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:41 Member Main 0 // *Rect
2025/12/19 11:09:41 Call 0 0 // func()
2025/12/19 11:09:41 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:41 End // Func
--- PASS: TestErrClassFileGopx (0.00s)
=== RUN   TestErrVarInFunc
2025/12/19 11:09:41 ==> Preload func set
2025/12/19 11:09:41 ==> Preload func test
2025/12/19 11:09:41 ==> Load func set
2025/12/19 11:09:41 NewFunc set func(name string, v int) string
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 Val name string
2025/12/19 11:09:41 Return 1
2025/12/19 11:09:41 ==> MatchType string, string
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Load func test
2025/12/19 11:09:41 NewFunc test func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:6:1
2025/12/19 11:09:41 ==> Load var <nil> [a]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [a]
2025/12/19 11:09:41 Val set func(name string, v int) string
2025/12/19 11:09:41 Val &{0 STRING "box"} *ast.BasicLit
2025/12/19 11:09:41 Call 1 0 // func(name string, v int) string
2025/12/19 11:09:41 ==> MatchFuncCall func(name string, v int) string args: 1 flags: 0
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:7:1
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
--- PASS: TestErrVarInFunc (0.00s)
=== RUN   TestErrInt128
2025/12/19 11:09:41 ==> Preload var [a]
2025/12/19 11:09:41 ==> Load var github.com/qiniu/x/xgo/ng.Int128 [a]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [a]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 127} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp <<
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped int (127), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType untyped int (170141183460469231731687303715884105728), github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Int128 false
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val int128 github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Val type int128 = github.com/qiniu/x/xgo/ng.Int128 => Typ github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 127} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp <<
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped int (127), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 Call 1 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Int128}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Int128} args: 1 flags: 0
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val int128 github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Val type int128 = github.com/qiniu/x/xgo/ng.Int128 => Typ github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 UnaryOp - flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 Val &{0 INT 127} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp <<
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (-1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped int (127), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp -
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (-170141183460469231731687303715884105728), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped int (1), unboundFuncParam{typ: untyped int}
2025/12/19 11:09:41 Call 1 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Int128}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Int128} args: 1 flags: 0
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 NewConstDefs
2025/12/19 11:09:41 ==> Preload const [b]
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load const [b] <nil>
2025/12/19 11:09:41 NewConst [b] 0
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 UnaryOp - flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 Val &{0 INT 127} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp <<
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (-1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped int (127), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp -
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (-170141183460469231731687303715884105728), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped int (1), unboundFuncParam{typ: untyped int}
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val int128 github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Val type int128 = github.com/qiniu/x/xgo/ng.Int128 => Typ github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Val b untyped int
2025/12/19 11:09:41 Call 1 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Int128}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Int128} args: 1 flags: 0
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
--- PASS: TestErrInt128 (0.00s)
=== RUN   TestErrUint128
2025/12/19 11:09:41 ==> Preload var [a]
2025/12/19 11:09:41 ==> Load var github.com/qiniu/x/xgo/ng.Uint128 [a]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [a]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 128} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp <<
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped int (128), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType untyped int (340282366920938463463374607431768211456), github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Uint128 false
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val uint128 github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Val type uint128 = github.com/qiniu/x/xgo/ng.Uint128 => Typ github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 128} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp <<
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped int (128), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 Call 1 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128} args: 1 flags: 0
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload var [a]
2025/12/19 11:09:41 ==> Load var github.com/qiniu/x/xgo/ng.Uint128 [a]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [a]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 UnaryOp - flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType untyped int (-1), github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Uint128 false
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val uint128 github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Val type uint128 = github.com/qiniu/x/xgo/ng.Uint128 => Typ github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 UnaryOp - flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 Call 1 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128} args: 1 flags: 0
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 NewConstDefs
2025/12/19 11:09:41 ==> Preload const [b]
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load const [b] <nil>
2025/12/19 11:09:41 NewConst [b] 0
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 UnaryOp - flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 DefineVarStart [a]
2025/12/19 11:09:41 Val uint128 github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Val type uint128 = github.com/qiniu/x/xgo/ng.Uint128 => Typ github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Val b untyped int
2025/12/19 11:09:41 Call 1 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128} args: 1 flags: 0
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
--- PASS: TestErrUint128 (0.00s)
=== RUN   TestErrCompileFunc
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:2:1
2025/12/19 11:09:41 Val printf func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val &{0 STRING "%+v\n"} *ast.BasicLit
2025/12/19 11:09:41 Val int32 int32
2025/12/19 11:09:41 Val type int32 => Typ int32
2025/12/19 11:09:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(format string, a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped string ("%+v\n"), string
2025/12/19 11:09:41 ==> MatchType TypeType{typ: int32}, any
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
--- PASS: TestErrCompileFunc (0.00s)
=== RUN   TestToTypeError
2025/12/19 11:09:41 ==> Preload type a
2025/12/19 11:09:41 ==> Load > NewType a
2025/12/19 11:09:41 NewType a
2025/12/19 11:09:41 ==> Load > InitType a
2025/12/19 11:09:41 InitType a invalid type
--- PASS: TestToTypeError (0.00s)
=== RUN   TestCompileExprError
2025/12/19 11:09:41 ==> Preload func Foo
2025/12/19 11:09:41 ==> Preload func _
2025/12/19 11:09:41 ==> Load func Foo
2025/12/19 11:09:41 NewFunc Foo func()
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Load func _
2025/12/19 11:09:41 NewFunc _ func()
2025/12/19 11:09:41 SetComments 0
//line bar.go:4:1
2025/12/19 11:09:41 Val Foo func()
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload func _
2025/12/19 11:09:41 ==> Load func _
2025/12/19 11:09:41 NewFunc _ func()
2025/12/19 11:09:41 SetComments 0
//line bar.go:3:1
2025/12/19 11:09:41 ResetStmt
2025/12/19 11:09:41 End // Func
--- PASS: TestCompileExprError (0.00s)
=== RUN   TestOverloadFuncDecl
2025/12/19 11:09:41 NewConstDefs
2025/12/19 11:09:41 ==> Preload const [Gopo_mul]
2025/12/19 11:09:41 ==> Load const [Gopo_mul] <nil>
2025/12/19 11:09:41 NewConst [Gopo_mul] 0
2025/12/19 11:09:41 Val &{0 STRING "println"} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
--- PASS: TestOverloadFuncDecl (0.00s)
=== RUN   TestCompositeLitError
2025/12/19 11:09:41 ==> Preload var [a]
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load var [][]int [a]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [a]
2025/12/19 11:09:41 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 FLOAT 3.14} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:41 SliceLit []int 3 false
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val a [][]int
2025/12/19 11:09:41 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType [][]int, any
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload var [a]
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load var []int [a]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [a]
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val a []int
2025/12/19 11:09:41 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType []int, any
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload var [a]
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load var []func(int) string [a]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [a]
2025/12/19 11:09:41 NewClosure func(x int) string
2025/12/19 11:09:41 Val x int
2025/12/19 11:09:41 Return 1
2025/12/19 11:09:41 ==> MatchType int, string
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 SetComments 0
//line bar.xgo:3:1
2025/12/19 11:09:41 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val a []func(int) string
2025/12/19 11:09:41 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType []func(int) string, any
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Preload var [a]
2025/12/19 11:09:41 ==> Load var map[interface{}]int [a]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [a]
2025/12/19 11:09:41 Val &{0 STRING "A"} *ast.BasicLit
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ==> Preload var [a]
2025/12/19 11:09:41 ==> Load var map[interface{}]func(int) string [a]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [a]
2025/12/19 11:09:41 Val &{0 STRING "A"} *ast.BasicLit
2025/12/19 11:09:41 NewClosure func(x int) string
2025/12/19 11:09:41 Val x int
2025/12/19 11:09:41 Return 1
2025/12/19 11:09:41 ==> MatchType int, string
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ==> Preload var [a]
2025/12/19 11:09:41 ==> Load var <nil> [a]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [a]
2025/12/19 11:09:41 ResetInit
2025/12/19 11:09:41 ==> Preload var [a]
2025/12/19 11:09:41 ==> Load var <nil> [a]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [a]
2025/12/19 11:09:41 Val 0 int
2025/12/19 11:09:41 ResetInit
--- PASS: TestCompositeLitError (0.00s)
=== RUN   TestUint128_run
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 Block
2025/12/19 11:09:41 ==> Load var string [name]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [name]
2025/12/19 11:09:41 ==> Load var github.com/qiniu/x/xgo/ng.Uint128 [age]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [age]
2025/12/19 11:09:41 Val Sscanf func(str string, format string, a ...any) (n int, err error)
2025/12/19 11:09:41 Val &{0 STRING "Kim is 22 years old"} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 STRING "%s is %d years old"} *ast.BasicLit
2025/12/19 11:09:41 Val name string
2025/12/19 11:09:41 UnaryOp & flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:41 Val age github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 UnaryOp & flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:41 Call 4 0 // func(str string, format string, a ...any) (n int, err error)
2025/12/19 11:09:41 ==> MatchFuncCall func(str string, format string, a ...any) (n int, err error) args: 4 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped string ("Kim is 22 years old"), string
2025/12/19 11:09:41 ==> MatchType untyped string ("%s is %d years old"), string
2025/12/19 11:09:41 ==> MatchType *string, any
2025/12/19 11:09:41 ==> MatchType *github.com/qiniu/x/xgo/ng.Uint128, any
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val name string
2025/12/19 11:09:41 Val age github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType string, any
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, any
2025/12/19 11:09:41 End // Block
2025/12/19 11:09:41 Block
2025/12/19 11:09:41 ==> Load var github.com/qiniu/x/xgo/ng.Uint128 [x]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [x]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType untyped int (1), github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Uint128) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), int
2025/12/19 11:09:41 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Uint128 true
2025/12/19 11:09:41 ==> Load var <nil> [y]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [y]
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 UnaryOp + flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func() (v github.com/qiniu/x/xgo/ng.Uint128) args: 1 flags: 32
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 VarRef x github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 IncDec ++
2025/12/19 11:09:41 ==> MatchFuncCall func() args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Uint128}, *github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 VarRef x github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:41 AssignOp += Gop_AddAssign
2025/12/19 11:09:41 ==> MatchFuncCall func(b github.com/qiniu/x/xgo/ng.Uint128) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Uint128}, *github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 ==> MatchType untyped int (10), github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Uint128) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (10), int
2025/12/19 11:09:41 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Uint128 true
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Val y github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, any
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, any
2025/12/19 11:09:41 End // Block
2025/12/19 11:09:41 Block
2025/12/19 11:09:41 ==> Load var github.com/qiniu/x/xgo/ng.Uint128 [x]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [x]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 65} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp <<
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped int (65), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Uint128) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), int
2025/12/19 11:09:41 ==> AssignableConv untyped int (36893488147419103232): value is out of int range
2025/12/19 11:09:41 ==> MatchFuncCall func(v github.com/qiniu/x/xgo/ng.UntypedBigint) (out github.com/qiniu/x/xgo/ng.Uint128) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:41 NewClosure func() *math/big.Int
2025/12/19 11:09:41 DefineVarStart [v _]
2025/12/19 11:09:41 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:41 Typ math/big.Int
2025/12/19 11:09:41 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:41 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:41 Member SetString 0 // *math/big.Int
2025/12/19 11:09:41 Val 36893488147419103232 string
2025/12/19 11:09:41 Val 10 int
2025/12/19 11:09:41 Call 2 0 // func(s string, base int) (*math/big.Int, bool)
2025/12/19 11:09:41 ==> MatchFuncCall func(s string, base int) (*math/big.Int, bool) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped string ("36893488147419103232"), string
2025/12/19 11:09:41 ==> MatchType untyped int (10), int
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 Val v *math/big.Int
2025/12/19 11:09:41 Return 1
2025/12/19 11:09:41 ==> MatchType *math/big.Int, *math/big.Int
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 Call 0 0 // func() *math/big.Int
2025/12/19 11:09:41 ==> MatchFuncCall func() *math/big.Int args: 0 flags: 0
2025/12/19 11:09:41 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Uint128 true
2025/12/19 11:09:41 ==> Load var <nil> [y]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [y]
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Val &{0 INT 63} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp >>
2025/12/19 11:09:41 Typ github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Member Gop_Rsh 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128}
2025/12/19 11:09:41 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Uint128, n uint) github.com/qiniu/x/xgo/ng.Uint128 args: 2 flags: 64
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 ==> MatchType untyped int (63), uint
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> Load var <nil> [z]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [z]
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Val &{0 INT 65} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp >>
2025/12/19 11:09:41 Typ github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Member Gop_Rsh 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128}
2025/12/19 11:09:41 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Uint128, n uint) github.com/qiniu/x/xgo/ng.Uint128 args: 2 flags: 64
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 ==> MatchType untyped int (65), uint
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, any
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val y github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Val z github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, any
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, any
2025/12/19 11:09:41 End // Block
2025/12/19 11:09:41 Block
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val uint128 github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Val type uint128 = github.com/qiniu/x/xgo/ng.Uint128 => Typ github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 65} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp <<
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped int (65), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 Call 1 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128} args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v int) github.com/qiniu/x/xgo/ng.Uint128 args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), int
2025/12/19 11:09:41 ==> AssignableConv untyped int (36893488147419103232): value is out of int range
2025/12/19 11:09:41 ==> MatchFuncCall func(v github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Uint128 args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:41 NewClosure func() *math/big.Int
2025/12/19 11:09:41 DefineVarStart [v _]
2025/12/19 11:09:41 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:41 Typ math/big.Int
2025/12/19 11:09:41 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:41 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:41 Member SetString 0 // *math/big.Int
2025/12/19 11:09:41 Val 36893488147419103232 string
2025/12/19 11:09:41 Val 10 int
2025/12/19 11:09:41 Call 2 0 // func(s string, base int) (*math/big.Int, bool)
2025/12/19 11:09:41 ==> MatchFuncCall func(s string, base int) (*math/big.Int, bool) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped string ("36893488147419103232"), string
2025/12/19 11:09:41 ==> MatchType untyped int (10), int
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 Val v *math/big.Int
2025/12/19 11:09:41 Return 1
2025/12/19 11:09:41 ==> MatchType *math/big.Int, *math/big.Int
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 Call 0 0 // func() *math/big.Int
2025/12/19 11:09:41 ==> MatchFuncCall func() *math/big.Int args: 0 flags: 0
2025/12/19 11:09:41 Val uint128 github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Val type uint128 = github.com/qiniu/x/xgo/ng.Uint128 => Typ github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Call 0 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128} args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v int) github.com/qiniu/x/xgo/ng.Uint128 args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Uint128 args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v uint64) github.com/qiniu/x/xgo/ng.Uint128 args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v uint32) github.com/qiniu/x/xgo/ng.Uint128 args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v uint16) github.com/qiniu/x/xgo/ng.Uint128 args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v uint8) github.com/qiniu/x/xgo/ng.Uint128 args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v int64) (out github.com/qiniu/x/xgo/ng.Uint128) args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v int64) (out github.com/qiniu/x/xgo/ng.Uint128, inRange bool) args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v *math/big.Int) github.com/qiniu/x/xgo/ng.Uint128 args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v *math/big.Int) (out github.com/qiniu/x/xgo/ng.Uint128, inRange bool) args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func() github.com/qiniu/x/xgo/ng.Uint128 args: 0 flags: 0
2025/12/19 11:09:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128 (36893488147419103232), any
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, any
2025/12/19 11:09:41 End // Block
2025/12/19 11:09:41 Block
2025/12/19 11:09:41 ==> Load var github.com/qiniu/x/xgo/ng.Uint128 [x]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [x]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType untyped int (1), github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Uint128) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), int
2025/12/19 11:09:41 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Uint128 true
2025/12/19 11:09:41 Val printf func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val &{0 STRING "%4d\n"} *ast.BasicLit
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(format string, a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped string ("%4d\n"), string
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, any
2025/12/19 11:09:41 End // Block
2025/12/19 11:09:41 Block
2025/12/19 11:09:41 ==> Load var github.com/qiniu/x/xgo/ng.Uint128 [x]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [x]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 65} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp <<
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped int (65), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Uint128) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), int
2025/12/19 11:09:41 ==> AssignableConv untyped int (36893488147419103232): value is out of int range
2025/12/19 11:09:41 ==> MatchFuncCall func(v github.com/qiniu/x/xgo/ng.UntypedBigint) (out github.com/qiniu/x/xgo/ng.Uint128) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:41 NewClosure func() *math/big.Int
2025/12/19 11:09:41 DefineVarStart [v _]
2025/12/19 11:09:41 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:41 Typ math/big.Int
2025/12/19 11:09:41 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:41 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:41 Member SetString 0 // *math/big.Int
2025/12/19 11:09:41 Val 36893488147419103232 string
2025/12/19 11:09:41 Val 10 int
2025/12/19 11:09:41 Call 2 0 // func(s string, base int) (*math/big.Int, bool)
2025/12/19 11:09:41 ==> MatchFuncCall func(s string, base int) (*math/big.Int, bool) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped string ("36893488147419103232"), string
2025/12/19 11:09:41 ==> MatchType untyped int (10), int
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 Val v *math/big.Int
2025/12/19 11:09:41 Return 1
2025/12/19 11:09:41 ==> MatchType *math/big.Int, *math/big.Int
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 Call 0 0 // func() *math/big.Int
2025/12/19 11:09:41 ==> MatchFuncCall func() *math/big.Int args: 0 flags: 0
2025/12/19 11:09:41 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Uint128 true
2025/12/19 11:09:41 ==> Load var <nil> [y]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [y]
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp >>
2025/12/19 11:09:41 Typ github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Member Gop_Rsh 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128}
2025/12/19 11:09:41 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Uint128, n uint) github.com/qiniu/x/xgo/ng.Uint128 args: 2 flags: 64
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 ==> MatchType untyped int (2), uint
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp -
2025/12/19 11:09:41 Typ github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Member Gop_Sub 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Uint128}
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/12/19 11:09:41 ==> MatchFuncCall func(u github.com/qiniu/x/xgo/ng.Uint128, n uint64) (v github.com/qiniu/x/xgo/ng.Uint128) args: 2 flags: 64
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Uint128, github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 ==> MatchType untyped int (1), uint64
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 DefineVarStart [v1 ok1]
2025/12/19 11:09:41 Val int64 int64
2025/12/19 11:09:41 Val type int64 => Typ int64
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Call 1 2 // TypeType{typ: int64}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: int64} args: 1 flags: 2
2025/12/19 11:09:41 Val &{x github.com/qiniu/x/xgo/ng.Uint128 <nil> x} *internal.Elem
2025/12/19 11:09:41 Member Gop_Rcast__4 0 // github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Call 0 2 // func() (out int64, inRange bool)
2025/12/19 11:09:41 ==> MatchFuncCall func() (out int64, inRange bool) args: 0 flags: 2
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 DefineVarStart [v2 ok2]
2025/12/19 11:09:41 Val int64 int64
2025/12/19 11:09:41 Val type int64 => Typ int64
2025/12/19 11:09:41 Val y github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Call 1 2 // TypeType{typ: int64}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: int64} args: 1 flags: 2
2025/12/19 11:09:41 Val &{y github.com/qiniu/x/xgo/ng.Uint128 <nil> y} *internal.Elem
2025/12/19 11:09:41 Member Gop_Rcast__4 0 // github.com/qiniu/x/xgo/ng.Uint128
2025/12/19 11:09:41 Call 0 2 // func() (out int64, inRange bool)
2025/12/19 11:09:41 ==> MatchFuncCall func() (out int64, inRange bool) args: 0 flags: 2
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val v1 int64
2025/12/19 11:09:41 Val ok1 bool
2025/12/19 11:09:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType int64, any
2025/12/19 11:09:41 ==> MatchType bool, any
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val v2 int64
2025/12/19 11:09:41 Val ok2 bool
2025/12/19 11:09:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType int64, any
2025/12/19 11:09:41 ==> MatchType bool, any
2025/12/19 11:09:41 End // Block
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> ASTFile
--- PASS: TestUint128_run (0.36s)
=== RUN   TestInt128_run
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 Block
2025/12/19 11:09:41 ==> Load var string [name]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [name]
2025/12/19 11:09:41 ==> Load var github.com/qiniu/x/xgo/ng.Int128 [age]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [age]
2025/12/19 11:09:41 Val Sscanf func(str string, format string, a ...any) (n int, err error)
2025/12/19 11:09:41 Val &{0 STRING "Kim is 22 years old"} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 STRING "%s is %d years old"} *ast.BasicLit
2025/12/19 11:09:41 Val name string
2025/12/19 11:09:41 UnaryOp & flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:41 Val age github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 UnaryOp & flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:41 Call 4 0 // func(str string, format string, a ...any) (n int, err error)
2025/12/19 11:09:41 ==> MatchFuncCall func(str string, format string, a ...any) (n int, err error) args: 4 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped string ("Kim is 22 years old"), string
2025/12/19 11:09:41 ==> MatchType untyped string ("%s is %d years old"), string
2025/12/19 11:09:41 ==> MatchType *string, any
2025/12/19 11:09:41 ==> MatchType *github.com/qiniu/x/xgo/ng.Int128, any
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val name string
2025/12/19 11:09:41 Val age github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType string, any
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, any
2025/12/19 11:09:41 End // Block
2025/12/19 11:09:41 Block
2025/12/19 11:09:41 ==> Load var github.com/qiniu/x/xgo/ng.Int128 [x]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [x]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType untyped int (1), github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), int
2025/12/19 11:09:41 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Int128 true
2025/12/19 11:09:41 ==> Load var <nil> [y]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [y]
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 UnaryOp + flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func() (v github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 32
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 VarRef x github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 IncDec ++
2025/12/19 11:09:41 ==> MatchFuncCall func() args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Int128}, *github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 VarRef x github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:41 AssignOp += Gop_AddAssign
2025/12/19 11:09:41 ==> MatchFuncCall func(b github.com/qiniu/x/xgo/ng.Int128) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Int128}, *github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 ==> MatchType untyped int (10), github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (10), int
2025/12/19 11:09:41 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Int128 true
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Val y github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, any
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, any
2025/12/19 11:09:41 End // Block
2025/12/19 11:09:41 Block
2025/12/19 11:09:41 ==> Load var github.com/qiniu/x/xgo/ng.Int128 [x]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [x]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 65} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp <<
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped int (65), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), int
2025/12/19 11:09:41 ==> AssignableConv untyped int (36893488147419103232): value is out of int range
2025/12/19 11:09:41 ==> MatchFuncCall func(v github.com/qiniu/x/xgo/ng.UntypedBigint) (out github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:41 NewClosure func() *math/big.Int
2025/12/19 11:09:41 DefineVarStart [v _]
2025/12/19 11:09:41 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:41 Typ math/big.Int
2025/12/19 11:09:41 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:41 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:41 Member SetString 0 // *math/big.Int
2025/12/19 11:09:41 Val 36893488147419103232 string
2025/12/19 11:09:41 Val 10 int
2025/12/19 11:09:41 Call 2 0 // func(s string, base int) (*math/big.Int, bool)
2025/12/19 11:09:41 ==> MatchFuncCall func(s string, base int) (*math/big.Int, bool) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped string ("36893488147419103232"), string
2025/12/19 11:09:41 ==> MatchType untyped int (10), int
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 Val v *math/big.Int
2025/12/19 11:09:41 Return 1
2025/12/19 11:09:41 ==> MatchType *math/big.Int, *math/big.Int
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 Call 0 0 // func() *math/big.Int
2025/12/19 11:09:41 ==> MatchFuncCall func() *math/big.Int args: 0 flags: 0
2025/12/19 11:09:41 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Int128 true
2025/12/19 11:09:41 ==> Load var <nil> [y]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [y]
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Val &{0 INT 63} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp >>
2025/12/19 11:09:41 Typ github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Member Gop_Rsh 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Int128}
2025/12/19 11:09:41 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Int128, n uint) github.com/qiniu/x/xgo/ng.Int128 args: 2 flags: 64
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 ==> MatchType untyped int (63), uint
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> Load var <nil> [z]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [z]
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Val &{0 INT 65} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp >>
2025/12/19 11:09:41 Typ github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Member Gop_Rsh 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Int128}
2025/12/19 11:09:41 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Int128, n uint) github.com/qiniu/x/xgo/ng.Int128 args: 2 flags: 64
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 ==> MatchType untyped int (65), uint
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, any
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val y github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Val z github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, any
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, any
2025/12/19 11:09:41 End // Block
2025/12/19 11:09:41 Block
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val int128 github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Val type int128 = github.com/qiniu/x/xgo/ng.Int128 => Typ github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 65} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp <<
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped int (65), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 Call 1 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Int128}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Int128} args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v int) github.com/qiniu/x/xgo/ng.Int128 args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), int
2025/12/19 11:09:41 ==> AssignableConv untyped int (36893488147419103232): value is out of int range
2025/12/19 11:09:41 ==> MatchFuncCall func(v github.com/qiniu/x/xgo/ng.UntypedBigint) (out github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:41 NewClosure func() *math/big.Int
2025/12/19 11:09:41 DefineVarStart [v _]
2025/12/19 11:09:41 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:41 Typ math/big.Int
2025/12/19 11:09:41 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:41 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:41 Member SetString 0 // *math/big.Int
2025/12/19 11:09:41 Val 36893488147419103232 string
2025/12/19 11:09:41 Val 10 int
2025/12/19 11:09:41 Call 2 0 // func(s string, base int) (*math/big.Int, bool)
2025/12/19 11:09:41 ==> MatchFuncCall func(s string, base int) (*math/big.Int, bool) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped string ("36893488147419103232"), string
2025/12/19 11:09:41 ==> MatchType untyped int (10), int
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 Val v *math/big.Int
2025/12/19 11:09:41 Return 1
2025/12/19 11:09:41 ==> MatchType *math/big.Int, *math/big.Int
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 Call 0 0 // func() *math/big.Int
2025/12/19 11:09:41 ==> MatchFuncCall func() *math/big.Int args: 0 flags: 0
2025/12/19 11:09:41 Val int128 github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Val type int128 = github.com/qiniu/x/xgo/ng.Int128 => Typ github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Call 0 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Int128}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Int128} args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v int) github.com/qiniu/x/xgo/ng.Int128 args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v github.com/qiniu/x/xgo/ng.UntypedBigint) (out github.com/qiniu/x/xgo/ng.Int128) args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v int64) (out github.com/qiniu/x/xgo/ng.Int128) args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v uint64) github.com/qiniu/x/xgo/ng.Int128 args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v int32) github.com/qiniu/x/xgo/ng.Int128 args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v int16) github.com/qiniu/x/xgo/ng.Int128 args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v int8) github.com/qiniu/x/xgo/ng.Int128 args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v github.com/qiniu/x/xgo/ng.Uint128) (out github.com/qiniu/x/xgo/ng.Int128) args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v *math/big.Int) github.com/qiniu/x/xgo/ng.Int128 args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v *math/big.Int) (out github.com/qiniu/x/xgo/ng.Int128, inRange bool) args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func() github.com/qiniu/x/xgo/ng.Int128 args: 0 flags: 0
2025/12/19 11:09:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Int128 (36893488147419103232), any
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, any
2025/12/19 11:09:41 End // Block
2025/12/19 11:09:41 Block
2025/12/19 11:09:41 ==> Load var github.com/qiniu/x/xgo/ng.Int128 [x]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [x]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType untyped int (1), github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), int
2025/12/19 11:09:41 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Int128 true
2025/12/19 11:09:41 Val printf func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val &{0 STRING "%4d\n"} *ast.BasicLit
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(format string, a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped string ("%4d\n"), string
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, any
2025/12/19 11:09:41 End // Block
2025/12/19 11:09:41 Block
2025/12/19 11:09:41 ==> Load var github.com/qiniu/x/xgo/ng.Int128 [x]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [x]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 65} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp <<
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped int (65), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), int
2025/12/19 11:09:41 ==> AssignableConv untyped int (36893488147419103232): value is out of int range
2025/12/19 11:09:41 ==> MatchFuncCall func(v github.com/qiniu/x/xgo/ng.UntypedBigint) (out github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:41 NewClosure func() *math/big.Int
2025/12/19 11:09:41 DefineVarStart [v _]
2025/12/19 11:09:41 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:41 Typ math/big.Int
2025/12/19 11:09:41 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:41 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:41 Member SetString 0 // *math/big.Int
2025/12/19 11:09:41 Val 36893488147419103232 string
2025/12/19 11:09:41 Val 10 int
2025/12/19 11:09:41 Call 2 0 // func(s string, base int) (*math/big.Int, bool)
2025/12/19 11:09:41 ==> MatchFuncCall func(s string, base int) (*math/big.Int, bool) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped string ("36893488147419103232"), string
2025/12/19 11:09:41 ==> MatchType untyped int (10), int
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 Val v *math/big.Int
2025/12/19 11:09:41 Return 1
2025/12/19 11:09:41 ==> MatchType *math/big.Int, *math/big.Int
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 Call 0 0 // func() *math/big.Int
2025/12/19 11:09:41 ==> MatchFuncCall func() *math/big.Int args: 0 flags: 0
2025/12/19 11:09:41 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Int128 true
2025/12/19 11:09:41 ==> Load var <nil> [y]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [y]
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp >>
2025/12/19 11:09:41 Typ github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Member Gop_Rsh 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Int128}
2025/12/19 11:09:41 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Int128, n uint) github.com/qiniu/x/xgo/ng.Int128 args: 2 flags: 64
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 ==> MatchType untyped int (2), uint
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp -
2025/12/19 11:09:41 Typ github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Member Gop_Sub 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Int128}
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 64
2025/12/19 11:09:41 ==> MatchFuncCall func(i github.com/qiniu/x/xgo/ng.Int128, n int64) (v github.com/qiniu/x/xgo/ng.Int128) args: 2 flags: 64
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 ==> MatchType untyped int (1), int64
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 DefineVarStart [v1 ok1]
2025/12/19 11:09:41 Val int64 int64
2025/12/19 11:09:41 Val type int64 => Typ int64
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Call 1 2 // TypeType{typ: int64}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: int64} args: 1 flags: 2
2025/12/19 11:09:41 Val &{x github.com/qiniu/x/xgo/ng.Int128 <nil> x} *internal.Elem
2025/12/19 11:09:41 Member Gop_Rcast__3 0 // github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Call 0 2 // func() (out int64, inRange bool)
2025/12/19 11:09:41 ==> MatchFuncCall func() (out int64, inRange bool) args: 0 flags: 2
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 DefineVarStart [v2 ok2]
2025/12/19 11:09:41 Val int64 int64
2025/12/19 11:09:41 Val type int64 => Typ int64
2025/12/19 11:09:41 Val y github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Call 1 2 // TypeType{typ: int64}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: int64} args: 1 flags: 2
2025/12/19 11:09:41 Val &{y github.com/qiniu/x/xgo/ng.Int128 <nil> y} *internal.Elem
2025/12/19 11:09:41 Member Gop_Rcast__3 0 // github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Call 0 2 // func() (out int64, inRange bool)
2025/12/19 11:09:41 ==> MatchFuncCall func() (out int64, inRange bool) args: 0 flags: 2
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val v1 int64
2025/12/19 11:09:41 Val ok1 bool
2025/12/19 11:09:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType int64, any
2025/12/19 11:09:41 ==> MatchType bool, any
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val v2 int64
2025/12/19 11:09:41 Val ok2 bool
2025/12/19 11:09:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType int64, any
2025/12/19 11:09:41 ==> MatchType bool, any
2025/12/19 11:09:41 End // Block
2025/12/19 11:09:41 Block
2025/12/19 11:09:41 ==> Load var github.com/qiniu/x/xgo/ng.Int128 [x]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [x]
2025/12/19 11:09:41 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType untyped int (0), github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(v int) (out github.com/qiniu/x/xgo/ng.Int128) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (0), int
2025/12/19 11:09:41 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Int128 true
2025/12/19 11:09:41 VarRef x github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 IncDec --
2025/12/19 11:09:41 ==> MatchFuncCall func() args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Int128}, *github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Int128
2025/12/19 11:09:41 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Int128, any
2025/12/19 11:09:41 End // Block
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> ASTFile
--- PASS: TestInt128_run (0.33s)
=== RUN   TestBigint_run
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 Block
2025/12/19 11:09:41 ==> Load var github.com/qiniu/x/xgo/ng.Bigint [x]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [x]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType untyped int (1), github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), int
2025/12/19 11:09:41 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigint true
2025/12/19 11:09:41 ==> Load var <nil> [y]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [y]
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 UnaryOp + flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func() github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 32
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 VarRef x github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 IncDec ++
2025/12/19 11:09:41 ==> MatchFuncCall func() args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Bigint}, github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 VarRef x github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:09:41 AssignOp += Gop_AddAssign
2025/12/19 11:09:41 ==> MatchFuncCall func(b github.com/qiniu/x/xgo/ng.Bigint) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Bigint}, github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 ==> MatchType untyped int (10), github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (10), int
2025/12/19 11:09:41 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigint true
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Val y github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, any
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, any
2025/12/19 11:09:41 End // Block
2025/12/19 11:09:41 Block
2025/12/19 11:09:41 ==> Load var github.com/qiniu/x/xgo/ng.Bigint [x]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [x]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 65} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp <<
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped int (65), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), int
2025/12/19 11:09:41 ==> AssignableConv untyped int (36893488147419103232): value is out of int range
2025/12/19 11:09:41 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:41 NewClosure func() *math/big.Int
2025/12/19 11:09:41 DefineVarStart [v _]
2025/12/19 11:09:41 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:41 Typ math/big.Int
2025/12/19 11:09:41 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:41 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:41 Member SetString 0 // *math/big.Int
2025/12/19 11:09:41 Val 36893488147419103232 string
2025/12/19 11:09:41 Val 10 int
2025/12/19 11:09:41 Call 2 0 // func(s string, base int) (*math/big.Int, bool)
2025/12/19 11:09:41 ==> MatchFuncCall func(s string, base int) (*math/big.Int, bool) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped string ("36893488147419103232"), string
2025/12/19 11:09:41 ==> MatchType untyped int (10), int
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 Val v *math/big.Int
2025/12/19 11:09:41 Return 1
2025/12/19 11:09:41 ==> MatchType *math/big.Int, *math/big.Int
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 Call 0 0 // func() *math/big.Int
2025/12/19 11:09:41 ==> MatchFuncCall func() *math/big.Int args: 0 flags: 0
2025/12/19 11:09:41 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigint true
2025/12/19 11:09:41 ==> Load var <nil> [y]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [y]
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Val &{0 INT 63} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp >>
2025/12/19 11:09:41 Typ github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Member Gop_Rsh 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Bigint}
2025/12/19 11:09:41 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Bigint, n uint) github.com/qiniu/x/xgo/ng.Bigint args: 2 flags: 64
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 ==> MatchType untyped int (63), uint
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> Load var <nil> [z]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [z]
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Val &{0 INT 65} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp >>
2025/12/19 11:09:41 Typ github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Member Gop_Rsh 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Bigint}
2025/12/19 11:09:41 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Bigint, n uint) github.com/qiniu/x/xgo/ng.Bigint args: 2 flags: 64
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 ==> MatchType untyped int (65), uint
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, any
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val y github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Val z github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, any
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, any
2025/12/19 11:09:41 End // Block
2025/12/19 11:09:41 Block
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val bigint github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Val type bigint = github.com/qiniu/x/xgo/ng.Bigint => Typ github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 65} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp <<
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped int (65), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 Call 1 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Bigint}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Bigint} args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), int
2025/12/19 11:09:41 ==> AssignableConv untyped int (36893488147419103232): value is out of int range
2025/12/19 11:09:41 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:41 NewClosure func() *math/big.Int
2025/12/19 11:09:41 DefineVarStart [v _]
2025/12/19 11:09:41 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:41 Typ math/big.Int
2025/12/19 11:09:41 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:41 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:41 Member SetString 0 // *math/big.Int
2025/12/19 11:09:41 Val 36893488147419103232 string
2025/12/19 11:09:41 Val 10 int
2025/12/19 11:09:41 Call 2 0 // func(s string, base int) (*math/big.Int, bool)
2025/12/19 11:09:41 ==> MatchFuncCall func(s string, base int) (*math/big.Int, bool) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped string ("36893488147419103232"), string
2025/12/19 11:09:41 ==> MatchType untyped int (10), int
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 Val v *math/big.Int
2025/12/19 11:09:41 Return 1
2025/12/19 11:09:41 ==> MatchType *math/big.Int, *math/big.Int
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 Call 0 0 // func() *math/big.Int
2025/12/19 11:09:41 ==> MatchFuncCall func() *math/big.Int args: 0 flags: 0
2025/12/19 11:09:41 Val bigint github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Val type bigint = github.com/qiniu/x/xgo/ng.Bigint => Typ github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Call 0 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Bigint}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: github.com/qiniu/x/xgo/ng.Bigint} args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigint args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(x int64) github.com/qiniu/x/xgo/ng.Bigint args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(x uint64) github.com/qiniu/x/xgo/ng.Bigint args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(x uint) github.com/qiniu/x/xgo/ng.Bigint args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(x *math/big.Int) github.com/qiniu/x/xgo/ng.Bigint args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(x *math/big.Rat) github.com/qiniu/x/xgo/ng.Bigint args: 0 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func() github.com/qiniu/x/xgo/ng.Bigint args: 0 flags: 0
2025/12/19 11:09:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, any
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, any
2025/12/19 11:09:41 End // Block
2025/12/19 11:09:41 Block
2025/12/19 11:09:41 ==> Load var github.com/qiniu/x/xgo/ng.Bigint [x]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [x]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType untyped int (1), github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), int
2025/12/19 11:09:41 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigint true
2025/12/19 11:09:41 Val printf func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val &{0 STRING "%4d\n"} *ast.BasicLit
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(format string, a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped string ("%4d\n"), string
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, any
2025/12/19 11:09:41 End // Block
2025/12/19 11:09:41 Block
2025/12/19 11:09:41 ==> Load var github.com/qiniu/x/xgo/ng.Bigint [x]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [x]
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 Val &{0 INT 65} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp <<
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, n TemplateParamType{name: N}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType untyped int (65), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), int
2025/12/19 11:09:41 ==> AssignableConv untyped int (36893488147419103232): value is out of int range
2025/12/19 11:09:41 ==> MatchFuncCall func(x github.com/qiniu/x/xgo/ng.UntypedBigint) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (36893488147419103232), github.com/qiniu/x/xgo/ng.UntypedBigint
2025/12/19 11:09:41 NewClosure func() *math/big.Int
2025/12/19 11:09:41 DefineVarStart [v _]
2025/12/19 11:09:41 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:41 Typ math/big.Int
2025/12/19 11:09:41 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:41 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:41 Member SetString 0 // *math/big.Int
2025/12/19 11:09:41 Val 36893488147419103232 string
2025/12/19 11:09:41 Val 10 int
2025/12/19 11:09:41 Call 2 0 // func(s string, base int) (*math/big.Int, bool)
2025/12/19 11:09:41 ==> MatchFuncCall func(s string, base int) (*math/big.Int, bool) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped string ("36893488147419103232"), string
2025/12/19 11:09:41 ==> MatchType untyped int (10), int
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 Val v *math/big.Int
2025/12/19 11:09:41 Return 1
2025/12/19 11:09:41 ==> MatchType *math/big.Int, *math/big.Int
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 Call 0 0 // func() *math/big.Int
2025/12/19 11:09:41 ==> MatchFuncCall func() *math/big.Int args: 0 flags: 0
2025/12/19 11:09:41 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigint true
2025/12/19 11:09:41 ==> Load var <nil> [y]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [y]
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp >>
2025/12/19 11:09:41 Typ github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Member Gop_Rsh 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Bigint}
2025/12/19 11:09:41 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Bigint, n uint) github.com/qiniu/x/xgo/ng.Bigint args: 2 flags: 64
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 ==> MatchType untyped int (2), uint
2025/12/19 11:09:41 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:41 BinaryOp -
2025/12/19 11:09:41 Typ github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Member Gop_Sub 0 // TypeType{typ: github.com/qiniu/x/xgo/ng.Bigint}
2025/12/19 11:09:41 ==> MatchFuncCall func(github.com/qiniu/x/xgo/ng.Bigint, b github.com/qiniu/x/xgo/ng.Bigint) github.com/qiniu/x/xgo/ng.Bigint args: 2 flags: 64
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 ==> MatchType untyped int (1), github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (1), int
2025/12/19 11:09:41 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigint true
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 DefineVarStart [v1 ok1]
2025/12/19 11:09:41 Val int64 int64
2025/12/19 11:09:41 Val type int64 => Typ int64
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Call 1 2 // TypeType{typ: int64}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: int64} args: 1 flags: 2
2025/12/19 11:09:41 Val &{x github.com/qiniu/x/xgo/ng.Bigint <nil> x} *internal.Elem
2025/12/19 11:09:41 Member Gop_Rcast__1 0 // github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Call 0 2 // func() (int64, bool)
2025/12/19 11:09:41 ==> MatchFuncCall func() (int64, bool) args: 0 flags: 2
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 DefineVarStart [v2 ok2]
2025/12/19 11:09:41 Val int64 int64
2025/12/19 11:09:41 Val type int64 => Typ int64
2025/12/19 11:09:41 Val y github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Call 1 2 // TypeType{typ: int64}
2025/12/19 11:09:41 ==> MatchFuncCall TypeType{typ: int64} args: 1 flags: 2
2025/12/19 11:09:41 Val &{y github.com/qiniu/x/xgo/ng.Bigint <nil> y} *internal.Elem
2025/12/19 11:09:41 Member Gop_Rcast__1 0 // github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Call 0 2 // func() (int64, bool)
2025/12/19 11:09:41 ==> MatchFuncCall func() (int64, bool) args: 0 flags: 2
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val v1 int64
2025/12/19 11:09:41 Val ok1 bool
2025/12/19 11:09:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType int64, any
2025/12/19 11:09:41 ==> MatchType bool, any
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val v2 int64
2025/12/19 11:09:41 Val ok2 bool
2025/12/19 11:09:41 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType int64, any
2025/12/19 11:09:41 ==> MatchType bool, any
2025/12/19 11:09:41 End // Block
2025/12/19 11:09:41 Block
2025/12/19 11:09:41 ==> Load var github.com/qiniu/x/xgo/ng.Bigint [x]
2025/12/19 11:09:41 NewVarDefs
2025/12/19 11:09:41 NewVar [x]
2025/12/19 11:09:41 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:41 EndInit 1
2025/12/19 11:09:41 ==> MatchType untyped int (0), github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(x int) github.com/qiniu/x/xgo/ng.Bigint args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType untyped int (0), int
2025/12/19 11:09:41 ==> AssignableConv untyped int github.com/qiniu/x/xgo/ng.Bigint true
2025/12/19 11:09:41 VarRef x github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 IncDec --
2025/12/19 11:09:41 ==> MatchFuncCall func() args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType refType{typ: github.com/qiniu/x/xgo/ng.Bigint}, github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 Val x github.com/qiniu/x/xgo/ng.Bigint
2025/12/19 11:09:41 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:41 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:41 ==> MatchType github.com/qiniu/x/xgo/ng.Bigint, any
2025/12/19 11:09:41 End // Block
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> ASTFile
--- PASS: TestBigint_run (0.34s)
=== RUN   TestTypeParams
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Preload type Data
2025/12/19 11:09:42 ==> Preload method Data.foo
2025/12/19 11:09:42 ==> Load > NewType Data
2025/12/19 11:09:42 ==> Load > InitType Data
2025/12/19 11:09:42 ==> LookupParent Data => type github.com/goplus/xgo/cl.Data[X, Y interface{}] struct{v X}
2025/12/19 11:09:42 ==> Load method *github.com/goplus/xgo/cl.Data[X, Y interface{}].foo
2025/12/19 11:09:42 ==> Load func main
2025/12/19 11:09:42 NewFunc main func()
2025/12/19 11:09:42 DefineVarStart [v]
2025/12/19 11:09:42 ==> LookupParent Data => type github.com/goplus/xgo/cl.Data[X, Y interface{}] struct{v X}
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 StructLit github.com/goplus/xgo/cl.Data[int, float64] 1 false
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 Val v github.com/goplus/xgo/cl.Data[int, float64]
2025/12/19 11:09:42 Member foo 1 // github.com/goplus/xgo/cl.Data[int, float64]
2025/12/19 11:09:42 Call 0 0 // func()
2025/12/19 11:09:42 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:42 End // Func
2025/12/19 11:09:42 ==> ASTFile
--- PASS: TestTypeParams (0.00s)
=== RUN   TestTypeParamsFunc
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Preload type Number
2025/12/19 11:09:42 ==> Preload func Sum
2025/12/19 11:09:42 ==> Preload func At
2025/12/19 11:09:42 ==> Preload func Loader
2025/12/19 11:09:42 ==> Preload func Add
2025/12/19 11:09:42 ==> Preload type Int
2025/12/19 11:09:42 ==> Preload var [MyInts]
2025/12/19 11:09:42 ==> Load > NewType Number
2025/12/19 11:09:42 ==> Load > InitType Number
2025/12/19 11:09:42 ==> Load > NewType Int
2025/12/19 11:09:42 ==> Load > InitType Int
2025/12/19 11:09:42 ==> Load func main
2025/12/19 11:09:42 NewFunc main func()
2025/12/19 11:09:42 VarRef _
2025/12/19 11:09:42 ==> Load func At
2025/12/19 11:09:42 Val At func[T interface{interface{~[]E}}, E interface{}](x T, i int) E
2025/12/19 11:09:42 Typ []int
2025/12/19 11:09:42 Index 1 false
2025/12/19 11:09:42 ==> InferType inferFuncType{typ: func[T interface{interface{~[]E}}, E interface{}](x T, i int) E, targs: [[]int]}
2025/12/19 11:09:42 Assign 1 1
2025/12/19 11:09:42 VarRef _
2025/12/19 11:09:42 Val At func[T interface{interface{~[]E}}, E interface{}](x T, i int) E
2025/12/19 11:09:42 Typ []int
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Index 2 false
2025/12/19 11:09:42 ==> InferType func(x []int, i int) int
2025/12/19 11:09:42 Assign 1 1
2025/12/19 11:09:42 VarRef _
2025/12/19 11:09:42 ==> Load func Sum
2025/12/19 11:09:42 ==> LookupParent Number => type github.com/goplus/xgo/cl.Number interface{interface{~int | ~uint | float64}}
2025/12/19 11:09:42 Val Sum func[T github.com/goplus/xgo/cl.Number](vec []T) T
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Index 1 false
2025/12/19 11:09:42 ==> InferType func(vec []int) int
2025/12/19 11:09:42 Assign 1 1
2025/12/19 11:09:42 VarRef _
2025/12/19 11:09:42 ==> Load func Loader
2025/12/19 11:09:42 Val Loader func[T1, T2 interface{}](p1 T1, p2 T2) T1
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Star
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Index 2 false
2025/12/19 11:09:42 ==> InferType func(p1 *int, p2 int) *int
2025/12/19 11:09:42 Assign 1 1
2025/12/19 11:09:42 VarRef _
2025/12/19 11:09:42 ==> Load func Add
2025/12/19 11:09:42 Val Add func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/12/19 11:09:42 Val string string
2025/12/19 11:09:42 Val type string => Typ string
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Index 2 false
2025/12/19 11:09:42 ==> InferType func(v1 string, v2 ...int) (sum int)
2025/12/19 11:09:42 Assign 1 1
2025/12/19 11:09:42 ==> Load var int [s1]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [s1]
2025/12/19 11:09:42 Val Sum func[T github.com/goplus/xgo/cl.Number](vec []T) T
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 SliceLit <nil> 3 false
2025/12/19 11:09:42 Call 1 0 // func[T github.com/goplus/xgo/cl.Number](vec []T) T
2025/12/19 11:09:42 ==> MatchFuncCall func[T github.com/goplus/xgo/cl.Number](vec []T) T args: 1 flags: 0
2025/12/19 11:09:42 ==> InferFunc func(vec []int) int
2025/12/19 11:09:42 ==> MatchType []int, []int
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 ==> MatchType int, int
2025/12/19 11:09:42 ==> Load var int [s2]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [s2]
2025/12/19 11:09:42 Val Sum func[T github.com/goplus/xgo/cl.Number](vec []T) T
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Index 1 false
2025/12/19 11:09:42 ==> InferType func(vec []int) int
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 SliceLit []int 3 false
2025/12/19 11:09:42 Call 1 0 // func(vec []int) int
2025/12/19 11:09:42 ==> MatchFuncCall func(vec []int) int args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchType []int, []int
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 ==> MatchType int, int
2025/12/19 11:09:42 ==> Load var int [v1]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [v1]
2025/12/19 11:09:42 Val At func[T interface{interface{~[]E}}, E interface{}](x T, i int) E
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 SliceLit <nil> 3 false
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Call 2 0 // func[T interface{interface{~[]E}}, E interface{}](x T, i int) E
2025/12/19 11:09:42 ==> MatchFuncCall func[T interface{interface{~[]E}}, E interface{}](x T, i int) E args: 2 flags: 0
2025/12/19 11:09:42 ==> InferFunc func(x []int, i int) int
2025/12/19 11:09:42 ==> MatchType []int, []int
2025/12/19 11:09:42 ==> MatchType untyped int (1), int
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 ==> MatchType int, int
2025/12/19 11:09:42 ==> Load var int [v2]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [v2]
2025/12/19 11:09:42 Val At func[T interface{interface{~[]E}}, E interface{}](x T, i int) E
2025/12/19 11:09:42 Typ []int
2025/12/19 11:09:42 Index 1 false
2025/12/19 11:09:42 ==> InferType inferFuncType{typ: func[T interface{interface{~[]E}}, E interface{}](x T, i int) E, targs: [[]int]}
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 SliceLit <nil> 3 false
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Call 2 0 // inferFuncType{typ: func[T interface{interface{~[]E}}, E interface{}](x T, i int) E, targs: [[]int]}
2025/12/19 11:09:42 ==> MatchFuncCall inferFuncType{typ: func[T interface{interface{~[]E}}, E interface{}](x T, i int) E, targs: [[]int]} args: 2 flags: 0
2025/12/19 11:09:42 ==> InferFunc func(x []int, i int) int
2025/12/19 11:09:42 ==> MatchType []int, []int
2025/12/19 11:09:42 ==> MatchType untyped int (1), int
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 ==> MatchType int, int
2025/12/19 11:09:42 ==> Load var int [v3]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [v3]
2025/12/19 11:09:42 Val At func[T interface{interface{~[]E}}, E interface{}](x T, i int) E
2025/12/19 11:09:42 Typ []int
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Index 2 false
2025/12/19 11:09:42 ==> InferType func(x []int, i int) int
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 SliceLit []int 3 false
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Call 2 0 // func(x []int, i int) int
2025/12/19 11:09:42 ==> MatchFuncCall func(x []int, i int) int args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchType []int, []int
2025/12/19 11:09:42 ==> MatchType untyped int (1), int
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 ==> MatchType int, int
2025/12/19 11:09:42 ==> Load var int [n1]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [n1]
2025/12/19 11:09:42 Val Add func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/12/19 11:09:42 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 Call 4 0 // func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/12/19 11:09:42 ==> MatchFuncCall func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2) args: 4 flags: 0
2025/12/19 11:09:42 ==> InferFunc func(v1 string, v2 ...int) (sum int)
2025/12/19 11:09:42 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:42 ==> MatchType untyped int (1), int
2025/12/19 11:09:42 ==> MatchType untyped int (2), int
2025/12/19 11:09:42 ==> MatchType untyped int (3), int
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 ==> MatchType int, int
2025/12/19 11:09:42 ==> Load var int [n2]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [n2]
2025/12/19 11:09:42 Val Add func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/12/19 11:09:42 Val string string
2025/12/19 11:09:42 Val type string => Typ string
2025/12/19 11:09:42 Index 1 false
2025/12/19 11:09:42 ==> InferType inferFuncType{typ: func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2), targs: [string]}
2025/12/19 11:09:42 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 Call 4 0 // inferFuncType{typ: func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2), targs: [string]}
2025/12/19 11:09:42 ==> MatchFuncCall inferFuncType{typ: func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2), targs: [string]} args: 4 flags: 0
2025/12/19 11:09:42 ==> InferFunc func(v1 string, v2 ...int) (sum int)
2025/12/19 11:09:42 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:42 ==> MatchType untyped int (1), int
2025/12/19 11:09:42 ==> MatchType untyped int (2), int
2025/12/19 11:09:42 ==> MatchType untyped int (3), int
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 ==> MatchType int, int
2025/12/19 11:09:42 ==> Load var int [n3]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [n3]
2025/12/19 11:09:42 Val Add func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/12/19 11:09:42 Val string string
2025/12/19 11:09:42 Val type string => Typ string
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Index 2 false
2025/12/19 11:09:42 ==> InferType func(v1 string, v2 ...int) (sum int)
2025/12/19 11:09:42 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 Call 4 0 // func(v1 string, v2 ...int) (sum int)
2025/12/19 11:09:42 ==> MatchFuncCall func(v1 string, v2 ...int) (sum int) args: 4 flags: 0
2025/12/19 11:09:42 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:42 ==> MatchType untyped int (1), int
2025/12/19 11:09:42 ==> MatchType untyped int (2), int
2025/12/19 11:09:42 ==> MatchType untyped int (3), int
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 ==> MatchType int, int
2025/12/19 11:09:42 ==> Load var int [n4]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [n4]
2025/12/19 11:09:42 Val Add func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/12/19 11:09:42 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 SliceLit <nil> 3 false
2025/12/19 11:09:42 Call 2 1 // func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/12/19 11:09:42 ==> MatchFuncCall func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2) args: 2 flags: 1
2025/12/19 11:09:42 ==> InferFunc func(v1 string, v2 ...int) (sum int)
2025/12/19 11:09:42 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:42 ==> MatchType []int, []int
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 ==> MatchType int, int
2025/12/19 11:09:42 ==> Load var int [n5]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [n5]
2025/12/19 11:09:42 Val Add func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/12/19 11:09:42 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 SliceLit <nil> 3 false
2025/12/19 11:09:42 Call 2 1 // func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/12/19 11:09:42 ==> MatchFuncCall func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2) args: 2 flags: 1
2025/12/19 11:09:42 ==> InferFunc func(v1 string, v2 ...int) (sum int)
2025/12/19 11:09:42 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:42 ==> MatchType []int, []int
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 ==> MatchType int, int
2025/12/19 11:09:42 ==> Load var int [n6]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [n6]
2025/12/19 11:09:42 Val Add func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/12/19 11:09:42 Val string string
2025/12/19 11:09:42 Val type string => Typ string
2025/12/19 11:09:42 Index 1 false
2025/12/19 11:09:42 ==> InferType inferFuncType{typ: func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2), targs: [string]}
2025/12/19 11:09:42 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:42 ==> Load var <nil> [MyInts]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [MyInts]
2025/12/19 11:09:42 ==> LookupParent Int => type github.com/goplus/xgo/cl.Int []int
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 4} *ast.BasicLit
2025/12/19 11:09:42 SliceLit github.com/goplus/xgo/cl.Int 4 false
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 Val MyInts github.com/goplus/xgo/cl.Int
2025/12/19 11:09:42 Call 2 1 // inferFuncType{typ: func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2), targs: [string]}
2025/12/19 11:09:42 ==> MatchFuncCall inferFuncType{typ: func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2), targs: [string]} args: 2 flags: 1
2025/12/19 11:09:42 ==> InferFunc func(v1 string, v2 ...int) (sum int)
2025/12/19 11:09:42 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:42 ==> MatchType github.com/goplus/xgo/cl.Int, []int
2025/12/19 11:09:42 ==> EnsureLoaded github.com/goplus/xgo/cl.Int
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 ==> MatchType int, int
2025/12/19 11:09:42 ==> Load var int [n7]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [n7]
2025/12/19 11:09:42 Val Add func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/12/19 11:09:42 Val string string
2025/12/19 11:09:42 Val type string => Typ string
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Index 2 false
2025/12/19 11:09:42 ==> InferType func(v1 string, v2 ...int) (sum int)
2025/12/19 11:09:42 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 SliceLit []int 3 false
2025/12/19 11:09:42 Call 2 1 // func(v1 string, v2 ...int) (sum int)
2025/12/19 11:09:42 ==> MatchFuncCall func(v1 string, v2 ...int) (sum int) args: 2 flags: 1
2025/12/19 11:09:42 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:42 ==> MatchType []int, []int
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 ==> MatchType int, int
2025/12/19 11:09:42 ==> Load var *int [p1]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [p1]
2025/12/19 11:09:42 Val Loader func[T1, T2 interface{}](p1 T1, p2 T2) T1
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Star
2025/12/19 11:09:42 Index 1 false
2025/12/19 11:09:42 ==> InferType inferFuncType{typ: func[T1, T2 interface{}](p1 T1, p2 T2) T1, targs: [*int]}
2025/12/19 11:09:42 Val nil untyped nil
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Call 2 0 // inferFuncType{typ: func[T1, T2 interface{}](p1 T1, p2 T2) T1, targs: [*int]}
2025/12/19 11:09:42 ==> MatchFuncCall inferFuncType{typ: func[T1, T2 interface{}](p1 T1, p2 T2) T1, targs: [*int]} args: 2 flags: 0
2025/12/19 11:09:42 ==> InferFunc func(p1 *int, p2 int) *int
2025/12/19 11:09:42 ==> MatchType untyped nil, *int
2025/12/19 11:09:42 ==> MatchType untyped int (1), int
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 ==> MatchType *int, *int
2025/12/19 11:09:42 ==> Load var *int [p2]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [p2]
2025/12/19 11:09:42 Val Loader func[T1, T2 interface{}](p1 T1, p2 T2) T1
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Star
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Index 2 false
2025/12/19 11:09:42 ==> InferType func(p1 *int, p2 int) *int
2025/12/19 11:09:42 Val nil untyped nil
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Call 2 0 // func(p1 *int, p2 int) *int
2025/12/19 11:09:42 ==> MatchFuncCall func(p1 *int, p2 int) *int args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchType untyped nil, *int
2025/12/19 11:09:42 ==> MatchType untyped int (1), int
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 ==> MatchType *int, *int
2025/12/19 11:09:42 ==> Load var func(p1 *int, p2 int) *int [fn1]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [fn1]
2025/12/19 11:09:42 VarRef fn1 func(p1 *int, p2 int) *int
2025/12/19 11:09:42 Val Loader func[T1, T2 interface{}](p1 T1, p2 T2) T1
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Star
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Index 2 false
2025/12/19 11:09:42 ==> InferType func(p1 *int, p2 int) *int
2025/12/19 11:09:42 Assign 1 1
2025/12/19 11:09:42 ==> MatchType func(p1 *int, p2 int) *int, func(p1 *int, p2 int) *int
2025/12/19 11:09:42 Val fn1 func(p1 *int, p2 int) *int
2025/12/19 11:09:42 Val nil untyped nil
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Call 2 0 // func(p1 *int, p2 int) *int
2025/12/19 11:09:42 ==> MatchFuncCall func(p1 *int, p2 int) *int args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchType untyped nil, *int
2025/12/19 11:09:42 ==> MatchType untyped int (1), int
2025/12/19 11:09:42 End // Func
2025/12/19 11:09:42 ==> ASTFile
--- PASS: TestTypeParamsFunc (0.01s)
=== RUN   TestTypeParamsType
2025/12/19 11:09:42 ==> Preload type DataString
2025/12/19 11:09:42 ==> Preload type SliceString
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Preload type Data
2025/12/19 11:09:42 ==> Preload method Data.Set
2025/12/19 11:09:42 ==> Preload method Data.Set2
2025/12/19 11:09:42 ==> Preload type sliceOf
2025/12/19 11:09:42 ==> Preload type Slice
2025/12/19 11:09:42 ==> Preload method Slice.Append
2025/12/19 11:09:42 ==> Preload method Slice.Append2
2025/12/19 11:09:42 ==> Preload type DataInt
2025/12/19 11:09:42 ==> Preload type SliceInt
2025/12/19 11:09:42 ==> Load > AliasType SliceInt
2025/12/19 11:09:42 ==> Load > NewType Slice
2025/12/19 11:09:42 ==> Lookup (LoadSymbol) Slice => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:42 ==> EnsureLoaded github.com/goplus/xgo/cl.Slice
2025/12/19 11:09:42 ==> Load > InitType Slice
2025/12/19 11:09:42 ==> Load > NewType sliceOf
2025/12/19 11:09:42 ==> Lookup (LoadSymbol) sliceOf => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:42 ==> EnsureLoaded github.com/goplus/xgo/cl.sliceOf
2025/12/19 11:09:42 ==> Load > InitType sliceOf
2025/12/19 11:09:42 ==> LookupParent Slice => type github.com/goplus/xgo/cl.Slice[S github.com/goplus/xgo/cl.sliceOf[T], T interface{}] struct{Data S}
2025/12/19 11:09:42 ==> Load method *github.com/goplus/xgo/cl.Slice[S github.com/goplus/xgo/cl.sliceOf[T], T interface{}].Append
2025/12/19 11:09:42 ==> LookupParent Slice => type github.com/goplus/xgo/cl.Slice[S github.com/goplus/xgo/cl.sliceOf[T], T interface{}] struct{Data S}
2025/12/19 11:09:42 ==> Load method *github.com/goplus/xgo/cl.Slice[S github.com/goplus/xgo/cl.sliceOf[T], T interface{}].Append2
2025/12/19 11:09:42 ==> Load > NewType Data
2025/12/19 11:09:42 ==> Load > InitType Data
2025/12/19 11:09:42 ==> LookupParent Data => type github.com/goplus/xgo/cl.Data[T interface{}] struct{v T}
2025/12/19 11:09:42 ==> Load method *github.com/goplus/xgo/cl.Data[T interface{}].Set
2025/12/19 11:09:42 ==> LookupParent Data => type github.com/goplus/xgo/cl.Data[T interface{}] struct{v T}
2025/12/19 11:09:42 ==> Load method *github.com/goplus/xgo/cl.Data[T interface{}].Set2
2025/12/19 11:09:42 ==> Load > AliasType DataInt
2025/12/19 11:09:42 ==> LookupParent Data => type github.com/goplus/xgo/cl.Data[T interface{}] struct{v T}
2025/12/19 11:09:42 ==> Load > AliasType DataString
2025/12/19 11:09:42 ==> LookupParent Data => type github.com/goplus/xgo/cl.Data[T interface{}] struct{v T}
2025/12/19 11:09:42 AliasType DataString github.com/goplus/xgo/cl.Data[string]
2025/12/19 11:09:42 ==> Load > AliasType SliceString
2025/12/19 11:09:42 ==> LookupParent Slice => type github.com/goplus/xgo/cl.Slice[S github.com/goplus/xgo/cl.sliceOf[T], T interface{}] struct{Data S}
2025/12/19 11:09:42 AliasType SliceString github.com/goplus/xgo/cl.Slice[[]string, string]
2025/12/19 11:09:42 ==> Load func main
2025/12/19 11:09:42 NewFunc main func()
2025/12/19 11:09:42 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> LookupParent DataInt => type github.com/goplus/xgo/cl.DataInt[T interface{}] = github.com/goplus/xgo/cl.Data[int]
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 StructLit github.com/goplus/xgo/cl.Data[int] 1 false
2025/12/19 11:09:42 Member v 2 // github.com/goplus/xgo/cl.Data[int]
2025/12/19 11:09:42 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchType int, any
2025/12/19 11:09:42 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> LookupParent DataString => type github.com/goplus/xgo/cl.DataString[T interface{}] = github.com/goplus/xgo/cl.Data[string]
2025/12/19 11:09:42 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:42 StructLit github.com/goplus/xgo/cl.Data[string] 1 false
2025/12/19 11:09:42 Member v 2 // github.com/goplus/xgo/cl.Data[string]
2025/12/19 11:09:42 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchType string, any
2025/12/19 11:09:42 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> LookupParent Data => type github.com/goplus/xgo/cl.Data[T interface{}] struct{v T}
2025/12/19 11:09:42 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:42 StructLit github.com/goplus/xgo/cl.Data[int] 1 false
2025/12/19 11:09:42 Member v 2 // github.com/goplus/xgo/cl.Data[int]
2025/12/19 11:09:42 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchType int, any
2025/12/19 11:09:42 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> LookupParent Data => type github.com/goplus/xgo/cl.Data[T interface{}] struct{v T}
2025/12/19 11:09:42 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:42 StructLit github.com/goplus/xgo/cl.Data[string] 1 false
2025/12/19 11:09:42 Member v 2 // github.com/goplus/xgo/cl.Data[string]
2025/12/19 11:09:42 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchType string, any
2025/12/19 11:09:42 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> LookupParent Data => type github.com/goplus/xgo/cl.Data[T interface{}] struct{v T}
2025/12/19 11:09:42 StructLit github.com/goplus/xgo/cl.Data[struct{X int; Y int}] 0 false
2025/12/19 11:09:42 Member v 2 // github.com/goplus/xgo/cl.Data[struct{X int; Y int}]
2025/12/19 11:09:42 Member X 2 // struct{X int; Y int}
2025/12/19 11:09:42 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchType int, any
2025/12/19 11:09:42 DefineVarStart [v1]
2025/12/19 11:09:42 ==> LookupParent SliceInt => type github.com/goplus/xgo/cl.SliceInt[S github.com/goplus/xgo/cl.sliceOf[T], T interface{}] = github.com/goplus/xgo/cl.Slice[[]int, int]
2025/12/19 11:09:42 StructLit github.com/goplus/xgo/cl.Slice[[]int, int] 0 false
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 DefineVarStart [v2]
2025/12/19 11:09:42 ==> LookupParent SliceString => type github.com/goplus/xgo/cl.SliceString[S github.com/goplus/xgo/cl.sliceOf[T], T interface{}] = github.com/goplus/xgo/cl.Slice[[]string, string]
2025/12/19 11:09:42 StructLit github.com/goplus/xgo/cl.Slice[[]string, string] 0 false
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 DefineVarStart [v3]
2025/12/19 11:09:42 ==> LookupParent Slice => type github.com/goplus/xgo/cl.Slice[S github.com/goplus/xgo/cl.sliceOf[T], T interface{}] struct{Data S}
2025/12/19 11:09:42 StructLit github.com/goplus/xgo/cl.Slice[[]int, int] 0 false
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 Val v3 github.com/goplus/xgo/cl.Slice[[]int, int]
2025/12/19 11:09:42 Member Append 1 // github.com/goplus/xgo/cl.Slice[[]int, int]
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 4} *ast.BasicLit
2025/12/19 11:09:42 SliceLit []int 4 false
2025/12/19 11:09:42 Call 1 1 // func(t ...int) []int
2025/12/19 11:09:42 ==> MatchFuncCall func(t ...int) []int args: 1 flags: 1
2025/12/19 11:09:42 ==> MatchType []int, []int
2025/12/19 11:09:42 Val v3 github.com/goplus/xgo/cl.Slice[[]int, int]
2025/12/19 11:09:42 Member Append2 1 // github.com/goplus/xgo/cl.Slice[[]int, int]
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 4} *ast.BasicLit
2025/12/19 11:09:42 SliceLit []int 4 false
2025/12/19 11:09:42 Call 1 1 // func(t ...int) []int
2025/12/19 11:09:42 ==> MatchFuncCall func(t ...int) []int args: 1 flags: 1
2025/12/19 11:09:42 ==> MatchType []int, []int
2025/12/19 11:09:42 End // Func
2025/12/19 11:09:42 ==> ASTFile
--- PASS: TestTypeParamsType (0.00s)
=== RUN   TestTypeParamsComparable
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Preload func Index
2025/12/19 11:09:42 ==> Preload var [IndexInt]
2025/12/19 11:09:42 ==> Load func main
2025/12/19 11:09:42 NewFunc main func()
2025/12/19 11:09:42 DefineVarStart [v1]
2025/12/19 11:09:42 ==> Load var <nil> [IndexInt]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [IndexInt]
2025/12/19 11:09:42 ==> Load func Index
2025/12/19 11:09:42 Val Index func[T comparable](s []T, x T) int
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Index 1 false
2025/12/19 11:09:42 ==> InferType func(s []int, x int) int
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 Val IndexInt func(s []int, x int) int
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 4} *ast.BasicLit
2025/12/19 11:09:42 SliceLit []int 4 false
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Call 2 0 // func(s []int, x int) int
2025/12/19 11:09:42 ==> MatchFuncCall func(s []int, x int) int args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchType []int, []int
2025/12/19 11:09:42 ==> MatchType untyped int (1), int
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 DefineVarStart [v2]
2025/12/19 11:09:42 Val Index func[T comparable](s []T, x T) int
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 4} *ast.BasicLit
2025/12/19 11:09:42 SliceLit <nil> 4 false
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Call 2 0 // func[T comparable](s []T, x T) int
2025/12/19 11:09:42 ==> MatchFuncCall func[T comparable](s []T, x T) int args: 2 flags: 0
2025/12/19 11:09:42 ==> InferFunc func(s []int, x int) int
2025/12/19 11:09:42 ==> MatchType []int, []int
2025/12/19 11:09:42 ==> MatchType untyped int (1), int
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 DefineVarStart [v3]
2025/12/19 11:09:42 Val Index func[T comparable](s []T, x T) int
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Index 1 false
2025/12/19 11:09:42 ==> InferType func(s []int, x int) int
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 4} *ast.BasicLit
2025/12/19 11:09:42 SliceLit []int 4 false
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Call 2 0 // func(s []int, x int) int
2025/12/19 11:09:42 ==> MatchFuncCall func(s []int, x int) int args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchType []int, []int
2025/12/19 11:09:42 ==> MatchType untyped int (1), int
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 DefineVarStart [v4]
2025/12/19 11:09:42 Val Index func[T comparable](s []T, x T) int
2025/12/19 11:09:42 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 STRING "c"} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 STRING "d"} *ast.BasicLit
2025/12/19 11:09:42 SliceLit <nil> 4 false
2025/12/19 11:09:42 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:42 Call 2 0 // func[T comparable](s []T, x T) int
2025/12/19 11:09:42 ==> MatchFuncCall func[T comparable](s []T, x T) int args: 2 flags: 0
2025/12/19 11:09:42 ==> InferFunc func(s []string, x string) int
2025/12/19 11:09:42 ==> MatchType []string, []string
2025/12/19 11:09:42 ==> MatchType untyped string ("b"), string
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 End // Func
2025/12/19 11:09:42 ==> ASTFile
--- PASS: TestTypeParamsComparable (0.00s)
=== RUN   TestTypeParamsErrorInstantiate
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Preload type Number
2025/12/19 11:09:42 ==> Preload func Sum
2025/12/19 11:09:42 ==> Preload var [SumInt]
2025/12/19 11:09:42 ==> Load > NewType Number
2025/12/19 11:09:42 ==> Load > InitType Number
2025/12/19 11:09:42 ==> Load func main
2025/12/19 11:09:42 NewFunc main func()
2025/12/19 11:09:42 SetComments 0
//line b.xgo:2:1
2025/12/19 11:09:42 ==> Load func Sum
2025/12/19 11:09:42 ==> LookupParent Number => type Number interface{interface{~int | float64}}
2025/12/19 11:09:42 Val Sum func[T Number](vec []T) T
2025/12/19 11:09:42 Val uint uint
2025/12/19 11:09:42 Val type uint => Typ uint
2025/12/19 11:09:42 Index 1 false
2025/12/19 11:09:42 ResetStmt
2025/12/19 11:09:42 End // Func
--- PASS: TestTypeParamsErrorInstantiate (0.00s)
=== RUN   TestTypeParamsErrorMatch
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Preload func At
2025/12/19 11:09:42 ==> Preload var [AtInt]
2025/12/19 11:09:42 ==> Load func main
2025/12/19 11:09:42 NewFunc main func()
2025/12/19 11:09:42 SetComments 0
//line b.xgo:2:1
2025/12/19 11:09:42 VarRef _
2025/12/19 11:09:42 ==> Load func At
2025/12/19 11:09:42 Val At func[T interface{interface{~[]E}}, E interface{}](x T, i int) E
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Index 1 false
2025/12/19 11:09:42 ==> InferType inferFuncType{typ: func[T interface{interface{~[]E}}, E interface{}](x T, i int) E, targs: [int]}
2025/12/19 11:09:42 Assign 1 1
2025/12/19 11:09:42 ResetStmt
2025/12/19 11:09:42 End // Func
--- PASS: TestTypeParamsErrorMatch (0.00s)
=== RUN   TestTypeParamsErrInferFunc
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Preload func Loader
2025/12/19 11:09:42 ==> Load func main
2025/12/19 11:09:42 NewFunc main func()
2025/12/19 11:09:42 SetComments 0
//line b.xgo:2:1
2025/12/19 11:09:42 VarRef _
2025/12/19 11:09:42 ==> Load func Loader
2025/12/19 11:09:42 Val Loader func[T1, T2 interface{}](p1 T1, p2 T2) T1
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Index 1 false
2025/12/19 11:09:42 ==> InferType inferFuncType{typ: func[T1, T2 interface{}](p1 T1, p2 T2) T1, targs: [int]}
2025/12/19 11:09:42 Assign 1 1
2025/12/19 11:09:42 ResetStmt
2025/12/19 11:09:42 End // Func
--- PASS: TestTypeParamsErrInferFunc (0.00s)
=== RUN   TestTypeParamsErrArgumentsParameters1
2025/12/19 11:09:42 ==> Preload var [v]
2025/12/19 11:09:42 ==> Preload type Data
2025/12/19 11:09:42 ==> Load > NewType Data
2025/12/19 11:09:42 ==> Load > InitType Data
2025/12/19 11:09:42 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/12/19 11:09:42 ==> EnsureLoaded Data[T1, T2 interface{}]
2025/12/19 11:09:42 ==> Load var <nil> [v]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [v]
--- PASS: TestTypeParamsErrArgumentsParameters1 (0.00s)
=== RUN   TestTypeParamsErrArgumentsParameters2
2025/12/19 11:09:42 ==> Preload var [v]
2025/12/19 11:09:42 ==> Preload type Data
2025/12/19 11:09:42 ==> Load > NewType Data
2025/12/19 11:09:42 ==> Load > InitType Data
2025/12/19 11:09:42 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/12/19 11:09:42 ==> EnsureLoaded Data[T1, T2 interface{}]
2025/12/19 11:09:42 ==> Load var <nil> [v]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [v]
--- PASS: TestTypeParamsErrArgumentsParameters2 (0.00s)
=== RUN   TestTypeParamsErrArgumentsParameters3
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Preload func Test
2025/12/19 11:09:42 ==> Load func main
2025/12/19 11:09:42 NewFunc main func()
2025/12/19 11:09:42 SetComments 0
//line b.xgo:2:1
2025/12/19 11:09:42 ==> Load func Test
2025/12/19 11:09:42 Val Test func[T1, T2 interface{}](t1 T1, t2 T2)
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Index 3 false
2025/12/19 11:09:42 ResetStmt
2025/12/19 11:09:42 End // Func
--- PASS: TestTypeParamsErrArgumentsParameters3 (0.00s)
=== RUN   TestTypeParamsErrCallArguments1
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Preload func Test
2025/12/19 11:09:42 ==> Load func main
2025/12/19 11:09:42 NewFunc main func()
2025/12/19 11:09:42 SetComments 0
//line b.xgo:2:1
2025/12/19 11:09:42 ==> Load func Test
2025/12/19 11:09:42 Val Test func[T1, T2 interface{}](t1 T1, t2 T2)
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Call 1 0 // func[T1, T2 interface{}](t1 T1, t2 T2)
2025/12/19 11:09:42 ==> MatchFuncCall func[T1, T2 interface{}](t1 T1, t2 T2) args: 1 flags: 0
2025/12/19 11:09:42 ResetStmt
2025/12/19 11:09:42 End // Func
--- PASS: TestTypeParamsErrCallArguments1 (0.00s)
=== RUN   TestTypeParamsErrCallArguments2
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Preload func Test
2025/12/19 11:09:42 ==> Load func main
2025/12/19 11:09:42 NewFunc main func()
2025/12/19 11:09:42 SetComments 0
//line b.xgo:2:1
2025/12/19 11:09:42 ==> Load func Test
2025/12/19 11:09:42 Val Test func[T1, T2 interface{}](t1 T1, t2 T2)
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 Call 3 0 // func[T1, T2 interface{}](t1 T1, t2 T2)
2025/12/19 11:09:42 ==> MatchFuncCall func[T1, T2 interface{}](t1 T1, t2 T2) args: 3 flags: 0
2025/12/19 11:09:42 ResetStmt
2025/12/19 11:09:42 End // Func
--- PASS: TestTypeParamsErrCallArguments2 (0.00s)
=== RUN   TestTypeParamsErrCallArguments3
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Preload func Test
2025/12/19 11:09:42 ==> Load func main
2025/12/19 11:09:42 NewFunc main func()
2025/12/19 11:09:42 SetComments 0
//line b.xgo:2:1
2025/12/19 11:09:42 ==> Load func Test
2025/12/19 11:09:42 Val Test func[T1, T2 interface{}]()
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Call 2 0 // func[T1, T2 interface{}]()
2025/12/19 11:09:42 ==> MatchFuncCall func[T1, T2 interface{}]() args: 2 flags: 0
2025/12/19 11:09:42 ResetStmt
2025/12/19 11:09:42 End // Func
--- PASS: TestTypeParamsErrCallArguments3 (0.00s)
=== RUN   TestTypeParamsErrCallVariadicArguments1
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Preload func Add
2025/12/19 11:09:42 ==> Load func main
2025/12/19 11:09:42 NewFunc main func()
2025/12/19 11:09:42 SetComments 0
//line b.xgo:2:1
2025/12/19 11:09:42 ==> Load func Add
2025/12/19 11:09:42 Val Add func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/12/19 11:09:42 Call 0 0 // func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/12/19 11:09:42 ==> MatchFuncCall func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2) args: 0 flags: 0
2025/12/19 11:09:42 ResetStmt
2025/12/19 11:09:42 End // Func
--- PASS: TestTypeParamsErrCallVariadicArguments1 (0.00s)
=== RUN   TestTypeParamsErrCallVariadicArguments2
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Preload func Add
2025/12/19 11:09:42 ==> Load func main
2025/12/19 11:09:42 NewFunc main func()
2025/12/19 11:09:42 SetComments 0
//line b.xgo:2:1
2025/12/19 11:09:42 ==> Load func Add
2025/12/19 11:09:42 Val Add func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Call 1 0 // func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2)
2025/12/19 11:09:42 ==> MatchFuncCall func[T1 interface{}, T2 interface{~int | ~uint}](v1 T1, v2 ...T2) (sum T2) args: 1 flags: 0
2025/12/19 11:09:42 ResetStmt
2025/12/19 11:09:42 End // Func
--- PASS: TestTypeParamsErrCallVariadicArguments2 (0.00s)
=== RUN   TestTypeParamsRecvTypeError1
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Preload type Data
2025/12/19 11:09:42 ==> Preload method Data.Test
2025/12/19 11:09:42 ==> Load > NewType Data
2025/12/19 11:09:42 ==> Load > InitType Data
2025/12/19 11:09:42 ==> LookupParent Data => type Data[T interface{}] struct{v T}
2025/12/19 11:09:42 ==> Load method *Data[T interface{}].Test
--- PASS: TestTypeParamsRecvTypeError1 (0.00s)
=== RUN   TestTypeParamsRecvTypeError2
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Preload type Data
2025/12/19 11:09:42 ==> Preload method Data.Test
2025/12/19 11:09:42 ==> Load > NewType Data
2025/12/19 11:09:42 ==> Load > InitType Data
2025/12/19 11:09:42 ==> LookupParent Data => type Data[T interface{}] struct{v T}
2025/12/19 11:09:42 ==> Load method *Data[T interface{}].Test
--- PASS: TestTypeParamsRecvTypeError2 (0.00s)
=== RUN   TestTypeParamsRecvTypeError3
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Preload type Data
2025/12/19 11:09:42 ==> Preload method Data.Test
2025/12/19 11:09:42 ==> Load > NewType Data
2025/12/19 11:09:42 ==> Load > InitType Data
2025/12/19 11:09:42 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/12/19 11:09:42 ==> Load method *Data[T1, T2 interface{}].Test
--- PASS: TestTypeParamsRecvTypeError3 (0.00s)
=== RUN   TestGenericTypeWithoutInst1
2025/12/19 11:09:42 ==> Preload var [v]
2025/12/19 11:09:42 ==> Preload type Data
2025/12/19 11:09:42 ==> Preload method Data.Test
2025/12/19 11:09:42 ==> Load > NewType Data
2025/12/19 11:09:42 ==> Load > InitType Data
2025/12/19 11:09:42 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/12/19 11:09:42 ==> Load method *Data[T1, T2 interface{}].Test
--- PASS: TestGenericTypeWithoutInst1 (0.00s)
=== RUN   TestGenericTypeWithoutInst2
2025/12/19 11:09:42 ==> Preload var [v]
2025/12/19 11:09:42 ==> Preload type Data
2025/12/19 11:09:42 ==> Preload type My
2025/12/19 11:09:42 ==> Load > NewType Data
2025/12/19 11:09:42 ==> Load > InitType Data
2025/12/19 11:09:42 ==> Load > NewType My
2025/12/19 11:09:42 ==> Load > InitType My
2025/12/19 11:09:42 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/12/19 11:09:42 ==> LookupParent My => type My[T interface{}] struct{invalid type}
2025/12/19 11:09:42 ==> EnsureLoaded My[T interface{}]
2025/12/19 11:09:42 ==> Load var My[int] [v]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [v]
--- PASS: TestGenericTypeWithoutInst2 (0.00s)
=== RUN   TestGenericTypeWithoutInst3
2025/12/19 11:09:42 ==> Preload var [v]
2025/12/19 11:09:42 ==> Preload type Data
2025/12/19 11:09:42 ==> Preload type My
2025/12/19 11:09:42 ==> Load > NewType Data
2025/12/19 11:09:42 ==> Load > InitType Data
2025/12/19 11:09:42 ==> Load > NewType My
2025/12/19 11:09:42 ==> Load > InitType My
2025/12/19 11:09:42 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/12/19 11:09:42 ==> LookupParent My => type My struct{invalid type}
2025/12/19 11:09:42 ==> Load var My [v]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [v]
--- PASS: TestGenericTypeWithoutInst3 (0.00s)
=== RUN   TestGenericTypeWithoutInst4
2025/12/19 11:09:42 ==> Preload var [v]
2025/12/19 11:09:42 ==> Preload type Data
2025/12/19 11:09:42 ==> Preload type My
2025/12/19 11:09:42 ==> Load > NewType Data
2025/12/19 11:09:42 ==> Load > InitType Data
2025/12/19 11:09:42 ==> Load > NewType My
2025/12/19 11:09:42 ==> Load > InitType My
2025/12/19 11:09:42 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/12/19 11:09:42 ==> LookupParent My => type My struct{v map[string]invalid type}
2025/12/19 11:09:42 ==> Load var My [v]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [v]
--- PASS: TestGenericTypeWithoutInst4 (0.00s)
=== RUN   TestGenericTypeWithoutInst5
2025/12/19 11:09:42 ==> Preload var [v]
2025/12/19 11:09:42 ==> Preload type Data
2025/12/19 11:09:42 ==> Load > NewType Data
2025/12/19 11:09:42 ==> Load > InitType Data
2025/12/19 11:09:42 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/12/19 11:09:42 ==> Load var invalid type [v]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [v]
--- PASS: TestGenericTypeWithoutInst5 (0.00s)
=== RUN   TestGenericTypeWithoutInst6
2025/12/19 11:09:42 ==> Preload type T
2025/12/19 11:09:42 ==> Preload type Data
2025/12/19 11:09:42 ==> Load > NewType Data
2025/12/19 11:09:42 ==> Load > InitType Data
2025/12/19 11:09:42 ==> Load > NewType T
2025/12/19 11:09:42 NewType T
2025/12/19 11:09:42 ==> Load > InitType T
2025/12/19 11:09:42 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/12/19 11:09:42 InitType T invalid type
--- PASS: TestGenericTypeWithoutInst6 (0.00s)
=== RUN   TestGenericTypeWithoutInst7
2025/12/19 11:09:42 ==> Preload type My
2025/12/19 11:09:42 ==> Preload type Data
2025/12/19 11:09:42 ==> Load > NewType Data
2025/12/19 11:09:42 ==> Load > InitType Data
2025/12/19 11:09:42 ==> Load > NewType My
2025/12/19 11:09:42 NewType My
2025/12/19 11:09:42 ==> Load > InitType My
2025/12/19 11:09:42 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/12/19 11:09:42 InitType My struct{invalid type}
--- PASS: TestGenericTypeWithoutInst7 (0.00s)
=== RUN   TestGenericTypeWithoutInst8
2025/12/19 11:09:42 ==> Preload func test
2025/12/19 11:09:42 ==> Preload type Data
2025/12/19 11:09:42 ==> Load > NewType Data
2025/12/19 11:09:42 ==> Load > InitType Data
2025/12/19 11:09:42 ==> Load func test
2025/12/19 11:09:42 ==> LookupParent Data => type Data[T1, T2 interface{}] struct{v1 T1; v2 T2}
2025/12/19 11:09:42 NewFunc test func(v1 int, v2 *invalid type)
2025/12/19 11:09:42 End // Func
--- PASS: TestGenericTypeWithoutInst8 (0.00s)
=== RUN   TestGenericTypeCompositeLit
2025/12/19 11:09:42 ==> Preload var [a]
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Preload type A
2025/12/19 11:09:42 ==> Preload type B
2025/12/19 11:09:42 ==> Load > NewType A
2025/12/19 11:09:42 ==> Load > InitType A
2025/12/19 11:09:42 ==> Load > NewType B
2025/12/19 11:09:42 ==> Load > InitType B
2025/12/19 11:09:42 ==> LookupParent A => type github.com/goplus/xgo/cl.A[T interface{}] struct{m T}
2025/12/19 11:09:42 ==> EnsureLoaded github.com/goplus/xgo/cl.A[T interface{}]
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 ==> Load var [2]int [a]
2025/12/19 11:09:42 NewVarDefs
2025/12/19 11:09:42 NewVar [a]
2025/12/19 11:09:42 ==> Load func main
2025/12/19 11:09:42 NewFunc main func()
2025/12/19 11:09:42 If
2025/12/19 11:09:42 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:42 Val a [2]int
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Index 1 false
2025/12/19 11:09:42 BinaryOp ==
2025/12/19 11:09:42 Then
2025/12/19 11:09:42 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 Val &{0 STRING "world"} *ast.BasicLit
2025/12/19 11:09:42 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchType untyped string ("world"), any
2025/12/19 11:09:42 End // If
2025/12/19 11:09:42 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> LookupParent B => type github.com/goplus/xgo/cl.B[T interface{}] struct{n github.com/goplus/xgo/cl.A[T]}
2025/12/19 11:09:42 ==> EnsureLoaded github.com/goplus/xgo/cl.B[T interface{}]
2025/12/19 11:09:42 StructLit github.com/goplus/xgo/cl.B[int] 0 false
2025/12/19 11:09:42 Member n 2 // github.com/goplus/xgo/cl.B[int]
2025/12/19 11:09:42 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchType github.com/goplus/xgo/cl.A[int], any
2025/12/19 11:09:42 ==> EnsureLoaded github.com/goplus/xgo/cl.A[int]
2025/12/19 11:09:42 If
2025/12/19 11:09:42 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:42 ==> LookupParent B => type github.com/goplus/xgo/cl.B[T interface{}] struct{n github.com/goplus/xgo/cl.A[T]}
2025/12/19 11:09:42 ==> EnsureLoaded github.com/goplus/xgo/cl.B[T interface{}]
2025/12/19 11:09:42 StructLit github.com/goplus/xgo/cl.B[int] 0 false
2025/12/19 11:09:42 Member n 2 // github.com/goplus/xgo/cl.B[int]
2025/12/19 11:09:42 Member m 2 // github.com/goplus/xgo/cl.A[int]
2025/12/19 11:09:42 BinaryOp <
2025/12/19 11:09:42 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchType untyped int (0), unboundFuncParam{typ: <nil>}
2025/12/19 11:09:42 ==> MatchType int, unboundFuncParam{typ: untyped int}
2025/12/19 11:09:42 Then
2025/12/19 11:09:42 End // If
2025/12/19 11:09:42 End // Func
2025/12/19 11:09:42 ==> ASTFile
--- PASS: TestGenericTypeCompositeLit (0.00s)
=== RUN   TestInferFuncLambda
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Preload func ListMap
2025/12/19 11:09:42 ==> Load func main
2025/12/19 11:09:42 NewFunc main func()
2025/12/19 11:09:42 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> Load func ListMap
2025/12/19 11:09:42 Val ListMap func[T interface{}](ar []T, fn func(v T) T) []T
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 4} *ast.BasicLit
2025/12/19 11:09:42 SliceLit <nil> 4 false
2025/12/19 11:09:42 Val nil untyped nil
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 4} *ast.BasicLit
2025/12/19 11:09:42 SliceLit []int 4 false
2025/12/19 11:09:42 NewClosure func(x int) int
2025/12/19 11:09:42 Val x int
2025/12/19 11:09:42 Val x int
2025/12/19 11:09:42 BinaryOp *
2025/12/19 11:09:42 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:42 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:42 Return 1
2025/12/19 11:09:42 ==> MatchType int, int
2025/12/19 11:09:42 End // Func
2025/12/19 11:09:42 Call 2 0 // func[T interface{}](ar []T, fn func(v T) T) []T
2025/12/19 11:09:42 ==> MatchFuncCall func[T interface{}](ar []T, fn func(v T) T) []T args: 2 flags: 0
2025/12/19 11:09:42 ==> InferFunc func(ar []int, fn func(v int) int) []int
2025/12/19 11:09:42 ==> MatchType []int, []int
2025/12/19 11:09:42 ==> MatchType func(x int) int, func(v int) int
2025/12/19 11:09:42 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchType []int, any
2025/12/19 11:09:42 Val ListMap func[T interface{}](ar []T, fn func(v T) T) []T
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 4} *ast.BasicLit
2025/12/19 11:09:42 SliceLit <nil> 4 false
2025/12/19 11:09:42 Val nil untyped nil
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 4} *ast.BasicLit
2025/12/19 11:09:42 SliceLit []int 4 false
2025/12/19 11:09:42 NewClosure func(x int) int
2025/12/19 11:09:42 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 Val x int
2025/12/19 11:09:42 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchType int, any
2025/12/19 11:09:42 Val x int
2025/12/19 11:09:42 Return 1
2025/12/19 11:09:42 ==> MatchType int, int
2025/12/19 11:09:42 End // Func
2025/12/19 11:09:42 Call 2 0 // func[T interface{}](ar []T, fn func(v T) T) []T
2025/12/19 11:09:42 ==> MatchFuncCall func[T interface{}](ar []T, fn func(v T) T) []T args: 2 flags: 0
2025/12/19 11:09:42 ==> InferFunc func(ar []int, fn func(v int) int) []int
2025/12/19 11:09:42 ==> MatchType []int, []int
2025/12/19 11:09:42 ==> MatchType func(x int) int, func(v int) int
2025/12/19 11:09:42 End // Func
2025/12/19 11:09:42 ==> ASTFile
--- PASS: TestInferFuncLambda (0.00s)
=== RUN   TestInferOverloadFuncLambda
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Preload func ListMap__0
2025/12/19 11:09:42 ==> Preload func ListMap__1
2025/12/19 11:09:42 ==> Load func ListMap__0
2025/12/19 11:09:42 ==> Load func ListMap__1
2025/12/19 11:09:42 ==> NewOverloadFunc ListMap
2025/12/19 11:09:42 ==> Load func main
2025/12/19 11:09:42 NewFunc main func()
2025/12/19 11:09:42 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 Val ListMap func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 4} *ast.BasicLit
2025/12/19 11:09:42 SliceLit <nil> 4 false
2025/12/19 11:09:42 Val nil untyped nil
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 4} *ast.BasicLit
2025/12/19 11:09:42 SliceLit []int 4 false
2025/12/19 11:09:42 NewClosure func(x int) int
2025/12/19 11:09:42 Val x int
2025/12/19 11:09:42 Val x int
2025/12/19 11:09:42 BinaryOp *
2025/12/19 11:09:42 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:42 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:42 Return 1
2025/12/19 11:09:42 ==> MatchType int, int
2025/12/19 11:09:42 End // Func
2025/12/19 11:09:42 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func[T interface{}](ar []T, fn func(v T) T) []T args: 2 flags: 0
2025/12/19 11:09:42 ==> InferFunc func(ar []int, fn func(v int) int) []int
2025/12/19 11:09:42 ==> MatchType []int, []int
2025/12/19 11:09:42 ==> MatchType func(x int) int, func(v int) int
2025/12/19 11:09:42 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchType []int, any
2025/12/19 11:09:42 Val ListMap func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 4} *ast.BasicLit
2025/12/19 11:09:42 SliceLit <nil> 4 false
2025/12/19 11:09:42 Val nil untyped nil
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 4} *ast.BasicLit
2025/12/19 11:09:42 SliceLit []int 4 false
2025/12/19 11:09:42 NewClosure func(x int) int
2025/12/19 11:09:42 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 Val x int
2025/12/19 11:09:42 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchType int, any
2025/12/19 11:09:42 Val x int
2025/12/19 11:09:42 Return 1
2025/12/19 11:09:42 ==> MatchType int, int
2025/12/19 11:09:42 End // Func
2025/12/19 11:09:42 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func[T interface{}](ar []T, fn func(v T) T) []T args: 2 flags: 0
2025/12/19 11:09:42 ==> InferFunc func(ar []int, fn func(v int) int) []int
2025/12/19 11:09:42 ==> MatchType []int, []int
2025/12/19 11:09:42 ==> MatchType func(x int) int, func(v int) int
2025/12/19 11:09:42 Val ListMap func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:42 Val nil untyped nil
2025/12/19 11:09:42 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:42 NewClosure func(x string)
2025/12/19 11:09:42 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 Val x string
2025/12/19 11:09:42 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchType string, any
2025/12/19 11:09:42 End // Func
2025/12/19 11:09:42 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func[T interface{}](ar []T, fn func(v T) T) []T args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func(a string, fn func(s string)) args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:42 ==> MatchType func(x string), func(s string)
2025/12/19 11:09:42 End // Func
2025/12/19 11:09:42 ==> ASTFile
--- PASS: TestInferOverloadFuncLambda (0.00s)
=== RUN   TestGenericFuncAlias
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Load func main
2025/12/19 11:09:42 NewFunc main func()
2025/12/19 11:09:42 Val Test func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:42 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func() args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func[N any](n N) args: 1 flags: 0
2025/12/19 11:09:42 ==> InferFunc func(n int)
2025/12/19 11:09:42 ==> MatchType untyped int (100), int
2025/12/19 11:09:42 Val Test func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:42 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func() args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func[N any](n N) args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func[N1, N2 any](n1 N1, n2 N2) args: 2 flags: 0
2025/12/19 11:09:42 ==> InferFunc func(n1 string, n2 int)
2025/12/19 11:09:42 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:42 ==> MatchType untyped int (100), int
2025/12/19 11:09:42 Val Test__1 func[N any](n N)
2025/12/19 11:09:42 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:42 Call 1 0 // func[N any](n N)
2025/12/19 11:09:42 ==> MatchFuncCall func[N any](n N) args: 1 flags: 0
2025/12/19 11:09:42 ==> InferFunc func(n int)
2025/12/19 11:09:42 ==> MatchType untyped int (100), int
2025/12/19 11:09:42 Val Test__1 func[N any](n N)
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Index 1 false
2025/12/19 11:09:42 ==> InferType func(n int)
2025/12/19 11:09:42 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:42 Call 1 0 // func(n int)
2025/12/19 11:09:42 ==> MatchFuncCall func(n int) args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchType untyped int (100), int
2025/12/19 11:09:42 Val Test__2 func[N1, N2 any](n1 N1, n2 N2)
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val true untyped bool
2025/12/19 11:09:42 Call 2 0 // func[N1, N2 any](n1 N1, n2 N2)
2025/12/19 11:09:42 ==> MatchFuncCall func[N1, N2 any](n1 N1, n2 N2) args: 2 flags: 0
2025/12/19 11:09:42 ==> InferFunc func(n1 int, n2 bool)
2025/12/19 11:09:42 ==> MatchType untyped int (1), int
2025/12/19 11:09:42 ==> MatchType untyped bool (true), bool
2025/12/19 11:09:42 Val Test__2 func[N1, N2 any](n1 N1, n2 N2)
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Val string string
2025/12/19 11:09:42 Val type string => Typ string
2025/12/19 11:09:42 Index 2 false
2025/12/19 11:09:42 ==> InferType func(n1 int, n2 string)
2025/12/19 11:09:42 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:42 Call 2 0 // func(n1 int, n2 string)
2025/12/19 11:09:42 ==> MatchFuncCall func(n1 int, n2 string) args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchType untyped int (1), int
2025/12/19 11:09:42 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:42 End // Func
2025/12/19 11:09:42 ==> ASTFile
--- PASS: TestGenericFuncAlias (0.00s)
=== RUN   TestGoptLambdaFunc
2025/12/19 11:09:42 ==> Preload type Message
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Load > NewType Message
2025/12/19 11:09:42 NewType Message
2025/12/19 11:09:42 ==> Load > InitType Message
2025/12/19 11:09:42 InitType Message struct{info string}
2025/12/19 11:09:42 ==> Load func main
2025/12/19 11:09:42 NewFunc main func()
2025/12/19 11:09:42 DefineVarStart [p]
2025/12/19 11:09:42 StructLit github.com/goplus/xgo/cl/internal/overload/bar.Player 0 false
2025/12/19 11:09:42 UnaryOp & flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 Val p *github.com/goplus/xgo/cl/internal/overload/bar.Player
2025/12/19 11:09:42 Member onCmd 1 // *github.com/goplus/xgo/cl/internal/overload/bar.Player
2025/12/19 11:09:42 Val Message github.com/goplus/xgo/cl.Message
2025/12/19 11:09:42 Val type github.com/goplus/xgo/cl.Message struct{info string} => Typ github.com/goplus/xgo/cl.Message
2025/12/19 11:09:42 NewClosure func(msg github.com/goplus/xgo/cl.Message) error
2025/12/19 11:09:42 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 Val msg github.com/goplus/xgo/cl.Message
2025/12/19 11:09:42 Member info 2 // github.com/goplus/xgo/cl.Message
2025/12/19 11:09:42 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:42 ==> MatchType string, any
2025/12/19 11:09:42 Val nil untyped nil
2025/12/19 11:09:42 Return 1
2025/12/19 11:09:42 ==> MatchType untyped nil, error
2025/12/19 11:09:42 ==> EnsureLoaded error
2025/12/19 11:09:42 End // Func
2025/12/19 11:09:42 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> MatchFuncCall TyTypeAsParams args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall TyTemplateRecvMethod args: 2 flags: 8
2025/12/19 11:09:42 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 24
2025/12/19 11:09:42 ==> MatchFuncCall func[T any](p *github.com/goplus/xgo/cl/internal/overload/bar.Player, handler func(cmd T) error) args: 3 flags: 24
2025/12/19 11:09:42 boundTypeParams: bar.Gopt_Player_Gopx_OnCmd__0 sig: func[T any](p *github.com/goplus/xgo/cl/internal/overload/bar.Player, handler func(cmd T) error) args: 3 flags: 24
2025/12/19 11:09:42 ==> MatchType *github.com/goplus/xgo/cl/internal/overload/bar.Player, *github.com/goplus/xgo/cl/internal/overload/bar.Player
2025/12/19 11:09:42 ==> MatchType func(msg github.com/goplus/xgo/cl.Message) error, func(cmd github.com/goplus/xgo/cl.Message) error
2025/12/19 11:09:42 Val p *github.com/goplus/xgo/cl/internal/overload/bar.Player
2025/12/19 11:09:42 Member onCmd 1 // *github.com/goplus/xgo/cl/internal/overload/bar.Player
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Val Message github.com/goplus/xgo/cl.Message
2025/12/19 11:09:42 Val type github.com/goplus/xgo/cl.Message struct{info string} => Typ github.com/goplus/xgo/cl.Message
2025/12/19 11:09:42 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:42 Val int int
2025/12/19 11:09:42 Val type int => Typ int
2025/12/19 11:09:42 Val Message github.com/goplus/xgo/cl.Message
2025/12/19 11:09:42 Val type github.com/goplus/xgo/cl.Message struct{info string} => Typ github.com/goplus/xgo/cl.Message
2025/12/19 11:09:42 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:42 NewClosure func(n int, msg github.com/goplus/xgo/cl.Message) error
2025/12/19 11:09:42 Val echo func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 Val n int
2025/12/19 11:09:42 Val msg github.com/goplus/xgo/cl.Message
2025/12/19 11:09:42 Member info 2 // github.com/goplus/xgo/cl.Message
2025/12/19 11:09:42 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchType int, any
2025/12/19 11:09:42 ==> MatchType string, any
2025/12/19 11:09:42 Val nil untyped nil
2025/12/19 11:09:42 Return 1
2025/12/19 11:09:42 ==> MatchType untyped nil, error
2025/12/19 11:09:42 ==> EnsureLoaded error
2025/12/19 11:09:42 End // Func
2025/12/19 11:09:42 Call 4 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:42 ==> MatchFuncCall TyTypeAsParams args: 4 flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall TyTemplateRecvMethod args: 4 flags: 8
2025/12/19 11:09:42 ==> MatchFuncCall TyOverloadFunc args: 5 flags: 24
2025/12/19 11:09:42 ==> MatchFuncCall func[T any](p *github.com/goplus/xgo/cl/internal/overload/bar.Player, handler func(cmd T) error) args: 5 flags: 24
2025/12/19 11:09:42 boundTypeParams: bar.Gopt_Player_Gopx_OnCmd__0 sig: func[T any](p *github.com/goplus/xgo/cl/internal/overload/bar.Player, handler func(cmd T) error) args: 5 flags: 24
2025/12/19 11:09:42 ==> MatchFuncCall func[T1 ~int, T2 any](p *github.com/goplus/xgo/cl/internal/overload/bar.Player, n T1, handler func(n T1, cmd T2) error) args: 5 flags: 24
2025/12/19 11:09:42 boundTypeParams: bar.Gopt_Player_Gopx_OnCmd__1 sig: func[T1 ~int, T2 any](p *github.com/goplus/xgo/cl/internal/overload/bar.Player, n T1, handler func(n T1, cmd T2) error) args: 5 flags: 24
2025/12/19 11:09:42 ==> MatchType *github.com/goplus/xgo/cl/internal/overload/bar.Player, *github.com/goplus/xgo/cl/internal/overload/bar.Player
2025/12/19 11:09:42 ==> MatchType untyped int (100), int
2025/12/19 11:09:42 ==> MatchType func(n int, msg github.com/goplus/xgo/cl.Message) error, func(n int, cmd github.com/goplus/xgo/cl.Message) error
2025/12/19 11:09:42 End // Func
2025/12/19 11:09:42 ==> ASTFile
--- PASS: TestGoptLambdaFunc (0.00s)
=== RUN   TestGoptLambdaError
2025/12/19 11:09:42 ==> Preload type Message
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Load > NewType Message
2025/12/19 11:09:42 NewType Message
2025/12/19 11:09:42 ==> Load > InitType Message
2025/12/19 11:09:42 InitType Message struct{info string}
2025/12/19 11:09:42 ==> Load func main
2025/12/19 11:09:42 NewFunc main func()
2025/12/19 11:09:42 SetComments 0
//line bar.xgo:7:1
2025/12/19 11:09:42 DefineVarStart [p]
2025/12/19 11:09:42 StructLit github.com/goplus/xgo/cl/internal/overload/bar.Player 0 false
2025/12/19 11:09:42 UnaryOp & flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 SetComments 0
//line bar.xgo:8:1
2025/12/19 11:09:42 Val p *github.com/goplus/xgo/cl/internal/overload/bar.Player
2025/12/19 11:09:42 Member onCmd 1 // *github.com/goplus/xgo/cl/internal/overload/bar.Player
2025/12/19 11:09:42 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:42 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:42 Val Message Message
2025/12/19 11:09:42 Val type Message struct{info string} => Typ Message
2025/12/19 11:09:42 ResetStmt
2025/12/19 11:09:42 End // Func
2025/12/19 11:09:42 ==> Preload type Message
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Load > NewType Message
2025/12/19 11:09:42 NewType Message
2025/12/19 11:09:42 ==> Load > InitType Message
2025/12/19 11:09:42 InitType Message struct{info string}
2025/12/19 11:09:42 ==> Load func main
2025/12/19 11:09:42 NewFunc main func()
2025/12/19 11:09:42 SetComments 0
//line bar.xgo:7:1
2025/12/19 11:09:42 DefineVarStart [p]
2025/12/19 11:09:42 StructLit github.com/goplus/xgo/cl/internal/overload/bar.Player 0 false
2025/12/19 11:09:42 UnaryOp & flags: 0
2025/12/19 11:09:42 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:42 EndInit 1
2025/12/19 11:09:42 SetComments 0
//line bar.xgo:8:1
2025/12/19 11:09:42 Val p *github.com/goplus/xgo/cl/internal/overload/bar.Player
2025/12/19 11:09:42 Member onCmd 1 // *github.com/goplus/xgo/cl/internal/overload/bar.Player
2025/12/19 11:09:42 Val string string
2025/12/19 11:09:42 Val type string => Typ string
2025/12/19 11:09:42 Val Message Message
2025/12/19 11:09:42 Val type Message struct{info string} => Typ Message
2025/12/19 11:09:42 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:42 Val string string
2025/12/19 11:09:42 Val type string => Typ string
2025/12/19 11:09:42 Val Message Message
2025/12/19 11:09:42 Val type Message struct{info string} => Typ Message
2025/12/19 11:09:42 ResetStmt
2025/12/19 11:09:42 End // Func
--- PASS: TestGoptLambdaError (0.00s)
=== RUN   TestAliasTypeparams
    typeparams_test.go:850:
--- SKIP: TestAliasTypeparams (0.00s)
PASS
coverage: 74.1% of statements
ok  	github.com/goplus/xgo/cl	20.859s	coverage: 74.1% of statements
=== RUN   TestTypeAndValue
--- PASS: TestTypeAndValue (0.00s)
PASS
coverage: 100.0% of statements
ok  	github.com/goplus/xgo/cl/internal/typesutil	0.008s	coverage: 100.0% of statements
=== RUN   TestToIndex
--- PASS: TestToIndex (0.00s)
=== RUN   TestCheckTypeMethod
--- PASS: TestCheckTypeMethod (0.00s)
=== RUN   TestIsGopPackage
--- PASS: TestIsGopPackage (0.00s)
=== RUN   TestDocRecv
--- PASS: TestDocRecv (0.00s)
=== RUN   TestFromTestdata
=== RUN   TestFromTestdata/gopoFn
=== RUN   TestFromTestdata/gopoMethod
=== RUN   TestFromTestdata/overloadFn
=== RUN   TestFromTestdata/overloadMethod
--- PASS: TestFromTestdata (0.00s)
    --- PASS: TestFromTestdata/gopoFn (0.00s)
    --- PASS: TestFromTestdata/gopoMethod (0.00s)
    --- PASS: TestFromTestdata/overloadFn (0.00s)
    --- PASS: TestFromTestdata/overloadMethod (0.00s)
PASS
coverage: 100.0% of statements
ok  	github.com/goplus/xgo/doc	0.013s	coverage: 100.0% of statements
=== RUN   TestBasic
--- PASS: TestBasic (0.00s)
=== RUN   TestFindGoModFileInGoModDir
=== RUN   TestFindGoModFileInGoModDir/the_src/_is_a_valid_mod_dir
=== RUN   TestFindGoModFileInGoModDir/the_src/_is_not_a_valid_mod_dir
--- PASS: TestFindGoModFileInGoModDir (0.00s)
    --- PASS: TestFindGoModFileInGoModDir/the_src/_is_a_valid_mod_dir (0.00s)
    --- PASS: TestFindGoModFileInGoModDir/the_src/_is_not_a_valid_mod_dir (0.00s)
=== RUN   TestFindGoModFileInGopRoot
=== RUN   TestFindGoModFileInGopRoot/without_xgo_root
=== RUN   TestFindGoModFileInGopRoot/set_XGOROOT_to_a_valid_xgoroot_path
=== RUN   TestFindGoModFileInGopRoot/set_XGOROOT_to_an_invalid_xgoroot_path
2025/12/19 11:09:23
XGOROOT (/tmp/TestFindGoModFileInGopRootset_XGOROOT_to_an_invalid_xgoroot_path1108368534/001/invalid_xgoroot) is not valid
=== RUN   TestFindGoModFileInGopRoot/set_defaultXGoRoot_to_a_valid_xgoroot_path
=== RUN   TestFindGoModFileInGopRoot/set_defaultXGoRoot_to_an_invalid_path
=== RUN   TestFindGoModFileInGopRoot/use_$HOME/xgo
=== RUN   TestFindGoModFileInGopRoot/check_if_parent_dir_of_the_executable_is_valid_gop_root
=== RUN   TestFindGoModFileInGopRoot/test_xgo_root_priority
=== RUN   TestFindGoModFileInGopRoot/test_xgo_root_priority/without_xgo_root
=== RUN   TestFindGoModFileInGopRoot/test_xgo_root_priority/set_defaultXGoRoot_to_a_valid_xgo_root_dir
=== RUN   TestFindGoModFileInGopRoot/test_xgo_root_priority/the_executable's_parent_dir_is_a_valid_xgo_root_dir
=== RUN   TestFindGoModFileInGopRoot/test_xgo_root_priority/set_XGOROOT_to_an_invalid_xgo_root_dir
2025/12/19 11:09:23
XGOROOT (/tmp/TestFindGoModFileInGopRoottest_xgo_root_priority188839131/001/new_xgo_root3) is not valid
=== RUN   TestFindGoModFileInGopRoot/test_xgo_root_priority/set_XGOROOT_to_a_valid_xgo_root_dir
--- PASS: TestFindGoModFileInGopRoot (0.01s)
    --- PASS: TestFindGoModFileInGopRoot/without_xgo_root (0.00s)
    --- PASS: TestFindGoModFileInGopRoot/set_XGOROOT_to_a_valid_xgoroot_path (0.00s)
    --- PASS: TestFindGoModFileInGopRoot/set_XGOROOT_to_an_invalid_xgoroot_path (0.00s)
    --- PASS: TestFindGoModFileInGopRoot/set_defaultXGoRoot_to_a_valid_xgoroot_path (0.00s)
    --- PASS: TestFindGoModFileInGopRoot/set_defaultXGoRoot_to_an_invalid_path (0.00s)
    --- PASS: TestFindGoModFileInGopRoot/use_$HOME/xgo (0.00s)
    --- PASS: TestFindGoModFileInGopRoot/check_if_parent_dir_of_the_executable_is_valid_gop_root (0.00s)
    --- PASS: TestFindGoModFileInGopRoot/test_xgo_root_priority (0.00s)
        --- PASS: TestFindGoModFileInGopRoot/test_xgo_root_priority/without_xgo_root (0.00s)
        --- PASS: TestFindGoModFileInGopRoot/test_xgo_root_priority/set_defaultXGoRoot_to_a_valid_xgo_root_dir (0.00s)
        --- PASS: TestFindGoModFileInGopRoot/test_xgo_root_priority/the_executable's_parent_dir_is_a_valid_xgo_root_dir (0.00s)
        --- PASS: TestFindGoModFileInGopRoot/test_xgo_root_priority/set_XGOROOT_to_an_invalid_xgo_root_dir (0.00s)
        --- PASS: TestFindGoModFileInGopRoot/test_xgo_root_priority/set_XGOROOT_to_a_valid_xgo_root_dir (0.00s)
=== RUN   TestPanic
=== RUN   TestPanic/initEnvPanic
=== RUN   TestPanic/XGOROOT_panic
2025/12/19 11:09:23 XGOROOT not found: no such file or directory
--- PASS: TestPanic (0.00s)
    --- PASS: TestPanic/initEnvPanic (0.00s)
    --- PASS: TestPanic/XGOROOT_panic (0.00s)
=== RUN   TestEnv
--- PASS: TestEnv (0.00s)
PASS
coverage: 100.0% of statements
ok  	github.com/goplus/xgo/env	0.025s	coverage: 100.0% of statements
=== RUN   TestSeekAfter
--- PASS: TestSeekAfter (0.00s)
=== RUN   TestTokOf
--- PASS: TestTokOf (0.00s)
=== RUN   TestSplitStmts
=== RUN   TestSplitStmts/basic
2025/12/19 11:09:23 Parsing /app/format/formatutil/_testdata/splitstmts/basic
--- PASS: TestSplitStmts (0.00s)
    --- PASS: TestSplitStmts/basic (0.00s)
=== RUN   TestRearrangeFuncs
=== RUN   TestRearrangeFuncs/noeol
2025/12/19 11:09:23 Parsing /app/format/formatutil/_testdata/rearrange/noeol
=== RUN   TestRearrangeFuncs/nondecl
2025/12/19 11:09:23 Parsing /app/format/formatutil/_testdata/rearrange/nondecl
--- PASS: TestRearrangeFuncs (0.00s)
    --- PASS: TestRearrangeFuncs/noeol (0.00s)
    --- PASS: TestRearrangeFuncs/nondecl (0.00s)
=== RUN   TestFormat
=== RUN   TestFormat/basic
2025/12/19 11:09:23 Parsing /app/format/formatutil/_testdata/format/basic
=== RUN   TestFormat/nondecl
2025/12/19 11:09:23 Parsing /app/format/formatutil/_testdata/format/nondecl
--- PASS: TestFormat (0.00s)
    --- PASS: TestFormat/basic (0.00s)
    --- PASS: TestFormat/nondecl (0.00s)
PASS
coverage: 17.1% of statements
ok  	github.com/goplus/xgo/format/formatutil	0.023s	coverage: 17.1% of statements
=== RUN   TestFilter
--- PASS: TestFilter (0.00s)
=== RUN   TestAssert
--- PASS: TestAssert (0.00s)
=== RUN   TestErrLabel
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:3615: expected ';', found 'EOF'
--- PASS: TestErrLabel (0.00s)
=== RUN   TestErrTplLit
 /app/parser/parser.go:713: ast.Ident{Name: tpl}
 /app/parser/parser.go:1830: ast.DomainTextLit{Domain: tpl, Value: `a =`}
--- PASS: TestErrTplLit (0.00s)
=== RUN   TestErrTuple
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:3615: expected ';', found 'EOF'
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
 /app/parser/parser.go:1895: expected ')', found ','
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{12 INT 1 <nil>}}
 /app/parser/parser.go:2147: missing ',' in argument list
 /app/parser/parser.go:1945: expected operand, found ')'
 /app/parser/parser.go:2147: missing ',' in argument list
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:3615: expected ';', found 'EOF'
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
 /app/parser/parser.go:3009: expected ';', found 'EOF'
 /app/parser/parser.go:1635: expected '}', found 'EOF'
 /app/parser/parser.go:4050: expected ';', found 'EOF'
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
--- PASS: TestErrTuple (0.00s)
=== RUN   TestErrOperand
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:1945: expected operand, found 'EOF'
 /app/parser/parser.go:3615: expected ';', found 'EOF'
--- PASS: TestErrOperand (0.00s)
=== RUN   TestErrMissingComma
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:713: ast.Ident{Name: b}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:4088: ast.FuncDecl{Name: a, ...}
--- PASS: TestErrMissingComma (0.00s)
=== RUN   TestErrLambda
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "hello"}
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "lambda"}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:3457: expected 'IDENT', found "hello"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: test, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "hello"}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "x"}
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "lambda"}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:3457: expected 'IDENT', found "x"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: test, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "hello"}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "x"}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{54 STRING "x" <nil>}}
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "lambda"}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:3457: expected 'IDENT', found "x"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: test, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "hello"}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "y"}
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "lambda"}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:713: ast.Ident{Name: y}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:3457: expected 'IDENT', found "y"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: test, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:713: ast.Ident{Name: onTouchStart}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "someone"}
 /app/parser/parser.go:713: ast.Ident{Name: say}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "touched by someone"}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: say, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:3457: expected 'IDENT', found "someone"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: onTouchStart, Ellipsis: false, isCmd: true}
--- PASS: TestErrLambda (0.00s)
=== RUN   TestErrTooManyParseExpr
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:710: expected 'IDENT', found 'var'
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3777: expected ';', found 'var'
 /app/parser/parser.go:710: expected 'IDENT', found 'var'
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3777: expected ';', found 'var'
 /app/parser/parser.go:710: expected 'IDENT', found 'var'
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3777: expected ';', found 'var'
 /app/parser/parser.go:710: expected 'IDENT', found 'var'
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3777: expected ';', found 'var'
--- PASS: TestErrTooManyParseExpr (0.00s)
=== RUN   TestErrTooMany
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:710: expected 'IDENT', found '}'
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:1340: expected '(', found g
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 'var'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found newline
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:1340: expected '(', found h
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 'var'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found newline
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:1340: expected '(', found h
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 'var'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found newline
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:1340: expected '(', found h
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 'var'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found newline
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:1340: expected '(', found h
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 'var'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found newline
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:1340: expected '(', found h
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 'var'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found newline
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:1340: expected '(', found h
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 'var'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found newline
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:1340: expected '(', found h
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 'var'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found newline
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:1340: expected '(', found h
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 'var'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found newline
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:1340: expected '(', found h
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 'var'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found newline
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:1340: expected '(', found h
--- PASS: TestErrTooMany (0.00s)
=== RUN   TestErrInFunc
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:1945: expected operand, found '}'
 /app/parser/parser.go:2897: expected 1 expression
 /app/parser/parser.go:3615: expected ';', found 'EOF'
 /app/parser/parser.go:1635: expected '}', found 'EOF'
 /app/parser/parser.go:4050: expected ';', found 'EOF'
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:1945: expected operand, found '=>'
 /app/parser/parser.go:2897: expected 1 expression
 /app/parser/parser.go:3615: expected ';', found 'EOF'
 /app/parser/parser.go:1635: expected '}', found 'EOF'
 /app/parser/parser.go:4050: expected ';', found 'EOF'
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:3648: expected statement, found ','
 /app/parser/parser.go:1635: expected '}', found 'EOF'
 /app/parser/parser.go:4050: expected ';', found 'EOF'
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
--- PASS: TestErrInFunc (0.00s)
=== RUN   TestClassErrCode
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: B}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:710: expected 'IDENT', found '*'
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3768: expected ';', found B
 /app/parser/parser.go:710: expected 'IDENT', found newline
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:3768: expected ';', found int
 /app/parser/parser.go:710: expected 'IDENT', found newline
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3768: expected ';', found ')'
 /app/parser/parser.go:710: expected 'IDENT', found newline
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3768: expected ';', found 'EOF'
 /app/parser/parser.go:3852: expected ')', found 'EOF'
 /app/parser/parser.go:3853: expected ';', found 'EOF'
 /app/parser/parser.go:710: expected 'IDENT', found '['
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3768: expected ';', found ']'
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:710: expected 'IDENT', found '['
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3768: expected ';', found ']'
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:3768: expected ';', found '='
 /app/parser/parser.go:710: expected 'IDENT', found 10
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:3768: expected ';', found '='
 /app/parser/parser.go:710: expected 'IDENT', found 10
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:713: ast.Ident{Name: c}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
 /app/parser/parser.go:713: ast.Ident{Name: d}
--- PASS: TestClassErrCode (0.00s)
=== RUN   TestErrGlobal
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
 /app/parser/parser.go:4133: expected statement, found '}'
--- PASS: TestErrGlobal (0.00s)
=== RUN   TestErrCompositeLiteral
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:2064: ast.IndexExpr{X: T, Index: int}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{T 11 int 15}}
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
 /app/parser/parser.go:713: ast.Ident{Name: b}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
--- PASS: TestErrCompositeLiteral (0.00s)
=== RUN   TestErrSelectorExpr
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:2417: expected selector or type assertion, found '*'
 /app/parser/parser.go:3615: expected ';', found p
--- PASS: TestErrSelectorExpr (0.00s)
=== RUN   TestErrStringLitEx
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1945: expected operand, found '...'
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "${ ... }"}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "${b"}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "$a${b}"}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
--- PASS: TestErrStringLitEx (0.00s)
=== RUN   TestErrStringLiteral
 /app/parser/parser.go:713: ast.Ident{Name: run}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: run, Ellipsis: false, isCmd: true}
--- PASS: TestErrStringLiteral (0.00s)
=== RUN   TestErrFieldDecl
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: Foo}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: Foo}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: Foo}
--- PASS: TestErrFieldDecl (0.00s)
=== RUN   TestParseFieldDecl
 /app/parser/parser.go:1050: expected field name or embedded type, found 'type'
--- PASS: TestParseFieldDecl (0.00s)
=== RUN   TestCheckExpr
 /app/parser/parser_test.go:349: expected expression
--- PASS: TestCheckExpr (0.00s)
=== RUN   TestErrFuncDecl
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
 /app/parser/parser.go:713: ast.Ident{Name: test}
 /app/parser/parser.go:4060: expected ';', found '+'
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:453: expected type, found '+'
 /app/parser/parser.go:2110: expected '(', found newline
 /app/parser/parser.go:502: expected ')', found 'EOF'
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{0xc0001c8380 0xc0001cc540}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4004: expected ';', found 'EOF'
 /app/parser/parser.go:639: ast.Ident{Tok: +}
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: b}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: +, ...}
--- PASS: TestErrFuncDecl (0.00s)
=== RUN   TestErrForIn
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:3482: expected 'in', found i
 /app/parser/parser.go:713: ast.Ident{Name: b}
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: a, Fors: [0xc0001d40c0]}
--- PASS: TestErrForIn (0.00s)
=== RUN   TestErrKwargExpr
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: a}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 13}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: f, Ellipsis: false, isCmd: true}
--- PASS: TestErrKwargExpr (0.00s)
=== RUN   TestNumberUnitLit
 /app/parser/parser.go:3459: expected 'IDENT', found , found 'ILLEGAL'
--- PASS: TestNumberUnitLit (0.00s)
=== RUN   TestImplicitIdent
--- PASS: TestImplicitIdent (0.00s)
=== RUN   TestErrGlobalVarWithSyntaxError
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:710: expected 'IDENT', found '='
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3768: expected ';', found 2
 /app/parser/parser.go:710: expected 'IDENT', found newline
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:713: ast.Ident{Name: sprites}
 /app/parser/parser.go:1505: expected type argument list
 /app/parser/parser.go:3768: expected ';', found Sprite
 /app/parser/parser.go:710: expected 'IDENT', found newline
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:3768: expected ';', found ')'
 /app/parser/parser.go:710: expected 'IDENT', found newline
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:1340: expected '(', found reset
 /app/parser/parser.go:799: expected type, found ')'
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:1297: expected ')', found 10
 /app/parser/parser.go:1145: missing ',' before newline in parameter list
 /app/parser/parser.go:713: ast.Ident{Name: sprites}
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:713: ast.Ident{Name: make}
 /app/parser/parser.go:713: ast.Ident{Name: Sprite}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: Sprite}
 /app/parser/parser.go:1593: expected ')', found ','
 /app/parser/parser.go:1145: missing ',' in parameter list
 /app/parser/parser.go:710: expected 'IDENT', found '}'
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:713: ast.Ident{Name: onStart}
 /app/parser/parser.go:3768: expected ';', found '=>'
 /app/parser/parser.go:710: expected 'IDENT', found '{'
 /app/parser/parser.go:713: ast.Ident{Name: _}
 /app/parser/parser.go:713: ast.Ident{Name: reset}
 /app/parser/parser.go:3768: expected ';', found '('
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: sprites}
 /app/parser/parser.go:713: ast.Ident{Name: Sprite}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: Sprite}
 /app/parser/parser.go:713: ast.Ident{Name: reset}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
 /app/parser/parser.go:713: ast.Ident{Name: sprites}
 /app/parser/parser.go:713: ast.Ident{Name: make}
 /app/parser/parser.go:713: ast.Ident{Name: Sprite}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: Sprite}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: make, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: reset, ...}
 /app/parser/parser.go:713: ast.Ident{Name: onStart}
 /app/parser/parser.go:713: ast.Ident{Name: reset}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: reset, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: onStart, Ellipsis: false, isCmd: true}
--- PASS: TestErrGlobalVarWithSyntaxError (0.00s)
=== RUN   TestStd
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: t}
 /app/parser/parser.go:713: ast.Ident{Name: false}
 /app/parser/parser.go:713: ast.Ident{Name: t}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "x:"}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: s}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hello"}
 /app/parser/parser.go:713: ast.Ident{Name: s}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "world"}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "hi"}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "xsw"}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
 /app/parser/parser.go:713: ast.Ident{Name: println}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "x:"}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:713: ast.Ident{Name: c}
 /app/parser/parser.go:713: ast.Ident{Name: make}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: make, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:713: ast.Ident{Name: c}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: c}
 /app/parser/parser.go:713: ast.Ident{Name: panic}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "error"}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: panic, Ellipsis: false, isCmd: false}
--- PASS: TestStd (0.00s)
=== RUN   TestFromInstance
=== RUN   TestFromInstance/instance1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_instance/instance1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . GenDecl(type) (
    1:  1: . . . "type"
    1:  6: . . . TypeSpec (
    1:  6: . . . . IDENT T1
 /app/parser/parser.go:713: ast.Ident{Name: T1}
    1:  9: . . . . Type (
    1:  9: . . . . . TypeName (
    1:  9: . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    1: 11: . . . . . )
    1: 11: . . . . . TypeInstance (
    1: 11: . . . . . . "["
    1: 12: . . . . . . Type (
    1: 12: . . . . . . . TypeName (
    1: 12: . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 15: . . . . . . . )
    1: 15: . . . . . . )
    1: 15: . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
    1: 16: . . . . . )
    1: 16: . . . . )
    1: 16: . . . . ";"
    3:  1: . . . )
    3:  1: . . )
    3:  1: . )
    3:  1: . Declaration (
    3:  1: . . GenDecl(type) (
    3:  1: . . . "type"
    3:  6: . . . TypeSpec (
    3:  6: . . . . IDENT T2
 /app/parser/parser.go:713: ast.Ident{Name: T2}
    3:  9: . . . . Type (
    3:  9: . . . . . TypeName (
    3:  9: . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    3: 11: . . . . . )
    3: 11: . . . . . TypeInstance (
    3: 11: . . . . . . "["
    3: 12: . . . . . . Type (
    3: 12: . . . . . . . TypeName (
    3: 12: . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    3: 15: . . . . . . . )
    3: 15: . . . . . . )
    3: 15: . . . . . . ","
    3: 17: . . . . . . Type (
    3: 17: . . . . . . . TypeName (
    3: 17: . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    3: 23: . . . . . . . )
    3: 23: . . . . . . )
    3: 23: . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    3: 24: . . . . . )
    3: 24: . . . . )
    3: 24: . . . . ";"
    5:  1: . . . )
    5:  1: . . )
    5:  1: . )
    5:  1: . Declaration (
    5:  1: . . GenDecl(type) (
    5:  1: . . . "type"
    5:  6: . . . TypeSpec (
    5:  6: . . . . IDENT T3
 /app/parser/parser.go:713: ast.Ident{Name: T3}
    5:  9: . . . . Type (
    5:  9: . . . . . PointerType (
    5:  9: . . . . . . "*"
    5: 10: . . . . . . Type (
    5: 10: . . . . . . . TypeName (
    5: 10: . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    5: 12: . . . . . . . )
    5: 12: . . . . . . . TypeInstance (
    5: 12: . . . . . . . . "["
    5: 13: . . . . . . . . Type (
    5: 13: . . . . . . . . . TypeName (
    5: 13: . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    5: 15: . . . . . . . . . )
    5: 15: . . . . . . . . . TypeInstance (
    5: 15: . . . . . . . . . . "["
    5: 16: . . . . . . . . . . Type (
    5: 16: . . . . . . . . . . . TypeName (
    5: 16: . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5: 19: . . . . . . . . . . . )
    5: 19: . . . . . . . . . . )
    5: 19: . . . . . . . . . . ","
    5: 21: . . . . . . . . . . Type (
    5: 21: . . . . . . . . . . . TypeName (
    5: 21: . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    5: 23: . . . . . . . . . . . )
    5: 23: . . . . . . . . . . . TypeInstance (
    5: 23: . . . . . . . . . . . . "["
    5: 24: . . . . . . . . . . . . Type (
    5: 24: . . . . . . . . . . . . . TypeName (
    5: 24: . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5: 27: . . . . . . . . . . . . . )
    5: 27: . . . . . . . . . . . . )
    5: 27: . . . . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
    5: 28: . . . . . . . . . . . )
    5: 28: . . . . . . . . . . )
    5: 28: . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int 0xc000214000]}
    5: 29: . . . . . . . . . )
    5: 29: . . . . . . . . )
    5: 29: . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: &{P2 57 [int 0xc000214000] 70}}
    5: 30: . . . . . . . )
    5: 30: . . . . . . )
    5: 30: . . . . . )
    5: 30: . . . . )
    5: 30: . . . . ";"
    7:  1: . . . )
    7:  1: . . )
    7:  1: . )
    7:  1: . Declaration (
    7:  1: . . GenDecl(type) (
    7:  1: . . . "type"
    7:  6: . . . TypeSpec (
    7:  6: . . . . IDENT S1
 /app/parser/parser.go:713: ast.Ident{Name: S1}
    7:  9: . . . . Type (
    7:  9: . . . . . StructType (
    7:  9: . . . . . . "struct"
    7: 16: . . . . . . "{"
    8:  2: . . . . . . FieldDecl (
    8:  2: . . . . . . . IDENT v1
 /app/parser/parser.go:713: ast.Ident{Name: v1}
    8:  5: . . . . . . . Type (
    8:  5: . . . . . . . . TypeName (
    8:  5: . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    8:  7: . . . . . . . . )
    8:  7: . . . . . . . . TypeInstance (
    8:  7: . . . . . . . . . "["
    8:  8: . . . . . . . . . Type (
    8:  8: . . . . . . . . . . TypeName (
    8:  8: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    8: 11: . . . . . . . . . . )
    8: 11: . . . . . . . . . )
    8: 11: . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
    8: 12: . . . . . . . . )
    8: 12: . . . . . . . )
    8: 12: . . . . . . . ";"
    9:  2: . . . . . . )
    9:  2: . . . . . . FieldDecl (
    9:  2: . . . . . . . IDENT v2
 /app/parser/parser.go:713: ast.Ident{Name: v2}
    9:  5: . . . . . . . Type (
    9:  5: . . . . . . . . TypeName (
    9:  5: . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    9:  7: . . . . . . . . )
    9:  7: . . . . . . . . TypeInstance (
    9:  7: . . . . . . . . . "["
    9:  8: . . . . . . . . . Type (
    9:  8: . . . . . . . . . . TypeName (
    9:  8: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    9: 11: . . . . . . . . . . )
    9: 11: . . . . . . . . . )
    9: 11: . . . . . . . . . ","
    9: 13: . . . . . . . . . Type (
    9: 13: . . . . . . . . . . TypeName (
    9: 13: . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    9: 19: . . . . . . . . . . )
    9: 19: . . . . . . . . . )
    9: 19: . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    9: 20: . . . . . . . . )
    9: 20: . . . . . . . )
    9: 20: . . . . . . . ";"
   10:  1: . . . . . . )
   10:  1: . . . . . . "}"
   10:  2: . . . . . )
   10:  2: . . . . )
   10:  2: . . . . ";"
   12:  1: . . . )
   12:  1: . . )
   12:  1: . )
   12:  1: . Declaration (
   12:  1: . . GenDecl(type) (
   12:  1: . . . "type"
   12:  6: . . . TypeSpec (
   12:  6: . . . . IDENT S2
 /app/parser/parser.go:713: ast.Ident{Name: S2}
   12:  9: . . . . Type (
   12:  9: . . . . . StructType (
   12:  9: . . . . . . "struct"
   12: 16: . . . . . . "{"
   13:  2: . . . . . . FieldDecl (
   13:  2: . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   13:  4: . . . . . . . ArrayFieldOrTypeInstance (
   13:  4: . . . . . . . . "["
   13:  5: . . . . . . . . Expression (
   13:  5: . . . . . . . . . BinaryExpr (
   13:  5: . . . . . . . . . . UnaryExpr (
   13:  5: . . . . . . . . . . . PrimaryExpr (
   13:  5: . . . . . . . . . . . . Operand (
   13:  5: . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   13:  8: . . . . . . . . . . . . )
   13:  8: . . . . . . . . . . . )
   13:  8: . . . . . . . . . . )
   13:  8: . . . . . . . . . )
   13:  8: . . . . . . . . )
   13:  8: . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
   13:  9: . . . . . . . )
   13:  9: . . . . . . . ";"
   14:  1: . . . . . . )
   14:  1: . . . . . . "}"
   14:  2: . . . . . )
   14:  2: . . . . )
   14:  2: . . . . ";"
   16:  1: . . . )
   16:  1: . . )
   16:  1: . )
   16:  1: . Declaration (
   16:  1: . . GenDecl(type) (
   16:  1: . . . "type"
   16:  6: . . . TypeSpec (
   16:  6: . . . . IDENT A1
 /app/parser/parser.go:713: ast.Ident{Name: A1}
   16:  9: . . . . Type (
   16:  9: . . . . . ArrayType (
   16:  9: . . . . . . "["
   16: 10: . . . . . . "]"
   16: 11: . . . . . . Type (
   16: 11: . . . . . . . TypeName (
   16: 11: . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   16: 13: . . . . . . . )
   16: 13: . . . . . . . TypeInstance (
   16: 13: . . . . . . . . "["
   16: 14: . . . . . . . . Type (
   16: 14: . . . . . . . . . TypeName (
   16: 14: . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   16: 17: . . . . . . . . . )
   16: 17: . . . . . . . . )
   16: 17: . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
   16: 18: . . . . . . . )
   16: 18: . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: &{P1 167 int 171}}
   16: 18: . . . . . )
   16: 18: . . . . )
   16: 18: . . . . ";"
   18:  1: . . . )
   18:  1: . . )
   18:  1: . )
   18:  1: . Declaration (
   18:  1: . . GenDecl(type) (
   18:  1: . . . "type"
   18:  6: . . . TypeSpec (
   18:  6: . . . . IDENT A2
 /app/parser/parser.go:713: ast.Ident{Name: A2}
   18:  9: . . . . Type (
   18:  9: . . . . . ArrayType (
   18:  9: . . . . . . "["
   18: 10: . . . . . . Expression (
   18: 10: . . . . . . . BinaryExpr (
   18: 10: . . . . . . . . UnaryExpr (
   18: 10: . . . . . . . . . PrimaryExpr (
   18: 10: . . . . . . . . . . Operand (
   18: 10: . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   18: 11: . . . . . . . . . . )
   18: 11: . . . . . . . . . )
   18: 11: . . . . . . . . )
   18: 11: . . . . . . . )
   18: 11: . . . . . . )
   18: 11: . . . . . . "]"
   18: 12: . . . . . . Type (
   18: 12: . . . . . . . TypeName (
   18: 12: . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
   18: 14: . . . . . . . )
   18: 14: . . . . . . . TypeInstance (
   18: 14: . . . . . . . . "["
   18: 15: . . . . . . . . Type (
   18: 15: . . . . . . . . . TypeName (
   18: 15: . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   18: 18: . . . . . . . . . )
   18: 18: . . . . . . . . )
   18: 18: . . . . . . . . ","
   18: 20: . . . . . . . . Type (
   18: 20: . . . . . . . . . TypeName (
   18: 20: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   18: 26: . . . . . . . . . )
   18: 26: . . . . . . . . )
   18: 26: . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
   18: 27: . . . . . . . )
   18: 27: . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: &{183 INT 2 <nil>}, Elt: &{P2 187 [int string] 199}}
   18: 27: . . . . . )
   18: 27: . . . . )
   18: 27: . . . . ";"
   20:  1: . . . )
   20:  1: . . )
   20:  1: . )
   20:  1: . Declaration (
   20:  1: . . GenDecl(type) (
   20:  1: . . . "type"
   20:  6: . . . TypeSpec (
   20:  6: . . . . IDENT M1
 /app/parser/parser.go:713: ast.Ident{Name: M1}
   20:  9: . . . . Type (
   20:  9: . . . . . MapType (
   20:  9: . . . . . . "map"
   20: 12: . . . . . . "["
   20: 13: . . . . . . Type (
   20: 13: . . . . . . . TypeName (
   20: 13: . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   20: 15: . . . . . . . )
   20: 15: . . . . . . . TypeInstance (
   20: 15: . . . . . . . . "["
   20: 16: . . . . . . . . Type (
   20: 16: . . . . . . . . . TypeName (
   20: 16: . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   20: 19: . . . . . . . . . )
   20: 19: . . . . . . . . )
   20: 19: . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
   20: 20: . . . . . . . )
   20: 20: . . . . . . )
   20: 20: . . . . . . "]"
   20: 21: . . . . . . Type (
   20: 21: . . . . . . . TypeName (
   20: 21: . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
   20: 23: . . . . . . . )
   20: 23: . . . . . . . TypeInstance (
   20: 23: . . . . . . . . "["
   20: 24: . . . . . . . . Type (
   20: 24: . . . . . . . . . TypeName (
   20: 24: . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   20: 27: . . . . . . . . . )
   20: 27: . . . . . . . . )
   20: 27: . . . . . . . . ","
   20: 29: . . . . . . . . Type (
   20: 29: . . . . . . . . . TypeName (
   20: 29: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   20: 35: . . . . . . . . . )
   20: 35: . . . . . . . . )
   20: 35: . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
   20: 36: . . . . . . . )
   20: 36: . . . . . . )
 /app/parser/parser.go:1455: ast.MapType{Key: &{P1 216 int 220}, Value: &{P2 224 [int string] 236}}
   20: 36: . . . . . )
   20: 36: . . . . )
   20: 36: . . . . ";"
   22:  1: . . . )
   22:  1: . . )
   22:  1: . )
   22:  1: . Declaration (
   22:  1: . . GenDecl(type) (
   22:  1: . . . "type"
   22:  6: . . . TypeSpec (
   22:  6: . . . . IDENT C1
 /app/parser/parser.go:713: ast.Ident{Name: C1}
   22:  9: . . . . Type (
   22:  9: . . . . . ChanType (
   22:  9: . . . . . . "chan"
   22: 14: . . . . . . Type (
   22: 14: . . . . . . . TypeName (
   22: 14: . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   22: 16: . . . . . . . )
   22: 16: . . . . . . . TypeInstance (
   22: 16: . . . . . . . . "["
   22: 17: . . . . . . . . Type (
   22: 17: . . . . . . . . . TypeName (
   22: 17: . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   22: 20: . . . . . . . . . )
   22: 20: . . . . . . . . )
   22: 20: . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
   22: 21: . . . . . . . )
   22: 21: . . . . . . )
   22: 21: . . . . . )
   22: 21: . . . . )
   22: 21: . . . . ";"
   22: 22: . . . )
   22: 22: . . )
   22: 22: . )
   22: 22: )
=== RUN   TestFromInstance/instance2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_instance/instance2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  6: . . . IDENT fn1
 /app/parser/parser.go:713: ast.Ident{Name: fn1}
    1:  9: . . . Signature (
    1:  9: . . . . Parameters (
    1:  9: . . . . . "("
    1: 10: . . . . . ParameterList (
    1: 10: . . . . . . ParamDeclOrNil (
    1: 10: . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    1: 12: . . . . . . . ArrayFieldOrTypeInstance (
    1: 12: . . . . . . . . "["
    1: 13: . . . . . . . . Expression (
    1: 13: . . . . . . . . . BinaryExpr (
    1: 13: . . . . . . . . . . UnaryExpr (
    1: 13: . . . . . . . . . . . PrimaryExpr (
    1: 13: . . . . . . . . . . . . Operand (
    1: 13: . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 16: . . . . . . . . . . . . )
    1: 16: . . . . . . . . . . . )
    1: 16: . . . . . . . . . . )
    1: 16: . . . . . . . . . )
    1: 16: . . . . . . . . )
    1: 16: . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
    1: 17: . . . . . . . )
    1: 17: . . . . . . )
    1: 17: . . . . . . ","
    1: 19: . . . . . . ParamDeclOrNil (
    1: 19: . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    1: 21: . . . . . . . ArrayFieldOrTypeInstance (
    1: 21: . . . . . . . . "["
    1: 22: . . . . . . . . Expression (
    1: 22: . . . . . . . . . BinaryExpr (
    1: 22: . . . . . . . . . . UnaryExpr (
    1: 22: . . . . . . . . . . . PrimaryExpr (
    1: 22: . . . . . . . . . . . . Operand (
    1: 22: . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 25: . . . . . . . . . . . . )
    1: 25: . . . . . . . . . . . )
    1: 25: . . . . . . . . . . )
    1: 25: . . . . . . . . . )
    1: 25: . . . . . . . . )
    1: 25: . . . . . . . . ","
    1: 27: . . . . . . . . Expression (
    1: 27: . . . . . . . . . BinaryExpr (
    1: 27: . . . . . . . . . . UnaryExpr (
    1: 27: . . . . . . . . . . . PrimaryExpr (
    1: 27: . . . . . . . . . . . . Operand (
    1: 27: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    1: 33: . . . . . . . . . . . . )
    1: 33: . . . . . . . . . . . )
    1: 33: . . . . . . . . . . )
    1: 33: . . . . . . . . . )
    1: 33: . . . . . . . . )
    1: 33: . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    1: 34: . . . . . . . )
    1: 34: . . . . . . )
    1: 34: . . . . . )
    1: 34: . . . . . ")"
    1: 35: . . . . )
    1: 35: . . . . Result (
    1: 35: . . . . )
    1: 35: . . . )
    1: 35: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: fn1, ...}
    3:  1: . . )
    3:  1: . )
    3:  1: . Declaration (
    3:  1: . . FunctionDeclOrCall (
    3:  1: . . . "func"
    3:  6: . . . IDENT fn2
 /app/parser/parser.go:713: ast.Ident{Name: fn2}
    3:  9: . . . Signature (
    3:  9: . . . . Parameters (
    3:  9: . . . . . "("
    3: 10: . . . . . ParameterList (
    3: 10: . . . . . . ParamDeclOrNil (
    3: 10: . . . . . . . IDENT p1
 /app/parser/parser.go:713: ast.Ident{Name: p1}
    3: 13: . . . . . . . Type (
    3: 13: . . . . . . . . TypeName (
    3: 13: . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    3: 15: . . . . . . . . )
    3: 15: . . . . . . . . TypeInstance (
    3: 15: . . . . . . . . . "["
    3: 16: . . . . . . . . . Type (
    3: 16: . . . . . . . . . . TypeName (
    3: 16: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    3: 19: . . . . . . . . . . )
    3: 19: . . . . . . . . . )
    3: 19: . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
    3: 20: . . . . . . . . )
    3: 20: . . . . . . . )
    3: 20: . . . . . . )
    3: 20: . . . . . . ","
    3: 22: . . . . . . ParamDeclOrNil (
    3: 22: . . . . . . . IDENT p2
 /app/parser/parser.go:713: ast.Ident{Name: p2}
    3: 25: . . . . . . . Type (
    3: 25: . . . . . . . . TypeName (
    3: 25: . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    3: 27: . . . . . . . . )
    3: 27: . . . . . . . . TypeInstance (
    3: 27: . . . . . . . . . "["
    3: 28: . . . . . . . . . Type (
    3: 28: . . . . . . . . . . TypeName (
    3: 28: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    3: 31: . . . . . . . . . . )
    3: 31: . . . . . . . . . )
    3: 31: . . . . . . . . . ","
    3: 33: . . . . . . . . . Type (
    3: 33: . . . . . . . . . . TypeName (
    3: 33: . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    3: 39: . . . . . . . . . . )
    3: 39: . . . . . . . . . )
    3: 39: . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    3: 40: . . . . . . . . )
    3: 40: . . . . . . . )
    3: 40: . . . . . . )
    3: 40: . . . . . )
    3: 40: . . . . . ")"
    3: 41: . . . . )
    3: 41: . . . . Result (
    3: 41: . . . . )
    3: 41: . . . )
    3: 41: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: fn2, ...}
    5:  1: . . )
    5:  1: . )
    5:  1: . Declaration (
    5:  1: . . FunctionDeclOrCall (
    5:  1: . . . "func"
    5:  6: . . . IDENT fn3
 /app/parser/parser.go:713: ast.Ident{Name: fn3}
    5:  9: . . . Signature (
    5:  9: . . . . Parameters (
    5:  9: . . . . . "("
    5: 10: . . . . . ParameterList (
    5: 10: . . . . . . ParamDeclOrNil (
    5: 10: . . . . . . . IDENT p1
 /app/parser/parser.go:713: ast.Ident{Name: p1}
    5: 13: . . . . . . . Type (
    5: 13: . . . . . . . . TypeName (
    5: 13: . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    5: 15: . . . . . . . . )
    5: 15: . . . . . . . . TypeInstance (
    5: 15: . . . . . . . . . "["
    5: 16: . . . . . . . . . Type (
    5: 16: . . . . . . . . . . TypeName (
    5: 16: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5: 19: . . . . . . . . . . )
    5: 19: . . . . . . . . . )
    5: 19: . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
    5: 20: . . . . . . . . )
    5: 20: . . . . . . . )
    5: 20: . . . . . . )
    5: 20: . . . . . . ","
    5: 22: . . . . . . ParamDeclOrNil (
    5: 22: . . . . . . . IDENT p2
 /app/parser/parser.go:713: ast.Ident{Name: p2}
    5: 25: . . . . . . . DotsType (
    5: 25: . . . . . . . . "..."
    5: 28: . . . . . . . . Type (
    5: 28: . . . . . . . . . TypeName (
    5: 28: . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    5: 30: . . . . . . . . . )
    5: 30: . . . . . . . . . TypeInstance (
    5: 30: . . . . . . . . . . "["
    5: 31: . . . . . . . . . . Type (
    5: 31: . . . . . . . . . . . TypeName (
    5: 31: . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5: 34: . . . . . . . . . . . )
    5: 34: . . . . . . . . . . )
    5: 34: . . . . . . . . . . ","
    5: 36: . . . . . . . . . . Type (
    5: 36: . . . . . . . . . . . TypeName (
    5: 36: . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    5: 42: . . . . . . . . . . . )
    5: 42: . . . . . . . . . . )
    5: 42: . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    5: 43: . . . . . . . . . )
    5: 43: . . . . . . . . )
    5: 43: . . . . . . . )
    5: 43: . . . . . . )
    5: 43: . . . . . )
    5: 43: . . . . . ")"
    5: 44: . . . . )
    5: 44: . . . . Result (
    5: 44: . . . . )
    5: 44: . . . )
    5: 44: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: fn3, ...}
    7:  1: . . )
    7:  1: . )
    7:  1: . Declaration (
    7:  1: . . FunctionDeclOrCall (
    7:  1: . . . "func"
    7:  6: . . . IDENT fn4
 /app/parser/parser.go:713: ast.Ident{Name: fn4}
    7:  9: . . . Signature (
    7:  9: . . . . Parameters (
    7:  9: . . . . . "("
    7: 10: . . . . . ParameterList (
    7: 10: . . . . . . ParamDeclOrNil (
    7: 10: . . . . . . . IDENT p1
 /app/parser/parser.go:713: ast.Ident{Name: p1}
    7: 13: . . . . . . . ArrayFieldOrTypeInstance (
    7: 13: . . . . . . . . "["
    7: 14: . . . . . . . . "]"
    7: 15: . . . . . . . . Type (
    7: 15: . . . . . . . . . TypeName (
    7: 15: . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    7: 17: . . . . . . . . . )
    7: 17: . . . . . . . . . TypeInstance (
    7: 17: . . . . . . . . . . "["
    7: 18: . . . . . . . . . . Type (
    7: 18: . . . . . . . . . . . TypeName (
    7: 18: . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    7: 21: . . . . . . . . . . . )
    7: 21: . . . . . . . . . . )
    7: 21: . . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
    7: 22: . . . . . . . . . )
    7: 22: . . . . . . . . )
    7: 22: . . . . . . . )
    7: 22: . . . . . . )
    7: 22: . . . . . . ","
    7: 24: . . . . . . ParamDeclOrNil (
    7: 24: . . . . . . . IDENT p3
 /app/parser/parser.go:713: ast.Ident{Name: p3}
    7: 27: . . . . . . . ArrayFieldOrTypeInstance (
    7: 27: . . . . . . . . "["
    7: 28: . . . . . . . . "]"
    7: 29: . . . . . . . . Type (
    7: 29: . . . . . . . . . TypeName (
    7: 29: . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    7: 31: . . . . . . . . . )
    7: 31: . . . . . . . . . TypeInstance (
    7: 31: . . . . . . . . . . "["
    7: 32: . . . . . . . . . . Type (
    7: 32: . . . . . . . . . . . TypeName (
    7: 32: . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    7: 35: . . . . . . . . . . . )
    7: 35: . . . . . . . . . . )
    7: 35: . . . . . . . . . . ","
    7: 37: . . . . . . . . . . Type (
    7: 37: . . . . . . . . . . . TypeName (
    7: 37: . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    7: 43: . . . . . . . . . . . )
    7: 43: . . . . . . . . . . )
    7: 43: . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    7: 44: . . . . . . . . . )
    7: 44: . . . . . . . . )
    7: 44: . . . . . . . )
    7: 44: . . . . . . )
    7: 44: . . . . . )
    7: 44: . . . . . ")"
    7: 46: . . . . )
    7: 46: . . . . Result (
    7: 46: . . . . . PointerType (
    7: 46: . . . . . . "*"
    7: 47: . . . . . . Type (
    7: 47: . . . . . . . TypeName (
    7: 47: . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    7: 49: . . . . . . . )
    7: 49: . . . . . . . TypeInstance (
    7: 49: . . . . . . . . "["
    7: 50: . . . . . . . . Type (
    7: 50: . . . . . . . . . TypeName (
    7: 50: . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    7: 52: . . . . . . . . . )
    7: 52: . . . . . . . . . TypeInstance (
    7: 52: . . . . . . . . . . "["
    7: 53: . . . . . . . . . . Type (
    7: 53: . . . . . . . . . . . TypeName (
    7: 53: . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    7: 56: . . . . . . . . . . . )
    7: 56: . . . . . . . . . . )
    7: 56: . . . . . . . . . . ","
    7: 58: . . . . . . . . . . Type (
    7: 58: . . . . . . . . . . . TypeName (
    7: 58: . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    7: 60: . . . . . . . . . . . )
    7: 60: . . . . . . . . . . . TypeInstance (
    7: 60: . . . . . . . . . . . . "["
    7: 61: . . . . . . . . . . . . Type (
    7: 61: . . . . . . . . . . . . . TypeName (
    7: 61: . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    7: 64: . . . . . . . . . . . . . )
    7: 64: . . . . . . . . . . . . )
    7: 64: . . . . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
    7: 65: . . . . . . . . . . . )
    7: 65: . . . . . . . . . . )
    7: 65: . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int 0xc0002147e0]}
    7: 66: . . . . . . . . . )
    7: 66: . . . . . . . . )
    7: 66: . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: &{P2 175 [int 0xc0002147e0] 188}}
    7: 67: . . . . . . . )
    7: 67: . . . . . . )
    7: 67: . . . . . )
    7: 67: . . . . )
    7: 67: . . . )
    7: 67: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: fn4, ...}
    9:  1: . . )
    9:  1: . )
    9:  1: . Declaration (
    9:  1: . . FunctionDeclOrCall (
    9:  1: . . . "func"
    9:  6: . . . IDENT fn5
 /app/parser/parser.go:713: ast.Ident{Name: fn5}
    9:  9: . . . Signature (
    9:  9: . . . . Parameters (
    9:  9: . . . . . "("
    9: 10: . . . . . ParameterList (
    9: 10: . . . . . . ParamDeclOrNil (
    9: 10: . . . . . . . IDENT p1
 /app/parser/parser.go:713: ast.Ident{Name: p1}
    9: 13: . . . . . . . ArrayFieldOrTypeInstance (
    9: 13: . . . . . . . . "["
    9: 14: . . . . . . . . "]"
    9: 15: . . . . . . . . Type (
    9: 15: . . . . . . . . . TypeName (
    9: 15: . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    9: 17: . . . . . . . . . )
    9: 17: . . . . . . . . . TypeInstance (
    9: 17: . . . . . . . . . . "["
    9: 18: . . . . . . . . . . Type (
    9: 18: . . . . . . . . . . . TypeName (
    9: 18: . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    9: 21: . . . . . . . . . . . )
    9: 21: . . . . . . . . . . )
    9: 21: . . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
    9: 22: . . . . . . . . . )
    9: 22: . . . . . . . . )
    9: 22: . . . . . . . )
    9: 22: . . . . . . )
    9: 22: . . . . . . ","
    9: 24: . . . . . . ParamDeclOrNil (
    9: 24: . . . . . . . IDENT p2
 /app/parser/parser.go:713: ast.Ident{Name: p2}
    9: 27: . . . . . . . ArrayFieldOrTypeInstance (
    9: 27: . . . . . . . . "["
    9: 28: . . . . . . . . Expression (
    9: 28: . . . . . . . . . BinaryExpr (
    9: 28: . . . . . . . . . . UnaryExpr (
    9: 28: . . . . . . . . . . . PrimaryExpr (
    9: 28: . . . . . . . . . . . . Operand (
    9: 28: . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    9: 29: . . . . . . . . . . . . )
    9: 29: . . . . . . . . . . . )
    9: 29: . . . . . . . . . . )
    9: 29: . . . . . . . . . )
    9: 29: . . . . . . . . )
    9: 29: . . . . . . . . "]"
    9: 30: . . . . . . . . TypeName (
    9: 30: . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    9: 32: . . . . . . . . )
    9: 32: . . . . . . . . TypeInstance (
    9: 32: . . . . . . . . . "["
    9: 33: . . . . . . . . . Type (
    9: 33: . . . . . . . . . . TypeName (
    9: 33: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    9: 36: . . . . . . . . . . )
    9: 36: . . . . . . . . . )
    9: 36: . . . . . . . . . ","
    9: 38: . . . . . . . . . Type (
    9: 38: . . . . . . . . . . TypeName (
    9: 38: . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    9: 44: . . . . . . . . . . )
    9: 44: . . . . . . . . . )
    9: 44: . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    9: 45: . . . . . . . . )
    9: 45: . . . . . . . )
    9: 45: . . . . . . )
    9: 45: . . . . . )
    9: 45: . . . . . ")"
    9: 46: . . . . )
    9: 46: . . . . Result (
    9: 46: . . . . )
    9: 46: . . . )
    9: 46: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: fn5, ...}
   11:  1: . . )
   11:  1: . )
   11:  1: . Declaration (
   11:  1: . . FunctionDeclOrCall (
   11:  1: . . . "func"
   11:  6: . . . IDENT fn6
 /app/parser/parser.go:713: ast.Ident{Name: fn6}
   11:  9: . . . Signature (
   11:  9: . . . . Parameters (
   11:  9: . . . . . "("
   11: 10: . . . . . ParameterList (
   11: 10: . . . . . . ParamDeclOrNil (
   11: 10: . . . . . . . IDENT p1
 /app/parser/parser.go:713: ast.Ident{Name: p1}
   11: 13: . . . . . . . Type (
   11: 13: . . . . . . . . ChanType (
   11: 13: . . . . . . . . . "chan"
   11: 18: . . . . . . . . . Type (
   11: 18: . . . . . . . . . . TypeName (
   11: 18: . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   11: 20: . . . . . . . . . . )
   11: 20: . . . . . . . . . . TypeInstance (
   11: 20: . . . . . . . . . . . "["
   11: 21: . . . . . . . . . . . Type (
   11: 21: . . . . . . . . . . . . TypeName (
   11: 21: . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   11: 24: . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
   11: 25: . . . . . . . . . . )
   11: 25: . . . . . . . . . )
   11: 25: . . . . . . . . )
   11: 25: . . . . . . . )
   11: 25: . . . . . . )
   11: 25: . . . . . . ","
   11: 27: . . . . . . ParamDeclOrNil (
   11: 27: . . . . . . . IDENT p2
 /app/parser/parser.go:713: ast.Ident{Name: p2}
   11: 30: . . . . . . . Type (
   11: 30: . . . . . . . . MapType (
   11: 30: . . . . . . . . . "map"
   11: 33: . . . . . . . . . "["
   11: 34: . . . . . . . . . Type (
   11: 34: . . . . . . . . . . TypeName (
   11: 34: . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   11: 36: . . . . . . . . . . )
   11: 36: . . . . . . . . . . TypeInstance (
   11: 36: . . . . . . . . . . . "["
   11: 37: . . . . . . . . . . . Type (
   11: 37: . . . . . . . . . . . . TypeName (
   11: 37: . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   11: 40: . . . . . . . . . . . . )
   11: 40: . . . . . . . . . . . )
   11: 40: . . . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
   11: 41: . . . . . . . . . . )
   11: 41: . . . . . . . . . )
   11: 41: . . . . . . . . . "]"
   11: 42: . . . . . . . . . Type (
   11: 42: . . . . . . . . . . TypeName (
   11: 42: . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
   11: 44: . . . . . . . . . . )
   11: 44: . . . . . . . . . . TypeInstance (
   11: 44: . . . . . . . . . . . "["
   11: 45: . . . . . . . . . . . Type (
   11: 45: . . . . . . . . . . . . TypeName (
   11: 45: . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   11: 48: . . . . . . . . . . . . )
   11: 48: . . . . . . . . . . . )
   11: 48: . . . . . . . . . . . ","
   11: 50: . . . . . . . . . . . Type (
   11: 50: . . . . . . . . . . . . TypeName (
   11: 50: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   11: 56: . . . . . . . . . . . . )
   11: 56: . . . . . . . . . . . )
   11: 56: . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
   11: 57: . . . . . . . . . . )
   11: 57: . . . . . . . . . )
 /app/parser/parser.go:1455: ast.MapType{Key: &{P1 274 int 278}, Value: &{P2 282 [int string] 294}}
   11: 57: . . . . . . . . )
   11: 57: . . . . . . . )
   11: 57: . . . . . . )
   11: 57: . . . . . )
   11: 57: . . . . . ")"
   11: 58: . . . . )
   11: 58: . . . . Result (
   11: 58: . . . . )
   11: 58: . . . )
   11: 58: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: fn6, ...}
   13:  1: . . )
   13:  1: . )
   13:  1: . Declaration (
   13:  1: . . FunctionDeclOrCall (
   13:  1: . . . "func"
   13:  6: . . . IDENT fn7
 /app/parser/parser.go:713: ast.Ident{Name: fn7}
   13:  9: . . . Signature (
   13:  9: . . . . Parameters (
   13:  9: . . . . . "("
   13: 10: . . . . . ParameterList (
   13: 10: . . . . . . ParamDeclOrNil (
   13: 10: . . . . . . . IDENT p1
 /app/parser/parser.go:713: ast.Ident{Name: p1}
   13: 13: . . . . . . . Type (
   13: 13: . . . . . . . . StructType (
   13: 13: . . . . . . . . . "struct"
   13: 20: . . . . . . . . . "{"
   14:  2: . . . . . . . . . FieldDecl (
   14:  2: . . . . . . . . . . IDENT v1
 /app/parser/parser.go:713: ast.Ident{Name: v1}
   14:  5: . . . . . . . . . . Type (
   14:  5: . . . . . . . . . . . TypeName (
   14:  5: . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   14:  7: . . . . . . . . . . . )
   14:  7: . . . . . . . . . . . TypeInstance (
   14:  7: . . . . . . . . . . . . "["
   14:  8: . . . . . . . . . . . . Type (
   14:  8: . . . . . . . . . . . . . TypeName (
   14:  8: . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   14: 11: . . . . . . . . . . . . . )
   14: 11: . . . . . . . . . . . . )
   14: 11: . . . . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
   14: 12: . . . . . . . . . . . )
   14: 12: . . . . . . . . . . )
   14: 12: . . . . . . . . . . ";"
   15:  2: . . . . . . . . . )
   15:  2: . . . . . . . . . FieldDecl (
   15:  2: . . . . . . . . . . IDENT v2
 /app/parser/parser.go:713: ast.Ident{Name: v2}
   15:  5: . . . . . . . . . . Type (
   15:  5: . . . . . . . . . . . TypeName (
   15:  5: . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
   15:  7: . . . . . . . . . . . )
   15:  7: . . . . . . . . . . . TypeInstance (
   15:  7: . . . . . . . . . . . . "["
   15:  8: . . . . . . . . . . . . Type (
   15:  8: . . . . . . . . . . . . . TypeName (
   15:  8: . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   15: 11: . . . . . . . . . . . . . )
   15: 11: . . . . . . . . . . . . )
   15: 11: . . . . . . . . . . . . ","
   15: 13: . . . . . . . . . . . . Type (
   15: 13: . . . . . . . . . . . . . TypeName (
   15: 13: . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   15: 19: . . . . . . . . . . . . . )
   15: 19: . . . . . . . . . . . . )
   15: 19: . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
   15: 20: . . . . . . . . . . . )
   15: 20: . . . . . . . . . . )
   15: 20: . . . . . . . . . . ";"
   16:  1: . . . . . . . . . )
   16:  1: . . . . . . . . . "}"
   16:  2: . . . . . . . . )
   16:  2: . . . . . . . )
   16:  2: . . . . . . )
   16:  2: . . . . . )
   16:  2: . . . . . ")"
   16:  3: . . . . )
   16:  3: . . . . Result (
   16:  3: . . . . )
   16:  3: . . . )
   16:  3: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: fn7, ...}
   16:  4: . . )
   16:  4: . )
   16:  4: )
=== RUN   TestFromInstance/instance3
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_instance/instance3
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    1:  8: . . . . . . . . . . )
    1:  8: . . . . . . . . . . CallOrConversion (
    1:  8: . . . . . . . . . . . "("
    1:  9: . . . . . . . . . . . Expression (
    1:  9: . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    1: 11: . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . IndexOrSlice (
    1: 11: . . . . . . . . . . . . . . . . "["
    1: 12: . . . . . . . . . . . . . . . . Expression (
    1: 12: . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 12: . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 12: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 12: . . . . . . . . . . . . . . . . . . . . Operand (
    1: 12: . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 15: . . . . . . . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: P1, Index: int}
    1: 16: . . . . . . . . . . . . . . . )
    1: 16: . . . . . . . . . . . . . . . LiteralValue (
    1: 16: . . . . . . . . . . . . . . . . "{"
    1: 17: . . . . . . . . . . . . . . . . "}"
    1: 18: . . . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . ","
    1: 20: . . . . . . . . . . . Expression (
    1: 20: . . . . . . . . . . . . BinaryExpr (
    1: 20: . . . . . . . . . . . . . UnaryExpr (
    1: 20: . . . . . . . . . . . . . . PrimaryExpr (
    1: 20: . . . . . . . . . . . . . . . Operand (
    1: 20: . . . . . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    1: 22: . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . IndexOrSlice (
    1: 22: . . . . . . . . . . . . . . . . "["
    1: 23: . . . . . . . . . . . . . . . . Expression (
    1: 23: . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 23: . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 23: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 23: . . . . . . . . . . . . . . . . . . . . Operand (
    1: 23: . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 26: . . . . . . . . . . . . . . . . . . . . )
    1: 26: . . . . . . . . . . . . . . . . . . . )
    1: 26: . . . . . . . . . . . . . . . . . . )
    1: 26: . . . . . . . . . . . . . . . . . )
    1: 26: . . . . . . . . . . . . . . . . )
    1: 26: . . . . . . . . . . . . . . . . ","
    1: 28: . . . . . . . . . . . . . . . . Type (
    1: 28: . . . . . . . . . . . . . . . . . TypeName (
    1: 28: . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    1: 34: . . . . . . . . . . . . . . . . . )
    1: 34: . . . . . . . . . . . . . . . . )
    1: 34: . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    1: 35: . . . . . . . . . . . . . . . )
    1: 35: . . . . . . . . . . . . . . . LiteralValue (
    1: 35: . . . . . . . . . . . . . . . . "{"
    1: 36: . . . . . . . . . . . . . . . . "}"
    1: 37: . . . . . . . . . . . . . . . )
    1: 37: . . . . . . . . . . . . . . )
    1: 37: . . . . . . . . . . . . . )
    1: 37: . . . . . . . . . . . . )
    1: 37: . . . . . . . . . . . )
    1: 37: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    1: 38: . . . . . . . . . . )
    1: 38: . . . . . . . . . )
    1: 38: . . . . . . . . )
    1: 38: . . . . . . . )
    1: 38: . . . . . . )
    1: 38: . . . . . )
    1: 38: . . . . )
    1: 38: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  8: . . . . . . . . . . )
    2:  8: . . . . . . . . . . CallOrConversion (
    2:  8: . . . . . . . . . . . "("
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . "("
    2: 10: . . . . . . . . . . . . . . . . Expression (
    2: 10: . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 10: . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 10: . . . . . . . . . . . . . . . . . . . "*"
    2: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    2: 13: . . . . . . . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . . . . . . . . IndexOrSlice (
    2: 13: . . . . . . . . . . . . . . . . . . . . . . "["
    2: 14: . . . . . . . . . . . . . . . . . . . . . . Expression (
    2: 14: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 14: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 14: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    2: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: P1, Index: int}
    2: 18: . . . . . . . . . . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{48 0xc000214e70}}
    2: 19: . . . . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . . . . CallOrConversion (
    2: 19: . . . . . . . . . . . . . . . . "("
    2: 20: . . . . . . . . . . . . . . . . Expression (
    2: 20: . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 20: . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 20: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 20: . . . . . . . . . . . . . . . . . . . . Operand (
    2: 20: . . . . . . . . . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
    2: 23: . . . . . . . . . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{47 0xc00020a888 56}, Ellipsis: false, isCmd: false}
    2: 24: . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . ","
    2: 26: . . . . . . . . . . . Expression (
    2: 26: . . . . . . . . . . . . BinaryExpr (
    2: 26: . . . . . . . . . . . . . UnaryExpr (
    2: 26: . . . . . . . . . . . . . . PrimaryExpr (
    2: 26: . . . . . . . . . . . . . . . Operand (
    2: 26: . . . . . . . . . . . . . . . . "("
    2: 27: . . . . . . . . . . . . . . . . Expression (
    2: 27: . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 27: . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 27: . . . . . . . . . . . . . . . . . . . "*"
    2: 28: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 28: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 28: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 28: . . . . . . . . . . . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    2: 30: . . . . . . . . . . . . . . . . . . . . . )
    2: 30: . . . . . . . . . . . . . . . . . . . . . IndexOrSlice (
    2: 30: . . . . . . . . . . . . . . . . . . . . . . "["
    2: 31: . . . . . . . . . . . . . . . . . . . . . . Expression (
    2: 31: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 31: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 31: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    2: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    2: 34: . . . . . . . . . . . . . . . . . . . . . . . . . )
    2: 34: . . . . . . . . . . . . . . . . . . . . . . . . )
    2: 34: . . . . . . . . . . . . . . . . . . . . . . . )
    2: 34: . . . . . . . . . . . . . . . . . . . . . . )
    2: 34: . . . . . . . . . . . . . . . . . . . . . . ","
    2: 36: . . . . . . . . . . . . . . . . . . . . . . Type (
    2: 36: . . . . . . . . . . . . . . . . . . . . . . . TypeName (
    2: 36: . . . . . . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    2: 42: . . . . . . . . . . . . . . . . . . . . . . . )
    2: 42: . . . . . . . . . . . . . . . . . . . . . . )
    2: 42: . . . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    2: 43: . . . . . . . . . . . . . . . . . . . . . )
    2: 43: . . . . . . . . . . . . . . . . . . . . )
    2: 43: . . . . . . . . . . . . . . . . . . . )
    2: 43: . . . . . . . . . . . . . . . . . . )
    2: 43: . . . . . . . . . . . . . . . . . )
    2: 43: . . . . . . . . . . . . . . . . )
    2: 43: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{65 0xc00020edc0}}
    2: 44: . . . . . . . . . . . . . . . )
    2: 44: . . . . . . . . . . . . . . . CallOrConversion (
    2: 44: . . . . . . . . . . . . . . . . "("
    2: 45: . . . . . . . . . . . . . . . . Expression (
    2: 45: . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 45: . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 45: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 45: . . . . . . . . . . . . . . . . . . . . Operand (
    2: 45: . . . . . . . . . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
    2: 48: . . . . . . . . . . . . . . . . . . . . )
    2: 48: . . . . . . . . . . . . . . . . . . . )
    2: 48: . . . . . . . . . . . . . . . . . . )
    2: 48: . . . . . . . . . . . . . . . . . )
    2: 48: . . . . . . . . . . . . . . . . )
    2: 48: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{64 0xc00020a8d0 81}, Ellipsis: false, isCmd: false}
    2: 49: . . . . . . . . . . . . . . . )
    2: 49: . . . . . . . . . . . . . . )
    2: 49: . . . . . . . . . . . . . )
    2: 49: . . . . . . . . . . . . )
    2: 49: . . . . . . . . . . . )
    2: 49: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    2: 50: . . . . . . . . . . )
    2: 50: . . . . . . . . . )
    2: 50: . . . . . . . . )
    2: 50: . . . . . . . )
    2: 50: . . . . . . )
    2: 50: . . . . . )
    2: 50: . . . . )
    2: 50: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    4:  9: . . . . . . . . . . )
    4:  9: . . . . . . . . . . CallOrConversion (
    4:  9: . . . . . . . . . . . Expression (
    4:  9: . . . . . . . . . . . . BinaryExpr (
    4:  9: . . . . . . . . . . . . . UnaryExpr (
    4:  9: . . . . . . . . . . . . . . PrimaryExpr (
    4:  9: . . . . . . . . . . . . . . . Operand (
    4:  9: . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    4: 11: . . . . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . . . . . IndexOrSlice (
    4: 11: . . . . . . . . . . . . . . . . "["
    4: 12: . . . . . . . . . . . . . . . . Expression (
    4: 12: . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 12: . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 12: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 12: . . . . . . . . . . . . . . . . . . . . Operand (
    4: 12: . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    4: 15: . . . . . . . . . . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: P1, Index: int}
    4: 16: . . . . . . . . . . . . . . . )
    4: 16: . . . . . . . . . . . . . . . LiteralValue (
    4: 16: . . . . . . . . . . . . . . . . "{"
    4: 17: . . . . . . . . . . . . . . . . "}"
    4: 18: . . . . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . ","
    4: 20: . . . . . . . . . . . Expression (
    4: 20: . . . . . . . . . . . . BinaryExpr (
    4: 20: . . . . . . . . . . . . . UnaryExpr (
    4: 20: . . . . . . . . . . . . . . PrimaryExpr (
    4: 20: . . . . . . . . . . . . . . . Operand (
    4: 20: . . . . . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    4: 22: . . . . . . . . . . . . . . . )
    4: 22: . . . . . . . . . . . . . . . IndexOrSlice (
    4: 22: . . . . . . . . . . . . . . . . "["
    4: 23: . . . . . . . . . . . . . . . . Expression (
    4: 23: . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 23: . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 23: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 23: . . . . . . . . . . . . . . . . . . . . Operand (
    4: 23: . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    4: 26: . . . . . . . . . . . . . . . . . . . . )
    4: 26: . . . . . . . . . . . . . . . . . . . )
    4: 26: . . . . . . . . . . . . . . . . . . )
    4: 26: . . . . . . . . . . . . . . . . . )
    4: 26: . . . . . . . . . . . . . . . . )
    4: 26: . . . . . . . . . . . . . . . . ","
    4: 28: . . . . . . . . . . . . . . . . Type (
    4: 28: . . . . . . . . . . . . . . . . . TypeName (
    4: 28: . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    4: 34: . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    4: 35: . . . . . . . . . . . . . . . )
    4: 35: . . . . . . . . . . . . . . . LiteralValue (
    4: 35: . . . . . . . . . . . . . . . . "{"
    4: 36: . . . . . . . . . . . . . . . . "}"
    4: 37: . . . . . . . . . . . . . . . )
    4: 37: . . . . . . . . . . . . . . )
    4: 37: . . . . . . . . . . . . . )
    4: 37: . . . . . . . . . . . . )
    4: 37: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    4: 37: . . . . . . . . . . )
    4: 37: . . . . . . . . . )
    4: 37: . . . . . . . . )
    4: 37: . . . . . . . )
    4: 37: . . . . . . )
    4: 37: . . . . . )
    4: 37: . . . . )
    4: 37: . . . . ";"
    5:  1: . . . )
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5:  9: . . . . . . . . . . )
    5:  9: . . . . . . . . . . CallOrConversion (
    5:  9: . . . . . . . . . . . Expression (
    5:  9: . . . . . . . . . . . . BinaryExpr (
    5:  9: . . . . . . . . . . . . . UnaryExpr (
    5:  9: . . . . . . . . . . . . . . PrimaryExpr (
    5:  9: . . . . . . . . . . . . . . . Operand (
    5:  9: . . . . . . . . . . . . . . . . "("
    5: 10: . . . . . . . . . . . . . . . . Expression (
    5: 10: . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 10: . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 10: . . . . . . . . . . . . . . . . . . . "*"
    5: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    5: 13: . . . . . . . . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . . . . . . . . . IndexOrSlice (
    5: 13: . . . . . . . . . . . . . . . . . . . . . . "["
    5: 14: . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 14: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 14: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 14: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: P1, Index: int}
    5: 18: . . . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{136 0xc000214ed0}}
    5: 19: . . . . . . . . . . . . . . . )
    5: 19: . . . . . . . . . . . . . . . CallOrConversion (
    5: 19: . . . . . . . . . . . . . . . . "("
    5: 20: . . . . . . . . . . . . . . . . Expression (
    5: 20: . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 20: . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 20: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 20: . . . . . . . . . . . . . . . . . . . . Operand (
    5: 20: . . . . . . . . . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
    5: 23: . . . . . . . . . . . . . . . . . . . . )
    5: 23: . . . . . . . . . . . . . . . . . . . )
    5: 23: . . . . . . . . . . . . . . . . . . )
    5: 23: . . . . . . . . . . . . . . . . . )
    5: 23: . . . . . . . . . . . . . . . . )
    5: 23: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{135 0xc00020a918 144}, Ellipsis: false, isCmd: false}
    5: 24: . . . . . . . . . . . . . . . )
    5: 24: . . . . . . . . . . . . . . )
    5: 24: . . . . . . . . . . . . . )
    5: 24: . . . . . . . . . . . . )
    5: 24: . . . . . . . . . . . )
    5: 24: . . . . . . . . . . . ","
    5: 26: . . . . . . . . . . . Expression (
    5: 26: . . . . . . . . . . . . BinaryExpr (
    5: 26: . . . . . . . . . . . . . UnaryExpr (
    5: 26: . . . . . . . . . . . . . . PrimaryExpr (
    5: 26: . . . . . . . . . . . . . . . Operand (
    5: 26: . . . . . . . . . . . . . . . . "("
    5: 27: . . . . . . . . . . . . . . . . Expression (
    5: 27: . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 27: . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 27: . . . . . . . . . . . . . . . . . . . "*"
    5: 28: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 28: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 28: . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 28: . . . . . . . . . . . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    5: 30: . . . . . . . . . . . . . . . . . . . . . )
    5: 30: . . . . . . . . . . . . . . . . . . . . . IndexOrSlice (
    5: 30: . . . . . . . . . . . . . . . . . . . . . . "["
    5: 31: . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 31: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 31: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 31: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 34: . . . . . . . . . . . . . . . . . . . . . . )
    5: 34: . . . . . . . . . . . . . . . . . . . . . . ","
    5: 36: . . . . . . . . . . . . . . . . . . . . . . Type (
    5: 36: . . . . . . . . . . . . . . . . . . . . . . . TypeName (
    5: 36: . . . . . . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    5: 42: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 42: . . . . . . . . . . . . . . . . . . . . . . )
    5: 42: . . . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    5: 43: . . . . . . . . . . . . . . . . . . . . . )
    5: 43: . . . . . . . . . . . . . . . . . . . . )
    5: 43: . . . . . . . . . . . . . . . . . . . )
    5: 43: . . . . . . . . . . . . . . . . . . )
    5: 43: . . . . . . . . . . . . . . . . . )
    5: 43: . . . . . . . . . . . . . . . . )
    5: 43: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{153 0xc00020ef00}}
    5: 44: . . . . . . . . . . . . . . . )
    5: 44: . . . . . . . . . . . . . . . CallOrConversion (
    5: 44: . . . . . . . . . . . . . . . . "("
    5: 45: . . . . . . . . . . . . . . . . Expression (
    5: 45: . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 45: . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 45: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 45: . . . . . . . . . . . . . . . . . . . . Operand (
    5: 45: . . . . . . . . . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
    5: 48: . . . . . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{152 0xc00020a960 169}, Ellipsis: false, isCmd: false}
    5: 49: . . . . . . . . . . . . . . . )
    5: 49: . . . . . . . . . . . . . . )
    5: 49: . . . . . . . . . . . . . )
    5: 49: . . . . . . . . . . . . )
    5: 49: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    5: 49: . . . . . . . . . . )
    5: 49: . . . . . . . . . )
    5: 49: . . . . . . . . )
    5: 49: . . . . . . . )
    5: 49: . . . . . . )
    5: 49: . . . . . )
    5: 49: . . . . )
    5: 49: . . . . ";"
    7:  1: . . . )
    7:  1: . . . Statement (
    7:  1: . . . . SimpleStmt (
    7:  1: . . . . . ExpressionList (
    7:  1: . . . . . . Expression (
    7:  1: . . . . . . . BinaryExpr (
    7:  1: . . . . . . . . UnaryExpr (
    7:  1: . . . . . . . . . PrimaryExpr (
    7:  1: . . . . . . . . . . Operand (
    7:  1: . . . . . . . . . . . FuncTypeOrLit (
    7:  1: . . . . . . . . . . . . FuncType (
    7:  1: . . . . . . . . . . . . . "func"
    7:  5: . . . . . . . . . . . . . Signature (
    7:  5: . . . . . . . . . . . . . . Parameters (
    7:  5: . . . . . . . . . . . . . . . "("
    7:  6: . . . . . . . . . . . . . . . ParameterList (
    7:  6: . . . . . . . . . . . . . . . . ParamDeclOrNil (
    7:  6: . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    7:  8: . . . . . . . . . . . . . . . . . Type (
    7:  8: . . . . . . . . . . . . . . . . . . TypeName (
    7:  8: . . . . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    7: 10: . . . . . . . . . . . . . . . . . . )
    7: 10: . . . . . . . . . . . . . . . . . . TypeInstance (
    7: 10: . . . . . . . . . . . . . . . . . . . "["
    7: 11: . . . . . . . . . . . . . . . . . . . Type (
    7: 11: . . . . . . . . . . . . . . . . . . . . TypeName (
    7: 11: . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    7: 14: . . . . . . . . . . . . . . . . . . . . )
    7: 14: . . . . . . . . . . . . . . . . . . . )
    7: 14: . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
    7: 15: . . . . . . . . . . . . . . . . . . )
    7: 15: . . . . . . . . . . . . . . . . . )
    7: 15: . . . . . . . . . . . . . . . . )
    7: 15: . . . . . . . . . . . . . . . . ","
    7: 17: . . . . . . . . . . . . . . . . ParamDeclOrNil (
    7: 17: . . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    7: 19: . . . . . . . . . . . . . . . . . Type (
    7: 19: . . . . . . . . . . . . . . . . . . PointerType (
    7: 19: . . . . . . . . . . . . . . . . . . . "*"
    7: 20: . . . . . . . . . . . . . . . . . . . Type (
    7: 20: . . . . . . . . . . . . . . . . . . . . TypeName (
    7: 20: . . . . . . . . . . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    7: 22: . . . . . . . . . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . . . . . . . . . . TypeInstance (
    7: 22: . . . . . . . . . . . . . . . . . . . . . "["
    7: 23: . . . . . . . . . . . . . . . . . . . . . Type (
    7: 23: . . . . . . . . . . . . . . . . . . . . . . TypeName (
    7: 23: . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    7: 26: . . . . . . . . . . . . . . . . . . . . . . )
    7: 26: . . . . . . . . . . . . . . . . . . . . . )
    7: 26: . . . . . . . . . . . . . . . . . . . . . ","
    7: 28: . . . . . . . . . . . . . . . . . . . . . Type (
    7: 28: . . . . . . . . . . . . . . . . . . . . . . TypeName (
    7: 28: . . . . . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    7: 34: . . . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    7: 35: . . . . . . . . . . . . . . . . . . . . )
    7: 35: . . . . . . . . . . . . . . . . . . . )
    7: 35: . . . . . . . . . . . . . . . . . . )
    7: 35: . . . . . . . . . . . . . . . . . )
    7: 35: . . . . . . . . . . . . . . . . )
    7: 35: . . . . . . . . . . . . . . . )
    7: 35: . . . . . . . . . . . . . . . ")"
    7: 37: . . . . . . . . . . . . . . )
    7: 37: . . . . . . . . . . . . . . Result (
    7: 37: . . . . . . . . . . . . . . . PointerType (
    7: 37: . . . . . . . . . . . . . . . . "*"
    7: 38: . . . . . . . . . . . . . . . . Type (
    7: 38: . . . . . . . . . . . . . . . . . TypeName (
    7: 38: . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    7: 42: . . . . . . . . . . . . . . . . . )
    7: 42: . . . . . . . . . . . . . . . . )
    7: 42: . . . . . . . . . . . . . . . )
    7: 42: . . . . . . . . . . . . . . )
    7: 42: . . . . . . . . . . . . . )
    7: 42: . . . . . . . . . . . . )
    7: 42: . . . . . . . . . . . . Body (
    7: 42: . . . . . . . . . . . . . "{"
    8:  2: . . . . . . . . . . . . . StatementList (
    8:  2: . . . . . . . . . . . . . . Statement (
    8:  2: . . . . . . . . . . . . . . . ReturnStmt (
    8:  2: . . . . . . . . . . . . . . . . "return"
    8:  9: . . . . . . . . . . . . . . . . ExpressionList (
    8:  9: . . . . . . . . . . . . . . . . . Expression (
    8:  9: . . . . . . . . . . . . . . . . . . BinaryExpr (
    8:  9: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    8:  9: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    8:  9: . . . . . . . . . . . . . . . . . . . . . Operand (
    8:  9: . . . . . . . . . . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
    8: 12: . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . ";"
    9:  1: . . . . . . . . . . . . . . . )
    9:  1: . . . . . . . . . . . . . . )
    9:  1: . . . . . . . . . . . . . )
    9:  1: . . . . . . . . . . . . . "}"
    9:  2: . . . . . . . . . . . . )
    9:  2: . . . . . . . . . . . )
    9:  2: . . . . . . . . . . )
    9:  2: . . . . . . . . . . CallOrConversion (
    9:  2: . . . . . . . . . . . "("
    9:  3: . . . . . . . . . . . Expression (
    9:  3: . . . . . . . . . . . . BinaryExpr (
    9:  3: . . . . . . . . . . . . . UnaryExpr (
    9:  3: . . . . . . . . . . . . . . PrimaryExpr (
    9:  3: . . . . . . . . . . . . . . . Operand (
    9:  3: . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
    9:  5: . . . . . . . . . . . . . . . )
    9:  5: . . . . . . . . . . . . . . . IndexOrSlice (
    9:  5: . . . . . . . . . . . . . . . . "["
    9:  6: . . . . . . . . . . . . . . . . Expression (
    9:  6: . . . . . . . . . . . . . . . . . BinaryExpr (
    9:  6: . . . . . . . . . . . . . . . . . . UnaryExpr (
    9:  6: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    9:  6: . . . . . . . . . . . . . . . . . . . . Operand (
    9:  6: . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    9:  9: . . . . . . . . . . . . . . . . . . . . )
    9:  9: . . . . . . . . . . . . . . . . . . . )
    9:  9: . . . . . . . . . . . . . . . . . . )
    9:  9: . . . . . . . . . . . . . . . . . )
    9:  9: . . . . . . . . . . . . . . . . )
    9:  9: . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: P1, Index: int}
    9: 10: . . . . . . . . . . . . . . . )
    9: 10: . . . . . . . . . . . . . . . LiteralValue (
    9: 10: . . . . . . . . . . . . . . . . "{"
    9: 11: . . . . . . . . . . . . . . . . ElementList (
    9: 11: . . . . . . . . . . . . . . . . . Element (
    9: 11: . . . . . . . . . . . . . . . . . . Element (
    9: 11: . . . . . . . . . . . . . . . . . . . Expression (
    9: 11: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    9: 11: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    9: 11: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 11: . . . . . . . . . . . . . . . . . . . . . . . Operand (
    9: 11: . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    9: 12: . . . . . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . "}"
    9: 13: . . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . ","
    9: 15: . . . . . . . . . . . Expression (
    9: 15: . . . . . . . . . . . . BinaryExpr (
    9: 15: . . . . . . . . . . . . . UnaryExpr (
    9: 15: . . . . . . . . . . . . . . "&"
    9: 16: . . . . . . . . . . . . . . UnaryExpr (
    9: 16: . . . . . . . . . . . . . . . PrimaryExpr (
    9: 16: . . . . . . . . . . . . . . . . Operand (
    9: 16: . . . . . . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
    9: 18: . . . . . . . . . . . . . . . . )
    9: 18: . . . . . . . . . . . . . . . . IndexOrSlice (
    9: 18: . . . . . . . . . . . . . . . . . "["
    9: 19: . . . . . . . . . . . . . . . . . Expression (
    9: 19: . . . . . . . . . . . . . . . . . . BinaryExpr (
    9: 19: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    9: 19: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 19: . . . . . . . . . . . . . . . . . . . . . Operand (
    9: 19: . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    9: 22: . . . . . . . . . . . . . . . . . . . . . )
    9: 22: . . . . . . . . . . . . . . . . . . . . )
    9: 22: . . . . . . . . . . . . . . . . . . . )
    9: 22: . . . . . . . . . . . . . . . . . . )
    9: 22: . . . . . . . . . . . . . . . . . )
    9: 22: . . . . . . . . . . . . . . . . . ","
    9: 24: . . . . . . . . . . . . . . . . . Type (
    9: 24: . . . . . . . . . . . . . . . . . . TypeName (
    9: 24: . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    9: 30: . . . . . . . . . . . . . . . . . . )
    9: 30: . . . . . . . . . . . . . . . . . )
    9: 30: . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
    9: 31: . . . . . . . . . . . . . . . . )
    9: 31: . . . . . . . . . . . . . . . . LiteralValue (
    9: 31: . . . . . . . . . . . . . . . . . "{"
    9: 32: . . . . . . . . . . . . . . . . . "}"
    9: 33: . . . . . . . . . . . . . . . . )
    9: 33: . . . . . . . . . . . . . . . )
    9: 33: . . . . . . . . . . . . . . )
    9: 33: . . . . . . . . . . . . . )
    9: 33: . . . . . . . . . . . . )
    9: 33: . . . . . . . . . . . )
    9: 33: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{0xc0002097e0 0xc000215020}, Ellipsis: false, isCmd: false}
    9: 34: . . . . . . . . . . )
    9: 34: . . . . . . . . . )
    9: 34: . . . . . . . . )
    9: 34: . . . . . . . )
    9: 34: . . . . . . )
    9: 34: . . . . . )
    9: 34: . . . . )
    9: 34: . . . . ";"
   11:  1: . . . )
   11:  1: . . . Statement (
   11:  1: . . . . SimpleStmt (
   11:  1: . . . . . ExpressionList (
   11:  1: . . . . . . Expression (
   11:  1: . . . . . . . BinaryExpr (
   11:  1: . . . . . . . . UnaryExpr (
   11:  1: . . . . . . . . . PrimaryExpr (
   11:  1: . . . . . . . . . . Operand (
   11:  1: . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   11:  4: . . . . . . . . . . )
   11:  4: . . . . . . . . . . CallOrConversion (
   11:  4: . . . . . . . . . . . "("
   11:  5: . . . . . . . . . . . Expression (
   11:  5: . . . . . . . . . . . . "=>"
   11:  8: . . . . . . . . . . . . Expression (
   11:  8: . . . . . . . . . . . . . BinaryExpr (
   11:  8: . . . . . . . . . . . . . . UnaryExpr (
   11:  8: . . . . . . . . . . . . . . . PrimaryExpr (
   11:  8: . . . . . . . . . . . . . . . . Operand (
   11:  8: . . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   11: 10: . . . . . . . . . . . . . . . . )
   11: 10: . . . . . . . . . . . . . . . . IndexOrSlice (
   11: 10: . . . . . . . . . . . . . . . . . "["
   11: 11: . . . . . . . . . . . . . . . . . Expression (
   11: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
   11: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   11: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
   11: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   11: 14: . . . . . . . . . . . . . . . . . . . . . )
   11: 14: . . . . . . . . . . . . . . . . . . . . )
   11: 14: . . . . . . . . . . . . . . . . . . . )
   11: 14: . . . . . . . . . . . . . . . . . . )
   11: 14: . . . . . . . . . . . . . . . . . )
   11: 14: . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: P1, Index: int}
   11: 15: . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . LiteralValue (
   11: 15: . . . . . . . . . . . . . . . . . "{"
   11: 16: . . . . . . . . . . . . . . . . . ElementList (
   11: 16: . . . . . . . . . . . . . . . . . . Element (
   11: 16: . . . . . . . . . . . . . . . . . . . Element (
   11: 16: . . . . . . . . . . . . . . . . . . . . Expression (
   11: 16: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   11: 16: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   11: 16: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 16: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   11: 16: . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   11: 17: . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . . . "}"
   11: 18: . . . . . . . . . . . . . . . . )
   11: 18: . . . . . . . . . . . . . . . )
   11: 18: . . . . . . . . . . . . . . )
   11: 18: . . . . . . . . . . . . . )
   11: 18: . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
   11: 18: . . . . . . . . . . . )
   11: 18: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
   11: 19: . . . . . . . . . . )
   11: 19: . . . . . . . . . )
   11: 19: . . . . . . . . )
   11: 19: . . . . . . . )
   11: 19: . . . . . . )
   11: 19: . . . . . )
   11: 19: . . . . )
   11: 19: . . . . ";"
   12:  1: . . . )
   12:  1: . . . Statement (
   12:  1: . . . . SimpleStmt (
   12:  1: . . . . . ExpressionList (
   12:  1: . . . . . . Expression (
   12:  1: . . . . . . . BinaryExpr (
   12:  1: . . . . . . . . UnaryExpr (
   12:  1: . . . . . . . . . PrimaryExpr (
   12:  1: . . . . . . . . . . Operand (
   12:  1: . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   12:  4: . . . . . . . . . . )
   12:  4: . . . . . . . . . . CallOrConversion (
   12:  4: . . . . . . . . . . . "("
   12:  5: . . . . . . . . . . . Expression (
   12:  5: . . . . . . . . . . . . "=>"
   12:  8: . . . . . . . . . . . . BlockStmt (
   12:  8: . . . . . . . . . . . . . "{"
   13:  2: . . . . . . . . . . . . . StatementList (
   13:  2: . . . . . . . . . . . . . . Statement (
   13:  2: . . . . . . . . . . . . . . . SimpleStmt (
   13:  2: . . . . . . . . . . . . . . . . ExpressionList (
   13:  2: . . . . . . . . . . . . . . . . . Expression (
   13:  2: . . . . . . . . . . . . . . . . . . BinaryExpr (
   13:  2: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   13:  2: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13:  2: . . . . . . . . . . . . . . . . . . . . . Operand (
   13:  2: . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   13:  9: . . . . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
   13:  9: . . . . . . . . . . . . . . . . . . . . . . "("
   13: 10: . . . . . . . . . . . . . . . . . . . . . . Expression (
   13: 10: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 10: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 10: . . . . . . . . . . . . . . . . . . . . . . . . . "&"
   13: 11: . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   13: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
   13: 13: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . . . . . . . . . . . . . . . . . IndexOrSlice (
   13: 13: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "["
   13: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   13: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   13: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   13: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ","
   13: 19: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Type (
   13: 19: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . TypeName (
   13: 19: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   13: 25: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 25: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 25: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
   13: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . LiteralValue (
   13: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "{"
   13: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "}"
   13: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . . . . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . . . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   13: 29: . . . . . . . . . . . . . . . . . . . . . )
   13: 29: . . . . . . . . . . . . . . . . . . . . )
   13: 29: . . . . . . . . . . . . . . . . . . . )
   13: 29: . . . . . . . . . . . . . . . . . . )
   13: 29: . . . . . . . . . . . . . . . . . )
   13: 29: . . . . . . . . . . . . . . . . )
   13: 29: . . . . . . . . . . . . . . . )
   13: 29: . . . . . . . . . . . . . . . ";"
   14:  1: . . . . . . . . . . . . . . )
   14:  1: . . . . . . . . . . . . . )
   14:  1: . . . . . . . . . . . . . "}"
   14:  2: . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
   14:  2: . . . . . . . . . . . )
   14:  2: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
   14:  3: . . . . . . . . . . )
   14:  3: . . . . . . . . . )
   14:  3: . . . . . . . . )
   14:  3: . . . . . . . )
   14:  3: . . . . . . )
   14:  3: . . . . . )
   14:  3: . . . . )
   14:  3: . . . . ";"
   16:  1: . . . )
   16:  1: . . . Statement (
   16:  1: . . . . SimpleStmt (
   16:  1: . . . . . ExpressionList (
   16:  1: . . . . . . Expression (
   16:  1: . . . . . . . BinaryExpr (
   16:  1: . . . . . . . . UnaryExpr (
   16:  1: . . . . . . . . . PrimaryExpr (
   16:  1: . . . . . . . . . . Operand (
   16:  1: . . . . . . . . . . . IDENT fn1
 /app/parser/parser.go:713: ast.Ident{Name: fn1}
   16:  4: . . . . . . . . . . )
   16:  4: . . . . . . . . . . IndexOrSlice (
   16:  4: . . . . . . . . . . . "["
   16:  5: . . . . . . . . . . . Expression (
   16:  5: . . . . . . . . . . . . BinaryExpr (
   16:  5: . . . . . . . . . . . . . UnaryExpr (
   16:  5: . . . . . . . . . . . . . . PrimaryExpr (
   16:  5: . . . . . . . . . . . . . . . Operand (
   16:  5: . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   16:  8: . . . . . . . . . . . . . . . )
   16:  8: . . . . . . . . . . . . . . )
   16:  8: . . . . . . . . . . . . . )
   16:  8: . . . . . . . . . . . . )
   16:  8: . . . . . . . . . . . )
   16:  8: . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: fn1, Index: int}
   16:  9: . . . . . . . . . . )
   16:  9: . . . . . . . . . . CallOrConversion (
   16:  9: . . . . . . . . . . . "("
   16: 10: . . . . . . . . . . . Expression (
   16: 10: . . . . . . . . . . . . BinaryExpr (
   16: 10: . . . . . . . . . . . . . UnaryExpr (
   16: 10: . . . . . . . . . . . . . . PrimaryExpr (
   16: 10: . . . . . . . . . . . . . . . Operand (
   16: 10: . . . . . . . . . . . . . . . . ArrayType (
   16: 10: . . . . . . . . . . . . . . . . . "["
   16: 11: . . . . . . . . . . . . . . . . . "]"
   16: 12: . . . . . . . . . . . . . . . . . TypeName (
   16: 12: . . . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   16: 14: . . . . . . . . . . . . . . . . . )
   16: 14: . . . . . . . . . . . . . . . . . TypeInstance (
   16: 14: . . . . . . . . . . . . . . . . . . "["
   16: 15: . . . . . . . . . . . . . . . . . . Type (
   16: 15: . . . . . . . . . . . . . . . . . . . TypeName (
   16: 15: . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   16: 18: . . . . . . . . . . . . . . . . . . . )
   16: 18: . . . . . . . . . . . . . . . . . . )
   16: 18: . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2080: ast.IndexExpr{X: P1, Index: int}
   16: 19: . . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: &{P1 341 int 345}}
   16: 19: . . . . . . . . . . . . . . . . )
   16: 19: . . . . . . . . . . . . . . . )
   16: 19: . . . . . . . . . . . . . . . LiteralValue (
   16: 19: . . . . . . . . . . . . . . . . "{"
   16: 20: . . . . . . . . . . . . . . . . ElementList (
   16: 20: . . . . . . . . . . . . . . . . . Element (
   16: 20: . . . . . . . . . . . . . . . . . . Element (
   16: 20: . . . . . . . . . . . . . . . . . . . Expression (
   16: 20: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   16: 20: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   16: 20: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   16: 20: . . . . . . . . . . . . . . . . . . . . . . . Operand (
   16: 20: . . . . . . . . . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   16: 22: . . . . . . . . . . . . . . . . . . . . . . . )
   16: 22: . . . . . . . . . . . . . . . . . . . . . . . IndexOrSlice (
   16: 22: . . . . . . . . . . . . . . . . . . . . . . . . "["
   16: 23: . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   16: 23: . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   16: 23: . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   16: 23: . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   16: 23: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   16: 23: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   16: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 26: . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 26: . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 26: . . . . . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: P1, Index: int}
   16: 27: . . . . . . . . . . . . . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . . . . . . . . . . . . . LiteralValue (
   16: 27: . . . . . . . . . . . . . . . . . . . . . . . . "{"
   16: 28: . . . . . . . . . . . . . . . . . . . . . . . . ElementList (
   16: 28: . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   16: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   16: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   16: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   16: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   16: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   16: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   16: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   16: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 29: . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 29: . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 29: . . . . . . . . . . . . . . . . . . . . . . . . "}"
   16: 30: . . . . . . . . . . . . . . . . . . . . . . . )
   16: 30: . . . . . . . . . . . . . . . . . . . . . . )
   16: 30: . . . . . . . . . . . . . . . . . . . . . )
   16: 30: . . . . . . . . . . . . . . . . . . . . )
   16: 30: . . . . . . . . . . . . . . . . . . . )
   16: 30: . . . . . . . . . . . . . . . . . . )
   16: 30: . . . . . . . . . . . . . . . . . )
   16: 30: . . . . . . . . . . . . . . . . . ","
   16: 32: . . . . . . . . . . . . . . . . . Element (
   16: 32: . . . . . . . . . . . . . . . . . . Element (
   16: 32: . . . . . . . . . . . . . . . . . . . Expression (
   16: 32: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   16: 32: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   16: 32: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   16: 32: . . . . . . . . . . . . . . . . . . . . . . . Operand (
   16: 32: . . . . . . . . . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   16: 34: . . . . . . . . . . . . . . . . . . . . . . . )
   16: 34: . . . . . . . . . . . . . . . . . . . . . . . IndexOrSlice (
   16: 34: . . . . . . . . . . . . . . . . . . . . . . . . "["
   16: 35: . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   16: 35: . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   16: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   16: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   16: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   16: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   16: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 38: . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 38: . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 38: . . . . . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: P1, Index: int}
   16: 39: . . . . . . . . . . . . . . . . . . . . . . . )
   16: 39: . . . . . . . . . . . . . . . . . . . . . . . LiteralValue (
   16: 39: . . . . . . . . . . . . . . . . . . . . . . . . "{"
   16: 40: . . . . . . . . . . . . . . . . . . . . . . . . ElementList (
   16: 40: . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   16: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   16: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   16: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   16: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   16: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   16: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   16: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   16: 41: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 41: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 41: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 41: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 41: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 41: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 41: . . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 41: . . . . . . . . . . . . . . . . . . . . . . . . )
   16: 41: . . . . . . . . . . . . . . . . . . . . . . . . "}"
   16: 42: . . . . . . . . . . . . . . . . . . . . . . . )
   16: 42: . . . . . . . . . . . . . . . . . . . . . . )
   16: 42: . . . . . . . . . . . . . . . . . . . . . )
   16: 42: . . . . . . . . . . . . . . . . . . . . )
   16: 42: . . . . . . . . . . . . . . . . . . . )
   16: 42: . . . . . . . . . . . . . . . . . . )
   16: 42: . . . . . . . . . . . . . . . . . )
   16: 42: . . . . . . . . . . . . . . . . )
   16: 42: . . . . . . . . . . . . . . . . "}"
   16: 43: . . . . . . . . . . . . . . . )
   16: 43: . . . . . . . . . . . . . . )
   16: 43: . . . . . . . . . . . . . )
   16: 43: . . . . . . . . . . . . )
   16: 43: . . . . . . . . . . . )
   16: 43: . . . . . . . . . . . ","
   16: 45: . . . . . . . . . . . Expression (
   16: 45: . . . . . . . . . . . . BinaryExpr (
   16: 45: . . . . . . . . . . . . . UnaryExpr (
   16: 45: . . . . . . . . . . . . . . "&"
   16: 46: . . . . . . . . . . . . . . UnaryExpr (
   16: 46: . . . . . . . . . . . . . . . PrimaryExpr (
   16: 46: . . . . . . . . . . . . . . . . Operand (
   16: 46: . . . . . . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
   16: 48: . . . . . . . . . . . . . . . . )
   16: 48: . . . . . . . . . . . . . . . . IndexOrSlice (
   16: 48: . . . . . . . . . . . . . . . . . "["
   16: 49: . . . . . . . . . . . . . . . . . Expression (
   16: 49: . . . . . . . . . . . . . . . . . . BinaryExpr (
   16: 49: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   16: 49: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   16: 49: . . . . . . . . . . . . . . . . . . . . . Operand (
   16: 49: . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   16: 52: . . . . . . . . . . . . . . . . . . . . . )
   16: 52: . . . . . . . . . . . . . . . . . . . . )
   16: 52: . . . . . . . . . . . . . . . . . . . )
   16: 52: . . . . . . . . . . . . . . . . . . )
   16: 52: . . . . . . . . . . . . . . . . . )
   16: 52: . . . . . . . . . . . . . . . . . ","
   16: 54: . . . . . . . . . . . . . . . . . Type (
   16: 54: . . . . . . . . . . . . . . . . . . TypeName (
   16: 54: . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   16: 60: . . . . . . . . . . . . . . . . . . )
   16: 60: . . . . . . . . . . . . . . . . . )
   16: 60: . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
   16: 61: . . . . . . . . . . . . . . . . )
   16: 61: . . . . . . . . . . . . . . . . LiteralValue (
   16: 61: . . . . . . . . . . . . . . . . . "{"
   16: 62: . . . . . . . . . . . . . . . . . "}"
   16: 63: . . . . . . . . . . . . . . . . )
   16: 63: . . . . . . . . . . . . . . . )
   16: 63: . . . . . . . . . . . . . . )
   16: 63: . . . . . . . . . . . . . )
   16: 63: . . . . . . . . . . . . )
   16: 63: . . . . . . . . . . . )
   16: 63: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn1 331 int 335}, Ellipsis: false, isCmd: false}
   16: 64: . . . . . . . . . . )
   16: 64: . . . . . . . . . )
   16: 64: . . . . . . . . )
   16: 64: . . . . . . . )
   16: 64: . . . . . . )
   16: 64: . . . . . )
   16: 64: . . . . )
   16: 64: . . . . ";"
   17:  1: . . . )
   17:  1: . . . Statement (
   17:  1: . . . . SimpleStmt (
   17:  1: . . . . . ExpressionList (
   17:  1: . . . . . . Expression (
   17:  1: . . . . . . . BinaryExpr (
   17:  1: . . . . . . . . UnaryExpr (
   17:  1: . . . . . . . . . PrimaryExpr (
   17:  1: . . . . . . . . . . Operand (
   17:  1: . . . . . . . . . . . IDENT fn2
 /app/parser/parser.go:713: ast.Ident{Name: fn2}
   17:  4: . . . . . . . . . . )
   17:  4: . . . . . . . . . . IndexOrSlice (
   17:  4: . . . . . . . . . . . "["
   17:  5: . . . . . . . . . . . Expression (
   17:  5: . . . . . . . . . . . . BinaryExpr (
   17:  5: . . . . . . . . . . . . . UnaryExpr (
   17:  5: . . . . . . . . . . . . . . PrimaryExpr (
   17:  5: . . . . . . . . . . . . . . . Operand (
   17:  5: . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   17:  8: . . . . . . . . . . . . . . . )
   17:  8: . . . . . . . . . . . . . . )
   17:  8: . . . . . . . . . . . . . )
   17:  8: . . . . . . . . . . . . )
   17:  8: . . . . . . . . . . . )
   17:  8: . . . . . . . . . . . ","
   17: 10: . . . . . . . . . . . Type (
   17: 10: . . . . . . . . . . . . TypeName (
   17: 10: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   17: 16: . . . . . . . . . . . . )
   17: 16: . . . . . . . . . . . )
   17: 16: . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: fn2, Index: [int string]}
   17: 17: . . . . . . . . . . )
   17: 17: . . . . . . . . . . CallOrConversion (
   17: 17: . . . . . . . . . . . "("
   17: 18: . . . . . . . . . . . Expression (
   17: 18: . . . . . . . . . . . . BinaryExpr (
   17: 18: . . . . . . . . . . . . . UnaryExpr (
   17: 18: . . . . . . . . . . . . . . "&"
   17: 19: . . . . . . . . . . . . . . UnaryExpr (
   17: 19: . . . . . . . . . . . . . . . PrimaryExpr (
   17: 19: . . . . . . . . . . . . . . . . Operand (
   17: 19: . . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   17: 21: . . . . . . . . . . . . . . . . )
   17: 21: . . . . . . . . . . . . . . . . IndexOrSlice (
   17: 21: . . . . . . . . . . . . . . . . . "["
   17: 22: . . . . . . . . . . . . . . . . . Expression (
   17: 22: . . . . . . . . . . . . . . . . . . BinaryExpr (
   17: 22: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   17: 22: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   17: 22: . . . . . . . . . . . . . . . . . . . . . Operand (
   17: 22: . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   17: 25: . . . . . . . . . . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: P1, Index: int}
   17: 26: . . . . . . . . . . . . . . . . )
   17: 26: . . . . . . . . . . . . . . . . LiteralValue (
   17: 26: . . . . . . . . . . . . . . . . . "{"
   17: 27: . . . . . . . . . . . . . . . . . "}"
   17: 28: . . . . . . . . . . . . . . . . )
   17: 28: . . . . . . . . . . . . . . . )
   17: 28: . . . . . . . . . . . . . . )
   17: 28: . . . . . . . . . . . . . )
   17: 28: . . . . . . . . . . . . )
   17: 28: . . . . . . . . . . . )
   17: 28: . . . . . . . . . . . ","
   17: 30: . . . . . . . . . . . Expression (
   17: 30: . . . . . . . . . . . . BinaryExpr (
   17: 30: . . . . . . . . . . . . . UnaryExpr (
   17: 30: . . . . . . . . . . . . . . "&"
   17: 31: . . . . . . . . . . . . . . UnaryExpr (
   17: 31: . . . . . . . . . . . . . . . PrimaryExpr (
   17: 31: . . . . . . . . . . . . . . . . Operand (
   17: 31: . . . . . . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
   17: 33: . . . . . . . . . . . . . . . . )
   17: 33: . . . . . . . . . . . . . . . . IndexOrSlice (
   17: 33: . . . . . . . . . . . . . . . . . "["
   17: 34: . . . . . . . . . . . . . . . . . Expression (
   17: 34: . . . . . . . . . . . . . . . . . . BinaryExpr (
   17: 34: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   17: 34: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   17: 34: . . . . . . . . . . . . . . . . . . . . . Operand (
   17: 34: . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   17: 37: . . . . . . . . . . . . . . . . . . . . . )
   17: 37: . . . . . . . . . . . . . . . . . . . . )
   17: 37: . . . . . . . . . . . . . . . . . . . )
   17: 37: . . . . . . . . . . . . . . . . . . )
   17: 37: . . . . . . . . . . . . . . . . . )
   17: 37: . . . . . . . . . . . . . . . . . ","
   17: 39: . . . . . . . . . . . . . . . . . Type (
   17: 39: . . . . . . . . . . . . . . . . . . TypeName (
   17: 39: . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   17: 45: . . . . . . . . . . . . . . . . . . )
   17: 45: . . . . . . . . . . . . . . . . . )
   17: 45: . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
   17: 46: . . . . . . . . . . . . . . . . )
   17: 46: . . . . . . . . . . . . . . . . LiteralValue (
   17: 46: . . . . . . . . . . . . . . . . . "{"
   17: 47: . . . . . . . . . . . . . . . . . "}"
   17: 48: . . . . . . . . . . . . . . . . )
   17: 48: . . . . . . . . . . . . . . . )
   17: 48: . . . . . . . . . . . . . . )
   17: 48: . . . . . . . . . . . . . )
   17: 48: . . . . . . . . . . . . )
   17: 48: . . . . . . . . . . . )
   17: 48: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn2 395 [int string] 407}, Ellipsis: false, isCmd: false}
   17: 49: . . . . . . . . . . )
   17: 49: . . . . . . . . . )
   17: 49: . . . . . . . . )
   17: 49: . . . . . . . )
   17: 49: . . . . . . )
   17: 49: . . . . . )
   17: 49: . . . . )
   17: 49: . . . . ";"
   19:  1: . . . )
   19:  1: . . . Statement (
   19:  1: . . . . SimpleStmt (
   19:  1: . . . . . ExpressionList (
   19:  1: . . . . . . Expression (
   19:  1: . . . . . . . BinaryExpr (
   19:  1: . . . . . . . . UnaryExpr (
   19:  1: . . . . . . . . . PrimaryExpr (
   19:  1: . . . . . . . . . . Operand (
   19:  1: . . . . . . . . . . . IDENT foo1
 /app/parser/parser.go:713: ast.Ident{Name: foo1}
   19:  5: . . . . . . . . . . )
   19:  5: . . . . . . . . . . IndexOrSlice (
   19:  5: . . . . . . . . . . . "["
   19:  6: . . . . . . . . . . . Expression (
   19:  6: . . . . . . . . . . . . BinaryExpr (
   19:  6: . . . . . . . . . . . . . UnaryExpr (
   19:  6: . . . . . . . . . . . . . . PrimaryExpr (
   19:  6: . . . . . . . . . . . . . . . Operand (
   19:  6: . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   19:  9: . . . . . . . . . . . . . . . )
   19:  9: . . . . . . . . . . . . . . )
   19:  9: . . . . . . . . . . . . . )
   19:  9: . . . . . . . . . . . . )
   19:  9: . . . . . . . . . . . )
   19:  9: . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: foo1, Index: int}
   19: 10: . . . . . . . . . . )
   19: 10: . . . . . . . . . . CallOrConversion (
   19: 10: . . . . . . . . . . . "("
   19: 11: . . . . . . . . . . . Expression (
   19: 11: . . . . . . . . . . . . "=>"
   19: 14: . . . . . . . . . . . . Expression (
   19: 14: . . . . . . . . . . . . . BinaryExpr (
   19: 14: . . . . . . . . . . . . . . UnaryExpr (
   19: 14: . . . . . . . . . . . . . . . PrimaryExpr (
   19: 14: . . . . . . . . . . . . . . . . Operand (
   19: 14: . . . . . . . . . . . . . . . . . IDENT P1
 /app/parser/parser.go:713: ast.Ident{Name: P1}
   19: 16: . . . . . . . . . . . . . . . . )
   19: 16: . . . . . . . . . . . . . . . . IndexOrSlice (
   19: 16: . . . . . . . . . . . . . . . . . "["
   19: 17: . . . . . . . . . . . . . . . . . Expression (
   19: 17: . . . . . . . . . . . . . . . . . . BinaryExpr (
   19: 17: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   19: 17: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   19: 17: . . . . . . . . . . . . . . . . . . . . . Operand (
   19: 17: . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   19: 20: . . . . . . . . . . . . . . . . . . . . . )
   19: 20: . . . . . . . . . . . . . . . . . . . . )
   19: 20: . . . . . . . . . . . . . . . . . . . )
   19: 20: . . . . . . . . . . . . . . . . . . )
   19: 20: . . . . . . . . . . . . . . . . . )
   19: 20: . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: P1, Index: int}
   19: 21: . . . . . . . . . . . . . . . . )
   19: 21: . . . . . . . . . . . . . . . . LiteralValue (
   19: 21: . . . . . . . . . . . . . . . . . "{"
   19: 22: . . . . . . . . . . . . . . . . . ElementList (
   19: 22: . . . . . . . . . . . . . . . . . . Element (
   19: 22: . . . . . . . . . . . . . . . . . . . Element (
   19: 22: . . . . . . . . . . . . . . . . . . . . Expression (
   19: 22: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   19: 22: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   19: 22: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   19: 22: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   19: 22: . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   19: 23: . . . . . . . . . . . . . . . . . . . . . . . . )
   19: 23: . . . . . . . . . . . . . . . . . . . . . . . )
   19: 23: . . . . . . . . . . . . . . . . . . . . . . )
   19: 23: . . . . . . . . . . . . . . . . . . . . . )
   19: 23: . . . . . . . . . . . . . . . . . . . . )
   19: 23: . . . . . . . . . . . . . . . . . . . )
   19: 23: . . . . . . . . . . . . . . . . . . )
   19: 23: . . . . . . . . . . . . . . . . . )
   19: 23: . . . . . . . . . . . . . . . . . "}"
   19: 24: . . . . . . . . . . . . . . . . )
   19: 24: . . . . . . . . . . . . . . . )
   19: 24: . . . . . . . . . . . . . . )
   19: 24: . . . . . . . . . . . . . )
   19: 24: . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
   19: 24: . . . . . . . . . . . )
   19: 24: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{foo1 446 int 450}, Ellipsis: false, isCmd: false}
   19: 25: . . . . . . . . . . )
   19: 25: . . . . . . . . . )
   19: 25: . . . . . . . . )
   19: 25: . . . . . . . )
   19: 25: . . . . . . )
   19: 25: . . . . . )
   19: 25: . . . . )
   19: 25: . . . . ";"
   20:  1: . . . )
   20:  1: . . . Statement (
   20:  1: . . . . SimpleStmt (
   20:  1: . . . . . ExpressionList (
   20:  1: . . . . . . Expression (
   20:  1: . . . . . . . BinaryExpr (
   20:  1: . . . . . . . . UnaryExpr (
   20:  1: . . . . . . . . . PrimaryExpr (
   20:  1: . . . . . . . . . . Operand (
   20:  1: . . . . . . . . . . . IDENT foo2
 /app/parser/parser.go:713: ast.Ident{Name: foo2}
   20:  5: . . . . . . . . . . )
   20:  5: . . . . . . . . . . IndexOrSlice (
   20:  5: . . . . . . . . . . . "["
   20:  6: . . . . . . . . . . . Expression (
   20:  6: . . . . . . . . . . . . BinaryExpr (
   20:  6: . . . . . . . . . . . . . UnaryExpr (
   20:  6: . . . . . . . . . . . . . . PrimaryExpr (
   20:  6: . . . . . . . . . . . . . . . Operand (
   20:  6: . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   20:  9: . . . . . . . . . . . . . . . )
   20:  9: . . . . . . . . . . . . . . )
   20:  9: . . . . . . . . . . . . . )
   20:  9: . . . . . . . . . . . . )
   20:  9: . . . . . . . . . . . )
   20:  9: . . . . . . . . . . . ","
   20: 11: . . . . . . . . . . . Type (
   20: 11: . . . . . . . . . . . . TypeName (
   20: 11: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   20: 17: . . . . . . . . . . . . )
   20: 17: . . . . . . . . . . . )
   20: 17: . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: foo2, Index: [int string]}
   20: 18: . . . . . . . . . . )
   20: 18: . . . . . . . . . . CallOrConversion (
   20: 18: . . . . . . . . . . . "("
   20: 19: . . . . . . . . . . . Expression (
   20: 19: . . . . . . . . . . . . "=>"
   20: 22: . . . . . . . . . . . . BlockStmt (
   20: 22: . . . . . . . . . . . . . "{"
   21:  2: . . . . . . . . . . . . . StatementList (
   21:  2: . . . . . . . . . . . . . . Statement (
   21:  2: . . . . . . . . . . . . . . . SimpleStmt (
   21:  2: . . . . . . . . . . . . . . . . ExpressionList (
   21:  2: . . . . . . . . . . . . . . . . . Expression (
   21:  2: . . . . . . . . . . . . . . . . . . BinaryExpr (
   21:  2: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   21:  2: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   21:  2: . . . . . . . . . . . . . . . . . . . . . Operand (
   21:  2: . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   21:  9: . . . . . . . . . . . . . . . . . . . . . )
   21:  9: . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
   21:  9: . . . . . . . . . . . . . . . . . . . . . . "("
   21: 10: . . . . . . . . . . . . . . . . . . . . . . Expression (
   21: 10: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   21: 10: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   21: 10: . . . . . . . . . . . . . . . . . . . . . . . . . "&"
   21: 11: . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   21: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   21: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   21: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT P2
 /app/parser/parser.go:713: ast.Ident{Name: P2}
   21: 13: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 13: . . . . . . . . . . . . . . . . . . . . . . . . . . . IndexOrSlice (
   21: 13: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "["
   21: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   21: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   21: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   21: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   21: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   21: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   21: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ","
   21: 19: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Type (
   21: 19: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . TypeName (
   21: 19: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   21: 25: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 25: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 25: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: P2, Index: [int string]}
   21: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . LiteralValue (
   21: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "{"
   21: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "}"
   21: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 28: . . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 28: . . . . . . . . . . . . . . . . . . . . . . . . )
   21: 28: . . . . . . . . . . . . . . . . . . . . . . . )
   21: 28: . . . . . . . . . . . . . . . . . . . . . . )
   21: 28: . . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   21: 29: . . . . . . . . . . . . . . . . . . . . . )
   21: 29: . . . . . . . . . . . . . . . . . . . . )
   21: 29: . . . . . . . . . . . . . . . . . . . )
   21: 29: . . . . . . . . . . . . . . . . . . )
   21: 29: . . . . . . . . . . . . . . . . . )
   21: 29: . . . . . . . . . . . . . . . . )
   21: 29: . . . . . . . . . . . . . . . )
   21: 29: . . . . . . . . . . . . . . . ";"
   22:  1: . . . . . . . . . . . . . . )
   22:  1: . . . . . . . . . . . . . )
   22:  1: . . . . . . . . . . . . . "}"
   22:  2: . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
   22:  2: . . . . . . . . . . . )
   22:  2: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{foo2 471 [int string] 483}, Ellipsis: false, isCmd: false}
   22:  3: . . . . . . . . . . )
   22:  3: . . . . . . . . . )
   22:  3: . . . . . . . . )
   22:  3: . . . . . . . )
   22:  3: . . . . . . )
   22:  3: . . . . . )
   22:  3: . . . . )
   22:  3: . . . . ";"
   22:  4: . . . )
   22:  4: . . )
   22:  4: . )
   22:  4: )
=== RUN   TestFromInstance/instance4
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_instance/instance4
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . . IndexOrSlice (
    1:  3: . . . . . . . . . . . "["
    1:  4: . . . . . . . . . . . Expression (
    1:  4: . . . . . . . . . . . . BinaryExpr (
    1:  4: . . . . . . . . . . . . . UnaryExpr (
    1:  4: . . . . . . . . . . . . . . PrimaryExpr (
    1:  4: . . . . . . . . . . . . . . . Operand (
    1:  4: . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1:  7: . . . . . . . . . . . . . . . )
    1:  7: . . . . . . . . . . . . . . )
    1:  7: . . . . . . . . . . . . . )
    1:  7: . . . . . . . . . . . . )
    1:  7: . . . . . . . . . . . )
    1:  7: . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: fn, Index: int}
    1:  8: . . . . . . . . . . )
    1:  8: . . . . . . . . . . CallOrConversion (
    1:  8: . . . . . . . . . . . "("
    1:  9: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn 3 int 7}, Ellipsis: false, isCmd: false}
    1: 10: . . . . . . . . . . )
    1: 10: . . . . . . . . . )
    1: 10: . . . . . . . . )
    1: 10: . . . . . . . )
    1: 10: . . . . . . )
    1: 10: . . . . . )
    1: 10: . . . . )
    1: 10: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
    2:  3: . . . . . . . . . . )
    2:  3: . . . . . . . . . . IndexOrSlice (
    2:  3: . . . . . . . . . . . "["
    2:  4: . . . . . . . . . . . Expression (
    2:  4: . . . . . . . . . . . . BinaryExpr (
    2:  4: . . . . . . . . . . . . . UnaryExpr (
    2:  4: . . . . . . . . . . . . . . PrimaryExpr (
    2:  4: . . . . . . . . . . . . . . . Operand (
    2:  4: . . . . . . . . . . . . . . . . ArrayType (
    2:  4: . . . . . . . . . . . . . . . . . "["
    2:  5: . . . . . . . . . . . . . . . . . "]"
    2:  6: . . . . . . . . . . . . . . . . . TypeName (
    2:  6: . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    2:  9: . . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: int}
    2:  9: . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: fn, Index: &{14 <nil> int}}
    2: 10: . . . . . . . . . . )
    2: 10: . . . . . . . . . . CallOrConversion (
    2: 10: . . . . . . . . . . . "("
    2: 11: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn 13 0xc0002157a0 19}, Ellipsis: false, isCmd: false}
    2: 12: . . . . . . . . . . )
    2: 12: . . . . . . . . . )
    2: 12: . . . . . . . . )
    2: 12: . . . . . . . )
    2: 12: . . . . . . )
    2: 12: . . . . . )
    2: 12: . . . . )
    2: 12: . . . . ";"
    3:  1: . . . )
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
    3:  3: . . . . . . . . . . )
    3:  3: . . . . . . . . . . IndexOrSlice (
    3:  3: . . . . . . . . . . . "["
    3:  4: . . . . . . . . . . . Expression (
    3:  4: . . . . . . . . . . . . BinaryExpr (
    3:  4: . . . . . . . . . . . . . UnaryExpr (
    3:  4: . . . . . . . . . . . . . . PrimaryExpr (
    3:  4: . . . . . . . . . . . . . . . Operand (
    3:  4: . . . . . . . . . . . . . . . . StructType (
    3:  4: . . . . . . . . . . . . . . . . . "struct"
    3: 11: . . . . . . . . . . . . . . . . . "{"
    4:  2: . . . . . . . . . . . . . . . . . FieldDecl (
    4:  2: . . . . . . . . . . . . . . . . . . IDENT X
 /app/parser/parser.go:713: ast.Ident{Name: X}
    4:  4: . . . . . . . . . . . . . . . . . . Type (
    4:  4: . . . . . . . . . . . . . . . . . . . TypeName (
    4:  4: . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    4:  7: . . . . . . . . . . . . . . . . . . . )
    4:  7: . . . . . . . . . . . . . . . . . . )
    4:  7: . . . . . . . . . . . . . . . . . . ";"
    5:  2: . . . . . . . . . . . . . . . . . )
    5:  2: . . . . . . . . . . . . . . . . . FieldDecl (
    5:  2: . . . . . . . . . . . . . . . . . . IDENT Y
 /app/parser/parser.go:713: ast.Ident{Name: Y}
    5:  4: . . . . . . . . . . . . . . . . . . Type (
    5:  4: . . . . . . . . . . . . . . . . . . . TypeName (
    5:  4: . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5:  7: . . . . . . . . . . . . . . . . . . . )
    5:  7: . . . . . . . . . . . . . . . . . . )
    5:  7: . . . . . . . . . . . . . . . . . . ";"
    6:  1: . . . . . . . . . . . . . . . . . )
    6:  1: . . . . . . . . . . . . . . . . . "}"
    6:  2: . . . . . . . . . . . . . . . . )
    6:  2: . . . . . . . . . . . . . . . )
    6:  2: . . . . . . . . . . . . . . )
    6:  2: . . . . . . . . . . . . . )
    6:  2: . . . . . . . . . . . . )
    6:  2: . . . . . . . . . . . )
    6:  2: . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: fn, Index: &{26 0xc000215860 false}}
    6:  3: . . . . . . . . . . )
    6:  3: . . . . . . . . . . CallOrConversion (
    6:  3: . . . . . . . . . . . "("
    6:  4: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn 25 0xc00020b2c0 50}, Ellipsis: false, isCmd: false}
    6:  5: . . . . . . . . . . )
    6:  5: . . . . . . . . . )
    6:  5: . . . . . . . . )
    6:  5: . . . . . . . )
    6:  5: . . . . . . )
    6:  5: . . . . . )
    6:  5: . . . . )
    6:  5: . . . . ";"
    7:  1: . . . )
    7:  1: . . . Statement (
    7:  1: . . . . SimpleStmt (
    7:  1: . . . . . ExpressionList (
    7:  1: . . . . . . Expression (
    7:  1: . . . . . . . BinaryExpr (
    7:  1: . . . . . . . . UnaryExpr (
    7:  1: . . . . . . . . . PrimaryExpr (
    7:  1: . . . . . . . . . . Operand (
    7:  1: . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
    7:  3: . . . . . . . . . . )
    7:  3: . . . . . . . . . . IndexOrSlice (
    7:  3: . . . . . . . . . . . "["
    7:  4: . . . . . . . . . . . Expression (
    7:  4: . . . . . . . . . . . . BinaryExpr (
    7:  4: . . . . . . . . . . . . . UnaryExpr (
    7:  4: . . . . . . . . . . . . . . PrimaryExpr (
    7:  4: . . . . . . . . . . . . . . . Operand (
    7:  4: . . . . . . . . . . . . . . . . "map"
    7:  4: . . . . . . . . . . . . . . . . MapType (
    7:  7: . . . . . . . . . . . . . . . . . "["
    7:  8: . . . . . . . . . . . . . . . . . Type (
    7:  8: . . . . . . . . . . . . . . . . . . TypeName (
    7:  8: . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    7: 11: . . . . . . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . . . . . . "]"
    7: 12: . . . . . . . . . . . . . . . . . Type (
    7: 12: . . . . . . . . . . . . . . . . . . TypeName (
    7: 12: . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    7: 18: . . . . . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:1455: ast.MapType{Key: int, Value: string}
    7: 18: . . . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: fn, Index: &{57 int string}}
    7: 19: . . . . . . . . . . )
    7: 19: . . . . . . . . . . CallOrConversion (
    7: 19: . . . . . . . . . . . "("
    7: 20: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn 56 0xc0002158f0 71}, Ellipsis: false, isCmd: false}
    7: 21: . . . . . . . . . . )
    7: 21: . . . . . . . . . )
    7: 21: . . . . . . . . )
    7: 21: . . . . . . . )
    7: 21: . . . . . . )
    7: 21: . . . . . )
    7: 21: . . . . )
    7: 21: . . . . ";"
    8:  1: . . . )
    8:  1: . . . Statement (
    8:  1: . . . . SimpleStmt (
    8:  1: . . . . . ExpressionList (
    8:  1: . . . . . . Expression (
    8:  1: . . . . . . . BinaryExpr (
    8:  1: . . . . . . . . UnaryExpr (
    8:  1: . . . . . . . . . PrimaryExpr (
    8:  1: . . . . . . . . . . Operand (
    8:  1: . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
    8:  3: . . . . . . . . . . )
    8:  3: . . . . . . . . . . IndexOrSlice (
    8:  3: . . . . . . . . . . . "["
    8:  4: . . . . . . . . . . . Expression (
    8:  4: . . . . . . . . . . . . BinaryExpr (
    8:  4: . . . . . . . . . . . . . UnaryExpr (
    8:  4: . . . . . . . . . . . . . . PrimaryExpr (
    8:  4: . . . . . . . . . . . . . . . Operand (
    8:  4: . . . . . . . . . . . . . . . . ChanType (
    8:  4: . . . . . . . . . . . . . . . . . "chan"
    8:  9: . . . . . . . . . . . . . . . . . Type (
    8:  9: . . . . . . . . . . . . . . . . . . TypeName (
    8:  9: . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    8: 12: . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: fn, Index: &{78 0 3 int}}
    8: 13: . . . . . . . . . . )
    8: 13: . . . . . . . . . . CallOrConversion (
    8: 13: . . . . . . . . . . . "("
    8: 14: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn 77 0xc0002159b0 86}, Ellipsis: false, isCmd: false}
    8: 15: . . . . . . . . . . )
    8: 15: . . . . . . . . . )
    8: 15: . . . . . . . . )
    8: 15: . . . . . . . )
    8: 15: . . . . . . )
    8: 15: . . . . . )
    8: 15: . . . . )
    8: 15: . . . . ";"
    9:  1: . . . )
    9:  1: . . . Statement (
    9:  1: . . . . SimpleStmt (
    9:  1: . . . . . ExpressionList (
    9:  1: . . . . . . Expression (
    9:  1: . . . . . . . BinaryExpr (
    9:  1: . . . . . . . . UnaryExpr (
    9:  1: . . . . . . . . . PrimaryExpr (
    9:  1: . . . . . . . . . . Operand (
    9:  1: . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
    9:  3: . . . . . . . . . . )
    9:  3: . . . . . . . . . . IndexOrSlice (
    9:  3: . . . . . . . . . . . "["
    9:  4: . . . . . . . . . . . Expression (
    9:  4: . . . . . . . . . . . . BinaryExpr (
    9:  4: . . . . . . . . . . . . . UnaryExpr (
    9:  4: . . . . . . . . . . . . . . PrimaryExpr (
    9:  4: . . . . . . . . . . . . . . . Operand (
    9:  4: . . . . . . . . . . . . . . . . ChanType (
    9:  4: . . . . . . . . . . . . . . . . . "chan"
    9:  9: . . . . . . . . . . . . . . . . . Type (
    9:  9: . . . . . . . . . . . . . . . . . . StructType (
    9:  9: . . . . . . . . . . . . . . . . . . . "struct"
    9: 15: . . . . . . . . . . . . . . . . . . . "{"
    9: 16: . . . . . . . . . . . . . . . . . . . "}"
    9: 17: . . . . . . . . . . . . . . . . . . )
    9: 17: . . . . . . . . . . . . . . . . . )
    9: 17: . . . . . . . . . . . . . . . . )
    9: 17: . . . . . . . . . . . . . . . )
    9: 17: . . . . . . . . . . . . . . )
    9: 17: . . . . . . . . . . . . . )
    9: 17: . . . . . . . . . . . . )
    9: 17: . . . . . . . . . . . )
    9: 17: . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: fn, Index: &{93 0 3 0xc00020b2f0}}
    9: 18: . . . . . . . . . . )
    9: 18: . . . . . . . . . . CallOrConversion (
    9: 18: . . . . . . . . . . . "("
    9: 19: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn 92 0xc000215aa0 106}, Ellipsis: false, isCmd: false}
    9: 20: . . . . . . . . . . )
    9: 20: . . . . . . . . . )
    9: 20: . . . . . . . . )
    9: 20: . . . . . . . )
    9: 20: . . . . . . )
    9: 20: . . . . . )
    9: 20: . . . . )
    9: 20: . . . . ";"
   10:  1: . . . )
   10:  1: . . . Statement (
   10:  1: . . . . SimpleStmt (
   10:  1: . . . . . ExpressionList (
   10:  1: . . . . . . Expression (
   10:  1: . . . . . . . BinaryExpr (
   10:  1: . . . . . . . . UnaryExpr (
   10:  1: . . . . . . . . . PrimaryExpr (
   10:  1: . . . . . . . . . . Operand (
   10:  1: . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
   10:  3: . . . . . . . . . . )
   10:  3: . . . . . . . . . . IndexOrSlice (
   10:  3: . . . . . . . . . . . "["
   10:  4: . . . . . . . . . . . Expression (
   10:  4: . . . . . . . . . . . . BinaryExpr (
   10:  4: . . . . . . . . . . . . . UnaryExpr (
   10:  4: . . . . . . . . . . . . . . PrimaryExpr (
   10:  4: . . . . . . . . . . . . . . . Operand (
   10:  4: . . . . . . . . . . . . . . . . InterfaceType (
   10:  4: . . . . . . . . . . . . . . . . . "interface"
   10: 13: . . . . . . . . . . . . . . . . . "{"
   10: 14: . . . . . . . . . . . . . . . . . "}"
   10: 15: . . . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: fn, Index: &{113 0xc000215b60 false}}
   10: 16: . . . . . . . . . . )
   10: 16: . . . . . . . . . . CallOrConversion (
   10: 16: . . . . . . . . . . . "("
   10: 17: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn 112 0xc00020b308 124}, Ellipsis: false, isCmd: false}
   10: 18: . . . . . . . . . . )
   10: 18: . . . . . . . . . )
   10: 18: . . . . . . . . )
   10: 18: . . . . . . . )
   10: 18: . . . . . . )
   10: 18: . . . . . )
   10: 18: . . . . )
   10: 18: . . . . ";"
   11:  1: . . . )
   11:  1: . . . Statement (
   11:  1: . . . . SimpleStmt (
   11:  1: . . . . . ExpressionList (
   11:  1: . . . . . . Expression (
   11:  1: . . . . . . . BinaryExpr (
   11:  1: . . . . . . . . UnaryExpr (
   11:  1: . . . . . . . . . PrimaryExpr (
   11:  1: . . . . . . . . . . Operand (
   11:  1: . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
   11:  3: . . . . . . . . . . )
   11:  3: . . . . . . . . . . IndexOrSlice (
   11:  3: . . . . . . . . . . . "["
   11:  4: . . . . . . . . . . . Expression (
   11:  4: . . . . . . . . . . . . BinaryExpr (
   11:  4: . . . . . . . . . . . . . UnaryExpr (
   11:  4: . . . . . . . . . . . . . . PrimaryExpr (
   11:  4: . . . . . . . . . . . . . . . Operand (
   11:  4: . . . . . . . . . . . . . . . . InterfaceType (
   11:  4: . . . . . . . . . . . . . . . . . "interface"
   11: 13: . . . . . . . . . . . . . . . . . "{"
   11: 15: . . . . . . . . . . . . . . . . . MethodSpec (
   11: 15: . . . . . . . . . . . . . . . . . . TypeName (
   11: 15: . . . . . . . . . . . . . . . . . . . IDENT Method
 /app/parser/parser.go:713: ast.Ident{Name: Method}
   11: 21: . . . . . . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . . . . . . Signature (
   11: 21: . . . . . . . . . . . . . . . . . . . Parameters (
   11: 21: . . . . . . . . . . . . . . . . . . . . "("
   11: 22: . . . . . . . . . . . . . . . . . . . . ")"
   11: 24: . . . . . . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . . . . . . . Result (
   11: 24: . . . . . . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . . . . . "}"
   11: 25: . . . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: fn, Index: &{131 0xc000215c20 false}}
   11: 26: . . . . . . . . . . )
   11: 26: . . . . . . . . . . CallOrConversion (
   11: 26: . . . . . . . . . . . "("
   11: 27: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn 130 0xc00020b338 152}, Ellipsis: false, isCmd: false}
   11: 28: . . . . . . . . . . )
   11: 28: . . . . . . . . . )
   11: 28: . . . . . . . . )
   11: 28: . . . . . . . )
   11: 28: . . . . . . )
   11: 28: . . . . . )
   11: 28: . . . . )
   11: 28: . . . . ";"
   12:  1: . . . )
   12:  1: . . . Statement (
   12:  1: . . . . SimpleStmt (
   12:  1: . . . . . ExpressionList (
   12:  1: . . . . . . Expression (
   12:  1: . . . . . . . BinaryExpr (
   12:  1: . . . . . . . . UnaryExpr (
   12:  1: . . . . . . . . . PrimaryExpr (
   12:  1: . . . . . . . . . . Operand (
   12:  1: . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
   12:  3: . . . . . . . . . . )
   12:  3: . . . . . . . . . . IndexOrSlice (
   12:  3: . . . . . . . . . . . "["
   12:  4: . . . . . . . . . . . Expression (
   12:  4: . . . . . . . . . . . . BinaryExpr (
   12:  4: . . . . . . . . . . . . . UnaryExpr (
   12:  4: . . . . . . . . . . . . . . PrimaryExpr (
   12:  4: . . . . . . . . . . . . . . . Operand (
   12:  4: . . . . . . . . . . . . . . . . ArrayType (
   12:  4: . . . . . . . . . . . . . . . . . "["
   12:  5: . . . . . . . . . . . . . . . . . "]"
   12:  6: . . . . . . . . . . . . . . . . . StructType (
   12:  6: . . . . . . . . . . . . . . . . . . "struct"
   12: 13: . . . . . . . . . . . . . . . . . . "{"
   13:  2: . . . . . . . . . . . . . . . . . . FieldDecl (
   13:  2: . . . . . . . . . . . . . . . . . . . IDENT X
 /app/parser/parser.go:713: ast.Ident{Name: X}
   13:  4: . . . . . . . . . . . . . . . . . . . Type (
   13:  4: . . . . . . . . . . . . . . . . . . . . TypeName (
   13:  4: . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   13:  7: . . . . . . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . . . . . . ";"
   14:  2: . . . . . . . . . . . . . . . . . . )
   14:  2: . . . . . . . . . . . . . . . . . . FieldDecl (
   14:  2: . . . . . . . . . . . . . . . . . . . IDENT Y
 /app/parser/parser.go:713: ast.Ident{Name: Y}
   14:  4: . . . . . . . . . . . . . . . . . . . Type (
   14:  4: . . . . . . . . . . . . . . . . . . . . TypeName (
   14:  4: . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   14:  7: . . . . . . . . . . . . . . . . . . . . )
   14:  7: . . . . . . . . . . . . . . . . . . . )
   14:  7: . . . . . . . . . . . . . . . . . . . ";"
   15:  1: . . . . . . . . . . . . . . . . . . )
   15:  1: . . . . . . . . . . . . . . . . . . "}"
   15:  2: . . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: &{161 0xc000215ce0 false}}
   15:  2: . . . . . . . . . . . . . . . . )
   15:  2: . . . . . . . . . . . . . . . )
   15:  2: . . . . . . . . . . . . . . )
   15:  2: . . . . . . . . . . . . . )
   15:  2: . . . . . . . . . . . . )
   15:  2: . . . . . . . . . . . )
   15:  2: . . . . . . . . . . . ","
   15:  4: . . . . . . . . . . . Type (
   15:  4: . . . . . . . . . . . . MapType (
   15:  4: . . . . . . . . . . . . . "map"
   15:  7: . . . . . . . . . . . . . "["
   15:  8: . . . . . . . . . . . . . Type (
   15:  8: . . . . . . . . . . . . . . TypeName (
   15:  8: . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   15: 11: . . . . . . . . . . . . . . )
   15: 11: . . . . . . . . . . . . . )
   15: 11: . . . . . . . . . . . . . "]"
   15: 12: . . . . . . . . . . . . . Type (
   15: 12: . . . . . . . . . . . . . . TypeName (
   15: 12: . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   15: 18: . . . . . . . . . . . . . . )
   15: 18: . . . . . . . . . . . . . )
 /app/parser/parser.go:1455: ast.MapType{Key: int, Value: string}
   15: 18: . . . . . . . . . . . . )
   15: 18: . . . . . . . . . . . )
   15: 18: . . . . . . . . . . . "]"
 /app/parser/parser.go:2090: ast.IndexListExpr{X: fn, Index: [0xc000215d10 0xc000215d40]}
   15: 19: . . . . . . . . . . )
   15: 19: . . . . . . . . . . CallOrConversion (
   15: 19: . . . . . . . . . . . "("
   15: 20: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn 158 [0xc000215d10 0xc000215d40] 201}, Ellipsis: false, isCmd: false}
   15: 21: . . . . . . . . . . )
   15: 21: . . . . . . . . . )
   15: 21: . . . . . . . . )
   15: 21: . . . . . . . )
   15: 21: . . . . . . )
   15: 21: . . . . . )
   15: 21: . . . . )
   15: 21: . . . . ";"
   15: 22: . . . )
   15: 22: . . )
   15: 22: . )
   15: 22: )
=== RUN   TestFromInstance/instance5
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_instance/instance5
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . GenDecl(var) (
    1:  1: . . . "var"
    1:  5: . . . varSpec (
    1:  5: . . . . IdentList (
    1:  5: . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  7: . . . . )
    1:  7: . . . . ArrayType (
    1:  7: . . . . . "["
    1:  8: . . . . . Expression (
    1:  8: . . . . . . BinaryExpr (
    1:  8: . . . . . . . UnaryExpr (
    1:  8: . . . . . . . . PrimaryExpr (
    1:  8: . . . . . . . . . Operand (
    1:  8: . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    1:  9: . . . . . . . . . )
    1:  9: . . . . . . . . )
    1:  9: . . . . . . . )
    1:  9: . . . . . . )
    1:  9: . . . . . )
    1:  9: . . . . . "]"
    1: 10: . . . . . Type (
    1: 10: . . . . . . TypeName (
    1: 10: . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 13: . . . . . . )
    1: 13: . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: &{8 INT 2 <nil>}, Elt: int}
    1: 13: . . . . )
    1: 13: . . . . ";"
    3:  1: . . . )
    3:  1: . . )
    3:  1: . )
    3:  1: . Declaration (
    3:  1: . . StatementList (
    3:  1: . . . Statement (
    3:  1: . . . . IfStmt (
    3:  1: . . . . . "if"
    3:  4: . . . . . SimpleStmt (
    3:  4: . . . . . . ExpressionList (
    3:  4: . . . . . . . Expression (
    3:  4: . . . . . . . . BinaryExpr (
    3:  4: . . . . . . . . . UnaryExpr (
    3:  4: . . . . . . . . . . PrimaryExpr (
    3:  4: . . . . . . . . . . . Operand (
    3:  4: . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    3:  6: . . . . . . . . . . . )
    3:  6: . . . . . . . . . . )
    3:  6: . . . . . . . . . )
    3:  6: . . . . . . . . . "<"
    3:  8: . . . . . . . . . BinaryExpr (
    3:  8: . . . . . . . . . . UnaryExpr (
    3:  8: . . . . . . . . . . . PrimaryExpr (
    3:  8: . . . . . . . . . . . . Operand (
    3:  8: . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    3:  9: . . . . . . . . . . . . )
    3:  9: . . . . . . . . . . . . IndexOrSlice (
    3:  9: . . . . . . . . . . . . . "["
    3: 10: . . . . . . . . . . . . . Expression (
    3: 10: . . . . . . . . . . . . . . BinaryExpr (
    3: 10: . . . . . . . . . . . . . . . UnaryExpr (
    3: 10: . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 10: . . . . . . . . . . . . . . . . . Operand (
    3: 10: . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    3: 11: . . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: a, Index: &{24 INT 0 <nil>}}
    3: 13: . . . . . . . . . . . . )
    3: 13: . . . . . . . . . . . )
    3: 13: . . . . . . . . . . )
    3: 13: . . . . . . . . . )
    3: 13: . . . . . . . . )
    3: 13: . . . . . . . )
    3: 13: . . . . . . )
    3: 13: . . . . . )
    3: 13: . . . . . BlockStmt (
    3: 13: . . . . . . "{"
    4:  2: . . . . . . StatementList (
    4:  2: . . . . . . . Statement (
    4:  2: . . . . . . . . SimpleStmt (
    4:  2: . . . . . . . . . ExpressionList (
    4:  2: . . . . . . . . . . Expression (
    4:  2: . . . . . . . . . . . BinaryExpr (
    4:  2: . . . . . . . . . . . . UnaryExpr (
    4:  2: . . . . . . . . . . . . . PrimaryExpr (
    4:  2: . . . . . . . . . . . . . . Operand (
    4:  2: . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    4: 10: . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . . CallOrConversion (
    4: 10: . . . . . . . . . . . . . . . Expression (
    4: 10: . . . . . . . . . . . . . . . . BinaryExpr (
    4: 10: . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 10: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 10: . . . . . . . . . . . . . . . . . . . Operand (
    4: 10: . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    4: 11: . . . . . . . . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    4: 11: . . . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . )
    4: 11: . . . . . . . . . . )
    4: 11: . . . . . . . . . )
    4: 11: . . . . . . . . )
    4: 11: . . . . . . . . ";"
    5:  2: . . . . . . . )
    5:  2: . . . . . . . Statement (
    5:  2: . . . . . . . . SimpleStmt (
    5:  2: . . . . . . . . . ExpressionList (
    5:  2: . . . . . . . . . . Expression (
    5:  2: . . . . . . . . . . . BinaryExpr (
    5:  2: . . . . . . . . . . . . UnaryExpr (
    5:  2: . . . . . . . . . . . . . PrimaryExpr (
    5:  2: . . . . . . . . . . . . . . Operand (
    5:  2: . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5: 10: . . . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . . . . CallOrConversion (
    5: 10: . . . . . . . . . . . . . . . Expression (
    5: 10: . . . . . . . . . . . . . . . . BinaryExpr (
    5: 10: . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 10: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 10: . . . . . . . . . . . . . . . . . . . Operand (
    5: 10: . . . . . . . . . . . . . . . . . . . . IDENT M
 /app/parser/parser.go:713: ast.Ident{Name: M}
    5: 11: . . . . . . . . . . . . . . . . . . . )
    5: 11: . . . . . . . . . . . . . . . . . . . IndexOrSlice (
    5: 11: . . . . . . . . . . . . . . . . . . . . "["
    5: 12: . . . . . . . . . . . . . . . . . . . . Expression (
    5: 12: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 12: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 12: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 12: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 12: . . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: M, Index: int}
    5: 16: . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . . LiteralValue (
    5: 16: . . . . . . . . . . . . . . . . . . . . "{"
    5: 17: . . . . . . . . . . . . . . . . . . . . ElementList (
    5: 17: . . . . . . . . . . . . . . . . . . . . . Element (
    5: 17: . . . . . . . . . . . . . . . . . . . . . . Element (
    5: 17: . . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 17: . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 17: . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    5: 18: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . . "}"
    5: 19: . . . . . . . . . . . . . . . . . . . )
    5: 19: . . . . . . . . . . . . . . . . . . )
    5: 19: . . . . . . . . . . . . . . . . . )
    5: 19: . . . . . . . . . . . . . . . . )
    5: 19: . . . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    5: 19: . . . . . . . . . . . . . . )
    5: 19: . . . . . . . . . . . . . )
    5: 19: . . . . . . . . . . . . )
    5: 19: . . . . . . . . . . . )
    5: 19: . . . . . . . . . . )
    5: 19: . . . . . . . . . )
    5: 19: . . . . . . . . )
    5: 19: . . . . . . . . ";"
    6:  2: . . . . . . . )
    6:  2: . . . . . . . Statement (
    6:  2: . . . . . . . . SimpleStmt (
    6:  2: . . . . . . . . . ExpressionList (
    6:  2: . . . . . . . . . . Expression (
    6:  2: . . . . . . . . . . . BinaryExpr (
    6:  2: . . . . . . . . . . . . UnaryExpr (
    6:  2: . . . . . . . . . . . . . PrimaryExpr (
    6:  2: . . . . . . . . . . . . . . Operand (
    6:  2: . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    6: 10: . . . . . . . . . . . . . . )
    6: 10: . . . . . . . . . . . . . . CallOrConversion (
    6: 10: . . . . . . . . . . . . . . . Expression (
    6: 10: . . . . . . . . . . . . . . . . BinaryExpr (
    6: 10: . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 10: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 10: . . . . . . . . . . . . . . . . . . . Operand (
    6: 10: . . . . . . . . . . . . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
    6: 11: . . . . . . . . . . . . . . . . . . . )
    6: 11: . . . . . . . . . . . . . . . . . . . IndexOrSlice (
    6: 11: . . . . . . . . . . . . . . . . . . . . "["
    6: 12: . . . . . . . . . . . . . . . . . . . . Expression (
    6: 12: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 12: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 12: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 12: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    6: 12: . . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    6: 15: . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 15: . . . . . . . . . . . . . . . . . . . . . . . )
    6: 15: . . . . . . . . . . . . . . . . . . . . . . )
    6: 15: . . . . . . . . . . . . . . . . . . . . . )
    6: 15: . . . . . . . . . . . . . . . . . . . . )
    6: 15: . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: T, Index: int}
    6: 16: . . . . . . . . . . . . . . . . . . . )
    6: 16: . . . . . . . . . . . . . . . . . . . LiteralValue (
    6: 16: . . . . . . . . . . . . . . . . . . . . "{"
    6: 17: . . . . . . . . . . . . . . . . . . . . ElementList (
    6: 17: . . . . . . . . . . . . . . . . . . . . . Element (
    6: 17: . . . . . . . . . . . . . . . . . . . . . . Element (
    6: 17: . . . . . . . . . . . . . . . . . . . . . . . Expression (
    6: 17: . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 17: . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    6: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    6: 18: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . . . . . . . . . . . . ":"
    6: 20: . . . . . . . . . . . . . . . . . . . . . . Element (
    6: 20: . . . . . . . . . . . . . . . . . . . . . . . Expression (
    6: 20: . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 20: . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 20: . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 20: . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    6: 20: . . . . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    6: 21: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . . . . . . . ","
    6: 23: . . . . . . . . . . . . . . . . . . . . . Element (
    6: 23: . . . . . . . . . . . . . . . . . . . . . . Element (
    6: 23: . . . . . . . . . . . . . . . . . . . . . . . Expression (
    6: 23: . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 23: . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 23: . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 23: . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    6: 23: . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    6: 24: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 24: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 24: . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 24: . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 24: . . . . . . . . . . . . . . . . . . . . . . . )
    6: 24: . . . . . . . . . . . . . . . . . . . . . . )
    6: 24: . . . . . . . . . . . . . . . . . . . . . . ":"
    6: 26: . . . . . . . . . . . . . . . . . . . . . . Element (
    6: 26: . . . . . . . . . . . . . . . . . . . . . . . Expression (
    6: 26: . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 26: . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    6: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    6: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . . . . . . . . "}"
    6: 28: . . . . . . . . . . . . . . . . . . . )
    6: 28: . . . . . . . . . . . . . . . . . . )
    6: 28: . . . . . . . . . . . . . . . . . )
    6: 28: . . . . . . . . . . . . . . . . )
    6: 28: . . . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    6: 28: . . . . . . . . . . . . . . )
    6: 28: . . . . . . . . . . . . . )
    6: 28: . . . . . . . . . . . . )
    6: 28: . . . . . . . . . . . )
    6: 28: . . . . . . . . . . )
    6: 28: . . . . . . . . . )
    6: 28: . . . . . . . . )
    6: 28: . . . . . . . . ";"
    7:  1: . . . . . . . )
    7:  1: . . . . . . )
    7:  1: . . . . . . "}"
    7:  2: . . . . . )
    7:  2: . . . . . ";"
    9:  1: . . . . )
    9:  1: . . . )
    9:  1: . . . Statement (
    9:  1: . . . . ForStmt (
    9:  1: . . . . . "for"
    9:  5: . . . . . SimpleStmt (
    9:  5: . . . . . . ExpressionList (
    9:  5: . . . . . . . Expression (
    9:  5: . . . . . . . . BinaryExpr (
    9:  5: . . . . . . . . . UnaryExpr (
    9:  5: . . . . . . . . . . PrimaryExpr (
    9:  5: . . . . . . . . . . . Operand (
    9:  5: . . . . . . . . . . . . IDENT _
 /app/parser/parser.go:713: ast.Ident{Name: _}
    9:  6: . . . . . . . . . . . )
    9:  6: . . . . . . . . . . )
    9:  6: . . . . . . . . . )
    9:  6: . . . . . . . . )
    9:  6: . . . . . . . )
    9:  6: . . . . . . . ","
    9:  8: . . . . . . . Expression (
    9:  8: . . . . . . . . BinaryExpr (
    9:  8: . . . . . . . . . UnaryExpr (
    9:  8: . . . . . . . . . . PrimaryExpr (
    9:  8: . . . . . . . . . . . Operand (
    9:  8: . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    9: 10: . . . . . . . . . . . )
    9: 10: . . . . . . . . . . )
    9: 10: . . . . . . . . . )
    9: 10: . . . . . . . . )
    9: 10: . . . . . . . )
    9: 10: . . . . . . )
    9: 10: . . . . . . ":="
    9: 13: . . . . . . "range"
    9: 19: . . . . . . Expression (
    9: 19: . . . . . . . RangeExpr (
    9: 19: . . . . . . . . BinaryExpr (
    9: 19: . . . . . . . . . UnaryExpr (
    9: 19: . . . . . . . . . . PrimaryExpr (
    9: 19: . . . . . . . . . . . Operand (
    9: 19: . . . . . . . . . . . . ArrayType (
    9: 19: . . . . . . . . . . . . . "["
    9: 20: . . . . . . . . . . . . . "]"
    9: 21: . . . . . . . . . . . . . TypeName (
    9: 21: . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    9: 24: . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: int}
    9: 24: . . . . . . . . . . . . )
    9: 24: . . . . . . . . . . . )
    9: 24: . . . . . . . . . . . LiteralValue (
    9: 24: . . . . . . . . . . . . "{"
    9: 25: . . . . . . . . . . . . ElementList (
    9: 25: . . . . . . . . . . . . . Element (
    9: 25: . . . . . . . . . . . . . . Element (
    9: 25: . . . . . . . . . . . . . . . Expression (
    9: 25: . . . . . . . . . . . . . . . . BinaryExpr (
    9: 25: . . . . . . . . . . . . . . . . . UnaryExpr (
    9: 25: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 25: . . . . . . . . . . . . . . . . . . . Operand (
    9: 25: . . . . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    9: 26: . . . . . . . . . . . . . . . . . . . )
    9: 26: . . . . . . . . . . . . . . . . . . )
    9: 26: . . . . . . . . . . . . . . . . . )
    9: 26: . . . . . . . . . . . . . . . . )
    9: 26: . . . . . . . . . . . . . . . )
    9: 26: . . . . . . . . . . . . . . )
    9: 26: . . . . . . . . . . . . . )
    9: 26: . . . . . . . . . . . . . ","
    9: 28: . . . . . . . . . . . . . Element (
    9: 28: . . . . . . . . . . . . . . Element (
    9: 28: . . . . . . . . . . . . . . . Expression (
    9: 28: . . . . . . . . . . . . . . . . BinaryExpr (
    9: 28: . . . . . . . . . . . . . . . . . UnaryExpr (
    9: 28: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 28: . . . . . . . . . . . . . . . . . . . Operand (
    9: 28: . . . . . . . . . . . . . . . . . . . . INT 42
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 42}
    9: 30: . . . . . . . . . . . . . . . . . . . )
    9: 30: . . . . . . . . . . . . . . . . . . )
    9: 30: . . . . . . . . . . . . . . . . . )
    9: 30: . . . . . . . . . . . . . . . . )
    9: 30: . . . . . . . . . . . . . . . )
    9: 30: . . . . . . . . . . . . . . )
    9: 30: . . . . . . . . . . . . . )
    9: 30: . . . . . . . . . . . . )
    9: 30: . . . . . . . . . . . . "}"
    9: 32: . . . . . . . . . . . )
    9: 32: . . . . . . . . . . )
    9: 32: . . . . . . . . . )
    9: 32: . . . . . . . . )
    9: 32: . . . . . . . )
    9: 32: . . . . . . )
    9: 32: . . . . . )
    9: 32: . . . . . BlockStmt (
    9: 32: . . . . . . "{"
   10:  2: . . . . . . StatementList (
   10:  2: . . . . . . . Statement (
   10:  2: . . . . . . . . SimpleStmt (
   10:  2: . . . . . . . . . ExpressionList (
   10:  2: . . . . . . . . . . Expression (
   10:  2: . . . . . . . . . . . BinaryExpr (
   10:  2: . . . . . . . . . . . . UnaryExpr (
   10:  2: . . . . . . . . . . . . . PrimaryExpr (
   10:  2: . . . . . . . . . . . . . . Operand (
   10:  2: . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   10: 10: . . . . . . . . . . . . . . )
   10: 10: . . . . . . . . . . . . . . CallOrConversion (
   10: 10: . . . . . . . . . . . . . . . Expression (
   10: 10: . . . . . . . . . . . . . . . . BinaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . . Operand (
   10: 10: . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   10: 11: . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
   10: 11: . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . )
   10: 11: . . . . . . . . . . )
   10: 11: . . . . . . . . . )
   10: 11: . . . . . . . . )
   10: 11: . . . . . . . . ";"
   11:  1: . . . . . . . )
   11:  1: . . . . . . )
   11:  1: . . . . . . "}"
   11:  2: . . . . . )
   11:  2: . . . . . ";"
   11:  3: . . . . )
   11:  3: . . . )
   11:  3: . . )
   11:  3: . )
   11:  3: )
--- PASS: TestFromInstance (0.02s)
    --- PASS: TestFromInstance/instance1 (0.00s)
    --- PASS: TestFromInstance/instance2 (0.00s)
    --- PASS: TestFromInstance/instance3 (0.01s)
    --- PASS: TestFromInstance/instance4 (0.00s)
    --- PASS: TestFromInstance/instance5 (0.00s)
=== RUN   TestParseExprFrom
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
 /app/parser/interface.go:160: expected 'EOF', found ';'
--- PASS: TestParseExprFrom (0.00s)
=== RUN   TestReadSource
--- PASS: TestReadSource (0.00s)
=== RUN   TestParseFiles
--- PASS: TestParseFiles (0.00s)
=== RUN   TestIparseFileInvalidSrc
--- PASS: TestIparseFileInvalidSrc (0.00s)
=== RUN   TestIparseFileNoFset
--- PASS: TestIparseFileNoFset (0.00s)
=== RUN   TestParseDir
--- PASS: TestParseDir (0.00s)
=== RUN   TestParseGo
   17:  1: File (
   17:  1: . Declaration (
   17:  1: . . GenDecl(type) (
   17:  1: . . . "type"
   17:  6: . . . TypeSpec (
   17:  6: . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
   17:  8: . . . . Type (
   17:  8: . . . . . StructType (
   17:  8: . . . . . . "struct"
   17: 15: . . . . . . "{"
   18:  2: . . . . . . FieldDecl (
   18:  2: . . . . . . . "*"
   18:  3: . . . . . . . QualifiedIdent (
   18:  3: . . . . . . . . TypeName (
   18:  3: . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
   18:  4: . . . . . . . . )
   18:  4: . . . . . . . )
   18:  4: . . . . . . . ";"
   19:  2: . . . . . . )
   19:  2: . . . . . . FieldDecl (
   19:  2: . . . . . . . IDENT A
 /app/parser/parser.go:713: ast.Ident{Name: A}
   19:  4: . . . . . . . Type (
   19:  4: . . . . . . . . TypeName (
   19:  4: . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   19:  8: . . . . . . . . )
   19:  8: . . . . . . . )
   19:  8: . . . . . . . STRING `json:"a"`
   19: 18: . . . . . . . ";"
   20:  1: . . . . . . )
   20:  1: . . . . . . "}"
   20:  2: . . . . . )
   20:  2: . . . . )
   20:  2: . . . . ";"
   22:  1: . . . )
   22:  1: . . )
   22:  1: . )
   22:  1: . Declaration (
   22:  1: . . FunctionDeclOrCall (
   22:  1: . . . "func"
   22:  6: . . . IDENT bar
 /app/parser/parser.go:713: ast.Ident{Name: bar}
   22:  9: . . . Signature (
   22:  9: . . . . Parameters (
   22:  9: . . . . . "("
   22: 10: . . . . . ParameterList (
   22: 10: . . . . . . ParamDeclOrNil (
   22: 10: . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   22: 12: . . . . . . . Type (
   22: 12: . . . . . . . . ChanType (
   22: 12: . . . . . . . . . "chan"
   22: 17: . . . . . . . . . Type (
   22: 17: . . . . . . . . . . TypeName (
   22: 17: . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   22: 21: . . . . . . . . . . )
   22: 21: . . . . . . . . . )
   22: 21: . . . . . . . . )
   22: 21: . . . . . . . )
   22: 21: . . . . . . )
   22: 21: . . . . . )
   22: 21: . . . . . ")"
   22: 23: . . . . )
   22: 23: . . . . Result (
   22: 23: . . . . . Parameters (
   22: 23: . . . . . . "("
   22: 24: . . . . . . ParameterList (
   22: 24: . . . . . . . ParamDeclOrNil (
   22: 24: . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   22: 27: . . . . . . . )
   22: 27: . . . . . . . ","
   22: 29: . . . . . . . ParamDeclOrNil (
   22: 29: . . . . . . . . Type (
   22: 29: . . . . . . . . . ChanType (
   22: 29: . . . . . . . . . . "<-"
   22: 31: . . . . . . . . . . "chan"
   22: 36: . . . . . . . . . . Type (
   22: 36: . . . . . . . . . . . TypeName (
   22: 36: . . . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   22: 41: . . . . . . . . . . . )
   22: 41: . . . . . . . . . . )
   22: 41: . . . . . . . . . )
   22: 41: . . . . . . . . )
   22: 41: . . . . . . . )
   22: 41: . . . . . . )
   22: 41: . . . . . . ")"
   22: 43: . . . . . )
   22: 43: . . . . )
   22: 43: . . . )
   22: 43: . . . Body (
   22: 43: . . . . "{"
   23:  2: . . . . StatementList (
   23:  2: . . . . . Statement (
   23:  2: . . . . . . SimpleStmt (
   23:  2: . . . . . . . ExpressionList (
   23:  2: . . . . . . . . Expression (
   23:  2: . . . . . . . . . BinaryExpr (
   23:  2: . . . . . . . . . . UnaryExpr (
   23:  2: . . . . . . . . . . . PrimaryExpr (
   23:  2: . . . . . . . . . . . . Operand (
   23:  2: . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   23:  4: . . . . . . . . . . . . )
   23:  4: . . . . . . . . . . . . "<-"
   23:  4: . . . . . . . . . . . )
   23:  4: . . . . . . . . . . )
   23:  4: . . . . . . . . . )
   23:  4: . . . . . . . . )
   23:  4: . . . . . . . )
   23:  7: . . . . . . . Expression (
   23:  7: . . . . . . . . BinaryExpr (
   23:  7: . . . . . . . . . UnaryExpr (
   23:  7: . . . . . . . . . . PrimaryExpr (
   23:  7: . . . . . . . . . . . Operand (
   23:  7: . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   23: 11: . . . . . . . . . . . )
   23: 11: . . . . . . . . . . )
   23: 11: . . . . . . . . . )
   23: 11: . . . . . . . . )
   23: 11: . . . . . . . )
   23: 11: . . . . . . )
   23: 11: . . . . . . ";"
   24:  2: . . . . . )
   24:  2: . . . . . Statement (
   24:  2: . . . . . . SimpleStmt (
   24:  2: . . . . . . . ExpressionList (
   24:  2: . . . . . . . . Expression (
   24:  2: . . . . . . . . . BinaryExpr (
   24:  2: . . . . . . . . . . UnaryExpr (
   24:  2: . . . . . . . . . . . "<-"
   24:  4: . . . . . . . . . . . UnaryExpr (
   24:  4: . . . . . . . . . . . . PrimaryExpr (
   24:  4: . . . . . . . . . . . . . Operand (
   24:  4: . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   24:  5: . . . . . . . . . . . . . )
   24:  5: . . . . . . . . . . . . )
   24:  5: . . . . . . . . . . . )
   24:  5: . . . . . . . . . . )
   24:  5: . . . . . . . . . )
   24:  5: . . . . . . . . )
   24:  5: . . . . . . . )
   24:  5: . . . . . . )
   24:  5: . . . . . . ";"
   25:  2: . . . . . )
   25:  2: . . . . . Statement (
   25:  2: . . . . . . ReturnStmt (
   25:  2: . . . . . . . "return"
   25:  9: . . . . . . . ExpressionList (
   25:  9: . . . . . . . . Expression (
   25:  9: . . . . . . . . . BinaryExpr (
   25:  9: . . . . . . . . . . UnaryExpr (
   25:  9: . . . . . . . . . . . PrimaryExpr (
   25:  9: . . . . . . . . . . . . Operand (
   25:  9: . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   25: 10: . . . . . . . . . . . . )
   25: 10: . . . . . . . . . . . )
   25: 10: . . . . . . . . . . )
   25: 10: . . . . . . . . . )
   25: 10: . . . . . . . . )
   25: 10: . . . . . . . . ","
   25: 12: . . . . . . . . Expression (
   25: 12: . . . . . . . . . BinaryExpr (
   25: 12: . . . . . . . . . . UnaryExpr (
   25: 12: . . . . . . . . . . . PrimaryExpr (
   25: 12: . . . . . . . . . . . . Operand (
   25: 12: . . . . . . . . . . . . . "("
   25: 13: . . . . . . . . . . . . . Expression (
   25: 13: . . . . . . . . . . . . . . BinaryExpr (
   25: 13: . . . . . . . . . . . . . . . UnaryExpr (
   25: 13: . . . . . . . . . . . . . . . . "<-"
   25: 15: . . . . . . . . . . . . . . . . UnaryExpr (
   25: 15: . . . . . . . . . . . . . . . . . PrimaryExpr (
   25: 15: . . . . . . . . . . . . . . . . . . Operand (
   25: 15: . . . . . . . . . . . . . . . . . . . ChanType (
   25: 15: . . . . . . . . . . . . . . . . . . . . "chan"
   25: 20: . . . . . . . . . . . . . . . . . . . . Type (
   25: 20: . . . . . . . . . . . . . . . . . . . . . TypeName (
   25: 20: . . . . . . . . . . . . . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   25: 25: . . . . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{750 750 2 error}}
   25: 26: . . . . . . . . . . . . )
   25: 26: . . . . . . . . . . . . CallOrConversion (
   25: 26: . . . . . . . . . . . . . "("
   25: 27: . . . . . . . . . . . . . Expression (
   25: 27: . . . . . . . . . . . . . . BinaryExpr (
   25: 27: . . . . . . . . . . . . . . . UnaryExpr (
   25: 27: . . . . . . . . . . . . . . . . PrimaryExpr (
   25: 27: . . . . . . . . . . . . . . . . . Operand (
   25: 27: . . . . . . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
   25: 30: . . . . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{749 0xc0002c4b70 762}, Ellipsis: false, isCmd: false}
   25: 31: . . . . . . . . . . . . )
   25: 31: . . . . . . . . . . . )
   25: 31: . . . . . . . . . . )
   25: 31: . . . . . . . . . )
   25: 31: . . . . . . . . )
   25: 31: . . . . . . . )
   25: 31: . . . . . . . ";"
   26:  1: . . . . . . )
   26:  1: . . . . . )
   26:  1: . . . . )
   26:  1: . . . . "}"
   26:  2: . . . )
   26:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
   28:  1: . . )
   28:  1: . )
   28:  1: . Declaration (
   28:  1: . . FunctionDeclOrCall (
   28:  1: . . . "func"
   28:  6: . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   28:  9: . . . Signature (
   28:  9: . . . . Parameters (
   28:  9: . . . . . "("
   28: 10: . . . . . ParameterList (
   28: 10: . . . . . . ParamDeclOrNil (
   28: 10: . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   28: 12: . . . . . . . Type (
   28: 12: . . . . . . . . FuncType (
   28: 12: . . . . . . . . . "func"
   28: 16: . . . . . . . . . Signature (
   28: 16: . . . . . . . . . . Parameters (
   28: 16: . . . . . . . . . . . "("
   28: 17: . . . . . . . . . . . ParameterList (
   28: 17: . . . . . . . . . . . . ParamDeclOrNil (
   28: 17: . . . . . . . . . . . . . Type (
   28: 17: . . . . . . . . . . . . . . ArrayType (
   28: 17: . . . . . . . . . . . . . . . "["
   28: 18: . . . . . . . . . . . . . . . "]"
   28: 19: . . . . . . . . . . . . . . . Type (
   28: 19: . . . . . . . . . . . . . . . . TypeName (
   28: 19: . . . . . . . . . . . . . . . . . IDENT byte
 /app/parser/parser.go:713: ast.Ident{Name: byte}
   28: 23: . . . . . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
   28: 23: . . . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . ","
   28: 25: . . . . . . . . . . . . ParamDeclOrNil (
   28: 25: . . . . . . . . . . . . . Type (
   28: 25: . . . . . . . . . . . . . . PointerType (
   28: 25: . . . . . . . . . . . . . . . "*"
   28: 26: . . . . . . . . . . . . . . . Type (
   28: 26: . . . . . . . . . . . . . . . . TypeName (
   28: 26: . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   28: 32: . . . . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . ","
   28: 34: . . . . . . . . . . . . ParamDeclOrNil (
   28: 34: . . . . . . . . . . . . . DotsType (
   28: 34: . . . . . . . . . . . . . . "..."
   28: 37: . . . . . . . . . . . . . . Type (
   28: 37: . . . . . . . . . . . . . . . TypeName (
   28: 37: . . . . . . . . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
   28: 38: . . . . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . ")"
   28: 40: . . . . . . . . . . )
   28: 40: . . . . . . . . . . Result (
   28: 40: . . . . . . . . . . . ChanType (
   28: 40: . . . . . . . . . . . . "chan"
   28: 44: . . . . . . . . . . . . "<-"
   28: 47: . . . . . . . . . . . . Type (
   28: 47: . . . . . . . . . . . . . TypeName (
   28: 47: . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   28: 50: . . . . . . . . . . . . . )
   28: 50: . . . . . . . . . . . . )
   28: 50: . . . . . . . . . . . )
   28: 50: . . . . . . . . . . )
   28: 50: . . . . . . . . . )
   28: 50: . . . . . . . . )
   28: 50: . . . . . . . )
   28: 50: . . . . . . )
   28: 50: . . . . . )
   28: 50: . . . . . ")"
   28: 52: . . . . )
   28: 52: . . . . Result (
   28: 52: . . . . . Parameters (
   28: 52: . . . . . . "("
   28: 53: . . . . . . ParameterList (
   28: 53: . . . . . . . ParamDeclOrNil (
   28: 53: . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   28: 55: . . . . . . . . Type (
   28: 55: . . . . . . . . . TypeName (
   28: 55: . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   28: 58: . . . . . . . . . )
   28: 58: . . . . . . . . )
   28: 58: . . . . . . . )
   28: 58: . . . . . . . ","
   28: 60: . . . . . . . ParamDeclOrNil (
   28: 60: . . . . . . . . IDENT err
 /app/parser/parser.go:713: ast.Ident{Name: err}
   28: 64: . . . . . . . . Type (
   28: 64: . . . . . . . . . TypeName (
   28: 64: . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   28: 69: . . . . . . . . . )
   28: 69: . . . . . . . . )
   28: 69: . . . . . . . )
   28: 69: . . . . . . )
   28: 69: . . . . . . ")"
   28: 71: . . . . . )
   28: 71: . . . . )
   28: 71: . . . )
   28: 71: . . . Body (
   28: 71: . . . . "{"
   29:  2: . . . . StatementList (
   29:  2: . . . . . Statement (
   29:  2: . . . . . . ReturnStmt (
   29:  2: . . . . . . . "return"
   29:  8: . . . . . . . ";"
   30:  1: . . . . . . )
   30:  1: . . . . . )
   30:  1: . . . . )
   30:  1: . . . . "}"
   30:  2: . . . )
   30:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
   30:  3: . . )
   30:  3: . )
   30:  3: )
--- PASS: TestParseGo (0.00s)
=== RUN   TestParseGoFiles
   17:  1: File (
   17:  1: . Declaration (
   17:  1: . . GenDecl(type) (
   17:  1: . . . "type"
   17:  6: . . . TypeSpec (
   17:  6: . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
   17:  8: . . . . Type (
   17:  8: . . . . . StructType (
   17:  8: . . . . . . "struct"
   17: 15: . . . . . . "{"
   18:  2: . . . . . . FieldDecl (
   18:  2: . . . . . . . "*"
   18:  3: . . . . . . . QualifiedIdent (
   18:  3: . . . . . . . . TypeName (
   18:  3: . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
   18:  4: . . . . . . . . )
   18:  4: . . . . . . . )
   18:  4: . . . . . . . ";"
   19:  2: . . . . . . )
   19:  2: . . . . . . FieldDecl (
   19:  2: . . . . . . . IDENT A
 /app/parser/parser.go:713: ast.Ident{Name: A}
   19:  4: . . . . . . . Type (
   19:  4: . . . . . . . . TypeName (
   19:  4: . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   19:  8: . . . . . . . . )
   19:  8: . . . . . . . )
   19:  8: . . . . . . . STRING `json:"a"`
   19: 18: . . . . . . . ";"
   20:  1: . . . . . . )
   20:  1: . . . . . . "}"
   20:  2: . . . . . )
   20:  2: . . . . )
   20:  2: . . . . ";"
   22:  1: . . . )
   22:  1: . . )
   22:  1: . )
   22:  1: . Declaration (
   22:  1: . . FunctionDeclOrCall (
   22:  1: . . . "func"
   22:  6: . . . IDENT bar
 /app/parser/parser.go:713: ast.Ident{Name: bar}
   22:  9: . . . Signature (
   22:  9: . . . . Parameters (
   22:  9: . . . . . "("
   22: 10: . . . . . ParameterList (
   22: 10: . . . . . . ParamDeclOrNil (
   22: 10: . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   22: 12: . . . . . . . Type (
   22: 12: . . . . . . . . ChanType (
   22: 12: . . . . . . . . . "chan"
   22: 17: . . . . . . . . . Type (
   22: 17: . . . . . . . . . . TypeName (
   22: 17: . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   22: 21: . . . . . . . . . . )
   22: 21: . . . . . . . . . )
   22: 21: . . . . . . . . )
   22: 21: . . . . . . . )
   22: 21: . . . . . . )
   22: 21: . . . . . )
   22: 21: . . . . . ")"
   22: 23: . . . . )
   22: 23: . . . . Result (
   22: 23: . . . . . Parameters (
   22: 23: . . . . . . "("
   22: 24: . . . . . . ParameterList (
   22: 24: . . . . . . . ParamDeclOrNil (
   22: 24: . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   22: 27: . . . . . . . )
   22: 27: . . . . . . . ","
   22: 29: . . . . . . . ParamDeclOrNil (
   22: 29: . . . . . . . . Type (
   22: 29: . . . . . . . . . ChanType (
   22: 29: . . . . . . . . . . "<-"
   22: 31: . . . . . . . . . . "chan"
   22: 36: . . . . . . . . . . Type (
   22: 36: . . . . . . . . . . . TypeName (
   22: 36: . . . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   22: 41: . . . . . . . . . . . )
   22: 41: . . . . . . . . . . )
   22: 41: . . . . . . . . . )
   22: 41: . . . . . . . . )
   22: 41: . . . . . . . )
   22: 41: . . . . . . )
   22: 41: . . . . . . ")"
   22: 43: . . . . . )
   22: 43: . . . . )
   22: 43: . . . )
   22: 43: . . . Body (
   22: 43: . . . . "{"
   23:  2: . . . . StatementList (
   23:  2: . . . . . Statement (
   23:  2: . . . . . . SimpleStmt (
   23:  2: . . . . . . . ExpressionList (
   23:  2: . . . . . . . . Expression (
   23:  2: . . . . . . . . . BinaryExpr (
   23:  2: . . . . . . . . . . UnaryExpr (
   23:  2: . . . . . . . . . . . PrimaryExpr (
   23:  2: . . . . . . . . . . . . Operand (
   23:  2: . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   23:  4: . . . . . . . . . . . . )
   23:  4: . . . . . . . . . . . . "<-"
   23:  4: . . . . . . . . . . . )
   23:  4: . . . . . . . . . . )
   23:  4: . . . . . . . . . )
   23:  4: . . . . . . . . )
   23:  4: . . . . . . . )
   23:  7: . . . . . . . Expression (
   23:  7: . . . . . . . . BinaryExpr (
   23:  7: . . . . . . . . . UnaryExpr (
   23:  7: . . . . . . . . . . PrimaryExpr (
   23:  7: . . . . . . . . . . . Operand (
   23:  7: . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   23: 11: . . . . . . . . . . . )
   23: 11: . . . . . . . . . . )
   23: 11: . . . . . . . . . )
   23: 11: . . . . . . . . )
   23: 11: . . . . . . . )
   23: 11: . . . . . . )
   23: 11: . . . . . . ";"
   24:  2: . . . . . )
   24:  2: . . . . . Statement (
   24:  2: . . . . . . SimpleStmt (
   24:  2: . . . . . . . ExpressionList (
   24:  2: . . . . . . . . Expression (
   24:  2: . . . . . . . . . BinaryExpr (
   24:  2: . . . . . . . . . . UnaryExpr (
   24:  2: . . . . . . . . . . . "<-"
   24:  4: . . . . . . . . . . . UnaryExpr (
   24:  4: . . . . . . . . . . . . PrimaryExpr (
   24:  4: . . . . . . . . . . . . . Operand (
   24:  4: . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   24:  5: . . . . . . . . . . . . . )
   24:  5: . . . . . . . . . . . . )
   24:  5: . . . . . . . . . . . )
   24:  5: . . . . . . . . . . )
   24:  5: . . . . . . . . . )
   24:  5: . . . . . . . . )
   24:  5: . . . . . . . )
   24:  5: . . . . . . )
   24:  5: . . . . . . ";"
   25:  2: . . . . . )
   25:  2: . . . . . Statement (
   25:  2: . . . . . . ReturnStmt (
   25:  2: . . . . . . . "return"
   25:  9: . . . . . . . ExpressionList (
   25:  9: . . . . . . . . Expression (
   25:  9: . . . . . . . . . BinaryExpr (
   25:  9: . . . . . . . . . . UnaryExpr (
   25:  9: . . . . . . . . . . . PrimaryExpr (
   25:  9: . . . . . . . . . . . . Operand (
   25:  9: . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   25: 10: . . . . . . . . . . . . )
   25: 10: . . . . . . . . . . . )
   25: 10: . . . . . . . . . . )
   25: 10: . . . . . . . . . )
   25: 10: . . . . . . . . )
   25: 10: . . . . . . . . ","
   25: 12: . . . . . . . . Expression (
   25: 12: . . . . . . . . . BinaryExpr (
   25: 12: . . . . . . . . . . UnaryExpr (
   25: 12: . . . . . . . . . . . PrimaryExpr (
   25: 12: . . . . . . . . . . . . Operand (
   25: 12: . . . . . . . . . . . . . "("
   25: 13: . . . . . . . . . . . . . Expression (
   25: 13: . . . . . . . . . . . . . . BinaryExpr (
   25: 13: . . . . . . . . . . . . . . . UnaryExpr (
   25: 13: . . . . . . . . . . . . . . . . "<-"
   25: 15: . . . . . . . . . . . . . . . . UnaryExpr (
   25: 15: . . . . . . . . . . . . . . . . . PrimaryExpr (
   25: 15: . . . . . . . . . . . . . . . . . . Operand (
   25: 15: . . . . . . . . . . . . . . . . . . . ChanType (
   25: 15: . . . . . . . . . . . . . . . . . . . . "chan"
   25: 20: . . . . . . . . . . . . . . . . . . . . Type (
   25: 20: . . . . . . . . . . . . . . . . . . . . . TypeName (
   25: 20: . . . . . . . . . . . . . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   25: 25: . . . . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{750 750 2 error}}
   25: 26: . . . . . . . . . . . . )
   25: 26: . . . . . . . . . . . . CallOrConversion (
   25: 26: . . . . . . . . . . . . . "("
   25: 27: . . . . . . . . . . . . . Expression (
   25: 27: . . . . . . . . . . . . . . BinaryExpr (
   25: 27: . . . . . . . . . . . . . . . UnaryExpr (
   25: 27: . . . . . . . . . . . . . . . . PrimaryExpr (
   25: 27: . . . . . . . . . . . . . . . . . Operand (
   25: 27: . . . . . . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
   25: 30: . . . . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{749 0xc0002c50e0 762}, Ellipsis: false, isCmd: false}
   25: 31: . . . . . . . . . . . . )
   25: 31: . . . . . . . . . . . )
   25: 31: . . . . . . . . . . )
   25: 31: . . . . . . . . . )
   25: 31: . . . . . . . . )
   25: 31: . . . . . . . )
   25: 31: . . . . . . . ";"
   26:  1: . . . . . . )
   26:  1: . . . . . )
   26:  1: . . . . )
   26:  1: . . . . "}"
   26:  2: . . . )
   26:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
   28:  1: . . )
   28:  1: . )
   28:  1: . Declaration (
   28:  1: . . FunctionDeclOrCall (
   28:  1: . . . "func"
   28:  6: . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   28:  9: . . . Signature (
   28:  9: . . . . Parameters (
   28:  9: . . . . . "("
   28: 10: . . . . . ParameterList (
   28: 10: . . . . . . ParamDeclOrNil (
   28: 10: . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   28: 12: . . . . . . . Type (
   28: 12: . . . . . . . . FuncType (
   28: 12: . . . . . . . . . "func"
   28: 16: . . . . . . . . . Signature (
   28: 16: . . . . . . . . . . Parameters (
   28: 16: . . . . . . . . . . . "("
   28: 17: . . . . . . . . . . . ParameterList (
   28: 17: . . . . . . . . . . . . ParamDeclOrNil (
   28: 17: . . . . . . . . . . . . . Type (
   28: 17: . . . . . . . . . . . . . . ArrayType (
   28: 17: . . . . . . . . . . . . . . . "["
   28: 18: . . . . . . . . . . . . . . . "]"
   28: 19: . . . . . . . . . . . . . . . Type (
   28: 19: . . . . . . . . . . . . . . . . TypeName (
   28: 19: . . . . . . . . . . . . . . . . . IDENT byte
 /app/parser/parser.go:713: ast.Ident{Name: byte}
   28: 23: . . . . . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
   28: 23: . . . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . ","
   28: 25: . . . . . . . . . . . . ParamDeclOrNil (
   28: 25: . . . . . . . . . . . . . Type (
   28: 25: . . . . . . . . . . . . . . PointerType (
   28: 25: . . . . . . . . . . . . . . . "*"
   28: 26: . . . . . . . . . . . . . . . Type (
   28: 26: . . . . . . . . . . . . . . . . TypeName (
   28: 26: . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   28: 32: . . . . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . ","
   28: 34: . . . . . . . . . . . . ParamDeclOrNil (
   28: 34: . . . . . . . . . . . . . DotsType (
   28: 34: . . . . . . . . . . . . . . "..."
   28: 37: . . . . . . . . . . . . . . Type (
   28: 37: . . . . . . . . . . . . . . . TypeName (
   28: 37: . . . . . . . . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
   28: 38: . . . . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . ")"
   28: 40: . . . . . . . . . . )
   28: 40: . . . . . . . . . . Result (
   28: 40: . . . . . . . . . . . ChanType (
   28: 40: . . . . . . . . . . . . "chan"
   28: 44: . . . . . . . . . . . . "<-"
   28: 47: . . . . . . . . . . . . Type (
   28: 47: . . . . . . . . . . . . . TypeName (
   28: 47: . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   28: 50: . . . . . . . . . . . . . )
   28: 50: . . . . . . . . . . . . )
   28: 50: . . . . . . . . . . . )
   28: 50: . . . . . . . . . . )
   28: 50: . . . . . . . . . )
   28: 50: . . . . . . . . )
   28: 50: . . . . . . . )
   28: 50: . . . . . . )
   28: 50: . . . . . )
   28: 50: . . . . . ")"
   28: 52: . . . . )
   28: 52: . . . . Result (
   28: 52: . . . . . Parameters (
   28: 52: . . . . . . "("
   28: 53: . . . . . . ParameterList (
   28: 53: . . . . . . . ParamDeclOrNil (
   28: 53: . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   28: 55: . . . . . . . . Type (
   28: 55: . . . . . . . . . TypeName (
   28: 55: . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   28: 58: . . . . . . . . . )
   28: 58: . . . . . . . . )
   28: 58: . . . . . . . )
   28: 58: . . . . . . . ","
   28: 60: . . . . . . . ParamDeclOrNil (
   28: 60: . . . . . . . . IDENT err
 /app/parser/parser.go:713: ast.Ident{Name: err}
   28: 64: . . . . . . . . Type (
   28: 64: . . . . . . . . . TypeName (
   28: 64: . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   28: 69: . . . . . . . . . )
   28: 69: . . . . . . . . )
   28: 69: . . . . . . . )
   28: 69: . . . . . . )
   28: 69: . . . . . . ")"
   28: 71: . . . . . )
   28: 71: . . . . )
   28: 71: . . . )
   28: 71: . . . Body (
   28: 71: . . . . "{"
   29:  2: . . . . StatementList (
   29:  2: . . . . . Statement (
   29:  2: . . . . . . ReturnStmt (
   29:  2: . . . . . . . "return"
   29:  8: . . . . . . . ";"
   30:  1: . . . . . . )
   30:  1: . . . . . )
   30:  1: . . . . )
   30:  1: . . . . "}"
   30:  2: . . . )
   30:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
   30:  3: . . )
   30:  3: . )
   30:  3: )
--- PASS: TestParseGoFiles (0.00s)
=== RUN   TestParseEntries
=== RUN   TestParseEntries/.xgo_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{750 750 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{749 0xc0002c56b0 762}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestParseEntries/.gox_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{1604 1604 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{1603 0xc0002c5c50 1616}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestParseEntries/.foo.gox_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{2458 2458 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{2457 0xc0002f2270 2470}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestParseEntries/.foo_file
=== RUN   TestParseEntries/.spx_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{3312 3312 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{3311 0xc0002f28a0 3324}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
--- PASS: TestParseEntries (0.00s)
    --- PASS: TestParseEntries/.xgo_file (0.00s)
    --- PASS: TestParseEntries/.gox_file (0.00s)
    --- PASS: TestParseEntries/.foo.gox_file (0.00s)
    --- PASS: TestParseEntries/.foo_file (0.00s)
    --- PASS: TestParseEntries/.spx_file (0.00s)
=== RUN   TestParseEntries_SaveAbsFile
=== RUN   TestParseEntries_SaveAbsFile/.xgo_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{750 750 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{749 0xc0002f2ed0 762}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestParseEntries_SaveAbsFile/.gox_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{1604 1604 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{1603 0xc0002f3470 1616}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestParseEntries_SaveAbsFile/.foo.gox_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{2458 2458 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{2457 0xc0002f3a10 2470}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestParseEntries_SaveAbsFile/.foo_file
=== RUN   TestParseEntries_SaveAbsFile/.spx_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{3312 3312 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{3311 0xc0003120c0 3324}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
--- PASS: TestParseEntries_SaveAbsFile (0.00s)
    --- PASS: TestParseEntries_SaveAbsFile/.xgo_file (0.00s)
    --- PASS: TestParseEntries_SaveAbsFile/.gox_file (0.00s)
    --- PASS: TestParseEntries_SaveAbsFile/.foo.gox_file (0.00s)
    --- PASS: TestParseEntries_SaveAbsFile/.foo_file (0.00s)
    --- PASS: TestParseEntries_SaveAbsFile/.spx_file (0.00s)
=== RUN   TestParseEntry
=== RUN   TestParseEntry/.xgo_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{750 750 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{749 0xc000312600 762}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestParseEntry/.gox_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{1604 1604 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{1603 0xc000312ae0 1616}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestParseEntry/.foo.gox_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{2458 2458 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{2457 0xc000312fc0 2470}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestParseEntry/.foo_file
=== RUN   TestParseEntry/.spx_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{3312 3312 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{3311 0xc0003134d0 3324}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
--- PASS: TestParseEntry (0.00s)
    --- PASS: TestParseEntry/.xgo_file (0.00s)
    --- PASS: TestParseEntry/.gox_file (0.00s)
    --- PASS: TestParseEntry/.foo.gox_file (0.00s)
    --- PASS: TestParseEntry/.foo_file (0.00s)
    --- PASS: TestParseEntry/.spx_file (0.00s)
=== RUN   TestParseEntry2
=== RUN   TestParseEntry2/_yap.gox_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{750 750 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{749 0xc0003139b0 762}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
--- PASS: TestParseEntry2 (0.00s)
    --- PASS: TestParseEntry2/_yap.gox_file (0.00s)
=== RUN   TestSaveAbsFile
=== RUN   TestSaveAbsFile/.xgo_file
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{750 750 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{749 0xc000313e90 762}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestSaveAbsFile/.xgo_file#01
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: A}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: bar}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: bool}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: true}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{1604 1604 2 error}}
 /app/parser/parser.go:713: ast.Ident{Name: nil}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{1603 0xc00033a3f0 1616}, Ellipsis: false, isCmd: false}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:713: ast.Ident{Name: f}
 /app/parser/parser.go:713: ast.Ident{Name: byte}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
 /app/parser/parser.go:713: ast.Ident{Name: string}
 /app/parser/parser.go:713: ast.Ident{Name: T}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: v}
 /app/parser/parser.go:713: ast.Ident{Name: int}
 /app/parser/parser.go:713: ast.Ident{Name: err}
 /app/parser/parser.go:713: ast.Ident{Name: error}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
=== RUN   TestSaveAbsFile/dir
 /app/parser/parser.go:713: ast.Ident{Name: main}
 /app/parser/parser.go:713: ast.Ident{Name: main}
 /app/parser/parser.go:713: ast.Ident{Name: changeYpos}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 0.7}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 8}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: changeYpos, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:713: ast.Ident{Name: changeYpos}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 0.7}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: changeYpos, Ellipsis: false, isCmd: true}
 /app/parser/parser.go:713: ast.Ident{Name: changeYpos}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 0.7}
 /app/parser/parser.go:713: ast.Ident{Name: changeYpos}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 0.7}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
 /app/parser/parser.go:2064: ast.IndexExpr{X: x, Index: &{1811 INT 1 <nil>}}
 /app/parser/parser.go:713: ast.Ident{Name: x}
 /app/parser/parser.go:902: ast.SliceLit{Elts: []}
 /app/parser/parser.go:2160: ast.CallExpr{Fun: x, Ellipsis: true, isCmd: true}
 /app/parser/parser.go:4088: ast.FuncDecl{Name: main, ...}
--- PASS: TestSaveAbsFile (0.00s)
    --- PASS: TestSaveAbsFile/.xgo_file (0.00s)
    --- PASS: TestSaveAbsFile/.xgo_file#01 (0.00s)
    --- PASS: TestSaveAbsFile/dir (0.00s)
=== RUN   TestGopAutoGen
--- PASS: TestGopAutoGen (0.00s)
=== RUN   TestGoFile
--- PASS: TestGoFile (0.00s)
=== RUN   TestErrParse
 /app/parser/parser.go:713: ast.Ident{Name: foo}
 /app/parser/parser.go:4187: expected ';', found bar
 /app/parser/parser.go:713: ast.Ident{Name: foo}
--- PASS: TestErrParse (0.00s)
=== RUN   TestFromTestexpr
=== RUN   TestFromTestexpr/lambda
 /app/parser/parserdir_test.go:130: Parsing /app/parser/_testexpr/lambda
    1:  1: Expression (
    1:  1: . "=>"
    1:  4: . BlockStmt (
    1:  4: . . "{"
    2:  5: . . StatementList (
    2:  5: . . . Statement (
    2:  5: . . . . ReturnStmt (
    2:  5: . . . . . "return"
    2: 12: . . . . . ExpressionList (
    2: 12: . . . . . . Expression (
    2: 12: . . . . . . . BinaryExpr (
    2: 12: . . . . . . . . UnaryExpr (
    2: 12: . . . . . . . . . PrimaryExpr (
    2: 12: . . . . . . . . . . Operand (
    2: 12: . . . . . . . . . . . IDENT this
 /app/parser/parser.go:713: ast.Ident{Name: this}
    2: 16: . . . . . . . . . . )
    2: 16: . . . . . . . . . )
    2: 16: . . . . . . . . )
    2: 16: . . . . . . . )
    2: 16: . . . . . . )
    2: 16: . . . . . )
    2: 16: . . . . . ";"
    3:  1: . . . . )
    3:  1: . . . )
    3:  1: . . )
    3:  1: . . "}"
    3:  2: . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
    3:  2: )
    3:  2: ";"
    3:  3: EOF
--- PASS: TestFromTestexpr (0.00s)
    --- PASS: TestFromTestexpr/lambda (0.00s)
=== RUN   TestFromTestdata
=== RUN   TestFromTestdata/append1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/append1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . . "<-"
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  6: . . . . . Expression (
    1:  6: . . . . . . BinaryExpr (
    1:  6: . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  7: . . . . . . . . . )
    1:  7: . . . . . . . . )
    1:  7: . . . . . . . )
    1:  7: . . . . . . )
    1:  7: . . . . . )
    1:  7: . . . . . ","
    1:  9: . . . . . Expression (
    1:  9: . . . . . . BinaryExpr (
    1:  9: . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    1: 10: . . . . . . . . . )
    1: 10: . . . . . . . . )
    1: 10: . . . . . . . )
    1: 10: . . . . . . )
    1: 10: . . . . . )
    1: 10: . . . . . ","
    1: 12: . . . . . Expression (
    1: 12: . . . . . . BinaryExpr (
    1: 12: . . . . . . . UnaryExpr (
    1: 12: . . . . . . . . PrimaryExpr (
    1: 12: . . . . . . . . . Operand (
    1: 12: . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    1: 13: . . . . . . . . . )
    1: 13: . . . . . . . . )
    1: 13: . . . . . . . )
    1: 13: . . . . . . )
    1: 13: . . . . . )
    1: 13: . . . . )
    1: 13: . . . . ";"
    1: 14: . . . )
    1: 14: . . )
    1: 14: . )
    1: 14: )
=== RUN   TestFromTestdata/append2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/append2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . . "<-"
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  6: . . . . . Expression (
    1:  6: . . . . . . BinaryExpr (
    1:  6: . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    1:  7: . . . . . . . . . )
    1:  7: . . . . . . . . )
    1:  7: . . . . . . . )
    1:  7: . . . . . . )
    1:  7: . . . . . )
    1:  7: . . . . . "..."
    1: 10: . . . . )
    1: 10: . . . . ";"
    1: 11: . . . )
    1: 11: . . )
    1: 11: . )
    1: 11: )
=== RUN   TestFromTestdata/arrowop
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/arrowop
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT echo
 /app/parser/parser.go:713: ast.Ident{Name: echo}
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . . CallOrConversion (
    1:  6: . . . . . . . . . . . Expression (
    1:  6: . . . . . . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  7: . . . . . . . . . . . . . . . )
    1:  7: . . . . . . . . . . . . . . )
    1:  7: . . . . . . . . . . . . . )
    1:  7: . . . . . . . . . . . . . "+"
    1:  8: . . . . . . . . . . . . . BinaryExpr (
    1:  8: . . . . . . . . . . . . . . UnaryExpr (
    1:  8: . . . . . . . . . . . . . . . PrimaryExpr (
    1:  8: . . . . . . . . . . . . . . . . Operand (
    1:  8: . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1: 10: . . . . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . . "->"
    1: 13: . . . . . . . . . . . . . BinaryExpr (
    1: 13: . . . . . . . . . . . . . . UnaryExpr (
    1: 13: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 13: . . . . . . . . . . . . . . . . Operand (
    1: 13: . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    1: 14: . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: echo, Ellipsis: false, isCmd: true}
    1: 14: . . . . . . . . . . )
    1: 14: . . . . . . . . . )
    1: 14: . . . . . . . . )
    1: 14: . . . . . . . )
    1: 14: . . . . . . )
    1: 14: . . . . . )
    1: 14: . . . . )
    1: 14: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT echo
 /app/parser/parser.go:713: ast.Ident{Name: echo}
    2:  6: . . . . . . . . . . )
    2:  6: . . . . . . . . . . CallOrConversion (
    2:  6: . . . . . . . . . . . Expression (
    2:  6: . . . . . . . . . . . . BinaryExpr (
    2:  6: . . . . . . . . . . . . . UnaryExpr (
    2:  6: . . . . . . . . . . . . . . PrimaryExpr (
    2:  6: . . . . . . . . . . . . . . . Operand (
    2:  6: . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2:  8: . . . . . . . . . . . . . . . )
    2:  8: . . . . . . . . . . . . . . )
    2:  8: . . . . . . . . . . . . . )
    2:  8: . . . . . . . . . . . . . "<>"
    2: 11: . . . . . . . . . . . . . BinaryExpr (
    2: 11: . . . . . . . . . . . . . . UnaryExpr (
    2: 11: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 11: . . . . . . . . . . . . . . . . Operand (
    2: 11: . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    2: 12: . . . . . . . . . . . . . . . . )
    2: 12: . . . . . . . . . . . . . . . )
    2: 12: . . . . . . . . . . . . . . )
    2: 12: . . . . . . . . . . . . . . "+"
    2: 13: . . . . . . . . . . . . . . BinaryExpr (
    2: 13: . . . . . . . . . . . . . . . UnaryExpr (
    2: 13: . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 13: . . . . . . . . . . . . . . . . . Operand (
    2: 13: . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2: 14: . . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: echo, Ellipsis: false, isCmd: true}
    2: 14: . . . . . . . . . . )
    2: 14: . . . . . . . . . )
    2: 14: . . . . . . . . )
    2: 14: . . . . . . . )
    2: 14: . . . . . . )
    2: 14: . . . . . )
    2: 14: . . . . )
    2: 14: . . . . ";"
    3:  1: . . . )
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . IDENT echo
 /app/parser/parser.go:713: ast.Ident{Name: echo}
    3:  6: . . . . . . . . . . )
    3:  6: . . . . . . . . . . CallOrConversion (
    3:  6: . . . . . . . . . . . Expression (
    3:  6: . . . . . . . . . . . . BinaryExpr (
    3:  6: . . . . . . . . . . . . . UnaryExpr (
    3:  6: . . . . . . . . . . . . . . PrimaryExpr (
    3:  6: . . . . . . . . . . . . . . . Operand (
    3:  6: . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    3:  8: . . . . . . . . . . . . . . . )
    3:  8: . . . . . . . . . . . . . . )
    3:  8: . . . . . . . . . . . . . )
    3:  8: . . . . . . . . . . . . . "->"
    3: 11: . . . . . . . . . . . . . BinaryExpr (
    3: 11: . . . . . . . . . . . . . . UnaryExpr (
    3: 11: . . . . . . . . . . . . . . . PrimaryExpr (
    3: 11: . . . . . . . . . . . . . . . . Operand (
    3: 11: . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    3: 12: . . . . . . . . . . . . . . . . )
    3: 12: . . . . . . . . . . . . . . . )
    3: 12: . . . . . . . . . . . . . . )
    3: 12: . . . . . . . . . . . . . )
    3: 12: . . . . . . . . . . . . )
    3: 12: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: echo, Ellipsis: false, isCmd: true}
    3: 12: . . . . . . . . . . )
    3: 12: . . . . . . . . . )
    3: 12: . . . . . . . . )
    3: 12: . . . . . . . )
    3: 12: . . . . . . )
    3: 12: . . . . . )
    3: 12: . . . . )
    3: 12: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT echo
 /app/parser/parser.go:713: ast.Ident{Name: echo}
    4:  6: . . . . . . . . . . )
    4:  6: . . . . . . . . . . CallOrConversion (
    4:  6: . . . . . . . . . . . Expression (
    4:  6: . . . . . . . . . . . . BinaryExpr (
    4:  6: . . . . . . . . . . . . . UnaryExpr (
    4:  6: . . . . . . . . . . . . . . PrimaryExpr (
    4:  6: . . . . . . . . . . . . . . . Operand (
    4:  6: . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    4:  8: . . . . . . . . . . . . . . . )
    4:  8: . . . . . . . . . . . . . . )
    4:  8: . . . . . . . . . . . . . )
    4:  8: . . . . . . . . . . . . . "<>"
    4: 11: . . . . . . . . . . . . . BinaryExpr (
    4: 11: . . . . . . . . . . . . . . UnaryExpr (
    4: 11: . . . . . . . . . . . . . . . PrimaryExpr (
    4: 11: . . . . . . . . . . . . . . . . Operand (
    4: 11: . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    4: 12: . . . . . . . . . . . . . . . . )
    4: 12: . . . . . . . . . . . . . . . )
    4: 12: . . . . . . . . . . . . . . )
    4: 12: . . . . . . . . . . . . . )
    4: 12: . . . . . . . . . . . . )
    4: 12: . . . . . . . . . . . )
    4: 12: . . . . . . . . . . . ","
    4: 14: . . . . . . . . . . . Expression (
    4: 14: . . . . . . . . . . . . BinaryExpr (
    4: 14: . . . . . . . . . . . . . UnaryExpr (
    4: 14: . . . . . . . . . . . . . . PrimaryExpr (
    4: 14: . . . . . . . . . . . . . . . Operand (
    4: 14: . . . . . . . . . . . . . . . . STRING "Hi"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hi"}
    4: 18: . . . . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: echo, Ellipsis: false, isCmd: true}
    4: 18: . . . . . . . . . . )
    4: 18: . . . . . . . . . )
    4: 18: . . . . . . . . )
    4: 18: . . . . . . . )
    4: 18: . . . . . . )
    4: 18: . . . . . )
    4: 18: . . . . )
    4: 18: . . . . ";"
    4: 19: . . . )
    4: 19: . . )
    4: 19: . )
    4: 19: )
=== RUN   TestFromTestdata/autoprop
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/autoprop
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT L
 /app/parser/parser.go:713: ast.Ident{Name: L}
    1:  2: . . . . . . . . . . )
    1:  2: . . . . . . . . . )
    1:  2: . . . . . . . . )
    1:  2: . . . . . . . )
    1:  2: . . . . . . )
    1:  2: . . . . . )
    1:  2: . . . . . ":"
    2:  2: . . . . . Statement (
    2:  2: . . . . . . BranchStmt (
    2:  2: . . . . . . . "goto"
    2:  2: . . . . . . . SimpleStmt (
    2:  2: . . . . . . . . ExpressionList (
    2:  2: . . . . . . . . . Expression (
    2:  2: . . . . . . . . . . BinaryExpr (
    2:  2: . . . . . . . . . . . UnaryExpr (
    2:  2: . . . . . . . . . . . . PrimaryExpr (
    2:  2: . . . . . . . . . . . . . Operand (
 /app/parser/parser.go:713: ast.Ident{Name: goto}
    2:  6: . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . CallOrConversion (
    2:  6: . . . . . . . . . . . . . . "("
    2:  7: . . . . . . . . . . . . . . Expression (
    2:  7: . . . . . . . . . . . . . . . BinaryExpr (
    2:  7: . . . . . . . . . . . . . . . . UnaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . . Operand (
    2:  7: . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2:  8: . . . . . . . . . . . . . . . . . . )
    2:  8: . . . . . . . . . . . . . . . . . )
    2:  8: . . . . . . . . . . . . . . . . )
    2:  8: . . . . . . . . . . . . . . . )
    2:  8: . . . . . . . . . . . . . . )
    2:  8: . . . . . . . . . . . . . . ","
    2: 10: . . . . . . . . . . . . . . Expression (
    2: 10: . . . . . . . . . . . . . . . BinaryExpr (
    2: 10: . . . . . . . . . . . . . . . . UnaryExpr (
    2: 10: . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 10: . . . . . . . . . . . . . . . . . . Operand (
    2: 10: . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    2: 11: . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: goto, Ellipsis: false, isCmd: false}
    2: 13: . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . "+"
    2: 15: . . . . . . . . . . . BinaryExpr (
    2: 15: . . . . . . . . . . . . UnaryExpr (
    2: 15: . . . . . . . . . . . . . PrimaryExpr (
    2: 15: . . . . . . . . . . . . . . Operand (
    2: 15: . . . . . . . . . . . . . . . IDENT break
 /app/parser/parser.go:713: ast.Ident{Name: break}
    2: 20: . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . CallOrConversion (
    2: 20: . . . . . . . . . . . . . . . "("
    2: 21: . . . . . . . . . . . . . . . Expression (
    2: 21: . . . . . . . . . . . . . . . . BinaryExpr (
    2: 21: . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 21: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 21: . . . . . . . . . . . . . . . . . . . Operand (
    2: 21: . . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    2: 22: . . . . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . ","
    2: 24: . . . . . . . . . . . . . . . Expression (
    2: 24: . . . . . . . . . . . . . . . . BinaryExpr (
    2: 24: . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 24: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 24: . . . . . . . . . . . . . . . . . . . Operand (
    2: 24: . . . . . . . . . . . . . . . . . . . . INT 4
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 4}
    2: 25: . . . . . . . . . . . . . . . . . . . )
    2: 25: . . . . . . . . . . . . . . . . . . )
    2: 25: . . . . . . . . . . . . . . . . . )
    2: 25: . . . . . . . . . . . . . . . . )
    2: 25: . . . . . . . . . . . . . . . )
    2: 25: . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: break, Ellipsis: false, isCmd: false}
    2: 27: . . . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . "+"
    2: 29: . . . . . . . . . . . BinaryExpr (
    2: 29: . . . . . . . . . . . . UnaryExpr (
    2: 29: . . . . . . . . . . . . . PrimaryExpr (
    2: 29: . . . . . . . . . . . . . . Operand (
    2: 29: . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2: 30: . . . . . . . . . . . . . . )
    2: 30: . . . . . . . . . . . . . . "."
    2: 31: . . . . . . . . . . . . . . Selector (
    2: 31: . . . . . . . . . . . . . . . IDENT goto
 /app/parser/parser.go:713: ast.Ident{Name: goto}
    2: 35: . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . CallOrConversion (
    2: 35: . . . . . . . . . . . . . . . "("
    2: 36: . . . . . . . . . . . . . . . Expression (
    2: 36: . . . . . . . . . . . . . . . . BinaryExpr (
    2: 36: . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 36: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 36: . . . . . . . . . . . . . . . . . . . Operand (
    2: 36: . . . . . . . . . . . . . . . . . . . . INT 6
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 6}
    2: 37: . . . . . . . . . . . . . . . . . . . )
    2: 37: . . . . . . . . . . . . . . . . . . )
    2: 37: . . . . . . . . . . . . . . . . . )
    2: 37: . . . . . . . . . . . . . . . . )
    2: 37: . . . . . . . . . . . . . . . )
    2: 37: . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{a goto}, Ellipsis: false, isCmd: false}
    2: 38: . . . . . . . . . . . . . . )
    2: 38: . . . . . . . . . . . . . )
    2: 38: . . . . . . . . . . . . )
    2: 38: . . . . . . . . . . . )
    2: 38: . . . . . . . . . . )
    2: 38: . . . . . . . . . )
    2: 38: . . . . . . . . )
    2: 38: . . . . . . . )
    2: 38: . . . . . . . ";"
    3:  2: . . . . . . )
    3:  2: . . . . . )
    3:  2: . . . . )
    3:  2: . . . )
    3:  2: . . . Statement (
    3:  2: . . . . BranchStmt (
    3:  2: . . . . . "goto"
    3:  7: . . . . . IDENT L
 /app/parser/parser.go:713: ast.Ident{Name: L}
    3:  8: . . . . . ";"
    3:  9: . . . . )
    3:  9: . . . )
    3:  9: . . )
    3:  9: . )
    3:  9: )
=== RUN   TestFromTestdata/build
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/build
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . GenDecl(type) (
    1:  1: . . . "type"
    1:  6: . . . TypeSpec (
    1:  6: . . . . IDENT cstring
 /app/parser/parser.go:713: ast.Ident{Name: cstring}
    1: 14: . . . . Type (
    1: 14: . . . . . TypeName (
    1: 14: . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    1: 20: . . . . . )
    1: 20: . . . . )
    1: 20: . . . . ";"
    3:  1: . . . )
    3:  1: . . )
    3:  1: . )
    3:  1: . Declaration (
    3:  1: . . StatementList (
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . IDENT title
 /app/parser/parser.go:713: ast.Ident{Name: title}
    3:  7: . . . . . . . . . . )
    3:  7: . . . . . . . . . )
    3:  7: . . . . . . . . )
    3:  7: . . . . . . . )
    3:  7: . . . . . . )
    3:  7: . . . . . )
    3:  7: . . . . . ":="
    3: 10: . . . . . ExpressionList (
    3: 10: . . . . . . Expression (
    3: 10: . . . . . . . BinaryExpr (
    3: 10: . . . . . . . . UnaryExpr (
    3: 10: . . . . . . . . . PrimaryExpr (
    3: 10: . . . . . . . . . . Operand (
    3: 10: . . . . . . . . . . . STRING "Hello,world!2020-05-27"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hello,world!2020-05-27"}
    3: 34: . . . . . . . . . . )
    3: 34: . . . . . . . . . )
    3: 34: . . . . . . . . )
    3: 34: . . . . . . . )
    3: 34: . . . . . . )
    3: 34: . . . . . )
    3: 34: . . . . )
    3: 34: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT s
 /app/parser/parser.go:713: ast.Ident{Name: s}
    4:  3: . . . . . . . . . . )
    4:  3: . . . . . . . . . )
    4:  3: . . . . . . . . )
    4:  3: . . . . . . . )
    4:  3: . . . . . . )
    4:  3: . . . . . )
    4:  3: . . . . . ":="
    4:  6: . . . . . ExpressionList (
    4:  6: . . . . . . Expression (
    4:  6: . . . . . . . BinaryExpr (
    4:  6: . . . . . . . . UnaryExpr (
    4:  6: . . . . . . . . . PrimaryExpr (
    4:  6: . . . . . . . . . . Operand (
    4:  6: . . . . . . . . . . . "("
    4:  7: . . . . . . . . . . . Expression (
    4:  7: . . . . . . . . . . . . BinaryExpr (
    4:  7: . . . . . . . . . . . . . UnaryExpr (
    4:  7: . . . . . . . . . . . . . . "*"
    4:  8: . . . . . . . . . . . . . . UnaryExpr (
    4:  8: . . . . . . . . . . . . . . . PrimaryExpr (
    4:  8: . . . . . . . . . . . . . . . . Operand (
    4:  8: . . . . . . . . . . . . . . . . . IDENT cstring
 /app/parser/parser.go:713: ast.Ident{Name: cstring}
    4: 15: . . . . . . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . )
    4: 15: . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{62 cstring}}
    4: 16: . . . . . . . . . . )
    4: 16: . . . . . . . . . . CallOrConversion (
    4: 16: . . . . . . . . . . . "("
    4: 17: . . . . . . . . . . . Expression (
    4: 17: . . . . . . . . . . . . BinaryExpr (
    4: 17: . . . . . . . . . . . . . UnaryExpr (
    4: 17: . . . . . . . . . . . . . . "&"
    4: 18: . . . . . . . . . . . . . . UnaryExpr (
    4: 18: . . . . . . . . . . . . . . . PrimaryExpr (
    4: 18: . . . . . . . . . . . . . . . . Operand (
    4: 18: . . . . . . . . . . . . . . . . . IDENT title
 /app/parser/parser.go:713: ast.Ident{Name: title}
    4: 23: . . . . . . . . . . . . . . . . )
    4: 23: . . . . . . . . . . . . . . . )
    4: 23: . . . . . . . . . . . . . . )
    4: 23: . . . . . . . . . . . . . )
    4: 23: . . . . . . . . . . . . )
    4: 23: . . . . . . . . . . . )
    4: 23: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{61 0xc000010408 70}, Ellipsis: false, isCmd: false}
    4: 24: . . . . . . . . . . )
    4: 24: . . . . . . . . . )
    4: 24: . . . . . . . . )
    4: 24: . . . . . . . )
    4: 24: . . . . . . )
    4: 24: . . . . . )
    4: 24: . . . . )
    4: 24: . . . . ";"
    5:  1: . . . )
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5:  8: . . . . . . . . . . )
    5:  8: . . . . . . . . . . CallOrConversion (
    5:  8: . . . . . . . . . . . "("
    5:  9: . . . . . . . . . . . Expression (
    5:  9: . . . . . . . . . . . . BinaryExpr (
    5:  9: . . . . . . . . . . . . . UnaryExpr (
    5:  9: . . . . . . . . . . . . . . PrimaryExpr (
    5:  9: . . . . . . . . . . . . . . . Operand (
    5:  9: . . . . . . . . . . . . . . . . IDENT title
 /app/parser/parser.go:713: ast.Ident{Name: title}
    5: 14: . . . . . . . . . . . . . . . )
    5: 14: . . . . . . . . . . . . . . . IndexOrSlice (
    5: 14: . . . . . . . . . . . . . . . . "["
    5: 15: . . . . . . . . . . . . . . . . Expression (
    5: 15: . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 15: . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 15: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 15: . . . . . . . . . . . . . . . . . . . . Operand (
    5: 15: . . . . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    5: 17: . . . . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . ":"
    5: 19: . . . . . . . . . . . . . . . . Expression (
    5: 19: . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 19: . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 19: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 19: . . . . . . . . . . . . . . . . . . . . Operand (
    5: 19: . . . . . . . . . . . . . . . . . . . . . IDENT len
 /app/parser/parser.go:713: ast.Ident{Name: len}
    5: 22: . . . . . . . . . . . . . . . . . . . . )
    5: 22: . . . . . . . . . . . . . . . . . . . . CallOrConversion (
    5: 22: . . . . . . . . . . . . . . . . . . . . . "("
    5: 23: . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 23: . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 23: . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 23: . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 23: . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 23: . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT title
 /app/parser/parser.go:713: ast.Ident{Name: title}
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 28: . . . . . . . . . . . . . . . . . . . . . . )
    5: 28: . . . . . . . . . . . . . . . . . . . . . )
    5: 28: . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: len, Ellipsis: false, isCmd: false}
    5: 29: . . . . . . . . . . . . . . . . . . . . )
    5: 29: . . . . . . . . . . . . . . . . . . . )
    5: 29: . . . . . . . . . . . . . . . . . . )
    5: 29: . . . . . . . . . . . . . . . . . . "-"
    5: 30: . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 30: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 30: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 30: . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 30: . . . . . . . . . . . . . . . . . . . . . . IDENT len
 /app/parser/parser.go:713: ast.Ident{Name: len}
    5: 33: . . . . . . . . . . . . . . . . . . . . . )
    5: 33: . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
    5: 33: . . . . . . . . . . . . . . . . . . . . . . "("
    5: 34: . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "2006-01-02"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "2006-01-02"}
    5: 46: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 46: . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 46: . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 46: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 46: . . . . . . . . . . . . . . . . . . . . . . )
    5: 46: . . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: len, Ellipsis: false, isCmd: false}
    5: 47: . . . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . "]"
    5: 48: . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    5: 49: . . . . . . . . . . )
    5: 49: . . . . . . . . . )
    5: 49: . . . . . . . . )
    5: 49: . . . . . . . )
    5: 49: . . . . . . )
    5: 49: . . . . . )
    5: 49: . . . . )
    5: 49: . . . . ";"
    5: 50: . . . )
    5: 50: . . )
    5: 50: . )
    5: 50: )
=== RUN   TestFromTestdata/c2gohello
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/c2gohello
    1:  1: File (
    1:  1: . GenDecl(import) (
    1:  1: . . "import"
    1:  8: . . ImportSpec (
    1:  8: . . . STRING "C"
    1: 11: . . . ";"
    3:  1: . . )
    3:  1: . )
    3:  1: . Declaration (
    3:  1: . . StatementList (
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . IDENT C
 /app/parser/parser.go:713: ast.Ident{Name: C}
    3:  2: . . . . . . . . . . )
    3:  2: . . . . . . . . . . "."
    3:  3: . . . . . . . . . . Selector (
    3:  3: . . . . . . . . . . . IDENT printf
 /app/parser/parser.go:713: ast.Ident{Name: printf}
    3: 10: . . . . . . . . . . )
    3: 10: . . . . . . . . . . CallOrConversion (
    3: 10: . . . . . . . . . . . Expression (
    3: 10: . . . . . . . . . . . . BinaryExpr (
    3: 10: . . . . . . . . . . . . . UnaryExpr (
    3: 10: . . . . . . . . . . . . . . PrimaryExpr (
    3: 10: . . . . . . . . . . . . . . . Operand (
    3: 10: . . . . . . . . . . . . . . . . CSTRING "Hello, world!\n"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: CSTRING, Value: "Hello, world!\n"}
    3: 28: . . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{C printf}, Ellipsis: false, isCmd: true}
    3: 28: . . . . . . . . . . )
    3: 28: . . . . . . . . . )
    3: 28: . . . . . . . . )
    3: 28: . . . . . . . )
    3: 28: . . . . . . )
    3: 28: . . . . . )
    3: 28: . . . . )
    3: 28: . . . . ";"
    3: 29: . . . )
    3: 29: . . )
    3: 29: . )
    3: 29: )
=== RUN   TestFromTestdata/cmdlinestyle1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/cmdlinestyle1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . . CallOrConversion (
    1:  9: . . . . . . . . . . . Expression (
    1:  9: . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . . . . . . . "("
    1: 10: . . . . . . . . . . . . . . . . Expression (
    1: 10: . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 10: . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 10: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 10: . . . . . . . . . . . . . . . . . . . . Operand (
    1: 10: . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1: 11: . . . . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . . "+"
    1: 12: . . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 12: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 12: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 12: . . . . . . . . . . . . . . . . . . . . . Operand (
    1: 12: . . . . . . . . . . . . . . . . . . . . . . IMAG 2i
 /app/parser/parser.go:1862: ast.BasicLit{Kind: IMAG, Value: 2i}
    1: 14: . . . . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{0xc000382f60 11 + 0xc000382f90}}
    1: 15: . . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . "*"
    1: 16: . . . . . . . . . . . . . BinaryExpr (
    1: 16: . . . . . . . . . . . . . . UnaryExpr (
    1: 16: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 16: . . . . . . . . . . . . . . . . Operand (
    1: 16: . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    1: 17: . . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    1: 17: . . . . . . . . . . )
    1: 17: . . . . . . . . . )
    1: 17: . . . . . . . . )
    1: 17: . . . . . . . )
    1: 17: . . . . . . )
    1: 17: . . . . . )
    1: 17: . . . . )
    1: 17: . . . . ";"
    1: 18: . . . )
    1: 18: . . )
    1: 18: . )
    1: 18: )
=== RUN   TestFromTestdata/cmdlinestyle2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/cmdlinestyle2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . . CallOrConversion (
    1:  3: . . . . . . . . . . . Expression (
    1:  3: . . . . . . . . . . . . BinaryExpr (
    1:  3: . . . . . . . . . . . . . UnaryExpr (
    1:  3: . . . . . . . . . . . . . . PrimaryExpr (
    1:  3: . . . . . . . . . . . . . . . Operand (
    1:  3: . . . . . . . . . . . . . . . . LiteralValue (
    1:  3: . . . . . . . . . . . . . . . . . "{"
    1:  4: . . . . . . . . . . . . . . . . . "}"
    1:  5: . . . . . . . . . . . . . . . . )
    1:  5: . . . . . . . . . . . . . . . )
    1:  5: . . . . . . . . . . . . . . )
    1:  5: . . . . . . . . . . . . . )
    1:  5: . . . . . . . . . . . . )
    1:  5: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: x, Ellipsis: false, isCmd: true}
    1:  5: . . . . . . . . . . )
    1:  5: . . . . . . . . . )
    1:  5: . . . . . . . . )
    1:  5: . . . . . . . )
    1:  5: . . . . . . )
    1:  5: . . . . . )
    1:  5: . . . . )
    1:  5: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2:  2: . . . . . . . . . . )
    2:  2: . . . . . . . . . . LiteralValue (
    2:  2: . . . . . . . . . . . "{"
    2:  3: . . . . . . . . . . . "}"
    2:  4: . . . . . . . . . . )
    2:  4: . . . . . . . . . )
    2:  4: . . . . . . . . )
    2:  4: . . . . . . . )
    2:  4: . . . . . . )
    2:  4: . . . . . )
    2:  4: . . . . )
    2:  4: . . . . ";"
    2:  5: . . . )
    2:  5: . . )
    2:  5: . )
    2:  5: )
=== RUN   TestFromTestdata/cmdlinestyle3
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/cmdlinestyle3
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . . "&"
    1:  9: . . . . . . . . . . CallOrConversion (
    1:  9: . . . . . . . . . . . Expression (
    1:  9: . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . UnaryExpr (
    1: 10: . . . . . . . . . . . . . . UnaryExpr (
    1: 10: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 10: . . . . . . . . . . . . . . . . Operand (
    1: 10: . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1: 11: . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    1: 11: . . . . . . . . . . )
    1: 11: . . . . . . . . . )
    1: 11: . . . . . . . . )
    1: 11: . . . . . . . )
    1: 11: . . . . . . )
    1: 11: . . . . . )
    1: 11: . . . . )
    1: 11: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  9: . . . . . . . . . . )
    2:  9: . . . . . . . . . . CallOrConversion (
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . "!"
    2: 10: . . . . . . . . . . . . . . UnaryExpr (
    2: 10: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 10: . . . . . . . . . . . . . . . . Operand (
    2: 10: . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 11: . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    2: 11: . . . . . . . . . . )
    2: 11: . . . . . . . . . )
    2: 11: . . . . . . . . )
    2: 11: . . . . . . . )
    2: 11: . . . . . . )
    2: 11: . . . . . )
    2: 11: . . . . )
    2: 11: . . . . ";"
    2: 12: . . . )
    2: 12: . . )
    2: 12: . )
    2: 12: )
=== RUN   TestFromTestdata/cmdlinestyle4
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/cmdlinestyle4
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  6: . . . IDENT call
 /app/parser/parser.go:713: ast.Ident{Name: call}
    1: 10: . . . Signature (
    1: 10: . . . . Parameters (
    1: 10: . . . . . "("
    1: 11: . . . . . ParameterList (
    1: 11: . . . . . . ParamDeclOrNil (
    1: 11: . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
    1: 14: . . . . . . . Type (
    1: 14: . . . . . . . . FuncType (
    1: 14: . . . . . . . . . "func"
    1: 18: . . . . . . . . . Signature (
    1: 18: . . . . . . . . . . Parameters (
    1: 18: . . . . . . . . . . . "("
    1: 19: . . . . . . . . . . . ParameterList (
    1: 19: . . . . . . . . . . . . ParamDeclOrNil (
    1: 19: . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1: 21: . . . . . . . . . . . . . Type (
    1: 21: . . . . . . . . . . . . . . TypeName (
    1: 21: . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 24: . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . ")"
    1: 25: . . . . . . . . . . )
    1: 25: . . . . . . . . . . Result (
    1: 25: . . . . . . . . . . )
    1: 25: . . . . . . . . . )
    1: 25: . . . . . . . . )
    1: 25: . . . . . . . )
    1: 25: . . . . . . )
    1: 25: . . . . . )
    1: 25: . . . . . ")"
    1: 27: . . . . )
    1: 27: . . . . Result (
    1: 27: . . . . )
    1: 27: . . . )
    1: 27: . . . Body (
    1: 27: . . . . "{"
    1: 29: . . . . StatementList (
    1: 29: . . . . . Statement (
    1: 29: . . . . . . SimpleStmt (
    1: 29: . . . . . . . ExpressionList (
    1: 29: . . . . . . . . Expression (
    1: 29: . . . . . . . . . BinaryExpr (
    1: 29: . . . . . . . . . . UnaryExpr (
    1: 29: . . . . . . . . . . . PrimaryExpr (
    1: 29: . . . . . . . . . . . . Operand (
    1: 29: . . . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
    1: 31: . . . . . . . . . . . . )
    1: 31: . . . . . . . . . . . . CallOrConversion (
    1: 31: . . . . . . . . . . . . . "("
    1: 32: . . . . . . . . . . . . . Expression (
    1: 32: . . . . . . . . . . . . . . BinaryExpr (
    1: 32: . . . . . . . . . . . . . . . UnaryExpr (
    1: 32: . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 32: . . . . . . . . . . . . . . . . . Operand (
    1: 32: . . . . . . . . . . . . . . . . . . INT 100
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
    1: 35: . . . . . . . . . . . . . . . . . )
    1: 35: . . . . . . . . . . . . . . . . )
    1: 35: . . . . . . . . . . . . . . . )
    1: 35: . . . . . . . . . . . . . . )
    1: 35: . . . . . . . . . . . . . )
    1: 35: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: fn, Ellipsis: false, isCmd: false}
    1: 37: . . . . . . . . . . . . )
    1: 37: . . . . . . . . . . . )
    1: 37: . . . . . . . . . . )
    1: 37: . . . . . . . . . )
    1: 37: . . . . . . . . )
    1: 37: . . . . . . . )
    1: 37: . . . . . . )
    1: 37: . . . . . )
    1: 37: . . . . )
    1: 37: . . . . "}"
    1: 38: . . . )
    1: 38: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: call, ...}
    3:  1: . . )
    3:  1: . )
    3:  1: . Declaration (
    3:  1: . . StatementList (
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . IDENT call
 /app/parser/parser.go:713: ast.Ident{Name: call}
    3:  5: . . . . . . . . . . )
    3:  5: . . . . . . . . . . CallOrConversion (
    3:  5: . . . . . . . . . . . "("
    3:  6: . . . . . . . . . . . Expression (
    3:  6: . . . . . . . . . . . . BinaryExpr (
    3:  6: . . . . . . . . . . . . . UnaryExpr (
    3:  6: . . . . . . . . . . . . . . PrimaryExpr (
    3:  6: . . . . . . . . . . . . . . . Operand (
    3:  6: . . . . . . . . . . . . . . . . FuncTypeOrLit (
    3:  6: . . . . . . . . . . . . . . . . . FuncType (
    3:  6: . . . . . . . . . . . . . . . . . . "func"
    3: 10: . . . . . . . . . . . . . . . . . . Signature (
    3: 10: . . . . . . . . . . . . . . . . . . . Parameters (
    3: 10: . . . . . . . . . . . . . . . . . . . . "("
    3: 11: . . . . . . . . . . . . . . . . . . . . ParameterList (
    3: 11: . . . . . . . . . . . . . . . . . . . . . ParamDeclOrNil (
    3: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    3: 13: . . . . . . . . . . . . . . . . . . . . . . Type (
    3: 13: . . . . . . . . . . . . . . . . . . . . . . . TypeName (
    3: 13: . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    3: 16: . . . . . . . . . . . . . . . . . . . . . . . )
    3: 16: . . . . . . . . . . . . . . . . . . . . . . )
    3: 16: . . . . . . . . . . . . . . . . . . . . . )
    3: 16: . . . . . . . . . . . . . . . . . . . . )
    3: 16: . . . . . . . . . . . . . . . . . . . . ")"
    3: 18: . . . . . . . . . . . . . . . . . . . )
    3: 18: . . . . . . . . . . . . . . . . . . . Result (
    3: 18: . . . . . . . . . . . . . . . . . . . )
    3: 18: . . . . . . . . . . . . . . . . . . )
    3: 18: . . . . . . . . . . . . . . . . . )
    3: 18: . . . . . . . . . . . . . . . . . Body (
    3: 18: . . . . . . . . . . . . . . . . . . "{"
    3: 20: . . . . . . . . . . . . . . . . . . StatementList (
    3: 20: . . . . . . . . . . . . . . . . . . . Statement (
    3: 20: . . . . . . . . . . . . . . . . . . . . SimpleStmt (
    3: 20: . . . . . . . . . . . . . . . . . . . . . ExpressionList (
    3: 20: . . . . . . . . . . . . . . . . . . . . . . Expression (
    3: 20: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    3: 20: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3: 20: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 20: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    3: 20: . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    3: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . . . . . . )
    3: 28: . . . . . . . . . . . . . . . . . . "}"
    3: 29: . . . . . . . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: call, Ellipsis: false, isCmd: false}
    3: 30: . . . . . . . . . . )
    3: 30: . . . . . . . . . )
    3: 30: . . . . . . . . )
    3: 30: . . . . . . . )
    3: 30: . . . . . . )
    3: 30: . . . . . )
    3: 30: . . . . )
    3: 30: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT call
 /app/parser/parser.go:713: ast.Ident{Name: call}
    4:  5: . . . . . . . . . . )
    4:  5: . . . . . . . . . . CallOrConversion (
    4:  5: . . . . . . . . . . . "("
    4:  6: . . . . . . . . . . . Expression (
    4:  6: . . . . . . . . . . . . BinaryExpr (
    4:  6: . . . . . . . . . . . . . UnaryExpr (
    4:  6: . . . . . . . . . . . . . . PrimaryExpr (
    4:  6: . . . . . . . . . . . . . . . Operand (
    4:  6: . . . . . . . . . . . . . . . . FuncTypeOrLit (
    4:  6: . . . . . . . . . . . . . . . . . FuncType (
    4:  6: . . . . . . . . . . . . . . . . . . "func"
    4: 10: . . . . . . . . . . . . . . . . . . Signature (
    4: 10: . . . . . . . . . . . . . . . . . . . Parameters (
    4: 10: . . . . . . . . . . . . . . . . . . . . "("
    4: 11: . . . . . . . . . . . . . . . . . . . . ParameterList (
    4: 11: . . . . . . . . . . . . . . . . . . . . . ParamDeclOrNil (
    4: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4: 13: . . . . . . . . . . . . . . . . . . . . . . Type (
    4: 13: . . . . . . . . . . . . . . . . . . . . . . . TypeName (
    4: 13: . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    4: 16: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 16: . . . . . . . . . . . . . . . . . . . . . . )
    4: 16: . . . . . . . . . . . . . . . . . . . . . )
    4: 16: . . . . . . . . . . . . . . . . . . . . )
    4: 16: . . . . . . . . . . . . . . . . . . . . ")"
    4: 18: . . . . . . . . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . . . . . . . . . Result (
    4: 18: . . . . . . . . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . . . . . . . )
    4: 18: . . . . . . . . . . . . . . . . . Body (
    4: 18: . . . . . . . . . . . . . . . . . . "{"
    4: 20: . . . . . . . . . . . . . . . . . . StatementList (
    4: 20: . . . . . . . . . . . . . . . . . . . Statement (
    4: 20: . . . . . . . . . . . . . . . . . . . . SimpleStmt (
    4: 20: . . . . . . . . . . . . . . . . . . . . . ExpressionList (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . Expression (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    4: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
    4: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    4: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . "}"
    4: 31: . . . . . . . . . . . . . . . . . )
    4: 31: . . . . . . . . . . . . . . . . )
    4: 31: . . . . . . . . . . . . . . . )
    4: 31: . . . . . . . . . . . . . . )
    4: 31: . . . . . . . . . . . . . )
    4: 31: . . . . . . . . . . . . )
    4: 31: . . . . . . . . . . . )
    4: 31: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: call, Ellipsis: false, isCmd: false}
    4: 32: . . . . . . . . . . )
    4: 32: . . . . . . . . . )
    4: 32: . . . . . . . . )
    4: 32: . . . . . . . )
    4: 32: . . . . . . )
    4: 32: . . . . . )
    4: 32: . . . . )
    4: 32: . . . . ";"
    5:  1: . . . )
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT call
 /app/parser/parser.go:713: ast.Ident{Name: call}
    5:  5: . . . . . . . . . . )
    5:  5: . . . . . . . . . . CallOrConversion (
    5:  5: . . . . . . . . . . . "("
    5:  6: . . . . . . . . . . . Expression (
    5:  6: . . . . . . . . . . . . BinaryExpr (
    5:  6: . . . . . . . . . . . . . UnaryExpr (
    5:  6: . . . . . . . . . . . . . . PrimaryExpr (
    5:  6: . . . . . . . . . . . . . . . Operand (
    5:  6: . . . . . . . . . . . . . . . . FuncTypeOrLit (
    5:  6: . . . . . . . . . . . . . . . . . FuncType (
    5:  6: . . . . . . . . . . . . . . . . . . "func"
    5: 10: . . . . . . . . . . . . . . . . . . Signature (
    5: 10: . . . . . . . . . . . . . . . . . . . Parameters (
    5: 10: . . . . . . . . . . . . . . . . . . . . "("
    5: 11: . . . . . . . . . . . . . . . . . . . . ParameterList (
    5: 11: . . . . . . . . . . . . . . . . . . . . . ParamDeclOrNil (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    5: 13: . . . . . . . . . . . . . . . . . . . . . . Type (
    5: 13: . . . . . . . . . . . . . . . . . . . . . . . TypeName (
    5: 13: . . . . . . . . . . . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5: 16: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . . . ")"
    5: 18: . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . . Result (
    5: 18: . . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . )
    5: 18: . . . . . . . . . . . . . . . . . Body (
    5: 18: . . . . . . . . . . . . . . . . . . "{"
    5: 20: . . . . . . . . . . . . . . . . . . StatementList (
    5: 20: . . . . . . . . . . . . . . . . . . . Statement (
    5: 20: . . . . . . . . . . . . . . . . . . . . SimpleStmt (
    5: 20: . . . . . . . . . . . . . . . . . . . . . ExpressionList (
    5: 20: . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 20: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 20: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 20: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 20: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 20: . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . LiteralValue (
    5: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "{"
    5: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ElementList (
    5: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
    5: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
    5: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "x"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "x"}
    5: 32: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 32: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 32: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 32: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 32: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 32: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 32: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ":"
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . INT 100
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
    5: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ","
    5: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
    5: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
    5: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "y"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "y"}
    5: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ":"
    5: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
    5: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . INT 200
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 200}
    5: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "}"
    5: 48: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 48: . . . . . . . . . . . . . . . . . . . . . . . . . . . ","
    5: 50: . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 50: . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 50: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 50: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 50: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 50: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    5: 52: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    5: 52: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . )
    5: 52: . . . . . . . . . . . . . . . . . . "}"
    5: 53: . . . . . . . . . . . . . . . . . )
    5: 53: . . . . . . . . . . . . . . . . )
    5: 53: . . . . . . . . . . . . . . . )
    5: 53: . . . . . . . . . . . . . . )
    5: 53: . . . . . . . . . . . . . )
    5: 53: . . . . . . . . . . . . )
    5: 53: . . . . . . . . . . . )
    5: 53: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: call, Ellipsis: false, isCmd: false}
    5: 54: . . . . . . . . . . )
    5: 54: . . . . . . . . . )
    5: 54: . . . . . . . . )
    5: 54: . . . . . . . )
    5: 54: . . . . . . )
    5: 54: . . . . . )
    5: 54: . . . . )
    5: 54: . . . . ";"
    5: 55: . . . )
    5: 55: . . )
    5: 55: . )
    5: 55: )
=== RUN   TestFromTestdata/collection
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/collection
    1:  1: COMMENT
    2:  1: COMMENT
    3:  1: COMMENT
    4:  1: COMMENT
    6:  1: COMMENT
    7:  1: COMMENT
    8:  1: COMMENT
    9:  1: COMMENT
   10:  1: COMMENT
   12:  1: COMMENT
   13:  1: COMMENT
   14:  1: COMMENT
   15:  1: COMMENT
   16:  1: COMMENT
   17:  1: COMMENT
   19:  1: File (
   19:  1: . "package"
   19:  9: . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
   19: 13: . ";"
   21:  1: . GenDecl(import) (
   21:  1: . . "import"
   21:  8: . . "("
   22:  2: . . ImportSpec (
   22:  2: . . . STRING "fmt"
   22:  7: . . . ";"
   23:  2: . . )
   23:  2: . . ImportSpec (
   23:  2: . . . STRING "strings"
   23: 11: . . . ";"
   24:  1: . . )
   24:  1: . . ")"
   24:  2: . . ";"
   26:  1: . . COMMENT
   27:  1: . . COMMENT
   28:  1: . )
   28:  1: . Declaration (
   28:  1: . . FunctionDeclOrCall (
   28:  1: . . . "func"
   28:  6: . . . IDENT Index
 /app/parser/parser.go:713: ast.Ident{Name: Index}
   28: 11: . . . Signature (
   28: 11: . . . . Parameters (
   28: 11: . . . . . "("
   28: 12: . . . . . ParameterList (
   28: 12: . . . . . . ParamDeclOrNil (
   28: 12: . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   28: 15: . . . . . . . ArrayFieldOrTypeInstance (
   28: 15: . . . . . . . . "["
   28: 16: . . . . . . . . "]"
   28: 17: . . . . . . . . Type (
   28: 17: . . . . . . . . . TypeName (
   28: 17: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   28: 23: . . . . . . . . . )
   28: 23: . . . . . . . . )
   28: 23: . . . . . . . )
   28: 23: . . . . . . )
   28: 23: . . . . . . ","
   28: 25: . . . . . . ParamDeclOrNil (
   28: 25: . . . . . . . IDENT t
 /app/parser/parser.go:713: ast.Ident{Name: t}
   28: 27: . . . . . . . Type (
   28: 27: . . . . . . . . TypeName (
   28: 27: . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   28: 33: . . . . . . . . )
   28: 33: . . . . . . . )
   28: 33: . . . . . . )
   28: 33: . . . . . )
   28: 33: . . . . . ")"
   28: 35: . . . . )
   28: 35: . . . . Result (
   28: 35: . . . . . TypeName (
   28: 35: . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   28: 39: . . . . . )
   28: 39: . . . . )
   28: 39: . . . )
   28: 39: . . . Body (
   28: 39: . . . . "{"
   29:  2: . . . . StatementList (
   29:  2: . . . . . Statement (
   29:  2: . . . . . . ForStmt (
   29:  2: . . . . . . . "for"
   29:  6: . . . . . . . SimpleStmt (
   29:  6: . . . . . . . . ExpressionList (
   29:  6: . . . . . . . . . Expression (
   29:  6: . . . . . . . . . . BinaryExpr (
   29:  6: . . . . . . . . . . . UnaryExpr (
   29:  6: . . . . . . . . . . . . PrimaryExpr (
   29:  6: . . . . . . . . . . . . . Operand (
   29:  6: . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   29:  7: . . . . . . . . . . . . . )
   29:  7: . . . . . . . . . . . . )
   29:  7: . . . . . . . . . . . )
   29:  7: . . . . . . . . . . )
   29:  7: . . . . . . . . . )
   29:  7: . . . . . . . . . ","
   29:  9: . . . . . . . . . Expression (
   29:  9: . . . . . . . . . . BinaryExpr (
   29:  9: . . . . . . . . . . . UnaryExpr (
   29:  9: . . . . . . . . . . . . PrimaryExpr (
   29:  9: . . . . . . . . . . . . . Operand (
   29:  9: . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   29: 11: . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . )
   29: 11: . . . . . . . . . . )
   29: 11: . . . . . . . . . )
   29: 11: . . . . . . . . )
   29: 11: . . . . . . . . ":="
   29: 14: . . . . . . . . "range"
   29: 20: . . . . . . . . Expression (
   29: 20: . . . . . . . . . RangeExpr (
   29: 20: . . . . . . . . . . BinaryExpr (
   29: 20: . . . . . . . . . . . UnaryExpr (
   29: 20: . . . . . . . . . . . . PrimaryExpr (
   29: 20: . . . . . . . . . . . . . Operand (
   29: 20: . . . . . . . . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   29: 23: . . . . . . . . . . . . . )
   29: 23: . . . . . . . . . . . . )
   29: 23: . . . . . . . . . . . )
   29: 23: . . . . . . . . . . )
   29: 23: . . . . . . . . . )
   29: 23: . . . . . . . . )
   29: 23: . . . . . . . )
   29: 23: . . . . . . . BlockStmt (
   29: 23: . . . . . . . . "{"
   30:  3: . . . . . . . . StatementList (
   30:  3: . . . . . . . . . Statement (
   30:  3: . . . . . . . . . . IfStmt (
   30:  3: . . . . . . . . . . . "if"
   30:  6: . . . . . . . . . . . SimpleStmt (
   30:  6: . . . . . . . . . . . . ExpressionList (
   30:  6: . . . . . . . . . . . . . Expression (
   30:  6: . . . . . . . . . . . . . . BinaryExpr (
   30:  6: . . . . . . . . . . . . . . . UnaryExpr (
   30:  6: . . . . . . . . . . . . . . . . PrimaryExpr (
   30:  6: . . . . . . . . . . . . . . . . . Operand (
   30:  6: . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   30:  8: . . . . . . . . . . . . . . . . . )
   30:  8: . . . . . . . . . . . . . . . . )
   30:  8: . . . . . . . . . . . . . . . )
   30:  8: . . . . . . . . . . . . . . . "=="
   30: 11: . . . . . . . . . . . . . . . BinaryExpr (
   30: 11: . . . . . . . . . . . . . . . . UnaryExpr (
   30: 11: . . . . . . . . . . . . . . . . . PrimaryExpr (
   30: 11: . . . . . . . . . . . . . . . . . . Operand (
   30: 11: . . . . . . . . . . . . . . . . . . . IDENT t
 /app/parser/parser.go:713: ast.Ident{Name: t}
   30: 13: . . . . . . . . . . . . . . . . . . )
   30: 13: . . . . . . . . . . . . . . . . . )
   30: 13: . . . . . . . . . . . . . . . . )
   30: 13: . . . . . . . . . . . . . . . )
   30: 13: . . . . . . . . . . . . . . )
   30: 13: . . . . . . . . . . . . . )
   30: 13: . . . . . . . . . . . . )
   30: 13: . . . . . . . . . . . )
   30: 13: . . . . . . . . . . . BlockStmt (
   30: 13: . . . . . . . . . . . . "{"
   31:  4: . . . . . . . . . . . . StatementList (
   31:  4: . . . . . . . . . . . . . Statement (
   31:  4: . . . . . . . . . . . . . . ReturnStmt (
   31:  4: . . . . . . . . . . . . . . . "return"
   31: 11: . . . . . . . . . . . . . . . ExpressionList (
   31: 11: . . . . . . . . . . . . . . . . Expression (
   31: 11: . . . . . . . . . . . . . . . . . BinaryExpr (
   31: 11: . . . . . . . . . . . . . . . . . . UnaryExpr (
   31: 11: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   31: 11: . . . . . . . . . . . . . . . . . . . . Operand (
   31: 11: . . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   31: 12: . . . . . . . . . . . . . . . . . . . . )
   31: 12: . . . . . . . . . . . . . . . . . . . )
   31: 12: . . . . . . . . . . . . . . . . . . )
   31: 12: . . . . . . . . . . . . . . . . . )
   31: 12: . . . . . . . . . . . . . . . . )
   31: 12: . . . . . . . . . . . . . . . )
   31: 12: . . . . . . . . . . . . . . . ";"
   32:  3: . . . . . . . . . . . . . . )
   32:  3: . . . . . . . . . . . . . )
   32:  3: . . . . . . . . . . . . )
   32:  3: . . . . . . . . . . . . "}"
   32:  4: . . . . . . . . . . . )
   32:  4: . . . . . . . . . . . ";"
   33:  2: . . . . . . . . . . )
   33:  2: . . . . . . . . . )
   33:  2: . . . . . . . . )
   33:  2: . . . . . . . . "}"
   33:  3: . . . . . . . )
   33:  3: . . . . . . . ";"
   34:  2: . . . . . . )
   34:  2: . . . . . )
   34:  2: . . . . . Statement (
   34:  2: . . . . . . ReturnStmt (
   34:  2: . . . . . . . "return"
   34:  9: . . . . . . . ExpressionList (
   34:  9: . . . . . . . . Expression (
   34:  9: . . . . . . . . . BinaryExpr (
   34:  9: . . . . . . . . . . UnaryExpr (
   34:  9: . . . . . . . . . . . "-"
   34: 10: . . . . . . . . . . . UnaryExpr (
   34: 10: . . . . . . . . . . . . PrimaryExpr (
   34: 10: . . . . . . . . . . . . . Operand (
   34: 10: . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   34: 11: . . . . . . . . . . . . . )
   34: 11: . . . . . . . . . . . . )
   34: 11: . . . . . . . . . . . )
   34: 11: . . . . . . . . . . )
   34: 11: . . . . . . . . . )
   34: 11: . . . . . . . . )
   34: 11: . . . . . . . )
   34: 11: . . . . . . . ";"
   35:  1: . . . . . . )
   35:  1: . . . . . )
   35:  1: . . . . )
   35:  1: . . . . "}"
   35:  2: . . . )
   35:  2: . . . ";"
   37:  1: . . . COMMENT
   38:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: Index, ...}
   39:  1: . . )
   39:  1: . )
   39:  1: . Declaration (
   39:  1: . . FunctionDeclOrCall (
   39:  1: . . . "func"
   39:  6: . . . IDENT Include
 /app/parser/parser.go:713: ast.Ident{Name: Include}
   39: 13: . . . Signature (
   39: 13: . . . . Parameters (
   39: 13: . . . . . "("
   39: 14: . . . . . ParameterList (
   39: 14: . . . . . . ParamDeclOrNil (
   39: 14: . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   39: 17: . . . . . . . ArrayFieldOrTypeInstance (
   39: 17: . . . . . . . . "["
   39: 18: . . . . . . . . "]"
   39: 19: . . . . . . . . Type (
   39: 19: . . . . . . . . . TypeName (
   39: 19: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   39: 25: . . . . . . . . . )
   39: 25: . . . . . . . . )
   39: 25: . . . . . . . )
   39: 25: . . . . . . )
   39: 25: . . . . . . ","
   39: 27: . . . . . . ParamDeclOrNil (
   39: 27: . . . . . . . IDENT t
 /app/parser/parser.go:713: ast.Ident{Name: t}
   39: 29: . . . . . . . Type (
   39: 29: . . . . . . . . TypeName (
   39: 29: . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   39: 35: . . . . . . . . )
   39: 35: . . . . . . . )
   39: 35: . . . . . . )
   39: 35: . . . . . )
   39: 35: . . . . . ")"
   39: 37: . . . . )
   39: 37: . . . . Result (
   39: 37: . . . . . TypeName (
   39: 37: . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   39: 42: . . . . . )
   39: 42: . . . . )
   39: 42: . . . )
   39: 42: . . . Body (
   39: 42: . . . . "{"
   40:  2: . . . . StatementList (
   40:  2: . . . . . Statement (
   40:  2: . . . . . . ReturnStmt (
   40:  2: . . . . . . . "return"
   40:  9: . . . . . . . ExpressionList (
   40:  9: . . . . . . . . Expression (
   40:  9: . . . . . . . . . BinaryExpr (
   40:  9: . . . . . . . . . . UnaryExpr (
   40:  9: . . . . . . . . . . . PrimaryExpr (
   40:  9: . . . . . . . . . . . . Operand (
   40:  9: . . . . . . . . . . . . . IDENT Index
 /app/parser/parser.go:713: ast.Ident{Name: Index}
   40: 14: . . . . . . . . . . . . )
   40: 14: . . . . . . . . . . . . CallOrConversion (
   40: 14: . . . . . . . . . . . . . "("
   40: 15: . . . . . . . . . . . . . Expression (
   40: 15: . . . . . . . . . . . . . . BinaryExpr (
   40: 15: . . . . . . . . . . . . . . . UnaryExpr (
   40: 15: . . . . . . . . . . . . . . . . PrimaryExpr (
   40: 15: . . . . . . . . . . . . . . . . . Operand (
   40: 15: . . . . . . . . . . . . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   40: 17: . . . . . . . . . . . . . . . . . )
   40: 17: . . . . . . . . . . . . . . . . )
   40: 17: . . . . . . . . . . . . . . . )
   40: 17: . . . . . . . . . . . . . . )
   40: 17: . . . . . . . . . . . . . )
   40: 17: . . . . . . . . . . . . . ","
   40: 19: . . . . . . . . . . . . . Expression (
   40: 19: . . . . . . . . . . . . . . BinaryExpr (
   40: 19: . . . . . . . . . . . . . . . UnaryExpr (
   40: 19: . . . . . . . . . . . . . . . . PrimaryExpr (
   40: 19: . . . . . . . . . . . . . . . . . Operand (
   40: 19: . . . . . . . . . . . . . . . . . . IDENT t
 /app/parser/parser.go:713: ast.Ident{Name: t}
   40: 20: . . . . . . . . . . . . . . . . . )
   40: 20: . . . . . . . . . . . . . . . . )
   40: 20: . . . . . . . . . . . . . . . )
   40: 20: . . . . . . . . . . . . . . )
   40: 20: . . . . . . . . . . . . . )
   40: 20: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: Index, Ellipsis: false, isCmd: false}
   40: 22: . . . . . . . . . . . . )
   40: 22: . . . . . . . . . . . )
   40: 22: . . . . . . . . . . )
   40: 22: . . . . . . . . . . ">="
   40: 25: . . . . . . . . . . BinaryExpr (
   40: 25: . . . . . . . . . . . UnaryExpr (
   40: 25: . . . . . . . . . . . . PrimaryExpr (
   40: 25: . . . . . . . . . . . . . Operand (
   40: 25: . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   40: 26: . . . . . . . . . . . . . )
   40: 26: . . . . . . . . . . . . )
   40: 26: . . . . . . . . . . . )
   40: 26: . . . . . . . . . . )
   40: 26: . . . . . . . . . )
   40: 26: . . . . . . . . )
   40: 26: . . . . . . . )
   40: 26: . . . . . . . ";"
   41:  1: . . . . . . )
   41:  1: . . . . . )
   41:  1: . . . . )
   41:  1: . . . . "}"
   41:  2: . . . )
   41:  2: . . . ";"
   43:  1: . . . COMMENT
   44:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: Include, ...}
   45:  1: . . )
   45:  1: . )
   45:  1: . Declaration (
   45:  1: . . FunctionDeclOrCall (
   45:  1: . . . "func"
   45:  6: . . . IDENT Any
 /app/parser/parser.go:713: ast.Ident{Name: Any}
   45:  9: . . . Signature (
   45:  9: . . . . Parameters (
   45:  9: . . . . . "("
   45: 10: . . . . . ParameterList (
   45: 10: . . . . . . ParamDeclOrNil (
   45: 10: . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   45: 13: . . . . . . . ArrayFieldOrTypeInstance (
   45: 13: . . . . . . . . "["
   45: 14: . . . . . . . . "]"
   45: 15: . . . . . . . . Type (
   45: 15: . . . . . . . . . TypeName (
   45: 15: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   45: 21: . . . . . . . . . )
   45: 21: . . . . . . . . )
   45: 21: . . . . . . . )
   45: 21: . . . . . . )
   45: 21: . . . . . . ","
   45: 23: . . . . . . ParamDeclOrNil (
   45: 23: . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   45: 25: . . . . . . . Type (
   45: 25: . . . . . . . . FuncType (
   45: 25: . . . . . . . . . "func"
   45: 29: . . . . . . . . . Signature (
   45: 29: . . . . . . . . . . Parameters (
   45: 29: . . . . . . . . . . . "("
   45: 30: . . . . . . . . . . . ParameterList (
   45: 30: . . . . . . . . . . . . ParamDeclOrNil (
   45: 30: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   45: 36: . . . . . . . . . . . . )
   45: 36: . . . . . . . . . . . )
   45: 36: . . . . . . . . . . . ")"
   45: 38: . . . . . . . . . . )
   45: 38: . . . . . . . . . . Result (
   45: 38: . . . . . . . . . . . TypeName (
   45: 38: . . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   45: 42: . . . . . . . . . . . )
   45: 42: . . . . . . . . . . )
   45: 42: . . . . . . . . . )
   45: 42: . . . . . . . . )
   45: 42: . . . . . . . )
   45: 42: . . . . . . )
   45: 42: . . . . . )
   45: 42: . . . . . ")"
   45: 44: . . . . )
   45: 44: . . . . Result (
   45: 44: . . . . . TypeName (
   45: 44: . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   45: 49: . . . . . )
   45: 49: . . . . )
   45: 49: . . . )
   45: 49: . . . Body (
   45: 49: . . . . "{"
   46:  2: . . . . StatementList (
   46:  2: . . . . . Statement (
   46:  2: . . . . . . ForStmt (
   46:  2: . . . . . . . "for"
   46:  6: . . . . . . . SimpleStmt (
   46:  6: . . . . . . . . ExpressionList (
   46:  6: . . . . . . . . . Expression (
   46:  6: . . . . . . . . . . BinaryExpr (
   46:  6: . . . . . . . . . . . UnaryExpr (
   46:  6: . . . . . . . . . . . . PrimaryExpr (
   46:  6: . . . . . . . . . . . . . Operand (
   46:  6: . . . . . . . . . . . . . . IDENT _
 /app/parser/parser.go:713: ast.Ident{Name: _}
   46:  7: . . . . . . . . . . . . . )
   46:  7: . . . . . . . . . . . . )
   46:  7: . . . . . . . . . . . )
   46:  7: . . . . . . . . . . )
   46:  7: . . . . . . . . . )
   46:  7: . . . . . . . . . ","
   46:  9: . . . . . . . . . Expression (
   46:  9: . . . . . . . . . . BinaryExpr (
   46:  9: . . . . . . . . . . . UnaryExpr (
   46:  9: . . . . . . . . . . . . PrimaryExpr (
   46:  9: . . . . . . . . . . . . . Operand (
   46:  9: . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   46: 11: . . . . . . . . . . . . . )
   46: 11: . . . . . . . . . . . . )
   46: 11: . . . . . . . . . . . )
   46: 11: . . . . . . . . . . )
   46: 11: . . . . . . . . . )
   46: 11: . . . . . . . . )
   46: 11: . . . . . . . . ":="
   46: 14: . . . . . . . . "range"
   46: 20: . . . . . . . . Expression (
   46: 20: . . . . . . . . . RangeExpr (
   46: 20: . . . . . . . . . . BinaryExpr (
   46: 20: . . . . . . . . . . . UnaryExpr (
   46: 20: . . . . . . . . . . . . PrimaryExpr (
   46: 20: . . . . . . . . . . . . . Operand (
   46: 20: . . . . . . . . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   46: 23: . . . . . . . . . . . . . )
   46: 23: . . . . . . . . . . . . )
   46: 23: . . . . . . . . . . . )
   46: 23: . . . . . . . . . . )
   46: 23: . . . . . . . . . )
   46: 23: . . . . . . . . )
   46: 23: . . . . . . . )
   46: 23: . . . . . . . BlockStmt (
   46: 23: . . . . . . . . "{"
   47:  3: . . . . . . . . StatementList (
   47:  3: . . . . . . . . . Statement (
   47:  3: . . . . . . . . . . IfStmt (
   47:  3: . . . . . . . . . . . "if"
   47:  6: . . . . . . . . . . . SimpleStmt (
   47:  6: . . . . . . . . . . . . ExpressionList (
   47:  6: . . . . . . . . . . . . . Expression (
   47:  6: . . . . . . . . . . . . . . BinaryExpr (
   47:  6: . . . . . . . . . . . . . . . UnaryExpr (
   47:  6: . . . . . . . . . . . . . . . . PrimaryExpr (
   47:  6: . . . . . . . . . . . . . . . . . Operand (
   47:  6: . . . . . . . . . . . . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   47:  7: . . . . . . . . . . . . . . . . . )
   47:  7: . . . . . . . . . . . . . . . . . CallOrConversion (
   47:  7: . . . . . . . . . . . . . . . . . . "("
   47:  8: . . . . . . . . . . . . . . . . . . Expression (
   47:  8: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   47:  8: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   47:  8: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   47:  8: . . . . . . . . . . . . . . . . . . . . . . Operand (
   47:  8: . . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   47:  9: . . . . . . . . . . . . . . . . . . . . . . )
   47:  9: . . . . . . . . . . . . . . . . . . . . . )
   47:  9: . . . . . . . . . . . . . . . . . . . . )
   47:  9: . . . . . . . . . . . . . . . . . . . )
   47:  9: . . . . . . . . . . . . . . . . . . )
   47:  9: . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: f, Ellipsis: false, isCmd: false}
   47: 11: . . . . . . . . . . . . . . . . . )
   47: 11: . . . . . . . . . . . . . . . . )
   47: 11: . . . . . . . . . . . . . . . )
   47: 11: . . . . . . . . . . . . . . )
   47: 11: . . . . . . . . . . . . . )
   47: 11: . . . . . . . . . . . . )
   47: 11: . . . . . . . . . . . )
   47: 11: . . . . . . . . . . . BlockStmt (
   47: 11: . . . . . . . . . . . . "{"
   48:  4: . . . . . . . . . . . . StatementList (
   48:  4: . . . . . . . . . . . . . Statement (
   48:  4: . . . . . . . . . . . . . . ReturnStmt (
   48:  4: . . . . . . . . . . . . . . . "return"
   48: 11: . . . . . . . . . . . . . . . ExpressionList (
   48: 11: . . . . . . . . . . . . . . . . Expression (
   48: 11: . . . . . . . . . . . . . . . . . BinaryExpr (
   48: 11: . . . . . . . . . . . . . . . . . . UnaryExpr (
   48: 11: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   48: 11: . . . . . . . . . . . . . . . . . . . . Operand (
   48: 11: . . . . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   48: 15: . . . . . . . . . . . . . . . . . . . . )
   48: 15: . . . . . . . . . . . . . . . . . . . )
   48: 15: . . . . . . . . . . . . . . . . . . )
   48: 15: . . . . . . . . . . . . . . . . . )
   48: 15: . . . . . . . . . . . . . . . . )
   48: 15: . . . . . . . . . . . . . . . )
   48: 15: . . . . . . . . . . . . . . . ";"
   49:  3: . . . . . . . . . . . . . . )
   49:  3: . . . . . . . . . . . . . )
   49:  3: . . . . . . . . . . . . )
   49:  3: . . . . . . . . . . . . "}"
   49:  4: . . . . . . . . . . . )
   49:  4: . . . . . . . . . . . ";"
   50:  2: . . . . . . . . . . )
   50:  2: . . . . . . . . . )
   50:  2: . . . . . . . . )
   50:  2: . . . . . . . . "}"
   50:  3: . . . . . . . )
   50:  3: . . . . . . . ";"
   51:  2: . . . . . . )
   51:  2: . . . . . )
   51:  2: . . . . . Statement (
   51:  2: . . . . . . ReturnStmt (
   51:  2: . . . . . . . "return"
   51:  9: . . . . . . . ExpressionList (
   51:  9: . . . . . . . . Expression (
   51:  9: . . . . . . . . . BinaryExpr (
   51:  9: . . . . . . . . . . UnaryExpr (
   51:  9: . . . . . . . . . . . PrimaryExpr (
   51:  9: . . . . . . . . . . . . Operand (
   51:  9: . . . . . . . . . . . . . IDENT false
 /app/parser/parser.go:713: ast.Ident{Name: false}
   51: 14: . . . . . . . . . . . . )
   51: 14: . . . . . . . . . . . )
   51: 14: . . . . . . . . . . )
   51: 14: . . . . . . . . . )
   51: 14: . . . . . . . . )
   51: 14: . . . . . . . )
   51: 14: . . . . . . . ";"
   52:  1: . . . . . . )
   52:  1: . . . . . )
   52:  1: . . . . )
   52:  1: . . . . "}"
   52:  2: . . . )
   52:  2: . . . ";"
   54:  1: . . . COMMENT
   55:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: Any, ...}
   56:  1: . . )
   56:  1: . )
   56:  1: . Declaration (
   56:  1: . . FunctionDeclOrCall (
   56:  1: . . . "func"
   56:  6: . . . IDENT All
 /app/parser/parser.go:713: ast.Ident{Name: All}
   56:  9: . . . Signature (
   56:  9: . . . . Parameters (
   56:  9: . . . . . "("
   56: 10: . . . . . ParameterList (
   56: 10: . . . . . . ParamDeclOrNil (
   56: 10: . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   56: 13: . . . . . . . ArrayFieldOrTypeInstance (
   56: 13: . . . . . . . . "["
   56: 14: . . . . . . . . "]"
   56: 15: . . . . . . . . Type (
   56: 15: . . . . . . . . . TypeName (
   56: 15: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   56: 21: . . . . . . . . . )
   56: 21: . . . . . . . . )
   56: 21: . . . . . . . )
   56: 21: . . . . . . )
   56: 21: . . . . . . ","
   56: 23: . . . . . . ParamDeclOrNil (
   56: 23: . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   56: 25: . . . . . . . Type (
   56: 25: . . . . . . . . FuncType (
   56: 25: . . . . . . . . . "func"
   56: 29: . . . . . . . . . Signature (
   56: 29: . . . . . . . . . . Parameters (
   56: 29: . . . . . . . . . . . "("
   56: 30: . . . . . . . . . . . ParameterList (
   56: 30: . . . . . . . . . . . . ParamDeclOrNil (
   56: 30: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   56: 36: . . . . . . . . . . . . )
   56: 36: . . . . . . . . . . . )
   56: 36: . . . . . . . . . . . ")"
   56: 38: . . . . . . . . . . )
   56: 38: . . . . . . . . . . Result (
   56: 38: . . . . . . . . . . . TypeName (
   56: 38: . . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   56: 42: . . . . . . . . . . . )
   56: 42: . . . . . . . . . . )
   56: 42: . . . . . . . . . )
   56: 42: . . . . . . . . )
   56: 42: . . . . . . . )
   56: 42: . . . . . . )
   56: 42: . . . . . )
   56: 42: . . . . . ")"
   56: 44: . . . . )
   56: 44: . . . . Result (
   56: 44: . . . . . TypeName (
   56: 44: . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   56: 49: . . . . . )
   56: 49: . . . . )
   56: 49: . . . )
   56: 49: . . . Body (
   56: 49: . . . . "{"
   57:  2: . . . . StatementList (
   57:  2: . . . . . Statement (
   57:  2: . . . . . . ForStmt (
   57:  2: . . . . . . . "for"
   57:  6: . . . . . . . SimpleStmt (
   57:  6: . . . . . . . . ExpressionList (
   57:  6: . . . . . . . . . Expression (
   57:  6: . . . . . . . . . . BinaryExpr (
   57:  6: . . . . . . . . . . . UnaryExpr (
   57:  6: . . . . . . . . . . . . PrimaryExpr (
   57:  6: . . . . . . . . . . . . . Operand (
   57:  6: . . . . . . . . . . . . . . IDENT _
 /app/parser/parser.go:713: ast.Ident{Name: _}
   57:  7: . . . . . . . . . . . . . )
   57:  7: . . . . . . . . . . . . )
   57:  7: . . . . . . . . . . . )
   57:  7: . . . . . . . . . . )
   57:  7: . . . . . . . . . )
   57:  7: . . . . . . . . . ","
   57:  9: . . . . . . . . . Expression (
   57:  9: . . . . . . . . . . BinaryExpr (
   57:  9: . . . . . . . . . . . UnaryExpr (
   57:  9: . . . . . . . . . . . . PrimaryExpr (
   57:  9: . . . . . . . . . . . . . Operand (
   57:  9: . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   57: 11: . . . . . . . . . . . . . )
   57: 11: . . . . . . . . . . . . )
   57: 11: . . . . . . . . . . . )
   57: 11: . . . . . . . . . . )
   57: 11: . . . . . . . . . )
   57: 11: . . . . . . . . )
   57: 11: . . . . . . . . ":="
   57: 14: . . . . . . . . "range"
   57: 20: . . . . . . . . Expression (
   57: 20: . . . . . . . . . RangeExpr (
   57: 20: . . . . . . . . . . BinaryExpr (
   57: 20: . . . . . . . . . . . UnaryExpr (
   57: 20: . . . . . . . . . . . . PrimaryExpr (
   57: 20: . . . . . . . . . . . . . Operand (
   57: 20: . . . . . . . . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   57: 23: . . . . . . . . . . . . . )
   57: 23: . . . . . . . . . . . . )
   57: 23: . . . . . . . . . . . )
   57: 23: . . . . . . . . . . )
   57: 23: . . . . . . . . . )
   57: 23: . . . . . . . . )
   57: 23: . . . . . . . )
   57: 23: . . . . . . . BlockStmt (
   57: 23: . . . . . . . . "{"
   58:  3: . . . . . . . . StatementList (
   58:  3: . . . . . . . . . Statement (
   58:  3: . . . . . . . . . . IfStmt (
   58:  3: . . . . . . . . . . . "if"
   58:  6: . . . . . . . . . . . SimpleStmt (
   58:  6: . . . . . . . . . . . . ExpressionList (
   58:  6: . . . . . . . . . . . . . Expression (
   58:  6: . . . . . . . . . . . . . . BinaryExpr (
   58:  6: . . . . . . . . . . . . . . . UnaryExpr (
   58:  6: . . . . . . . . . . . . . . . . "!"
   58:  7: . . . . . . . . . . . . . . . . UnaryExpr (
   58:  7: . . . . . . . . . . . . . . . . . PrimaryExpr (
   58:  7: . . . . . . . . . . . . . . . . . . Operand (
   58:  7: . . . . . . . . . . . . . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   58:  8: . . . . . . . . . . . . . . . . . . )
   58:  8: . . . . . . . . . . . . . . . . . . CallOrConversion (
   58:  8: . . . . . . . . . . . . . . . . . . . "("
   58:  9: . . . . . . . . . . . . . . . . . . . Expression (
   58:  9: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   58:  9: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   58:  9: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   58:  9: . . . . . . . . . . . . . . . . . . . . . . . Operand (
   58:  9: . . . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   58: 10: . . . . . . . . . . . . . . . . . . . . . . . )
   58: 10: . . . . . . . . . . . . . . . . . . . . . . )
   58: 10: . . . . . . . . . . . . . . . . . . . . . )
   58: 10: . . . . . . . . . . . . . . . . . . . . )
   58: 10: . . . . . . . . . . . . . . . . . . . )
   58: 10: . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: f, Ellipsis: false, isCmd: false}
   58: 12: . . . . . . . . . . . . . . . . . . )
   58: 12: . . . . . . . . . . . . . . . . . )
   58: 12: . . . . . . . . . . . . . . . . )
   58: 12: . . . . . . . . . . . . . . . )
   58: 12: . . . . . . . . . . . . . . )
   58: 12: . . . . . . . . . . . . . )
   58: 12: . . . . . . . . . . . . )
   58: 12: . . . . . . . . . . . )
   58: 12: . . . . . . . . . . . BlockStmt (
   58: 12: . . . . . . . . . . . . "{"
   59:  4: . . . . . . . . . . . . StatementList (
   59:  4: . . . . . . . . . . . . . Statement (
   59:  4: . . . . . . . . . . . . . . ReturnStmt (
   59:  4: . . . . . . . . . . . . . . . "return"
   59: 11: . . . . . . . . . . . . . . . ExpressionList (
   59: 11: . . . . . . . . . . . . . . . . Expression (
   59: 11: . . . . . . . . . . . . . . . . . BinaryExpr (
   59: 11: . . . . . . . . . . . . . . . . . . UnaryExpr (
   59: 11: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   59: 11: . . . . . . . . . . . . . . . . . . . . Operand (
   59: 11: . . . . . . . . . . . . . . . . . . . . . IDENT false
 /app/parser/parser.go:713: ast.Ident{Name: false}
   59: 16: . . . . . . . . . . . . . . . . . . . . )
   59: 16: . . . . . . . . . . . . . . . . . . . )
   59: 16: . . . . . . . . . . . . . . . . . . )
   59: 16: . . . . . . . . . . . . . . . . . )
   59: 16: . . . . . . . . . . . . . . . . )
   59: 16: . . . . . . . . . . . . . . . )
   59: 16: . . . . . . . . . . . . . . . ";"
   60:  3: . . . . . . . . . . . . . . )
   60:  3: . . . . . . . . . . . . . )
   60:  3: . . . . . . . . . . . . )
   60:  3: . . . . . . . . . . . . "}"
   60:  4: . . . . . . . . . . . )
   60:  4: . . . . . . . . . . . ";"
   61:  2: . . . . . . . . . . )
   61:  2: . . . . . . . . . )
   61:  2: . . . . . . . . )
   61:  2: . . . . . . . . "}"
   61:  3: . . . . . . . )
   61:  3: . . . . . . . ";"
   62:  2: . . . . . . )
   62:  2: . . . . . )
   62:  2: . . . . . Statement (
   62:  2: . . . . . . ReturnStmt (
   62:  2: . . . . . . . "return"
   62:  9: . . . . . . . ExpressionList (
   62:  9: . . . . . . . . Expression (
   62:  9: . . . . . . . . . BinaryExpr (
   62:  9: . . . . . . . . . . UnaryExpr (
   62:  9: . . . . . . . . . . . PrimaryExpr (
   62:  9: . . . . . . . . . . . . Operand (
   62:  9: . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   62: 13: . . . . . . . . . . . . )
   62: 13: . . . . . . . . . . . )
   62: 13: . . . . . . . . . . )
   62: 13: . . . . . . . . . )
   62: 13: . . . . . . . . )
   62: 13: . . . . . . . )
   62: 13: . . . . . . . ";"
   63:  1: . . . . . . )
   63:  1: . . . . . )
   63:  1: . . . . )
   63:  1: . . . . "}"
   63:  2: . . . )
   63:  2: . . . ";"
   65:  1: . . . COMMENT
   66:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: All, ...}
   67:  1: . . )
   67:  1: . )
   67:  1: . Declaration (
   67:  1: . . FunctionDeclOrCall (
   67:  1: . . . "func"
   67:  6: . . . IDENT Filter
 /app/parser/parser.go:713: ast.Ident{Name: Filter}
   67: 12: . . . Signature (
   67: 12: . . . . Parameters (
   67: 12: . . . . . "("
   67: 13: . . . . . ParameterList (
   67: 13: . . . . . . ParamDeclOrNil (
   67: 13: . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   67: 16: . . . . . . . ArrayFieldOrTypeInstance (
   67: 16: . . . . . . . . "["
   67: 17: . . . . . . . . "]"
   67: 18: . . . . . . . . Type (
   67: 18: . . . . . . . . . TypeName (
   67: 18: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   67: 24: . . . . . . . . . )
   67: 24: . . . . . . . . )
   67: 24: . . . . . . . )
   67: 24: . . . . . . )
   67: 24: . . . . . . ","
   67: 26: . . . . . . ParamDeclOrNil (
   67: 26: . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   67: 28: . . . . . . . Type (
   67: 28: . . . . . . . . FuncType (
   67: 28: . . . . . . . . . "func"
   67: 32: . . . . . . . . . Signature (
   67: 32: . . . . . . . . . . Parameters (
   67: 32: . . . . . . . . . . . "("
   67: 33: . . . . . . . . . . . ParameterList (
   67: 33: . . . . . . . . . . . . ParamDeclOrNil (
   67: 33: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   67: 39: . . . . . . . . . . . . )
   67: 39: . . . . . . . . . . . )
   67: 39: . . . . . . . . . . . ")"
   67: 41: . . . . . . . . . . )
   67: 41: . . . . . . . . . . Result (
   67: 41: . . . . . . . . . . . TypeName (
   67: 41: . . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   67: 45: . . . . . . . . . . . )
   67: 45: . . . . . . . . . . )
   67: 45: . . . . . . . . . )
   67: 45: . . . . . . . . )
   67: 45: . . . . . . . )
   67: 45: . . . . . . )
   67: 45: . . . . . )
   67: 45: . . . . . ")"
   67: 47: . . . . )
   67: 47: . . . . Result (
   67: 47: . . . . . ArrayType (
   67: 47: . . . . . . "["
   67: 48: . . . . . . "]"
   67: 49: . . . . . . Type (
   67: 49: . . . . . . . TypeName (
   67: 49: . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   67: 56: . . . . . . . )
   67: 56: . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: string}
   67: 56: . . . . . )
   67: 56: . . . . )
   67: 56: . . . )
   67: 56: . . . Body (
   67: 56: . . . . "{"
   68:  2: . . . . StatementList (
   68:  2: . . . . . Statement (
   68:  2: . . . . . . SimpleStmt (
   68:  2: . . . . . . . ExpressionList (
   68:  2: . . . . . . . . Expression (
   68:  2: . . . . . . . . . BinaryExpr (
   68:  2: . . . . . . . . . . UnaryExpr (
   68:  2: . . . . . . . . . . . PrimaryExpr (
   68:  2: . . . . . . . . . . . . Operand (
   68:  2: . . . . . . . . . . . . . IDENT vsf
 /app/parser/parser.go:713: ast.Ident{Name: vsf}
   68:  6: . . . . . . . . . . . . )
   68:  6: . . . . . . . . . . . )
   68:  6: . . . . . . . . . . )
   68:  6: . . . . . . . . . )
   68:  6: . . . . . . . . )
   68:  6: . . . . . . . )
   68:  6: . . . . . . . ":="
   68:  9: . . . . . . . ExpressionList (
   68:  9: . . . . . . . . Expression (
   68:  9: . . . . . . . . . BinaryExpr (
   68:  9: . . . . . . . . . . UnaryExpr (
   68:  9: . . . . . . . . . . . PrimaryExpr (
   68:  9: . . . . . . . . . . . . Operand (
   68:  9: . . . . . . . . . . . . . IDENT make
 /app/parser/parser.go:713: ast.Ident{Name: make}
   68: 13: . . . . . . . . . . . . )
   68: 13: . . . . . . . . . . . . CallOrConversion (
   68: 13: . . . . . . . . . . . . . "("
   68: 14: . . . . . . . . . . . . . Expression (
   68: 14: . . . . . . . . . . . . . . BinaryExpr (
   68: 14: . . . . . . . . . . . . . . . UnaryExpr (
   68: 14: . . . . . . . . . . . . . . . . PrimaryExpr (
   68: 14: . . . . . . . . . . . . . . . . . Operand (
   68: 14: . . . . . . . . . . . . . . . . . . ArrayType (
   68: 14: . . . . . . . . . . . . . . . . . . . "["
   68: 15: . . . . . . . . . . . . . . . . . . . "]"
   68: 16: . . . . . . . . . . . . . . . . . . . TypeName (
   68: 16: . . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   68: 22: . . . . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: string}
   68: 22: . . . . . . . . . . . . . . . . . . )
   68: 22: . . . . . . . . . . . . . . . . . )
   68: 22: . . . . . . . . . . . . . . . . )
   68: 22: . . . . . . . . . . . . . . . )
   68: 22: . . . . . . . . . . . . . . )
   68: 22: . . . . . . . . . . . . . )
   68: 22: . . . . . . . . . . . . . ","
   68: 24: . . . . . . . . . . . . . Expression (
   68: 24: . . . . . . . . . . . . . . BinaryExpr (
   68: 24: . . . . . . . . . . . . . . . UnaryExpr (
   68: 24: . . . . . . . . . . . . . . . . PrimaryExpr (
   68: 24: . . . . . . . . . . . . . . . . . Operand (
   68: 24: . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   68: 25: . . . . . . . . . . . . . . . . . )
   68: 25: . . . . . . . . . . . . . . . . )
   68: 25: . . . . . . . . . . . . . . . )
   68: 25: . . . . . . . . . . . . . . )
   68: 25: . . . . . . . . . . . . . )
   68: 25: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: make, Ellipsis: false, isCmd: false}
   68: 26: . . . . . . . . . . . . )
   68: 26: . . . . . . . . . . . )
   68: 26: . . . . . . . . . . )
   68: 26: . . . . . . . . . )
   68: 26: . . . . . . . . )
   68: 26: . . . . . . . )
   68: 26: . . . . . . )
   68: 26: . . . . . . ";"
   69:  2: . . . . . )
   69:  2: . . . . . Statement (
   69:  2: . . . . . . ForStmt (
   69:  2: . . . . . . . "for"
   69:  6: . . . . . . . SimpleStmt (
   69:  6: . . . . . . . . ExpressionList (
   69:  6: . . . . . . . . . Expression (
   69:  6: . . . . . . . . . . BinaryExpr (
   69:  6: . . . . . . . . . . . UnaryExpr (
   69:  6: . . . . . . . . . . . . PrimaryExpr (
   69:  6: . . . . . . . . . . . . . Operand (
   69:  6: . . . . . . . . . . . . . . IDENT _
 /app/parser/parser.go:713: ast.Ident{Name: _}
   69:  7: . . . . . . . . . . . . . )
   69:  7: . . . . . . . . . . . . )
   69:  7: . . . . . . . . . . . )
   69:  7: . . . . . . . . . . )
   69:  7: . . . . . . . . . )
   69:  7: . . . . . . . . . ","
   69:  9: . . . . . . . . . Expression (
   69:  9: . . . . . . . . . . BinaryExpr (
   69:  9: . . . . . . . . . . . UnaryExpr (
   69:  9: . . . . . . . . . . . . PrimaryExpr (
   69:  9: . . . . . . . . . . . . . Operand (
   69:  9: . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   69: 11: . . . . . . . . . . . . . )
   69: 11: . . . . . . . . . . . . )
   69: 11: . . . . . . . . . . . )
   69: 11: . . . . . . . . . . )
   69: 11: . . . . . . . . . )
   69: 11: . . . . . . . . )
   69: 11: . . . . . . . . ":="
   69: 14: . . . . . . . . "range"
   69: 20: . . . . . . . . Expression (
   69: 20: . . . . . . . . . RangeExpr (
   69: 20: . . . . . . . . . . BinaryExpr (
   69: 20: . . . . . . . . . . . UnaryExpr (
   69: 20: . . . . . . . . . . . . PrimaryExpr (
   69: 20: . . . . . . . . . . . . . Operand (
   69: 20: . . . . . . . . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   69: 23: . . . . . . . . . . . . . )
   69: 23: . . . . . . . . . . . . )
   69: 23: . . . . . . . . . . . )
   69: 23: . . . . . . . . . . )
   69: 23: . . . . . . . . . )
   69: 23: . . . . . . . . )
   69: 23: . . . . . . . )
   69: 23: . . . . . . . BlockStmt (
   69: 23: . . . . . . . . "{"
   70:  3: . . . . . . . . StatementList (
   70:  3: . . . . . . . . . Statement (
   70:  3: . . . . . . . . . . IfStmt (
   70:  3: . . . . . . . . . . . "if"
   70:  6: . . . . . . . . . . . SimpleStmt (
   70:  6: . . . . . . . . . . . . ExpressionList (
   70:  6: . . . . . . . . . . . . . Expression (
   70:  6: . . . . . . . . . . . . . . BinaryExpr (
   70:  6: . . . . . . . . . . . . . . . UnaryExpr (
   70:  6: . . . . . . . . . . . . . . . . PrimaryExpr (
   70:  6: . . . . . . . . . . . . . . . . . Operand (
   70:  6: . . . . . . . . . . . . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   70:  7: . . . . . . . . . . . . . . . . . )
   70:  7: . . . . . . . . . . . . . . . . . CallOrConversion (
   70:  7: . . . . . . . . . . . . . . . . . . "("
   70:  8: . . . . . . . . . . . . . . . . . . Expression (
   70:  8: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   70:  8: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   70:  8: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   70:  8: . . . . . . . . . . . . . . . . . . . . . . Operand (
   70:  8: . . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   70:  9: . . . . . . . . . . . . . . . . . . . . . . )
   70:  9: . . . . . . . . . . . . . . . . . . . . . )
   70:  9: . . . . . . . . . . . . . . . . . . . . )
   70:  9: . . . . . . . . . . . . . . . . . . . )
   70:  9: . . . . . . . . . . . . . . . . . . )
   70:  9: . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: f, Ellipsis: false, isCmd: false}
   70: 11: . . . . . . . . . . . . . . . . . )
   70: 11: . . . . . . . . . . . . . . . . )
   70: 11: . . . . . . . . . . . . . . . )
   70: 11: . . . . . . . . . . . . . . )
   70: 11: . . . . . . . . . . . . . )
   70: 11: . . . . . . . . . . . . )
   70: 11: . . . . . . . . . . . )
   70: 11: . . . . . . . . . . . BlockStmt (
   70: 11: . . . . . . . . . . . . "{"
   71:  4: . . . . . . . . . . . . StatementList (
   71:  4: . . . . . . . . . . . . . Statement (
   71:  4: . . . . . . . . . . . . . . SimpleStmt (
   71:  4: . . . . . . . . . . . . . . . ExpressionList (
   71:  4: . . . . . . . . . . . . . . . . Expression (
   71:  4: . . . . . . . . . . . . . . . . . BinaryExpr (
   71:  4: . . . . . . . . . . . . . . . . . . UnaryExpr (
   71:  4: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   71:  4: . . . . . . . . . . . . . . . . . . . . Operand (
   71:  4: . . . . . . . . . . . . . . . . . . . . . IDENT vsf
 /app/parser/parser.go:713: ast.Ident{Name: vsf}
   71:  8: . . . . . . . . . . . . . . . . . . . . )
   71:  8: . . . . . . . . . . . . . . . . . . . )
   71:  8: . . . . . . . . . . . . . . . . . . )
   71:  8: . . . . . . . . . . . . . . . . . )
   71:  8: . . . . . . . . . . . . . . . . )
   71:  8: . . . . . . . . . . . . . . . )
   71:  8: . . . . . . . . . . . . . . . "="
   71: 10: . . . . . . . . . . . . . . . ExpressionList (
   71: 10: . . . . . . . . . . . . . . . . Expression (
   71: 10: . . . . . . . . . . . . . . . . . BinaryExpr (
   71: 10: . . . . . . . . . . . . . . . . . . UnaryExpr (
   71: 10: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   71: 10: . . . . . . . . . . . . . . . . . . . . Operand (
   71: 10: . . . . . . . . . . . . . . . . . . . . . IDENT append
 /app/parser/parser.go:713: ast.Ident{Name: append}
   71: 16: . . . . . . . . . . . . . . . . . . . . )
   71: 16: . . . . . . . . . . . . . . . . . . . . CallOrConversion (
   71: 16: . . . . . . . . . . . . . . . . . . . . . "("
   71: 17: . . . . . . . . . . . . . . . . . . . . . Expression (
   71: 17: . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   71: 17: . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   71: 17: . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   71: 17: . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   71: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT vsf
 /app/parser/parser.go:713: ast.Ident{Name: vsf}
   71: 20: . . . . . . . . . . . . . . . . . . . . . . . . . )
   71: 20: . . . . . . . . . . . . . . . . . . . . . . . . )
   71: 20: . . . . . . . . . . . . . . . . . . . . . . . )
   71: 20: . . . . . . . . . . . . . . . . . . . . . . )
   71: 20: . . . . . . . . . . . . . . . . . . . . . )
   71: 20: . . . . . . . . . . . . . . . . . . . . . ","
   71: 22: . . . . . . . . . . . . . . . . . . . . . Expression (
   71: 22: . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   71: 22: . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   71: 22: . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   71: 22: . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   71: 22: . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   71: 23: . . . . . . . . . . . . . . . . . . . . . . . . . )
   71: 23: . . . . . . . . . . . . . . . . . . . . . . . . )
   71: 23: . . . . . . . . . . . . . . . . . . . . . . . )
   71: 23: . . . . . . . . . . . . . . . . . . . . . . )
   71: 23: . . . . . . . . . . . . . . . . . . . . . )
   71: 23: . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: append, Ellipsis: false, isCmd: false}
   71: 24: . . . . . . . . . . . . . . . . . . . . )
   71: 24: . . . . . . . . . . . . . . . . . . . )
   71: 24: . . . . . . . . . . . . . . . . . . )
   71: 24: . . . . . . . . . . . . . . . . . )
   71: 24: . . . . . . . . . . . . . . . . )
   71: 24: . . . . . . . . . . . . . . . )
   71: 24: . . . . . . . . . . . . . . )
   71: 24: . . . . . . . . . . . . . . ";"
   72:  3: . . . . . . . . . . . . . )
   72:  3: . . . . . . . . . . . . )
   72:  3: . . . . . . . . . . . . "}"
   72:  4: . . . . . . . . . . . )
   72:  4: . . . . . . . . . . . ";"
   73:  2: . . . . . . . . . . )
   73:  2: . . . . . . . . . )
   73:  2: . . . . . . . . )
   73:  2: . . . . . . . . "}"
   73:  3: . . . . . . . )
   73:  3: . . . . . . . ";"
   74:  2: . . . . . . )
   74:  2: . . . . . )
   74:  2: . . . . . Statement (
   74:  2: . . . . . . ReturnStmt (
   74:  2: . . . . . . . "return"
   74:  9: . . . . . . . ExpressionList (
   74:  9: . . . . . . . . Expression (
   74:  9: . . . . . . . . . BinaryExpr (
   74:  9: . . . . . . . . . . UnaryExpr (
   74:  9: . . . . . . . . . . . PrimaryExpr (
   74:  9: . . . . . . . . . . . . Operand (
   74:  9: . . . . . . . . . . . . . IDENT vsf
 /app/parser/parser.go:713: ast.Ident{Name: vsf}
   74: 12: . . . . . . . . . . . . )
   74: 12: . . . . . . . . . . . )
   74: 12: . . . . . . . . . . )
   74: 12: . . . . . . . . . )
   74: 12: . . . . . . . . )
   74: 12: . . . . . . . )
   74: 12: . . . . . . . ";"
   75:  1: . . . . . . )
   75:  1: . . . . . )
   75:  1: . . . . )
   75:  1: . . . . "}"
   75:  2: . . . )
   75:  2: . . . ";"
   77:  1: . . . COMMENT
   78:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: Filter, ...}
   79:  1: . . )
   79:  1: . )
   79:  1: . Declaration (
   79:  1: . . FunctionDeclOrCall (
   79:  1: . . . "func"
   79:  6: . . . IDENT Map
 /app/parser/parser.go:713: ast.Ident{Name: Map}
   79:  9: . . . Signature (
   79:  9: . . . . Parameters (
   79:  9: . . . . . "("
   79: 10: . . . . . ParameterList (
   79: 10: . . . . . . ParamDeclOrNil (
   79: 10: . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   79: 13: . . . . . . . ArrayFieldOrTypeInstance (
   79: 13: . . . . . . . . "["
   79: 14: . . . . . . . . "]"
   79: 15: . . . . . . . . Type (
   79: 15: . . . . . . . . . TypeName (
   79: 15: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   79: 21: . . . . . . . . . )
   79: 21: . . . . . . . . )
   79: 21: . . . . . . . )
   79: 21: . . . . . . )
   79: 21: . . . . . . ","
   79: 23: . . . . . . ParamDeclOrNil (
   79: 23: . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   79: 25: . . . . . . . Type (
   79: 25: . . . . . . . . FuncType (
   79: 25: . . . . . . . . . "func"
   79: 29: . . . . . . . . . Signature (
   79: 29: . . . . . . . . . . Parameters (
   79: 29: . . . . . . . . . . . "("
   79: 30: . . . . . . . . . . . ParameterList (
   79: 30: . . . . . . . . . . . . ParamDeclOrNil (
   79: 30: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   79: 36: . . . . . . . . . . . . )
   79: 36: . . . . . . . . . . . )
   79: 36: . . . . . . . . . . . ")"
   79: 38: . . . . . . . . . . )
   79: 38: . . . . . . . . . . Result (
   79: 38: . . . . . . . . . . . TypeName (
   79: 38: . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   79: 44: . . . . . . . . . . . )
   79: 44: . . . . . . . . . . )
   79: 44: . . . . . . . . . )
   79: 44: . . . . . . . . )
   79: 44: . . . . . . . )
   79: 44: . . . . . . )
   79: 44: . . . . . )
   79: 44: . . . . . ")"
   79: 46: . . . . )
   79: 46: . . . . Result (
   79: 46: . . . . . ArrayType (
   79: 46: . . . . . . "["
   79: 47: . . . . . . "]"
   79: 48: . . . . . . Type (
   79: 48: . . . . . . . TypeName (
   79: 48: . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   79: 55: . . . . . . . )
   79: 55: . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: string}
   79: 55: . . . . . )
   79: 55: . . . . )
   79: 55: . . . )
   79: 55: . . . Body (
   79: 55: . . . . "{"
   80:  2: . . . . StatementList (
   80:  2: . . . . . Statement (
   80:  2: . . . . . . SimpleStmt (
   80:  2: . . . . . . . ExpressionList (
   80:  2: . . . . . . . . Expression (
   80:  2: . . . . . . . . . BinaryExpr (
   80:  2: . . . . . . . . . . UnaryExpr (
   80:  2: . . . . . . . . . . . PrimaryExpr (
   80:  2: . . . . . . . . . . . . Operand (
   80:  2: . . . . . . . . . . . . . IDENT vsm
 /app/parser/parser.go:713: ast.Ident{Name: vsm}
   80:  6: . . . . . . . . . . . . )
   80:  6: . . . . . . . . . . . )
   80:  6: . . . . . . . . . . )
   80:  6: . . . . . . . . . )
   80:  6: . . . . . . . . )
   80:  6: . . . . . . . )
   80:  6: . . . . . . . ":="
   80:  9: . . . . . . . ExpressionList (
   80:  9: . . . . . . . . Expression (
   80:  9: . . . . . . . . . BinaryExpr (
   80:  9: . . . . . . . . . . UnaryExpr (
   80:  9: . . . . . . . . . . . PrimaryExpr (
   80:  9: . . . . . . . . . . . . Operand (
   80:  9: . . . . . . . . . . . . . IDENT make
 /app/parser/parser.go:713: ast.Ident{Name: make}
   80: 13: . . . . . . . . . . . . )
   80: 13: . . . . . . . . . . . . CallOrConversion (
   80: 13: . . . . . . . . . . . . . "("
   80: 14: . . . . . . . . . . . . . Expression (
   80: 14: . . . . . . . . . . . . . . BinaryExpr (
   80: 14: . . . . . . . . . . . . . . . UnaryExpr (
   80: 14: . . . . . . . . . . . . . . . . PrimaryExpr (
   80: 14: . . . . . . . . . . . . . . . . . Operand (
   80: 14: . . . . . . . . . . . . . . . . . . ArrayType (
   80: 14: . . . . . . . . . . . . . . . . . . . "["
   80: 15: . . . . . . . . . . . . . . . . . . . "]"
   80: 16: . . . . . . . . . . . . . . . . . . . TypeName (
   80: 16: . . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   80: 22: . . . . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: string}
   80: 22: . . . . . . . . . . . . . . . . . . )
   80: 22: . . . . . . . . . . . . . . . . . )
   80: 22: . . . . . . . . . . . . . . . . )
   80: 22: . . . . . . . . . . . . . . . )
   80: 22: . . . . . . . . . . . . . . )
   80: 22: . . . . . . . . . . . . . )
   80: 22: . . . . . . . . . . . . . ","
   80: 24: . . . . . . . . . . . . . Expression (
   80: 24: . . . . . . . . . . . . . . BinaryExpr (
   80: 24: . . . . . . . . . . . . . . . UnaryExpr (
   80: 24: . . . . . . . . . . . . . . . . PrimaryExpr (
   80: 24: . . . . . . . . . . . . . . . . . Operand (
   80: 24: . . . . . . . . . . . . . . . . . . IDENT len
 /app/parser/parser.go:713: ast.Ident{Name: len}
   80: 27: . . . . . . . . . . . . . . . . . )
   80: 27: . . . . . . . . . . . . . . . . . CallOrConversion (
   80: 27: . . . . . . . . . . . . . . . . . . "("
   80: 28: . . . . . . . . . . . . . . . . . . Expression (
   80: 28: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   80: 28: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   80: 28: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   80: 28: . . . . . . . . . . . . . . . . . . . . . . Operand (
   80: 28: . . . . . . . . . . . . . . . . . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   80: 30: . . . . . . . . . . . . . . . . . . . . . . )
   80: 30: . . . . . . . . . . . . . . . . . . . . . )
   80: 30: . . . . . . . . . . . . . . . . . . . . )
   80: 30: . . . . . . . . . . . . . . . . . . . )
   80: 30: . . . . . . . . . . . . . . . . . . )
   80: 30: . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: len, Ellipsis: false, isCmd: false}
   80: 31: . . . . . . . . . . . . . . . . . )
   80: 31: . . . . . . . . . . . . . . . . )
   80: 31: . . . . . . . . . . . . . . . )
   80: 31: . . . . . . . . . . . . . . )
   80: 31: . . . . . . . . . . . . . )
   80: 31: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: make, Ellipsis: false, isCmd: false}
   80: 32: . . . . . . . . . . . . )
   80: 32: . . . . . . . . . . . )
   80: 32: . . . . . . . . . . )
   80: 32: . . . . . . . . . )
   80: 32: . . . . . . . . )
   80: 32: . . . . . . . )
   80: 32: . . . . . . )
   80: 32: . . . . . . ";"
   81:  2: . . . . . )
   81:  2: . . . . . Statement (
   81:  2: . . . . . . ForStmt (
   81:  2: . . . . . . . "for"
   81:  6: . . . . . . . SimpleStmt (
   81:  6: . . . . . . . . ExpressionList (
   81:  6: . . . . . . . . . Expression (
   81:  6: . . . . . . . . . . BinaryExpr (
   81:  6: . . . . . . . . . . . UnaryExpr (
   81:  6: . . . . . . . . . . . . PrimaryExpr (
   81:  6: . . . . . . . . . . . . . Operand (
   81:  6: . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   81:  7: . . . . . . . . . . . . . )
   81:  7: . . . . . . . . . . . . )
   81:  7: . . . . . . . . . . . )
   81:  7: . . . . . . . . . . )
   81:  7: . . . . . . . . . )
   81:  7: . . . . . . . . . ","
   81:  9: . . . . . . . . . Expression (
   81:  9: . . . . . . . . . . BinaryExpr (
   81:  9: . . . . . . . . . . . UnaryExpr (
   81:  9: . . . . . . . . . . . . PrimaryExpr (
   81:  9: . . . . . . . . . . . . . Operand (
   81:  9: . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   81: 11: . . . . . . . . . . . . . )
   81: 11: . . . . . . . . . . . . )
   81: 11: . . . . . . . . . . . )
   81: 11: . . . . . . . . . . )
   81: 11: . . . . . . . . . )
   81: 11: . . . . . . . . )
   81: 11: . . . . . . . . ":="
   81: 14: . . . . . . . . "range"
   81: 20: . . . . . . . . Expression (
   81: 20: . . . . . . . . . RangeExpr (
   81: 20: . . . . . . . . . . BinaryExpr (
   81: 20: . . . . . . . . . . . UnaryExpr (
   81: 20: . . . . . . . . . . . . PrimaryExpr (
   81: 20: . . . . . . . . . . . . . Operand (
   81: 20: . . . . . . . . . . . . . . IDENT vs
 /app/parser/parser.go:713: ast.Ident{Name: vs}
   81: 23: . . . . . . . . . . . . . )
   81: 23: . . . . . . . . . . . . )
   81: 23: . . . . . . . . . . . )
   81: 23: . . . . . . . . . . )
   81: 23: . . . . . . . . . )
   81: 23: . . . . . . . . )
   81: 23: . . . . . . . )
   81: 23: . . . . . . . BlockStmt (
   81: 23: . . . . . . . . "{"
   82:  3: . . . . . . . . StatementList (
   82:  3: . . . . . . . . . Statement (
   82:  3: . . . . . . . . . . SimpleStmt (
   82:  3: . . . . . . . . . . . ExpressionList (
   82:  3: . . . . . . . . . . . . Expression (
   82:  3: . . . . . . . . . . . . . BinaryExpr (
   82:  3: . . . . . . . . . . . . . . UnaryExpr (
   82:  3: . . . . . . . . . . . . . . . PrimaryExpr (
   82:  3: . . . . . . . . . . . . . . . . Operand (
   82:  3: . . . . . . . . . . . . . . . . . IDENT vsm
 /app/parser/parser.go:713: ast.Ident{Name: vsm}
   82:  6: . . . . . . . . . . . . . . . . )
   82:  6: . . . . . . . . . . . . . . . . IndexOrSlice (
   82:  6: . . . . . . . . . . . . . . . . . "["
   82:  7: . . . . . . . . . . . . . . . . . Expression (
   82:  7: . . . . . . . . . . . . . . . . . . BinaryExpr (
   82:  7: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   82:  7: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   82:  7: . . . . . . . . . . . . . . . . . . . . . Operand (
   82:  7: . . . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   82:  8: . . . . . . . . . . . . . . . . . . . . . )
   82:  8: . . . . . . . . . . . . . . . . . . . . )
   82:  8: . . . . . . . . . . . . . . . . . . . )
   82:  8: . . . . . . . . . . . . . . . . . . )
   82:  8: . . . . . . . . . . . . . . . . . )
   82:  8: . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: vsm, Index: i}
   82: 10: . . . . . . . . . . . . . . . . )
   82: 10: . . . . . . . . . . . . . . . )
   82: 10: . . . . . . . . . . . . . . )
   82: 10: . . . . . . . . . . . . . )
   82: 10: . . . . . . . . . . . . )
   82: 10: . . . . . . . . . . . )
   82: 10: . . . . . . . . . . . "="
   82: 12: . . . . . . . . . . . ExpressionList (
   82: 12: . . . . . . . . . . . . Expression (
   82: 12: . . . . . . . . . . . . . BinaryExpr (
   82: 12: . . . . . . . . . . . . . . UnaryExpr (
   82: 12: . . . . . . . . . . . . . . . PrimaryExpr (
   82: 12: . . . . . . . . . . . . . . . . Operand (
   82: 12: . . . . . . . . . . . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   82: 13: . . . . . . . . . . . . . . . . )
   82: 13: . . . . . . . . . . . . . . . . CallOrConversion (
   82: 13: . . . . . . . . . . . . . . . . . "("
   82: 14: . . . . . . . . . . . . . . . . . Expression (
   82: 14: . . . . . . . . . . . . . . . . . . BinaryExpr (
   82: 14: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   82: 14: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   82: 14: . . . . . . . . . . . . . . . . . . . . . Operand (
   82: 14: . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   82: 15: . . . . . . . . . . . . . . . . . . . . . )
   82: 15: . . . . . . . . . . . . . . . . . . . . )
   82: 15: . . . . . . . . . . . . . . . . . . . )
   82: 15: . . . . . . . . . . . . . . . . . . )
   82: 15: . . . . . . . . . . . . . . . . . )
   82: 15: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: f, Ellipsis: false, isCmd: false}
   82: 16: . . . . . . . . . . . . . . . . )
   82: 16: . . . . . . . . . . . . . . . )
   82: 16: . . . . . . . . . . . . . . )
   82: 16: . . . . . . . . . . . . . )
   82: 16: . . . . . . . . . . . . )
   82: 16: . . . . . . . . . . . )
   82: 16: . . . . . . . . . . )
   82: 16: . . . . . . . . . . ";"
   83:  2: . . . . . . . . . )
   83:  2: . . . . . . . . )
   83:  2: . . . . . . . . "}"
   83:  3: . . . . . . . )
   83:  3: . . . . . . . ";"
   84:  2: . . . . . . )
   84:  2: . . . . . )
   84:  2: . . . . . Statement (
   84:  2: . . . . . . ReturnStmt (
   84:  2: . . . . . . . "return"
   84:  9: . . . . . . . ExpressionList (
   84:  9: . . . . . . . . Expression (
   84:  9: . . . . . . . . . BinaryExpr (
   84:  9: . . . . . . . . . . UnaryExpr (
   84:  9: . . . . . . . . . . . PrimaryExpr (
   84:  9: . . . . . . . . . . . . Operand (
   84:  9: . . . . . . . . . . . . . IDENT vsm
 /app/parser/parser.go:713: ast.Ident{Name: vsm}
   84: 12: . . . . . . . . . . . . )
   84: 12: . . . . . . . . . . . )
   84: 12: . . . . . . . . . . )
   84: 12: . . . . . . . . . )
   84: 12: . . . . . . . . )
   84: 12: . . . . . . . )
   84: 12: . . . . . . . ";"
   85:  1: . . . . . . )
   85:  1: . . . . . )
   85:  1: . . . . )
   85:  1: . . . . "}"
   85:  2: . . . )
   85:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: Map, ...}
   87:  1: . . )
   87:  1: . )
   87:  1: . Declaration (
   87:  1: . . FunctionDeclOrCall (
   87:  1: . . . "func"
   87:  6: . . . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
   87: 10: . . . Signature (
   87: 10: . . . . Parameters (
   87: 10: . . . . . "("
   87: 11: . . . . . ")"
   87: 13: . . . . )
   87: 13: . . . . Result (
   87: 13: . . . . )
   87: 13: . . . )
   87: 13: . . . Body (
   87: 13: . . . . "{"
   89:  2: . . . . COMMENT
   90:  2: . . . . StatementList (
   90:  2: . . . . . Statement (
   90:  2: . . . . . . GenDecl(var) (
   90:  2: . . . . . . . "var"
   90:  6: . . . . . . . varSpec (
   90:  6: . . . . . . . . IdentList (
   90:  6: . . . . . . . . . IDENT strs
 /app/parser/parser.go:713: ast.Ident{Name: strs}
   90: 11: . . . . . . . . )
   90: 11: . . . . . . . . "="
   90: 13: . . . . . . . . ExpressionList (
   90: 13: . . . . . . . . . Expression (
   90: 13: . . . . . . . . . . BinaryExpr (
   90: 13: . . . . . . . . . . . UnaryExpr (
   90: 13: . . . . . . . . . . . . PrimaryExpr (
   90: 13: . . . . . . . . . . . . . Operand (
   90: 13: . . . . . . . . . . . . . . ArrayType (
   90: 13: . . . . . . . . . . . . . . . "["
   90: 14: . . . . . . . . . . . . . . . "]"
   90: 15: . . . . . . . . . . . . . . . TypeName (
   90: 15: . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   90: 21: . . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: string}
   90: 21: . . . . . . . . . . . . . . )
   90: 21: . . . . . . . . . . . . . )
   90: 21: . . . . . . . . . . . . . LiteralValue (
   90: 21: . . . . . . . . . . . . . . "{"
   90: 22: . . . . . . . . . . . . . . ElementList (
   90: 22: . . . . . . . . . . . . . . . Element (
   90: 22: . . . . . . . . . . . . . . . . Element (
   90: 22: . . . . . . . . . . . . . . . . . Expression (
   90: 22: . . . . . . . . . . . . . . . . . . BinaryExpr (
   90: 22: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   90: 22: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   90: 22: . . . . . . . . . . . . . . . . . . . . . Operand (
   90: 22: . . . . . . . . . . . . . . . . . . . . . . STRING "peach"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "peach"}
   90: 29: . . . . . . . . . . . . . . . . . . . . . )
   90: 29: . . . . . . . . . . . . . . . . . . . . )
   90: 29: . . . . . . . . . . . . . . . . . . . )
   90: 29: . . . . . . . . . . . . . . . . . . )
   90: 29: . . . . . . . . . . . . . . . . . )
   90: 29: . . . . . . . . . . . . . . . . )
   90: 29: . . . . . . . . . . . . . . . )
   90: 29: . . . . . . . . . . . . . . . ","
   90: 31: . . . . . . . . . . . . . . . Element (
   90: 31: . . . . . . . . . . . . . . . . Element (
   90: 31: . . . . . . . . . . . . . . . . . Expression (
   90: 31: . . . . . . . . . . . . . . . . . . BinaryExpr (
   90: 31: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   90: 31: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   90: 31: . . . . . . . . . . . . . . . . . . . . . Operand (
   90: 31: . . . . . . . . . . . . . . . . . . . . . . STRING "apple"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "apple"}
   90: 38: . . . . . . . . . . . . . . . . . . . . . )
   90: 38: . . . . . . . . . . . . . . . . . . . . )
   90: 38: . . . . . . . . . . . . . . . . . . . )
   90: 38: . . . . . . . . . . . . . . . . . . )
   90: 38: . . . . . . . . . . . . . . . . . )
   90: 38: . . . . . . . . . . . . . . . . )
   90: 38: . . . . . . . . . . . . . . . )
   90: 38: . . . . . . . . . . . . . . . ","
   90: 40: . . . . . . . . . . . . . . . Element (
   90: 40: . . . . . . . . . . . . . . . . Element (
   90: 40: . . . . . . . . . . . . . . . . . Expression (
   90: 40: . . . . . . . . . . . . . . . . . . BinaryExpr (
   90: 40: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   90: 40: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   90: 40: . . . . . . . . . . . . . . . . . . . . . Operand (
   90: 40: . . . . . . . . . . . . . . . . . . . . . . STRING "pear"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "pear"}
   90: 46: . . . . . . . . . . . . . . . . . . . . . )
   90: 46: . . . . . . . . . . . . . . . . . . . . )
   90: 46: . . . . . . . . . . . . . . . . . . . )
   90: 46: . . . . . . . . . . . . . . . . . . )
   90: 46: . . . . . . . . . . . . . . . . . )
   90: 46: . . . . . . . . . . . . . . . . )
   90: 46: . . . . . . . . . . . . . . . )
   90: 46: . . . . . . . . . . . . . . . ","
   90: 48: . . . . . . . . . . . . . . . Element (
   90: 48: . . . . . . . . . . . . . . . . Element (
   90: 48: . . . . . . . . . . . . . . . . . Expression (
   90: 48: . . . . . . . . . . . . . . . . . . BinaryExpr (
   90: 48: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   90: 48: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   90: 48: . . . . . . . . . . . . . . . . . . . . . Operand (
   90: 48: . . . . . . . . . . . . . . . . . . . . . . STRING "plum"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "plum"}
   90: 54: . . . . . . . . . . . . . . . . . . . . . )
   90: 54: . . . . . . . . . . . . . . . . . . . . )
   90: 54: . . . . . . . . . . . . . . . . . . . )
   90: 54: . . . . . . . . . . . . . . . . . . )
   90: 54: . . . . . . . . . . . . . . . . . )
   90: 54: . . . . . . . . . . . . . . . . )
   90: 54: . . . . . . . . . . . . . . . )
   90: 54: . . . . . . . . . . . . . . )
   90: 54: . . . . . . . . . . . . . . "}"
   90: 55: . . . . . . . . . . . . . )
   90: 55: . . . . . . . . . . . . )
   90: 55: . . . . . . . . . . . )
   90: 55: . . . . . . . . . . )
   90: 55: . . . . . . . . . )
   90: 55: . . . . . . . . )
   90: 55: . . . . . . . . ";"
   92:  2: . . . . . . . )
   92:  2: . . . . . . )
   92:  2: . . . . . )
   92:  2: . . . . . Statement (
   92:  2: . . . . . . SimpleStmt (
   92:  2: . . . . . . . ExpressionList (
   92:  2: . . . . . . . . Expression (
   92:  2: . . . . . . . . . BinaryExpr (
   92:  2: . . . . . . . . . . UnaryExpr (
   92:  2: . . . . . . . . . . . PrimaryExpr (
   92:  2: . . . . . . . . . . . . Operand (
   92:  2: . . . . . . . . . . . . . IDENT fmt
 /app/parser/parser.go:713: ast.Ident{Name: fmt}
   92:  5: . . . . . . . . . . . . )
   92:  5: . . . . . . . . . . . . "."
   92:  6: . . . . . . . . . . . . Selector (
   92:  6: . . . . . . . . . . . . . IDENT Println
 /app/parser/parser.go:713: ast.Ident{Name: Println}
   92: 13: . . . . . . . . . . . . )
   92: 13: . . . . . . . . . . . . CallOrConversion (
   92: 13: . . . . . . . . . . . . . "("
   92: 14: . . . . . . . . . . . . . Expression (
   92: 14: . . . . . . . . . . . . . . BinaryExpr (
   92: 14: . . . . . . . . . . . . . . . UnaryExpr (
   92: 14: . . . . . . . . . . . . . . . . PrimaryExpr (
   92: 14: . . . . . . . . . . . . . . . . . Operand (
   92: 14: . . . . . . . . . . . . . . . . . . IDENT Index
 /app/parser/parser.go:713: ast.Ident{Name: Index}
   92: 19: . . . . . . . . . . . . . . . . . )
   92: 19: . . . . . . . . . . . . . . . . . CallOrConversion (
   92: 19: . . . . . . . . . . . . . . . . . . "("
   92: 20: . . . . . . . . . . . . . . . . . . Expression (
   92: 20: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   92: 20: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   92: 20: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   92: 20: . . . . . . . . . . . . . . . . . . . . . . Operand (
   92: 20: . . . . . . . . . . . . . . . . . . . . . . . IDENT strs
 /app/parser/parser.go:713: ast.Ident{Name: strs}
   92: 24: . . . . . . . . . . . . . . . . . . . . . . )
   92: 24: . . . . . . . . . . . . . . . . . . . . . )
   92: 24: . . . . . . . . . . . . . . . . . . . . )
   92: 24: . . . . . . . . . . . . . . . . . . . )
   92: 24: . . . . . . . . . . . . . . . . . . )
   92: 24: . . . . . . . . . . . . . . . . . . ","
   92: 26: . . . . . . . . . . . . . . . . . . Expression (
   92: 26: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   92: 26: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   92: 26: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   92: 26: . . . . . . . . . . . . . . . . . . . . . . Operand (
   92: 26: . . . . . . . . . . . . . . . . . . . . . . . STRING "pear"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "pear"}
   92: 32: . . . . . . . . . . . . . . . . . . . . . . )
   92: 32: . . . . . . . . . . . . . . . . . . . . . )
   92: 32: . . . . . . . . . . . . . . . . . . . . )
   92: 32: . . . . . . . . . . . . . . . . . . . )
   92: 32: . . . . . . . . . . . . . . . . . . )
   92: 32: . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: Index, Ellipsis: false, isCmd: false}
   92: 33: . . . . . . . . . . . . . . . . . )
   92: 33: . . . . . . . . . . . . . . . . )
   92: 33: . . . . . . . . . . . . . . . )
   92: 33: . . . . . . . . . . . . . . )
   92: 33: . . . . . . . . . . . . . )
   92: 33: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fmt Println}, Ellipsis: false, isCmd: false}
   92: 34: . . . . . . . . . . . . )
   92: 34: . . . . . . . . . . . )
   92: 34: . . . . . . . . . . )
   92: 34: . . . . . . . . . )
   92: 34: . . . . . . . . )
   92: 34: . . . . . . . )
   92: 34: . . . . . . )
   92: 34: . . . . . . ";"
   94:  2: . . . . . )
   94:  2: . . . . . Statement (
   94:  2: . . . . . . SimpleStmt (
   94:  2: . . . . . . . ExpressionList (
   94:  2: . . . . . . . . Expression (
   94:  2: . . . . . . . . . BinaryExpr (
   94:  2: . . . . . . . . . . UnaryExpr (
   94:  2: . . . . . . . . . . . PrimaryExpr (
   94:  2: . . . . . . . . . . . . Operand (
   94:  2: . . . . . . . . . . . . . IDENT fmt
 /app/parser/parser.go:713: ast.Ident{Name: fmt}
   94:  5: . . . . . . . . . . . . )
   94:  5: . . . . . . . . . . . . "."
   94:  6: . . . . . . . . . . . . Selector (
   94:  6: . . . . . . . . . . . . . IDENT Println
 /app/parser/parser.go:713: ast.Ident{Name: Println}
   94: 13: . . . . . . . . . . . . )
   94: 13: . . . . . . . . . . . . CallOrConversion (
   94: 13: . . . . . . . . . . . . . "("
   94: 14: . . . . . . . . . . . . . Expression (
   94: 14: . . . . . . . . . . . . . . BinaryExpr (
   94: 14: . . . . . . . . . . . . . . . UnaryExpr (
   94: 14: . . . . . . . . . . . . . . . . PrimaryExpr (
   94: 14: . . . . . . . . . . . . . . . . . Operand (
   94: 14: . . . . . . . . . . . . . . . . . . IDENT Include
 /app/parser/parser.go:713: ast.Ident{Name: Include}
   94: 21: . . . . . . . . . . . . . . . . . )
   94: 21: . . . . . . . . . . . . . . . . . CallOrConversion (
   94: 21: . . . . . . . . . . . . . . . . . . "("
   94: 22: . . . . . . . . . . . . . . . . . . Expression (
   94: 22: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   94: 22: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   94: 22: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   94: 22: . . . . . . . . . . . . . . . . . . . . . . Operand (
   94: 22: . . . . . . . . . . . . . . . . . . . . . . . IDENT strs
 /app/parser/parser.go:713: ast.Ident{Name: strs}
   94: 26: . . . . . . . . . . . . . . . . . . . . . . )
   94: 26: . . . . . . . . . . . . . . . . . . . . . )
   94: 26: . . . . . . . . . . . . . . . . . . . . )
   94: 26: . . . . . . . . . . . . . . . . . . . )
   94: 26: . . . . . . . . . . . . . . . . . . )
   94: 26: . . . . . . . . . . . . . . . . . . ","
   94: 28: . . . . . . . . . . . . . . . . . . Expression (
   94: 28: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   94: 28: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   94: 28: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   94: 28: . . . . . . . . . . . . . . . . . . . . . . Operand (
   94: 28: . . . . . . . . . . . . . . . . . . . . . . . STRING "grape"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "grape"}
   94: 35: . . . . . . . . . . . . . . . . . . . . . . )
   94: 35: . . . . . . . . . . . . . . . . . . . . . )
   94: 35: . . . . . . . . . . . . . . . . . . . . )
   94: 35: . . . . . . . . . . . . . . . . . . . )
   94: 35: . . . . . . . . . . . . . . . . . . )
   94: 35: . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: Include, Ellipsis: false, isCmd: false}
   94: 36: . . . . . . . . . . . . . . . . . )
   94: 36: . . . . . . . . . . . . . . . . )
   94: 36: . . . . . . . . . . . . . . . )
   94: 36: . . . . . . . . . . . . . . )
   94: 36: . . . . . . . . . . . . . )
   94: 36: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fmt Println}, Ellipsis: false, isCmd: false}
   94: 37: . . . . . . . . . . . . )
   94: 37: . . . . . . . . . . . )
   94: 37: . . . . . . . . . . )
   94: 37: . . . . . . . . . )
   94: 37: . . . . . . . . )
   94: 37: . . . . . . . )
   94: 37: . . . . . . )
   94: 37: . . . . . . ";"
   96:  2: . . . . . )
   96:  2: . . . . . Statement (
   96:  2: . . . . . . SimpleStmt (
   96:  2: . . . . . . . ExpressionList (
   96:  2: . . . . . . . . Expression (
   96:  2: . . . . . . . . . BinaryExpr (
   96:  2: . . . . . . . . . . UnaryExpr (
   96:  2: . . . . . . . . . . . PrimaryExpr (
   96:  2: . . . . . . . . . . . . Operand (
   96:  2: . . . . . . . . . . . . . IDENT fmt
 /app/parser/parser.go:713: ast.Ident{Name: fmt}
   96:  5: . . . . . . . . . . . . )
   96:  5: . . . . . . . . . . . . "."
   96:  6: . . . . . . . . . . . . Selector (
   96:  6: . . . . . . . . . . . . . IDENT Println
 /app/parser/parser.go:713: ast.Ident{Name: Println}
   96: 13: . . . . . . . . . . . . )
   96: 13: . . . . . . . . . . . . CallOrConversion (
   96: 13: . . . . . . . . . . . . . "("
   96: 14: . . . . . . . . . . . . . Expression (
   96: 14: . . . . . . . . . . . . . . BinaryExpr (
   96: 14: . . . . . . . . . . . . . . . UnaryExpr (
   96: 14: . . . . . . . . . . . . . . . . PrimaryExpr (
   96: 14: . . . . . . . . . . . . . . . . . Operand (
   96: 14: . . . . . . . . . . . . . . . . . . IDENT Any
 /app/parser/parser.go:713: ast.Ident{Name: Any}
   96: 17: . . . . . . . . . . . . . . . . . )
   96: 17: . . . . . . . . . . . . . . . . . CallOrConversion (
   96: 17: . . . . . . . . . . . . . . . . . . "("
   96: 18: . . . . . . . . . . . . . . . . . . Expression (
   96: 18: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   96: 18: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   96: 18: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   96: 18: . . . . . . . . . . . . . . . . . . . . . . Operand (
   96: 18: . . . . . . . . . . . . . . . . . . . . . . . IDENT strs
 /app/parser/parser.go:713: ast.Ident{Name: strs}
   96: 22: . . . . . . . . . . . . . . . . . . . . . . )
   96: 22: . . . . . . . . . . . . . . . . . . . . . )
   96: 22: . . . . . . . . . . . . . . . . . . . . )
   96: 22: . . . . . . . . . . . . . . . . . . . )
   96: 22: . . . . . . . . . . . . . . . . . . )
   96: 22: . . . . . . . . . . . . . . . . . . ","
   96: 24: . . . . . . . . . . . . . . . . . . Expression (
   96: 24: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   96: 24: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   96: 24: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   96: 24: . . . . . . . . . . . . . . . . . . . . . . Operand (
   96: 24: . . . . . . . . . . . . . . . . . . . . . . . FuncTypeOrLit (
   96: 24: . . . . . . . . . . . . . . . . . . . . . . . . FuncType (
   96: 24: . . . . . . . . . . . . . . . . . . . . . . . . . "func"
   96: 28: . . . . . . . . . . . . . . . . . . . . . . . . . Signature (
   96: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . Parameters (
   96: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . "("
   96: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . ParameterList (
   96: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ParamDeclOrNil (
   96: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   96: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Type (
   96: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . TypeName (
   96: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   96: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   96: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   96: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   96: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   96: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . ")"
   96: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   96: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . Result (
   96: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . TypeName (
   96: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   96: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   96: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   96: 44: . . . . . . . . . . . . . . . . . . . . . . . . . )
   96: 44: . . . . . . . . . . . . . . . . . . . . . . . . )
   96: 44: . . . . . . . . . . . . . . . . . . . . . . . . Body (
   96: 44: . . . . . . . . . . . . . . . . . . . . . . . . . "{"
   97:  3: . . . . . . . . . . . . . . . . . . . . . . . . . StatementList (
   97:  3: . . . . . . . . . . . . . . . . . . . . . . . . . . Statement (
   97:  3: . . . . . . . . . . . . . . . . . . . . . . . . . . . ReturnStmt (
   97:  3: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "return"
   97: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ExpressionList (
   97: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   97: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   97: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   97: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   97: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   97: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT strings
 /app/parser/parser.go:713: ast.Ident{Name: strings}
   97: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "."
   97: 18: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Selector (
   97: 18: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT HasPrefix
 /app/parser/parser.go:713: ast.Ident{Name: HasPrefix}
   97: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
   97: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "("
   97: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   97: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   97: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   97: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   97: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   97: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   97: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ","
   97: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   97: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   97: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   97: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   97: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   97: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "p"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "p"}
   97: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{strings HasPrefix}, Ellipsis: false, isCmd: false}
   97: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   97: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";"
   98:  2: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   98:  2: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   98:  2: . . . . . . . . . . . . . . . . . . . . . . . . . )
   98:  2: . . . . . . . . . . . . . . . . . . . . . . . . . "}"
   98:  3: . . . . . . . . . . . . . . . . . . . . . . . . )
   98:  3: . . . . . . . . . . . . . . . . . . . . . . . )
   98:  3: . . . . . . . . . . . . . . . . . . . . . . )
   98:  3: . . . . . . . . . . . . . . . . . . . . . )
   98:  3: . . . . . . . . . . . . . . . . . . . . )
   98:  3: . . . . . . . . . . . . . . . . . . . )
   98:  3: . . . . . . . . . . . . . . . . . . )
   98:  3: . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: Any, Ellipsis: false, isCmd: false}
   98:  4: . . . . . . . . . . . . . . . . . )
   98:  4: . . . . . . . . . . . . . . . . )
   98:  4: . . . . . . . . . . . . . . . )
   98:  4: . . . . . . . . . . . . . . )
   98:  4: . . . . . . . . . . . . . )
   98:  4: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fmt Println}, Ellipsis: false, isCmd: false}
   98:  5: . . . . . . . . . . . . )
   98:  5: . . . . . . . . . . . )
   98:  5: . . . . . . . . . . )
   98:  5: . . . . . . . . . )
   98:  5: . . . . . . . . )
   98:  5: . . . . . . . )
   98:  5: . . . . . . )
   98:  5: . . . . . . ";"
  100:  2: . . . . . )
  100:  2: . . . . . Statement (
  100:  2: . . . . . . SimpleStmt (
  100:  2: . . . . . . . ExpressionList (
  100:  2: . . . . . . . . Expression (
  100:  2: . . . . . . . . . BinaryExpr (
  100:  2: . . . . . . . . . . UnaryExpr (
  100:  2: . . . . . . . . . . . PrimaryExpr (
  100:  2: . . . . . . . . . . . . Operand (
  100:  2: . . . . . . . . . . . . . IDENT fmt
 /app/parser/parser.go:713: ast.Ident{Name: fmt}
  100:  5: . . . . . . . . . . . . )
  100:  5: . . . . . . . . . . . . "."
  100:  6: . . . . . . . . . . . . Selector (
  100:  6: . . . . . . . . . . . . . IDENT Println
 /app/parser/parser.go:713: ast.Ident{Name: Println}
  100: 13: . . . . . . . . . . . . )
  100: 13: . . . . . . . . . . . . CallOrConversion (
  100: 13: . . . . . . . . . . . . . "("
  100: 14: . . . . . . . . . . . . . Expression (
  100: 14: . . . . . . . . . . . . . . BinaryExpr (
  100: 14: . . . . . . . . . . . . . . . UnaryExpr (
  100: 14: . . . . . . . . . . . . . . . . PrimaryExpr (
  100: 14: . . . . . . . . . . . . . . . . . Operand (
  100: 14: . . . . . . . . . . . . . . . . . . IDENT All
 /app/parser/parser.go:713: ast.Ident{Name: All}
  100: 17: . . . . . . . . . . . . . . . . . )
  100: 17: . . . . . . . . . . . . . . . . . CallOrConversion (
  100: 17: . . . . . . . . . . . . . . . . . . "("
  100: 18: . . . . . . . . . . . . . . . . . . Expression (
  100: 18: . . . . . . . . . . . . . . . . . . . BinaryExpr (
  100: 18: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  100: 18: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  100: 18: . . . . . . . . . . . . . . . . . . . . . . Operand (
  100: 18: . . . . . . . . . . . . . . . . . . . . . . . IDENT strs
 /app/parser/parser.go:713: ast.Ident{Name: strs}
  100: 22: . . . . . . . . . . . . . . . . . . . . . . )
  100: 22: . . . . . . . . . . . . . . . . . . . . . )
  100: 22: . . . . . . . . . . . . . . . . . . . . )
  100: 22: . . . . . . . . . . . . . . . . . . . )
  100: 22: . . . . . . . . . . . . . . . . . . )
  100: 22: . . . . . . . . . . . . . . . . . . ","
  100: 24: . . . . . . . . . . . . . . . . . . Expression (
  100: 24: . . . . . . . . . . . . . . . . . . . BinaryExpr (
  100: 24: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  100: 24: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  100: 24: . . . . . . . . . . . . . . . . . . . . . . Operand (
  100: 24: . . . . . . . . . . . . . . . . . . . . . . . FuncTypeOrLit (
  100: 24: . . . . . . . . . . . . . . . . . . . . . . . . FuncType (
  100: 24: . . . . . . . . . . . . . . . . . . . . . . . . . "func"
  100: 28: . . . . . . . . . . . . . . . . . . . . . . . . . Signature (
  100: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . Parameters (
  100: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . "("
  100: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . ParameterList (
  100: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ParamDeclOrNil (
  100: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
  100: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Type (
  100: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . TypeName (
  100: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
  100: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  100: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  100: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  100: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  100: 37: . . . . . . . . . . . . . . . . . . . . . . . . . . . ")"
  100: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . )
  100: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . Result (
  100: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . TypeName (
  100: 39: . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
  100: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  100: 44: . . . . . . . . . . . . . . . . . . . . . . . . . . )
  100: 44: . . . . . . . . . . . . . . . . . . . . . . . . . )
  100: 44: . . . . . . . . . . . . . . . . . . . . . . . . )
  100: 44: . . . . . . . . . . . . . . . . . . . . . . . . Body (
  100: 44: . . . . . . . . . . . . . . . . . . . . . . . . . "{"
  101:  3: . . . . . . . . . . . . . . . . . . . . . . . . . StatementList (
  101:  3: . . . . . . . . . . . . . . . . . . . . . . . . . . Statement (
  101:  3: . . . . . . . . . . . . . . . . . . . . . . . . . . . ReturnStmt (
  101:  3: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "return"
  101: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ExpressionList (
  101: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
  101: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
  101: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  101: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  101: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
  101: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT strings
 /app/parser/parser.go:713: ast.Ident{Name: strings}
  101: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "."
  101: 18: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Selector (
  101: 18: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT HasPrefix
 /app/parser/parser.go:713: ast.Ident{Name: HasPrefix}
  101: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
  101: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "("
  101: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
  101: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
  101: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  101: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  101: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
  101: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
  101: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 29: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ","
  101: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
  101: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
  101: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  101: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  101: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
  101: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "p"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "p"}
  101: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{strings HasPrefix}, Ellipsis: false, isCmd: false}
  101: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  101: 35: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";"
  102:  2: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  102:  2: . . . . . . . . . . . . . . . . . . . . . . . . . . )
  102:  2: . . . . . . . . . . . . . . . . . . . . . . . . . )
  102:  2: . . . . . . . . . . . . . . . . . . . . . . . . . "}"
  102:  3: . . . . . . . . . . . . . . . . . . . . . . . . )
  102:  3: . . . . . . . . . . . . . . . . . . . . . . . )
  102:  3: . . . . . . . . . . . . . . . . . . . . . . )
  102:  3: . . . . . . . . . . . . . . . . . . . . . )
  102:  3: . . . . . . . . . . . . . . . . . . . . )
  102:  3: . . . . . . . . . . . . . . . . . . . )
  102:  3: . . . . . . . . . . . . . . . . . . )
  102:  3: . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: All, Ellipsis: false, isCmd: false}
  102:  4: . . . . . . . . . . . . . . . . . )
  102:  4: . . . . . . . . . . . . . . . . )
  102:  4: . . . . . . . . . . . . . . . )
  102:  4: . . . . . . . . . . . . . . )
  102:  4: . . . . . . . . . . . . . )
  102:  4: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fmt Println}, Ellipsis: false, isCmd: false}
  102:  5: . . . . . . . . . . . . )
  102:  5: . . . . . . . . . . . )
  102:  5: . . . . . . . . . . )
  102:  5: . . . . . . . . . )
  102:  5: . . . . . . . . )
  102:  5: . . . . . . . )
  102:  5: . . . . . . )
  102:  5: . . . . . . ";"
  104:  2: . . . . . )
  104:  2: . . . . . Statement (
  104:  2: . . . . . . SimpleStmt (
  104:  2: . . . . . . . ExpressionList (
  104:  2: . . . . . . . . Expression (
  104:  2: . . . . . . . . . BinaryExpr (
  104:  2: . . . . . . . . . . UnaryExpr (
  104:  2: . . . . . . . . . . . PrimaryExpr (
  104:  2: . . . . . . . . . . . . Operand (
  104:  2: . . . . . . . . . . . . . IDENT fmt
 /app/parser/parser.go:713: ast.Ident{Name: fmt}
  104:  5: . . . . . . . . . . . . )
  104:  5: . . . . . . . . . . . . "."
  104:  6: . . . . . . . . . . . . Selector (
  104:  6: . . . . . . . . . . . . . IDENT Println
 /app/parser/parser.go:713: ast.Ident{Name: Println}
  104: 13: . . . . . . . . . . . . )
  104: 13: . . . . . . . . . . . . CallOrConversion (
  104: 13: . . . . . . . . . . . . . "("
  104: 14: . . . . . . . . . . . . . Expression (
  104: 14: . . . . . . . . . . . . . . BinaryExpr (
  104: 14: . . . . . . . . . . . . . . . UnaryExpr (
  104: 14: . . . . . . . . . . . . . . . . PrimaryExpr (
  104: 14: . . . . . . . . . . . . . . . . . Operand (
  104: 14: . . . . . . . . . . . . . . . . . . IDENT Filter
 /app/parser/parser.go:713: ast.Ident{Name: Filter}
  104: 20: . . . . . . . . . . . . . . . . . )
  104: 20: . . . . . . . . . . . . . . . . . CallOrConversion (
  104: 20: . . . . . . . . . . . . . . . . . . "("
  104: 21: . . . . . . . . . . . . . . . . . . Expression (
  104: 21: . . . . . . . . . . . . . . . . . . . BinaryExpr (
  104: 21: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  104: 21: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  104: 21: . . . . . . . . . . . . . . . . . . . . . . Operand (
  104: 21: . . . . . . . . . . . . . . . . . . . . . . . IDENT strs
 /app/parser/parser.go:713: ast.Ident{Name: strs}
  104: 25: . . . . . . . . . . . . . . . . . . . . . . )
  104: 25: . . . . . . . . . . . . . . . . . . . . . )
  104: 25: . . . . . . . . . . . . . . . . . . . . )
  104: 25: . . . . . . . . . . . . . . . . . . . )
  104: 25: . . . . . . . . . . . . . . . . . . )
  104: 25: . . . . . . . . . . . . . . . . . . ","
  104: 27: . . . . . . . . . . . . . . . . . . Expression (
  104: 27: . . . . . . . . . . . . . . . . . . . BinaryExpr (
  104: 27: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  104: 27: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  104: 27: . . . . . . . . . . . . . . . . . . . . . . Operand (
  104: 27: . . . . . . . . . . . . . . . . . . . . . . . FuncTypeOrLit (
  104: 27: . . . . . . . . . . . . . . . . . . . . . . . . FuncType (
  104: 27: . . . . . . . . . . . . . . . . . . . . . . . . . "func"
  104: 31: . . . . . . . . . . . . . . . . . . . . . . . . . Signature (
  104: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . Parameters (
  104: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . "("
  104: 32: . . . . . . . . . . . . . . . . . . . . . . . . . . . ParameterList (
  104: 32: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ParamDeclOrNil (
  104: 32: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
  104: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Type (
  104: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . TypeName (
  104: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
  104: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  104: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  104: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  104: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  104: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . ")"
  104: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . )
  104: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . Result (
  104: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . . TypeName (
  104: 42: . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
  104: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  104: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . )
  104: 47: . . . . . . . . . . . . . . . . . . . . . . . . . )
  104: 47: . . . . . . . . . . . . . . . . . . . . . . . . )
  104: 47: . . . . . . . . . . . . . . . . . . . . . . . . Body (
  104: 47: . . . . . . . . . . . . . . . . . . . . . . . . . "{"
  105:  3: . . . . . . . . . . . . . . . . . . . . . . . . . StatementList (
  105:  3: . . . . . . . . . . . . . . . . . . . . . . . . . . Statement (
  105:  3: . . . . . . . . . . . . . . . . . . . . . . . . . . . ReturnStmt (
  105:  3: . . . . . . . . . . . . . . . . . . . . . . . . . . . . "return"
  105: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ExpressionList (
  105: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
  105: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
  105: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  105: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  105: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
  105: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT strings
 /app/parser/parser.go:713: ast.Ident{Name: strings}
  105: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "."
  105: 18: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Selector (
  105: 18: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT Contains
 /app/parser/parser.go:713: ast.Ident{Name: Contains}
  105: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
  105: 26: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . "("
  105: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
  105: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
  105: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  105: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  105: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
  105: 27: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
  105: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 28: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ","
  105: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
  105: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
  105: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  105: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  105: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
  105: 30: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "e"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "e"}
  105: 33: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 33: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 33: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 33: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 33: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 33: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{strings Contains}, Ellipsis: false, isCmd: false}
  105: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  105: 34: . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";"
  106:  2: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
  106:  2: . . . . . . . . . . . . . . . . . . . . . . . . . . )
  106:  2: . . . . . . . . . . . . . . . . . . . . . . . . . )
  106:  2: . . . . . . . . . . . . . . . . . . . . . . . . . "}"
  106:  3: . . . . . . . . . . . . . . . . . . . . . . . . )
  106:  3: . . . . . . . . . . . . . . . . . . . . . . . )
  106:  3: . . . . . . . . . . . . . . . . . . . . . . )
  106:  3: . . . . . . . . . . . . . . . . . . . . . )
  106:  3: . . . . . . . . . . . . . . . . . . . . )
  106:  3: . . . . . . . . . . . . . . . . . . . )
  106:  3: . . . . . . . . . . . . . . . . . . )
  106:  3: . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: Filter, Ellipsis: false, isCmd: false}
  106:  4: . . . . . . . . . . . . . . . . . )
  106:  4: . . . . . . . . . . . . . . . . )
  106:  4: . . . . . . . . . . . . . . . )
  106:  4: . . . . . . . . . . . . . . )
  106:  4: . . . . . . . . . . . . . )
  106:  4: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fmt Println}, Ellipsis: false, isCmd: false}
  106:  5: . . . . . . . . . . . . )
  106:  5: . . . . . . . . . . . )
  106:  5: . . . . . . . . . . )
  106:  5: . . . . . . . . . )
  106:  5: . . . . . . . . )
  106:  5: . . . . . . . )
  106:  5: . . . . . . )
  106:  5: . . . . . . ";"
  108:  2: . . . . . . COMMENT
  109:  2: . . . . . . COMMENT
  110:  2: . . . . . . COMMENT
  111:  2: . . . . . )
  111:  2: . . . . . Statement (
  111:  2: . . . . . . SimpleStmt (
  111:  2: . . . . . . . ExpressionList (
  111:  2: . . . . . . . . Expression (
  111:  2: . . . . . . . . . BinaryExpr (
  111:  2: . . . . . . . . . . UnaryExpr (
  111:  2: . . . . . . . . . . . PrimaryExpr (
  111:  2: . . . . . . . . . . . . Operand (
  111:  2: . . . . . . . . . . . . . IDENT fmt
 /app/parser/parser.go:713: ast.Ident{Name: fmt}
  111:  5: . . . . . . . . . . . . )
  111:  5: . . . . . . . . . . . . "."
  111:  6: . . . . . . . . . . . . Selector (
  111:  6: . . . . . . . . . . . . . IDENT Println
 /app/parser/parser.go:713: ast.Ident{Name: Println}
  111: 13: . . . . . . . . . . . . )
  111: 13: . . . . . . . . . . . . CallOrConversion (
  111: 13: . . . . . . . . . . . . . "("
  111: 14: . . . . . . . . . . . . . Expression (
  111: 14: . . . . . . . . . . . . . . BinaryExpr (
  111: 14: . . . . . . . . . . . . . . . UnaryExpr (
  111: 14: . . . . . . . . . . . . . . . . PrimaryExpr (
  111: 14: . . . . . . . . . . . . . . . . . Operand (
  111: 14: . . . . . . . . . . . . . . . . . . IDENT Map
 /app/parser/parser.go:713: ast.Ident{Name: Map}
  111: 17: . . . . . . . . . . . . . . . . . )
  111: 17: . . . . . . . . . . . . . . . . . CallOrConversion (
  111: 17: . . . . . . . . . . . . . . . . . . "("
  111: 18: . . . . . . . . . . . . . . . . . . Expression (
  111: 18: . . . . . . . . . . . . . . . . . . . BinaryExpr (
  111: 18: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  111: 18: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  111: 18: . . . . . . . . . . . . . . . . . . . . . . Operand (
  111: 18: . . . . . . . . . . . . . . . . . . . . . . . IDENT strs
 /app/parser/parser.go:713: ast.Ident{Name: strs}
  111: 22: . . . . . . . . . . . . . . . . . . . . . . )
  111: 22: . . . . . . . . . . . . . . . . . . . . . )
  111: 22: . . . . . . . . . . . . . . . . . . . . )
  111: 22: . . . . . . . . . . . . . . . . . . . )
  111: 22: . . . . . . . . . . . . . . . . . . )
  111: 22: . . . . . . . . . . . . . . . . . . ","
  111: 24: . . . . . . . . . . . . . . . . . . Expression (
  111: 24: . . . . . . . . . . . . . . . . . . . BinaryExpr (
  111: 24: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
  111: 24: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
  111: 24: . . . . . . . . . . . . . . . . . . . . . . Operand (
  111: 24: . . . . . . . . . . . . . . . . . . . . . . . IDENT strings
 /app/parser/parser.go:713: ast.Ident{Name: strings}
  111: 31: . . . . . . . . . . . . . . . . . . . . . . )
  111: 31: . . . . . . . . . . . . . . . . . . . . . . "."
  111: 32: . . . . . . . . . . . . . . . . . . . . . . Selector (
  111: 32: . . . . . . . . . . . . . . . . . . . . . . . IDENT ToUpper
 /app/parser/parser.go:713: ast.Ident{Name: ToUpper}
  111: 39: . . . . . . . . . . . . . . . . . . . . . . )
  111: 39: . . . . . . . . . . . . . . . . . . . . . )
  111: 39: . . . . . . . . . . . . . . . . . . . . )
  111: 39: . . . . . . . . . . . . . . . . . . . )
  111: 39: . . . . . . . . . . . . . . . . . . )
  111: 39: . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: Map, Ellipsis: false, isCmd: false}
  111: 40: . . . . . . . . . . . . . . . . . )
  111: 40: . . . . . . . . . . . . . . . . )
  111: 40: . . . . . . . . . . . . . . . )
  111: 40: . . . . . . . . . . . . . . )
  111: 40: . . . . . . . . . . . . . )
  111: 40: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fmt Println}, Ellipsis: false, isCmd: false}
  111: 41: . . . . . . . . . . . . )
  111: 41: . . . . . . . . . . . )
  111: 41: . . . . . . . . . . )
  111: 41: . . . . . . . . . )
  111: 41: . . . . . . . . )
  111: 41: . . . . . . . )
  111: 41: . . . . . . )
  111: 41: . . . . . . ";"
  113:  1: . . . . . )
  113:  1: . . . . )
  113:  1: . . . . "}"
  113:  2: . . . )
  113:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: main, ...}
  113:  3: . . )
  113:  3: . )
  113:  3: )
=== RUN   TestFromTestdata/complit
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/complit
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . ArrayType (
    1:  6: . . . . . . . . . . . . "["
    1:  7: . . . . . . . . . . . . "]"
    1:  8: . . . . . . . . . . . . ArrayType (
    1:  8: . . . . . . . . . . . . . "["
    1:  9: . . . . . . . . . . . . . "]"
    1: 10: . . . . . . . . . . . . . TypeName (
    1: 10: . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 13: . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: int}
    1: 13: . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: &{8 <nil> int}}
    1: 13: . . . . . . . . . . . )
    1: 13: . . . . . . . . . . )
    1: 13: . . . . . . . . . . LiteralValue (
    1: 13: . . . . . . . . . . . "{"
    1: 14: . . . . . . . . . . . "}"
    1: 15: . . . . . . . . . . )
    1: 15: . . . . . . . . . )
    1: 15: . . . . . . . . )
    1: 15: . . . . . . . )
    1: 15: . . . . . . )
    1: 15: . . . . . )
    1: 15: . . . . )
    1: 15: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  8: . . . . . . . . . . )
    2:  8: . . . . . . . . . . CallOrConversion (
    2:  8: . . . . . . . . . . . "("
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2: 10: . . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    2: 11: . . . . . . . . . . )
    2: 11: . . . . . . . . . )
    2: 11: . . . . . . . . )
    2: 11: . . . . . . . )
    2: 11: . . . . . . )
    2: 11: . . . . . )
    2: 11: . . . . )
    2: 11: . . . . ";"
    2: 12: . . . )
    2: 12: . . )
    2: 12: . )
    2: 12: )
=== RUN   TestFromTestdata/domainhuh
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/domainhuh
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT form
 /app/parser/parser.go:713: ast.Ident{Name: form}
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . )
    1:  6: . . . . . . . . )
    1:  6: . . . . . . . )
    1:  6: . . . . . . )
    1:  6: . . . . . )
    1:  6: . . . . . ":="
    1:  9: . . . . . ExpressionList (
    1:  9: . . . . . . Expression (
    1:  9: . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . . IDENT huh
 /app/parser/parser.go:713: ast.Ident{Name: huh}
 /app/parser/parser.go:713: ast.Ident{Name: ret}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
 /app/parser/parser.go:1830: ast.DomainTextLit{Domain: huh, Value: `> &ret, 10
<form>
	<group>
		<select id="Burger" title="Choose your burger">
			<option value="classic" title="Charmburger Classic"/>
			<option value="chickwich" title="Chickwich"/>
			<option value="fishburger" title="Fishburger"/>
			<option value="charmpossible" title="Charmpossible Burger"/>
		</select>
	</group>
</form>
`}
    1: 12: . . . . . . . . . . . STRING `> &ret, 10
<form>
	<group>
		<select id="Burger" title="Choose your burger">
			<option value="classic" title="Charmburger Classic"/>
			<option value="chickwich" title="Chickwich"/>
			<option value="fishburger" title="Fishburger"/>
			<option value="charmpossible" title="Charmpossible Burger"/>
		</select>
	</group>
</form>
`
   12:  2: . . . . . . . . . . )
   12:  2: . . . . . . . . . )
   12:  2: . . . . . . . . )
   12:  2: . . . . . . . )
   12:  2: . . . . . . )
   12:  2: . . . . . )
   12:  2: . . . . )
   12:  2: . . . . ";"
   12:  3: . . . )
   12:  3: . . )
   12:  3: . )
   12:  3: )
=== RUN   TestFromTestdata/domaintext
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/domaintext
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT cl
 /app/parser/parser.go:713: ast.Ident{Name: cl}
    1:  4: . . . . . . . . . . )
    1:  4: . . . . . . . . . )
    1:  4: . . . . . . . . )
    1:  4: . . . . . . . )
    1:  4: . . . . . . )
    1:  4: . . . . . )
    1:  4: . . . . . ":="
    1:  7: . . . . . ExpressionList (
    1:  7: . . . . . . Expression (
    1:  7: . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . IDENT tpl
 /app/parser/parser.go:713: ast.Ident{Name: tpl}
 /app/parser/parser.go:1830: ast.DomainTextLit{Domain: tpl, Value: `
expr = termExpr % ("+" | "-")

termExpr = unaryExpr % ("*" | "/")

unaryExpr = operand | "-" unaryExpr

operand = INT | FLOAT | "(" expr ")"
`}
    1: 10: . . . . . . . . . . . STRING `
expr = termExpr % ("+" | "-")

termExpr = unaryExpr % ("*" | "/")

unaryExpr = operand | "-" unaryExpr

operand = INT | FLOAT | "(" expr ")"
`
    9:  2: . . . . . . . . . . )
    9:  2: . . . . . . . . . . "!"
    9:  3: . . . . . . . . . )
    9:  3: . . . . . . . . )
    9:  3: . . . . . . . )
    9:  3: . . . . . . )
    9:  3: . . . . . )
    9:  3: . . . . )
    9:  3: . . . . ";"
    9:  4: . . . )
    9:  4: . . )
    9:  4: . )
    9:  4: )
=== RUN   TestFromTestdata/domaintpl
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/domaintpl
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT cl
 /app/parser/parser.go:713: ast.Ident{Name: cl}
    1:  4: . . . . . . . . . . )
    1:  4: . . . . . . . . . )
    1:  4: . . . . . . . . )
    1:  4: . . . . . . . )
    1:  4: . . . . . . )
    1:  4: . . . . . )
    1:  4: . . . . . ":="
    1:  7: . . . . . ExpressionList (
    1:  7: . . . . . . Expression (
    1:  7: . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . IDENT tpl
 /app/parser/parser.go:713: ast.Ident{Name: tpl}
 /app/parser/parser.go:713: ast.Ident{Name: ast}
 /app/parser/parser.go:713: ast.Ident{Name: File}
 /app/parser/parser.go:713: ast.Ident{Name: Stmts}
 /app/parser/parser.go:713: ast.Ident{Name: this}
 /app/parser/parser.go:713: ast.Ident{Name: ast}
 /app/parser/parser.go:713: ast.Ident{Name: Stmt}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: &{ast Stmt}}
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
 /app/parser/parser.go:713: ast.Ident{Name: n}
 /app/parser/parser.go:713: ast.Ident{Name: any}
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: any}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:2064: ast.IndexExpr{X: &{n 119 0xc000454570 125}, Index: &{127 INT 0 <nil>}}
 /app/parser/parser.go:713: ast.Ident{Name: ast}
 /app/parser/parser.go:713: ast.Ident{Name: Stmt}
 /app/parser/parser.go:713: ast.Ident{Name: n}
 /app/parser/parser.go:713: ast.Ident{Name: this}
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{0xc000454660 130 0xc000438a80 139}, Fors: [0xc000408840]}
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
 /app/parser/parser.go:1830: ast.DomainTextLit{Domain: tpl, Value: `
file = stmts => {
	return &ast.File{
		Stmts: this.([]ast.Stmt),
	}
}

stmts = *(stmt ";") => {
	return [n.([]any)[0].(ast.Stmt) for n in this]
}
`}
    1: 10: . . . . . . . . . . . STRING `
file = stmts => {
	return &ast.File{
		Stmts: this.([]ast.Stmt),
	}
}

stmts = *(stmt ";") => {
	return [n.([]any)[0].(ast.Stmt) for n in this]
}
`
   11:  2: . . . . . . . . . . )
   11:  2: . . . . . . . . . . "!"
   11:  3: . . . . . . . . . )
   11:  3: . . . . . . . . )
   11:  3: . . . . . . . )
   11:  3: . . . . . . )
   11:  3: . . . . . )
   11:  3: . . . . )
   11:  3: . . . . ";"
   11:  4: . . . )
   11:  4: . . )
   11:  4: . )
   11:  4: )
=== RUN   TestFromTestdata/embedded1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/embedded1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . GenDecl(type) (
    1:  1: . . . "type"
    1:  6: . . . TypeSpec (
    1:  6: . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
    1:  8: . . . . Type (
    1:  8: . . . . . StructType (
    1:  8: . . . . . . "struct"
    1: 15: . . . . . . "{"
    2:  2: . . . . . . FieldDecl (
    2:  2: . . . . . . . IDENT abc
 /app/parser/parser.go:713: ast.Ident{Name: abc}
    2:  5: . . . . . . . QualifiedIdent (
    2:  5: . . . . . . . . TypeName (
    2:  5: . . . . . . . . . "."
    2:  6: . . . . . . . . . IDENT E
 /app/parser/parser.go:713: ast.Ident{Name: E}
    2:  7: . . . . . . . . )
    2:  7: . . . . . . . )
    2:  7: . . . . . . . ";"
    3:  1: . . . . . . )
    3:  1: . . . . . . "}"
    3:  2: . . . . . )
    3:  2: . . . . )
    3:  2: . . . . ";"
    3:  3: . . . )
    3:  3: . . )
    3:  3: . )
    3:  3: )
=== RUN   TestFromTestdata/envop1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/envop1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT echo
 /app/parser/parser.go:713: ast.Ident{Name: echo}
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . . CallOrConversion (
    1:  6: . . . . . . . . . . . Expression (
    1:  6: . . . . . . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . . . . . . EnvExpr (
    1:  6: . . . . . . . . . . . . . . . . . "$"
    1:  7: . . . . . . . . . . . . . . . . . "{"
    1:  8: . . . . . . . . . . . . . . . . . IDENT name
 /app/parser/parser.go:713: ast.Ident{Name: name}
    1: 12: . . . . . . . . . . . . . . . . . "}"
    1: 13: . . . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . ","
    1: 15: . . . . . . . . . . . Expression (
    1: 15: . . . . . . . . . . . . BinaryExpr (
    1: 15: . . . . . . . . . . . . . UnaryExpr (
    1: 15: . . . . . . . . . . . . . . PrimaryExpr (
    1: 15: . . . . . . . . . . . . . . . Operand (
    1: 15: . . . . . . . . . . . . . . . . EnvExpr (
    1: 15: . . . . . . . . . . . . . . . . . "$"
    1: 16: . . . . . . . . . . . . . . . . . IDENT id
 /app/parser/parser.go:713: ast.Ident{Name: id}
    1: 18: . . . . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: echo, Ellipsis: false, isCmd: true}
    1: 18: . . . . . . . . . . )
    1: 18: . . . . . . . . . )
    1: 18: . . . . . . . . )
    1: 18: . . . . . . . )
    1: 18: . . . . . . )
    1: 18: . . . . . )
    1: 18: . . . . )
    1: 18: . . . . ";"
    1: 19: . . . )
    1: 19: . . )
    1: 19: . )
    1: 19: )
=== RUN   TestFromTestdata/envop2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/envop2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . EnvExpr (
    1:  1: . . . . . . . . . . . . "$"
    1:  2: . . . . . . . . . . . . "{"
    1:  3: . . . . . . . . . . . . IDENT name
 /app/parser/parser.go:713: ast.Ident{Name: name}
    1:  7: . . . . . . . . . . . . "}"
    1:  8: . . . . . . . . . . . )
    1:  8: . . . . . . . . . . )
    1:  8: . . . . . . . . . )
    1:  8: . . . . . . . . )
    1:  8: . . . . . . . )
    1:  8: . . . . . . )
    1:  8: . . . . . )
    1:  8: . . . . )
    1:  8: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT echo
 /app/parser/parser.go:713: ast.Ident{Name: echo}
    2:  6: . . . . . . . . . . )
    2:  6: . . . . . . . . . . CallOrConversion (
    2:  6: . . . . . . . . . . . Expression (
    2:  6: . . . . . . . . . . . . BinaryExpr (
    2:  6: . . . . . . . . . . . . . UnaryExpr (
    2:  6: . . . . . . . . . . . . . . PrimaryExpr (
    2:  6: . . . . . . . . . . . . . . . Operand (
    2:  6: . . . . . . . . . . . . . . . . LiteralValue (
    2:  6: . . . . . . . . . . . . . . . . . "{"
    2:  7: . . . . . . . . . . . . . . . . . ElementList (
    2:  7: . . . . . . . . . . . . . . . . . . Element (
    2:  7: . . . . . . . . . . . . . . . . . . . Element (
    2:  7: . . . . . . . . . . . . . . . . . . . . Expression (
    2:  7: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  7: . . . . . . . . . . . . . . . . . . . . . . . . . STRING "id"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "id"}
    2: 11: . . . . . . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . . ":"
    2: 13: . . . . . . . . . . . . . . . . . . . Element (
    2: 13: . . . . . . . . . . . . . . . . . . . . Expression (
    2: 13: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 13: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 13: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 13: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 13: . . . . . . . . . . . . . . . . . . . . . . . . . EnvExpr (
    2: 13: . . . . . . . . . . . . . . . . . . . . . . . . . . "$"
    2: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT id
 /app/parser/parser.go:713: ast.Ident{Name: id}
    2: 16: . . . . . . . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . "}"
    2: 17: . . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: echo, Ellipsis: false, isCmd: true}
    2: 17: . . . . . . . . . . )
    2: 17: . . . . . . . . . )
    2: 17: . . . . . . . . )
    2: 17: . . . . . . . )
    2: 17: . . . . . . )
    2: 17: . . . . . )
    2: 17: . . . . )
    2: 17: . . . . ";"
    2: 18: . . . )
    2: 18: . . )
    2: 18: . )
    2: 18: )
=== RUN   TestFromTestdata/errwrap1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/errwrap1
    1:  1: File (
    1:  1: . GenDecl(import) (
    1:  1: . . "import"
    1:  8: . . "("
    2:  2: . . ImportSpec (
    2:  2: . . . STRING "strconv"
    2: 11: . . . ";"
    3:  1: . . )
    3:  1: . . ")"
    3:  2: . . ";"
    5:  1: . )
    5:  1: . Declaration (
    5:  1: . . FunctionDeclOrCall (
    5:  1: . . . "func"
    5:  6: . . . IDENT add
 /app/parser/parser.go:713: ast.Ident{Name: add}
    5:  9: . . . Signature (
    5:  9: . . . . Parameters (
    5:  9: . . . . . "("
    5: 10: . . . . . ParameterList (
    5: 10: . . . . . . ParamDeclOrNil (
    5: 10: . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    5: 11: . . . . . . )
    5: 11: . . . . . . ","
    5: 13: . . . . . . ParamDeclOrNil (
    5: 13: . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    5: 15: . . . . . . . Type (
    5: 15: . . . . . . . . TypeName (
    5: 15: . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    5: 21: . . . . . . . . )
    5: 21: . . . . . . . )
    5: 21: . . . . . . )
    5: 21: . . . . . )
    5: 21: . . . . . ")"
    5: 23: . . . . )
    5: 23: . . . . Result (
    5: 23: . . . . . Parameters (
    5: 23: . . . . . . "("
    5: 24: . . . . . . ParameterList (
    5: 24: . . . . . . . ParamDeclOrNil (
    5: 24: . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5: 27: . . . . . . . )
    5: 27: . . . . . . . ","
    5: 29: . . . . . . . ParamDeclOrNil (
    5: 29: . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
    5: 34: . . . . . . . )
    5: 34: . . . . . . )
    5: 34: . . . . . . ")"
    5: 36: . . . . . )
    5: 36: . . . . )
    5: 36: . . . )
    5: 36: . . . Body (
    5: 36: . . . . "{"
    6:  2: . . . . StatementList (
    6:  2: . . . . . Statement (
    6:  2: . . . . . . ReturnStmt (
    6:  2: . . . . . . . "return"
    6:  9: . . . . . . . ExpressionList (
    6:  9: . . . . . . . . Expression (
    6:  9: . . . . . . . . . BinaryExpr (
    6:  9: . . . . . . . . . . UnaryExpr (
    6:  9: . . . . . . . . . . . PrimaryExpr (
    6:  9: . . . . . . . . . . . . Operand (
    6:  9: . . . . . . . . . . . . . IDENT strconv
 /app/parser/parser.go:713: ast.Ident{Name: strconv}
    6: 16: . . . . . . . . . . . . )
    6: 16: . . . . . . . . . . . . "."
    6: 17: . . . . . . . . . . . . Selector (
    6: 17: . . . . . . . . . . . . . IDENT Atoi
 /app/parser/parser.go:713: ast.Ident{Name: Atoi}
    6: 21: . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . CallOrConversion (
    6: 21: . . . . . . . . . . . . . "("
    6: 22: . . . . . . . . . . . . . Expression (
    6: 22: . . . . . . . . . . . . . . BinaryExpr (
    6: 22: . . . . . . . . . . . . . . . UnaryExpr (
    6: 22: . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 22: . . . . . . . . . . . . . . . . . Operand (
    6: 22: . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    6: 23: . . . . . . . . . . . . . . . . . )
    6: 23: . . . . . . . . . . . . . . . . )
    6: 23: . . . . . . . . . . . . . . . )
    6: 23: . . . . . . . . . . . . . . )
    6: 23: . . . . . . . . . . . . . )
    6: 23: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{strconv Atoi}, Ellipsis: false, isCmd: false}
    6: 24: . . . . . . . . . . . . )
    6: 24: . . . . . . . . . . . . "?"
    6: 26: . . . . . . . . . . . )
    6: 26: . . . . . . . . . . )
    6: 26: . . . . . . . . . . "+"
    6: 28: . . . . . . . . . . BinaryExpr (
    6: 28: . . . . . . . . . . . UnaryExpr (
    6: 28: . . . . . . . . . . . . PrimaryExpr (
    6: 28: . . . . . . . . . . . . . Operand (
    6: 28: . . . . . . . . . . . . . . IDENT strconv
 /app/parser/parser.go:713: ast.Ident{Name: strconv}
    6: 35: . . . . . . . . . . . . . )
    6: 35: . . . . . . . . . . . . . "."
    6: 36: . . . . . . . . . . . . . Selector (
    6: 36: . . . . . . . . . . . . . . IDENT Atoi
 /app/parser/parser.go:713: ast.Ident{Name: Atoi}
    6: 40: . . . . . . . . . . . . . )
    6: 40: . . . . . . . . . . . . . CallOrConversion (
    6: 40: . . . . . . . . . . . . . . "("
    6: 41: . . . . . . . . . . . . . . Expression (
    6: 41: . . . . . . . . . . . . . . . BinaryExpr (
    6: 41: . . . . . . . . . . . . . . . . UnaryExpr (
    6: 41: . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 41: . . . . . . . . . . . . . . . . . . Operand (
    6: 41: . . . . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    6: 42: . . . . . . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{strconv Atoi}, Ellipsis: false, isCmd: false}
    6: 43: . . . . . . . . . . . . . )
    6: 43: . . . . . . . . . . . . . "?"
    6: 44: . . . . . . . . . . . . )
    6: 44: . . . . . . . . . . . )
    6: 44: . . . . . . . . . . )
    6: 44: . . . . . . . . . )
    6: 44: . . . . . . . . )
    6: 44: . . . . . . . . ","
    6: 46: . . . . . . . . Expression (
    6: 46: . . . . . . . . . BinaryExpr (
    6: 46: . . . . . . . . . . UnaryExpr (
    6: 46: . . . . . . . . . . . PrimaryExpr (
    6: 46: . . . . . . . . . . . . Operand (
    6: 46: . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
    6: 49: . . . . . . . . . . . . )
    6: 49: . . . . . . . . . . . )
    6: 49: . . . . . . . . . . )
    6: 49: . . . . . . . . . )
    6: 49: . . . . . . . . )
    6: 49: . . . . . . . )
    6: 49: . . . . . . . ";"
    7:  1: . . . . . . )
    7:  1: . . . . . )
    7:  1: . . . . )
    7:  1: . . . . "}"
    7:  2: . . . )
    7:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: add, ...}
    9:  1: . . )
    9:  1: . )
    9:  1: . Declaration (
    9:  1: . . FunctionDeclOrCall (
    9:  1: . . . "func"
    9:  6: . . . IDENT addSafe
 /app/parser/parser.go:713: ast.Ident{Name: addSafe}
    9: 13: . . . Signature (
    9: 13: . . . . Parameters (
    9: 13: . . . . . "("
    9: 14: . . . . . ParameterList (
    9: 14: . . . . . . ParamDeclOrNil (
    9: 14: . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    9: 15: . . . . . . )
    9: 15: . . . . . . ","
    9: 17: . . . . . . ParamDeclOrNil (
    9: 17: . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    9: 19: . . . . . . . Type (
    9: 19: . . . . . . . . TypeName (
    9: 19: . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    9: 25: . . . . . . . . )
    9: 25: . . . . . . . )
    9: 25: . . . . . . )
    9: 25: . . . . . )
    9: 25: . . . . . ")"
    9: 27: . . . . )
    9: 27: . . . . Result (
    9: 27: . . . . . TypeName (
    9: 27: . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    9: 31: . . . . . )
    9: 31: . . . . )
    9: 31: . . . )
    9: 31: . . . Body (
    9: 31: . . . . "{"
   10:  2: . . . . StatementList (
   10:  2: . . . . . Statement (
   10:  2: . . . . . . ReturnStmt (
   10:  2: . . . . . . . "return"
   10:  9: . . . . . . . ExpressionList (
   10:  9: . . . . . . . . Expression (
   10:  9: . . . . . . . . . BinaryExpr (
   10:  9: . . . . . . . . . . UnaryExpr (
   10:  9: . . . . . . . . . . . PrimaryExpr (
   10:  9: . . . . . . . . . . . . Operand (
   10:  9: . . . . . . . . . . . . . IDENT strconv
 /app/parser/parser.go:713: ast.Ident{Name: strconv}
   10: 16: . . . . . . . . . . . . )
   10: 16: . . . . . . . . . . . . "."
   10: 17: . . . . . . . . . . . . Selector (
   10: 17: . . . . . . . . . . . . . IDENT Atoi
 /app/parser/parser.go:713: ast.Ident{Name: Atoi}
   10: 21: . . . . . . . . . . . . )
   10: 21: . . . . . . . . . . . . CallOrConversion (
   10: 21: . . . . . . . . . . . . . "("
   10: 22: . . . . . . . . . . . . . Expression (
   10: 22: . . . . . . . . . . . . . . BinaryExpr (
   10: 22: . . . . . . . . . . . . . . . UnaryExpr (
   10: 22: . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 22: . . . . . . . . . . . . . . . . . Operand (
   10: 22: . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   10: 23: . . . . . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{strconv Atoi}, Ellipsis: false, isCmd: false}
   10: 24: . . . . . . . . . . . . )
   10: 24: . . . . . . . . . . . . "?"
   10: 25: . . . . . . . . . . . )
   10: 25: . . . . . . . . . . . ":"
   10: 26: . . . . . . . . . . . UnaryExpr (
   10: 26: . . . . . . . . . . . . PrimaryExpr (
   10: 26: . . . . . . . . . . . . . Operand (
   10: 26: . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   10: 28: . . . . . . . . . . . . . )
   10: 28: . . . . . . . . . . . . )
   10: 28: . . . . . . . . . . . )
   10: 28: . . . . . . . . . . )
   10: 28: . . . . . . . . . . "+"
   10: 30: . . . . . . . . . . BinaryExpr (
   10: 30: . . . . . . . . . . . UnaryExpr (
   10: 30: . . . . . . . . . . . . PrimaryExpr (
   10: 30: . . . . . . . . . . . . . Operand (
   10: 30: . . . . . . . . . . . . . . IDENT strconv
 /app/parser/parser.go:713: ast.Ident{Name: strconv}
   10: 37: . . . . . . . . . . . . . )
   10: 37: . . . . . . . . . . . . . "."
   10: 38: . . . . . . . . . . . . . Selector (
   10: 38: . . . . . . . . . . . . . . IDENT Atoi
 /app/parser/parser.go:713: ast.Ident{Name: Atoi}
   10: 42: . . . . . . . . . . . . . )
   10: 42: . . . . . . . . . . . . . CallOrConversion (
   10: 42: . . . . . . . . . . . . . . "("
   10: 43: . . . . . . . . . . . . . . Expression (
   10: 43: . . . . . . . . . . . . . . . BinaryExpr (
   10: 43: . . . . . . . . . . . . . . . . UnaryExpr (
   10: 43: . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 43: . . . . . . . . . . . . . . . . . . Operand (
   10: 43: . . . . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
   10: 44: . . . . . . . . . . . . . . . . . . )
   10: 44: . . . . . . . . . . . . . . . . . )
   10: 44: . . . . . . . . . . . . . . . . )
   10: 44: . . . . . . . . . . . . . . . )
   10: 44: . . . . . . . . . . . . . . )
   10: 44: . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{strconv Atoi}, Ellipsis: false, isCmd: false}
   10: 45: . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . "?"
   10: 46: . . . . . . . . . . . . )
   10: 46: . . . . . . . . . . . . ":"
   10: 47: . . . . . . . . . . . . UnaryExpr (
   10: 47: . . . . . . . . . . . . . PrimaryExpr (
   10: 47: . . . . . . . . . . . . . . Operand (
   10: 47: . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   10: 48: . . . . . . . . . . . . . . )
   10: 48: . . . . . . . . . . . . . )
   10: 48: . . . . . . . . . . . . )
   10: 48: . . . . . . . . . . . )
   10: 48: . . . . . . . . . . )
   10: 48: . . . . . . . . . )
   10: 48: . . . . . . . . )
   10: 48: . . . . . . . )
   10: 48: . . . . . . . ";"
   11:  1: . . . . . . )
   11:  1: . . . . . )
   11:  1: . . . . )
   11:  1: . . . . "}"
   11:  2: . . . )
   11:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: addSafe, ...}
   13:  1: . . )
   13:  1: . )
   13:  1: . Declaration (
   13:  1: . . StatementList (
   13:  1: . . . Statement (
   13:  1: . . . . SimpleStmt (
   13:  1: . . . . . ExpressionList (
   13:  1: . . . . . . Expression (
   13:  1: . . . . . . . BinaryExpr (
   13:  1: . . . . . . . . UnaryExpr (
   13:  1: . . . . . . . . . PrimaryExpr (
   13:  1: . . . . . . . . . . Operand (
   13:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   13:  8: . . . . . . . . . . )
   13:  8: . . . . . . . . . . CallOrConversion (
   13:  8: . . . . . . . . . . . "("
   13:  9: . . . . . . . . . . . Expression (
   13:  9: . . . . . . . . . . . . BinaryExpr (
   13:  9: . . . . . . . . . . . . . UnaryExpr (
   13:  9: . . . . . . . . . . . . . . PrimaryExpr (
   13:  9: . . . . . . . . . . . . . . . Operand (
   13:  9: . . . . . . . . . . . . . . . . STRING `add("100", "23"):`
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: `add("100", "23"):`}
   13: 28: . . . . . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . )
   13: 28: . . . . . . . . . . . ","
   13: 30: . . . . . . . . . . . Expression (
   13: 30: . . . . . . . . . . . . BinaryExpr (
   13: 30: . . . . . . . . . . . . . UnaryExpr (
   13: 30: . . . . . . . . . . . . . . PrimaryExpr (
   13: 30: . . . . . . . . . . . . . . . Operand (
   13: 30: . . . . . . . . . . . . . . . . IDENT add
 /app/parser/parser.go:713: ast.Ident{Name: add}
   13: 33: . . . . . . . . . . . . . . . )
   13: 33: . . . . . . . . . . . . . . . CallOrConversion (
   13: 33: . . . . . . . . . . . . . . . . "("
   13: 34: . . . . . . . . . . . . . . . . Expression (
   13: 34: . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 34: . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 34: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 34: . . . . . . . . . . . . . . . . . . . . Operand (
   13: 34: . . . . . . . . . . . . . . . . . . . . . STRING "100"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "100"}
   13: 39: . . . . . . . . . . . . . . . . . . . . )
   13: 39: . . . . . . . . . . . . . . . . . . . )
   13: 39: . . . . . . . . . . . . . . . . . . )
   13: 39: . . . . . . . . . . . . . . . . . )
   13: 39: . . . . . . . . . . . . . . . . )
   13: 39: . . . . . . . . . . . . . . . . ","
   13: 41: . . . . . . . . . . . . . . . . Expression (
   13: 41: . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 41: . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 41: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 41: . . . . . . . . . . . . . . . . . . . . Operand (
   13: 41: . . . . . . . . . . . . . . . . . . . . . STRING "23"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "23"}
   13: 45: . . . . . . . . . . . . . . . . . . . . )
   13: 45: . . . . . . . . . . . . . . . . . . . )
   13: 45: . . . . . . . . . . . . . . . . . . )
   13: 45: . . . . . . . . . . . . . . . . . )
   13: 45: . . . . . . . . . . . . . . . . )
   13: 45: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: add, Ellipsis: false, isCmd: false}
   13: 46: . . . . . . . . . . . . . . . )
   13: 46: . . . . . . . . . . . . . . . "!"
   13: 47: . . . . . . . . . . . . . . )
   13: 47: . . . . . . . . . . . . . )
   13: 47: . . . . . . . . . . . . )
   13: 47: . . . . . . . . . . . )
   13: 47: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   13: 48: . . . . . . . . . . )
   13: 48: . . . . . . . . . )
   13: 48: . . . . . . . . )
   13: 48: . . . . . . . )
   13: 48: . . . . . . )
   13: 48: . . . . . )
   13: 48: . . . . )
   13: 48: . . . . ";"
   15:  1: . . . )
   15:  1: . . . Statement (
   15:  1: . . . . SimpleStmt (
   15:  1: . . . . . ExpressionList (
   15:  1: . . . . . . Expression (
   15:  1: . . . . . . . BinaryExpr (
   15:  1: . . . . . . . . UnaryExpr (
   15:  1: . . . . . . . . . PrimaryExpr (
   15:  1: . . . . . . . . . . Operand (
   15:  1: . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   15:  4: . . . . . . . . . . )
   15:  4: . . . . . . . . . )
   15:  4: . . . . . . . . )
   15:  4: . . . . . . . )
   15:  4: . . . . . . )
   15:  4: . . . . . . ","
   15:  6: . . . . . . Expression (
   15:  6: . . . . . . . BinaryExpr (
   15:  6: . . . . . . . . UnaryExpr (
   15:  6: . . . . . . . . . PrimaryExpr (
   15:  6: . . . . . . . . . . Operand (
   15:  6: . . . . . . . . . . . IDENT err
 /app/parser/parser.go:713: ast.Ident{Name: err}
   15: 10: . . . . . . . . . . )
   15: 10: . . . . . . . . . )
   15: 10: . . . . . . . . )
   15: 10: . . . . . . . )
   15: 10: . . . . . . )
   15: 10: . . . . . )
   15: 10: . . . . . ":="
   15: 13: . . . . . ExpressionList (
   15: 13: . . . . . . Expression (
   15: 13: . . . . . . . BinaryExpr (
   15: 13: . . . . . . . . UnaryExpr (
   15: 13: . . . . . . . . . PrimaryExpr (
   15: 13: . . . . . . . . . . Operand (
   15: 13: . . . . . . . . . . . IDENT add
 /app/parser/parser.go:713: ast.Ident{Name: add}
   15: 16: . . . . . . . . . . )
   15: 16: . . . . . . . . . . CallOrConversion (
   15: 16: . . . . . . . . . . . "("
   15: 17: . . . . . . . . . . . Expression (
   15: 17: . . . . . . . . . . . . BinaryExpr (
   15: 17: . . . . . . . . . . . . . UnaryExpr (
   15: 17: . . . . . . . . . . . . . . PrimaryExpr (
   15: 17: . . . . . . . . . . . . . . . Operand (
   15: 17: . . . . . . . . . . . . . . . . STRING "10"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "10"}
   15: 21: . . . . . . . . . . . . . . . )
   15: 21: . . . . . . . . . . . . . . )
   15: 21: . . . . . . . . . . . . . )
   15: 21: . . . . . . . . . . . . )
   15: 21: . . . . . . . . . . . )
   15: 21: . . . . . . . . . . . ","
   15: 23: . . . . . . . . . . . Expression (
   15: 23: . . . . . . . . . . . . BinaryExpr (
   15: 23: . . . . . . . . . . . . . UnaryExpr (
   15: 23: . . . . . . . . . . . . . . PrimaryExpr (
   15: 23: . . . . . . . . . . . . . . . Operand (
   15: 23: . . . . . . . . . . . . . . . . STRING "abc"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "abc"}
   15: 28: . . . . . . . . . . . . . . . )
   15: 28: . . . . . . . . . . . . . . )
   15: 28: . . . . . . . . . . . . . )
   15: 28: . . . . . . . . . . . . )
   15: 28: . . . . . . . . . . . )
   15: 28: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: add, Ellipsis: false, isCmd: false}
   15: 29: . . . . . . . . . . )
   15: 29: . . . . . . . . . )
   15: 29: . . . . . . . . )
   15: 29: . . . . . . . )
   15: 29: . . . . . . )
   15: 29: . . . . . )
   15: 29: . . . . )
   15: 29: . . . . ";"
   16:  1: . . . )
   16:  1: . . . Statement (
   16:  1: . . . . SimpleStmt (
   16:  1: . . . . . ExpressionList (
   16:  1: . . . . . . Expression (
   16:  1: . . . . . . . BinaryExpr (
   16:  1: . . . . . . . . UnaryExpr (
   16:  1: . . . . . . . . . PrimaryExpr (
   16:  1: . . . . . . . . . . Operand (
   16:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   16:  8: . . . . . . . . . . )
   16:  8: . . . . . . . . . . CallOrConversion (
   16:  8: . . . . . . . . . . . "("
   16:  9: . . . . . . . . . . . Expression (
   16:  9: . . . . . . . . . . . . BinaryExpr (
   16:  9: . . . . . . . . . . . . . UnaryExpr (
   16:  9: . . . . . . . . . . . . . . PrimaryExpr (
   16:  9: . . . . . . . . . . . . . . . Operand (
   16:  9: . . . . . . . . . . . . . . . . STRING `add("10", "abc"):`
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: `add("10", "abc"):`}
   16: 28: . . . . . . . . . . . . . . . )
   16: 28: . . . . . . . . . . . . . . )
   16: 28: . . . . . . . . . . . . . )
   16: 28: . . . . . . . . . . . . )
   16: 28: . . . . . . . . . . . )
   16: 28: . . . . . . . . . . . ","
   16: 30: . . . . . . . . . . . Expression (
   16: 30: . . . . . . . . . . . . BinaryExpr (
   16: 30: . . . . . . . . . . . . . UnaryExpr (
   16: 30: . . . . . . . . . . . . . . PrimaryExpr (
   16: 30: . . . . . . . . . . . . . . . Operand (
   16: 30: . . . . . . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   16: 33: . . . . . . . . . . . . . . . )
   16: 33: . . . . . . . . . . . . . . )
   16: 33: . . . . . . . . . . . . . )
   16: 33: . . . . . . . . . . . . )
   16: 33: . . . . . . . . . . . )
   16: 33: . . . . . . . . . . . ","
   16: 35: . . . . . . . . . . . Expression (
   16: 35: . . . . . . . . . . . . BinaryExpr (
   16: 35: . . . . . . . . . . . . . UnaryExpr (
   16: 35: . . . . . . . . . . . . . . PrimaryExpr (
   16: 35: . . . . . . . . . . . . . . . Operand (
   16: 35: . . . . . . . . . . . . . . . . IDENT err
 /app/parser/parser.go:713: ast.Ident{Name: err}
   16: 38: . . . . . . . . . . . . . . . )
   16: 38: . . . . . . . . . . . . . . )
   16: 38: . . . . . . . . . . . . . )
   16: 38: . . . . . . . . . . . . )
   16: 38: . . . . . . . . . . . )
   16: 38: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   16: 39: . . . . . . . . . . )
   16: 39: . . . . . . . . . )
   16: 39: . . . . . . . . )
   16: 39: . . . . . . . )
   16: 39: . . . . . . )
   16: 39: . . . . . )
   16: 39: . . . . )
   16: 39: . . . . ";"
   18:  1: . . . )
   18:  1: . . . Statement (
   18:  1: . . . . SimpleStmt (
   18:  1: . . . . . ExpressionList (
   18:  1: . . . . . . Expression (
   18:  1: . . . . . . . BinaryExpr (
   18:  1: . . . . . . . . UnaryExpr (
   18:  1: . . . . . . . . . PrimaryExpr (
   18:  1: . . . . . . . . . . Operand (
   18:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   18:  8: . . . . . . . . . . )
   18:  8: . . . . . . . . . . CallOrConversion (
   18:  8: . . . . . . . . . . . "("
   18:  9: . . . . . . . . . . . Expression (
   18:  9: . . . . . . . . . . . . BinaryExpr (
   18:  9: . . . . . . . . . . . . . UnaryExpr (
   18:  9: . . . . . . . . . . . . . . PrimaryExpr (
   18:  9: . . . . . . . . . . . . . . . Operand (
   18:  9: . . . . . . . . . . . . . . . . STRING `addSafe("10", "abc"):`
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: `addSafe("10", "abc"):`}
   18: 32: . . . . . . . . . . . . . . . )
   18: 32: . . . . . . . . . . . . . . )
   18: 32: . . . . . . . . . . . . . )
   18: 32: . . . . . . . . . . . . )
   18: 32: . . . . . . . . . . . )
   18: 32: . . . . . . . . . . . ","
   18: 34: . . . . . . . . . . . Expression (
   18: 34: . . . . . . . . . . . . BinaryExpr (
   18: 34: . . . . . . . . . . . . . UnaryExpr (
   18: 34: . . . . . . . . . . . . . . PrimaryExpr (
   18: 34: . . . . . . . . . . . . . . . Operand (
   18: 34: . . . . . . . . . . . . . . . . IDENT addSafe
 /app/parser/parser.go:713: ast.Ident{Name: addSafe}
   18: 41: . . . . . . . . . . . . . . . )
   18: 41: . . . . . . . . . . . . . . . CallOrConversion (
   18: 41: . . . . . . . . . . . . . . . . "("
   18: 42: . . . . . . . . . . . . . . . . Expression (
   18: 42: . . . . . . . . . . . . . . . . . BinaryExpr (
   18: 42: . . . . . . . . . . . . . . . . . . UnaryExpr (
   18: 42: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   18: 42: . . . . . . . . . . . . . . . . . . . . Operand (
   18: 42: . . . . . . . . . . . . . . . . . . . . . STRING "10"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "10"}
   18: 46: . . . . . . . . . . . . . . . . . . . . )
   18: 46: . . . . . . . . . . . . . . . . . . . )
   18: 46: . . . . . . . . . . . . . . . . . . )
   18: 46: . . . . . . . . . . . . . . . . . )
   18: 46: . . . . . . . . . . . . . . . . )
   18: 46: . . . . . . . . . . . . . . . . ","
   18: 48: . . . . . . . . . . . . . . . . Expression (
   18: 48: . . . . . . . . . . . . . . . . . BinaryExpr (
   18: 48: . . . . . . . . . . . . . . . . . . UnaryExpr (
   18: 48: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   18: 48: . . . . . . . . . . . . . . . . . . . . Operand (
   18: 48: . . . . . . . . . . . . . . . . . . . . . STRING "abc"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "abc"}
   18: 53: . . . . . . . . . . . . . . . . . . . . )
   18: 53: . . . . . . . . . . . . . . . . . . . )
   18: 53: . . . . . . . . . . . . . . . . . . )
   18: 53: . . . . . . . . . . . . . . . . . )
   18: 53: . . . . . . . . . . . . . . . . )
   18: 53: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: addSafe, Ellipsis: false, isCmd: false}
   18: 54: . . . . . . . . . . . . . . . )
   18: 54: . . . . . . . . . . . . . . )
   18: 54: . . . . . . . . . . . . . )
   18: 54: . . . . . . . . . . . . )
   18: 54: . . . . . . . . . . . )
   18: 54: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   18: 55: . . . . . . . . . . )
   18: 55: . . . . . . . . . )
   18: 55: . . . . . . . . )
   18: 55: . . . . . . . )
   18: 55: . . . . . . )
   18: 55: . . . . . )
   18: 55: . . . . )
   18: 55: . . . . ";"
   18: 56: . . . )
   18: 56: . . )
   18: 56: . )
   18: 56: )
=== RUN   TestFromTestdata/errwrap2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/errwrap2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  6: . . . IDENT neg
 /app/parser/parser.go:713: ast.Ident{Name: neg}
    1:  9: . . . Signature (
    1:  9: . . . . Parameters (
    1:  9: . . . . . "("
    1: 10: . . . . . ParameterList (
    1: 10: . . . . . . ParamDeclOrNil (
    1: 10: . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1: 12: . . . . . . . Type (
    1: 12: . . . . . . . . TypeName (
    1: 12: . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    1: 18: . . . . . . . . )
    1: 18: . . . . . . . )
    1: 18: . . . . . . )
    1: 18: . . . . . )
    1: 18: . . . . . ")"
    1: 20: . . . . )
    1: 20: . . . . Result (
    1: 20: . . . . . Parameters (
    1: 20: . . . . . . "("
    1: 21: . . . . . . ParameterList (
    1: 21: . . . . . . . ParamDeclOrNil (
    1: 21: . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 24: . . . . . . . )
    1: 24: . . . . . . . ","
    1: 26: . . . . . . . ParamDeclOrNil (
    1: 26: . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
    1: 31: . . . . . . . )
    1: 31: . . . . . . )
    1: 31: . . . . . . ")"
    1: 33: . . . . . )
    1: 33: . . . . )
    1: 33: . . . )
    1: 33: . . . Body (
    1: 33: . . . . "{"
    2:  2: . . . . StatementList (
    2:  2: . . . . . Statement (
    2:  2: . . . . . . ReturnStmt (
    2:  2: . . . . . . . "return"
    2:  9: . . . . . . . ExpressionList (
    2:  9: . . . . . . . . Expression (
    2:  9: . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . "-"
    2: 10: . . . . . . . . . . . UnaryExpr (
    2: 10: . . . . . . . . . . . . PrimaryExpr (
    2: 10: . . . . . . . . . . . . . Operand (
    2: 10: . . . . . . . . . . . . . . IDENT atoi
 /app/parser/parser.go:713: ast.Ident{Name: atoi}
    2: 14: . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . CallOrConversion (
    2: 14: . . . . . . . . . . . . . . "("
    2: 15: . . . . . . . . . . . . . . Expression (
    2: 15: . . . . . . . . . . . . . . . BinaryExpr (
    2: 15: . . . . . . . . . . . . . . . . UnaryExpr (
    2: 15: . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 15: . . . . . . . . . . . . . . . . . . Operand (
    2: 15: . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 16: . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: atoi, Ellipsis: false, isCmd: false}
    2: 17: . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . "?"
    2: 18: . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . )
    2: 18: . . . . . . . . . . )
    2: 18: . . . . . . . . . )
    2: 18: . . . . . . . . )
    2: 18: . . . . . . . . ","
    2: 20: . . . . . . . . Expression (
    2: 20: . . . . . . . . . BinaryExpr (
    2: 20: . . . . . . . . . . UnaryExpr (
    2: 20: . . . . . . . . . . . PrimaryExpr (
    2: 20: . . . . . . . . . . . . Operand (
    2: 20: . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
    2: 23: . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . )
    2: 23: . . . . . . . . . . )
    2: 23: . . . . . . . . . )
    2: 23: . . . . . . . . )
    2: 23: . . . . . . . )
    2: 23: . . . . . . . ";"
    3:  1: . . . . . . )
    3:  1: . . . . . )
    3:  1: . . . . )
    3:  1: . . . . "}"
    3:  2: . . . )
    3:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: neg, ...}
    3:  3: . . )
    3:  3: . )
    3:  3: )
=== RUN   TestFromTestdata/errwrap3
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/errwrap3
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT mkdir
 /app/parser/parser.go:713: ast.Ident{Name: mkdir}
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . . "!"
    1:  8: . . . . . . . . . . CallOrConversion (
    1:  8: . . . . . . . . . . . Expression (
    1:  8: . . . . . . . . . . . . BinaryExpr (
    1:  8: . . . . . . . . . . . . . UnaryExpr (
    1:  8: . . . . . . . . . . . . . . PrimaryExpr (
    1:  8: . . . . . . . . . . . . . . . Operand (
    1:  8: . . . . . . . . . . . . . . . . STRING "foo"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "foo"}
    1: 13: . . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{mkdir ! 6 <nil>}, Ellipsis: false, isCmd: true}
    1: 13: . . . . . . . . . . )
    1: 13: . . . . . . . . . )
    1: 13: . . . . . . . . )
    1: 13: . . . . . . . )
    1: 13: . . . . . . )
    1: 13: . . . . . )
    1: 13: . . . . )
    1: 13: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  9: . . . . . . . . . . )
    2:  9: . . . . . . . . . . CallOrConversion (
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    2: 12: . . . . . . . . . . . . . . . )
    2: 12: . . . . . . . . . . . . . . . CallOrConversion (
    2: 12: . . . . . . . . . . . . . . . . "("
    2: 13: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
    2: 14: . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . "!"
    2: 15: . . . . . . . . . . . . . . . "."
    2: 16: . . . . . . . . . . . . . . . Selector (
    2: 16: . . . . . . . . . . . . . . . . IDENT fields
 /app/parser/parser.go:713: ast.Ident{Name: fields}
    2: 22: . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    2: 22: . . . . . . . . . . )
    2: 22: . . . . . . . . . )
    2: 22: . . . . . . . . )
    2: 22: . . . . . . . )
    2: 22: . . . . . . )
    2: 22: . . . . . )
    2: 22: . . . . )
    2: 22: . . . . ";"
    2: 23: . . . )
    2: 23: . . )
    2: 23: . )
    2: 23: )
=== RUN   TestFromTestdata/exists
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/exists
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . ArrayType (
    1:  6: . . . . . . . . . . . . "["
    1:  7: . . . . . . . . . . . . Expression (
    1:  7: . . . . . . . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  8: . . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . ","
    1: 10: . . . . . . . . . . . . Expression (
    1: 10: . . . . . . . . . . . . . BinaryExpr (
    1: 10: . . . . . . . . . . . . . . UnaryExpr (
    1: 10: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 10: . . . . . . . . . . . . . . . . Operand (
    1: 10: . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    1: 11: . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . ","
    1: 13: . . . . . . . . . . . . Expression (
    1: 13: . . . . . . . . . . . . . BinaryExpr (
    1: 13: . . . . . . . . . . . . . . UnaryExpr (
    1: 13: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 13: . . . . . . . . . . . . . . . . Operand (
    1: 13: . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    1: 14: . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . ","
    1: 16: . . . . . . . . . . . . Expression (
    1: 16: . . . . . . . . . . . . . BinaryExpr (
    1: 16: . . . . . . . . . . . . . . UnaryExpr (
    1: 16: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 16: . . . . . . . . . . . . . . . . Operand (
    1: 16: . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    1: 17: . . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . ","
    1: 19: . . . . . . . . . . . . Expression (
    1: 19: . . . . . . . . . . . . . BinaryExpr (
    1: 19: . . . . . . . . . . . . . . UnaryExpr (
    1: 19: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 19: . . . . . . . . . . . . . . . . Operand (
    1: 19: . . . . . . . . . . . . . . . . . INT 8
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 8}
    1: 20: . . . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . ","
    1: 22: . . . . . . . . . . . . Expression (
    1: 22: . . . . . . . . . . . . . BinaryExpr (
    1: 22: . . . . . . . . . . . . . . UnaryExpr (
    1: 22: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 22: . . . . . . . . . . . . . . . . Operand (
    1: 22: . . . . . . . . . . . . . . . . . INT 19
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 19}
    1: 24: . . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . "]"
    1: 25: . . . . . . . . . . . )
    1: 25: . . . . . . . . . . )
    1: 25: . . . . . . . . . )
    1: 25: . . . . . . . . )
    1: 25: . . . . . . . )
    1: 25: . . . . . . )
    1: 25: . . . . . )
    1: 25: . . . . )
    1: 25: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT hasEven
 /app/parser/parser.go:713: ast.Ident{Name: hasEven}
    2:  9: . . . . . . . . . . )
    2:  9: . . . . . . . . . )
    2:  9: . . . . . . . . )
    2:  9: . . . . . . . )
    2:  9: . . . . . . )
    2:  9: . . . . . )
    2:  9: . . . . . ":="
    2: 12: . . . . . ExpressionList (
    2: 12: . . . . . . Expression (
    2: 12: . . . . . . . BinaryExpr (
    2: 12: . . . . . . . . UnaryExpr (
    2: 12: . . . . . . . . . PrimaryExpr (
    2: 12: . . . . . . . . . . Operand (
    2: 12: . . . . . . . . . . . LiteralValue (
    2: 12: . . . . . . . . . . . . "{"
    2: 13: . . . . . . . . . . . . ElementList (
    2: 13: . . . . . . . . . . . . . ForPhrase (
    2: 13: . . . . . . . . . . . . . . "for"
    2: 17: . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 19: . . . . . . . . . . . . . . IDENT in
    2: 22: . . . . . . . . . . . . . . Expression (
    2: 22: . . . . . . . . . . . . . . . RangeExpr (
    2: 22: . . . . . . . . . . . . . . . . BinaryExpr (
    2: 22: . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 22: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 22: . . . . . . . . . . . . . . . . . . . Operand (
    2: 22: . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2: 24: . . . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . "if"
    2: 27: . . . . . . . . . . . . . . SimpleStmt (
    2: 27: . . . . . . . . . . . . . . . ExpressionList (
    2: 27: . . . . . . . . . . . . . . . . Expression (
    2: 27: . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 27: . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 27: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 27: . . . . . . . . . . . . . . . . . . . . Operand (
    2: 27: . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 28: . . . . . . . . . . . . . . . . . . . . )
    2: 28: . . . . . . . . . . . . . . . . . . . )
    2: 28: . . . . . . . . . . . . . . . . . . )
    2: 28: . . . . . . . . . . . . . . . . . . "%"
    2: 29: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 29: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 29: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 29: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 29: . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    2: 31: . . . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . "=="
    2: 34: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 34: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 34: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 34: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 34: . . . . . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    2: 35: . . . . . . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . "}"
    2: 36: . . . . . . . . . . . )
    2: 36: . . . . . . . . . . )
    2: 36: . . . . . . . . . )
    2: 36: . . . . . . . . )
    2: 36: . . . . . . . )
    2: 36: . . . . . . )
    2: 36: . . . . . )
    2: 36: . . . . )
    2: 36: . . . . ";"
    2: 37: . . . )
    2: 37: . . )
    2: 37: . )
    2: 37: )
=== RUN   TestFromTestdata/fnbody
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/fnbody
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  7: . . . . . . . . . . )
    1:  7: . . . . . . . . . )
    1:  7: . . . . . . . . )
    1:  7: . . . . . . . )
    1:  7: . . . . . . )
    1:  7: . . . . . )
    1:  7: . . . . )
    1:  7: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . BlockStmt (
    2:  1: . . . . . "{"
    3:  2: . . . . . StatementList (
    3:  2: . . . . . . Statement (
    3:  2: . . . . . . . GenDecl(type) (
    3:  2: . . . . . . . . "type"
    3:  7: . . . . . . . . TypeSpec (
    3:  7: . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
    3:  9: . . . . . . . . . "="
    3: 11: . . . . . . . . . Type (
    3: 11: . . . . . . . . . . TypeName (
    3: 11: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    3: 14: . . . . . . . . . . )
    3: 14: . . . . . . . . . )
    3: 14: . . . . . . . . . ";"
    4:  2: . . . . . . . . )
    4:  2: . . . . . . . )
    4:  2: . . . . . . )
    4:  2: . . . . . . Statement (
    4:  2: . . . . . . . GenDecl(var) (
    4:  2: . . . . . . . . "var"
    4:  6: . . . . . . . . varSpec (
    4:  6: . . . . . . . . . IdentList (
    4:  6: . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    4:  8: . . . . . . . . . )
    4:  8: . . . . . . . . . "="
    4: 10: . . . . . . . . . ExpressionList (
    4: 10: . . . . . . . . . . Expression (
    4: 10: . . . . . . . . . . . BinaryExpr (
    4: 10: . . . . . . . . . . . . UnaryExpr (
    4: 10: . . . . . . . . . . . . . PrimaryExpr (
    4: 10: . . . . . . . . . . . . . . Operand (
    4: 10: . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    4: 11: . . . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . . )
    4: 11: . . . . . . . . . . . )
    4: 11: . . . . . . . . . . )
    4: 11: . . . . . . . . . )
    4: 11: . . . . . . . . . ";"
    5:  2: . . . . . . . . )
    5:  2: . . . . . . . )
    5:  2: . . . . . . )
    5:  2: . . . . . . Statement (
    5:  2: . . . . . . . GenDecl(var) (
    5:  2: . . . . . . . . "var"
    5:  6: . . . . . . . . varSpec (
    5:  6: . . . . . . . . . IdentList (
    5:  6: . . . . . . . . . . IDENT c
 /app/parser/parser.go:713: ast.Ident{Name: c}
    5:  8: . . . . . . . . . )
    5:  8: . . . . . . . . . TypeName (
    5:  8: . . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
    5: 10: . . . . . . . . . )
    5: 10: . . . . . . . . . "="
    5: 12: . . . . . . . . . ExpressionList (
    5: 12: . . . . . . . . . . Expression (
    5: 12: . . . . . . . . . . . BinaryExpr (
    5: 12: . . . . . . . . . . . . UnaryExpr (
    5: 12: . . . . . . . . . . . . . PrimaryExpr (
    5: 12: . . . . . . . . . . . . . . Operand (
    5: 12: . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    5: 13: . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . )
    5: 13: . . . . . . . . . . )
    5: 13: . . . . . . . . . )
    5: 13: . . . . . . . . . ";"
    6:  1: . . . . . . . . )
    6:  1: . . . . . . . )
    6:  1: . . . . . . )
    6:  1: . . . . . )
    6:  1: . . . . . "}"
    6:  2: . . . . )
    6:  2: . . . . ";"
    6:  3: . . . )
    6:  3: . . )
    6:  3: . )
    6:  3: )
=== RUN   TestFromTestdata/fncall
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/fncall
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT fn
 /app/parser/parser.go:713: ast.Ident{Name: fn}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . . CallOrConversion (
    1:  3: . . . . . . . . . . . "("
    1:  4: . . . . . . . . . . . Expression (
    1:  4: . . . . . . . . . . . . BinaryExpr (
    1:  4: . . . . . . . . . . . . . UnaryExpr (
    1:  4: . . . . . . . . . . . . . . PrimaryExpr (
    1:  4: . . . . . . . . . . . . . . . Operand (
    1:  4: . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  5: . . . . . . . . . . . . . . . )
    1:  5: . . . . . . . . . . . . . . )
    1:  5: . . . . . . . . . . . . . )
    1:  5: . . . . . . . . . . . . )
    1:  5: . . . . . . . . . . . )
    1:  5: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: fn, Ellipsis: false, isCmd: false}
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . . CallOrConversion (
    1:  6: . . . . . . . . . . . "("
    1:  7: . . . . . . . . . . . Expression (
    1:  7: . . . . . . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1:  8: . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{fn 3 [0xc00012ced0] 0 [] 5 0}, Ellipsis: false, isCmd: false}
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . )
    1:  9: . . . . . . . . )
    1:  9: . . . . . . . )
    1:  9: . . . . . . )
    1:  9: . . . . . )
    1:  9: . . . . )
    1:  9: . . . . ";"
    1: 10: . . . )
    1: 10: . . )
    1: 10: . )
    1: 10: )
=== RUN   TestFromTestdata/forloop
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/forloop
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT n
 /app/parser/parser.go:713: ast.Ident{Name: n}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    1:  7: . . . . . . . . . . )
    1:  7: . . . . . . . . . )
    1:  7: . . . . . . . . )
    1:  7: . . . . . . . )
    1:  7: . . . . . . )
    1:  7: . . . . . )
    1:  7: . . . . )
    1:  7: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . ForStmt (
    2:  1: . . . . . "for"
    2:  5: . . . . . "range"
    2: 11: . . . . . Expression (
    2: 11: . . . . . . RangeExpr (
    2: 11: . . . . . . . BinaryExpr (
    2: 11: . . . . . . . . UnaryExpr (
    2: 11: . . . . . . . . . PrimaryExpr (
    2: 11: . . . . . . . . . . Operand (
    2: 11: . . . . . . . . . . . ArrayType (
    2: 11: . . . . . . . . . . . . "["
    2: 12: . . . . . . . . . . . . Expression (
    2: 12: . . . . . . . . . . . . . BinaryExpr (
    2: 12: . . . . . . . . . . . . . . UnaryExpr (
    2: 12: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 12: . . . . . . . . . . . . . . . . Operand (
    2: 12: . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2: 13: . . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . ","
    2: 15: . . . . . . . . . . . . Expression (
    2: 15: . . . . . . . . . . . . . BinaryExpr (
    2: 15: . . . . . . . . . . . . . . UnaryExpr (
    2: 15: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 15: . . . . . . . . . . . . . . . . Operand (
    2: 15: . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    2: 16: . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . ","
    2: 18: . . . . . . . . . . . . Expression (
    2: 18: . . . . . . . . . . . . . BinaryExpr (
    2: 18: . . . . . . . . . . . . . . UnaryExpr (
    2: 18: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 18: . . . . . . . . . . . . . . . . Operand (
    2: 18: . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    2: 19: . . . . . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . ","
    2: 21: . . . . . . . . . . . . Expression (
    2: 21: . . . . . . . . . . . . . BinaryExpr (
    2: 21: . . . . . . . . . . . . . . UnaryExpr (
    2: 21: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 21: . . . . . . . . . . . . . . . . Operand (
    2: 21: . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    2: 22: . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . ","
    2: 24: . . . . . . . . . . . . Expression (
    2: 24: . . . . . . . . . . . . . BinaryExpr (
    2: 24: . . . . . . . . . . . . . . UnaryExpr (
    2: 24: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 24: . . . . . . . . . . . . . . . . Operand (
    2: 24: . . . . . . . . . . . . . . . . . INT 11
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 11}
    2: 26: . . . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . "]"
    2: 28: . . . . . . . . . . . )
    2: 28: . . . . . . . . . . )
    2: 28: . . . . . . . . . )
    2: 28: . . . . . . . . )
    2: 28: . . . . . . . )
    2: 28: . . . . . . )
    2: 28: . . . . . )
    2: 28: . . . . . BlockStmt (
    2: 28: . . . . . . "{"
    3:  2: . . . . . . StatementList (
    3:  2: . . . . . . . Statement (
    3:  2: . . . . . . . . SimpleStmt (
    3:  2: . . . . . . . . . ExpressionList (
    3:  2: . . . . . . . . . . Expression (
    3:  2: . . . . . . . . . . . BinaryExpr (
    3:  2: . . . . . . . . . . . . UnaryExpr (
    3:  2: . . . . . . . . . . . . . PrimaryExpr (
    3:  2: . . . . . . . . . . . . . . Operand (
    3:  2: . . . . . . . . . . . . . . . IDENT n
 /app/parser/parser.go:713: ast.Ident{Name: n}
    3:  3: . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . )
    3:  3: . . . . . . . . . . )
    3:  3: . . . . . . . . . )
    3:  3: . . . . . . . . . "++"
    3:  5: . . . . . . . . )
    3:  5: . . . . . . . . ";"
    4:  1: . . . . . . . )
    4:  1: . . . . . . )
    4:  1: . . . . . . "}"
    4:  2: . . . . . )
    4:  2: . . . . . ";"
    5:  1: . . . . )
    5:  1: . . . )
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5:  8: . . . . . . . . . . )
    5:  8: . . . . . . . . . . CallOrConversion (
    5:  8: . . . . . . . . . . . "("
    5:  9: . . . . . . . . . . . Expression (
    5:  9: . . . . . . . . . . . . BinaryExpr (
    5:  9: . . . . . . . . . . . . . UnaryExpr (
    5:  9: . . . . . . . . . . . . . . PrimaryExpr (
    5:  9: . . . . . . . . . . . . . . . Operand (
    5:  9: . . . . . . . . . . . . . . . . STRING "n:"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "n:"}
    5: 13: . . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . ","
    5: 15: . . . . . . . . . . . Expression (
    5: 15: . . . . . . . . . . . . BinaryExpr (
    5: 15: . . . . . . . . . . . . . UnaryExpr (
    5: 15: . . . . . . . . . . . . . . PrimaryExpr (
    5: 15: . . . . . . . . . . . . . . . Operand (
    5: 15: . . . . . . . . . . . . . . . . IDENT n
 /app/parser/parser.go:713: ast.Ident{Name: n}
    5: 16: . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    5: 17: . . . . . . . . . . )
    5: 17: . . . . . . . . . )
    5: 17: . . . . . . . . )
    5: 17: . . . . . . . )
    5: 17: . . . . . . )
    5: 17: . . . . . )
    5: 17: . . . . )
    5: 17: . . . . ";"
    7:  1: . . . )
    7:  1: . . . Statement (
    7:  1: . . . . ForStmt (
    7:  1: . . . . . "for"
    7:  5: . . . . . SimpleStmt (
    7:  5: . . . . . . ExpressionList (
    7:  5: . . . . . . . Expression (
    7:  5: . . . . . . . . BinaryExpr (
    7:  5: . . . . . . . . . UnaryExpr (
    7:  5: . . . . . . . . . . PrimaryExpr (
    7:  5: . . . . . . . . . . . Operand (
    7:  5: . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    7:  7: . . . . . . . . . . . )
    7:  7: . . . . . . . . . . )
    7:  7: . . . . . . . . . )
    7:  7: . . . . . . . . )
    7:  7: . . . . . . . )
    7:  7: . . . . . . )
    7:  7: . . . . . . ":="
    7: 10: . . . . . . "range"
    7: 16: . . . . . . Expression (
    7: 16: . . . . . . . RangeExpr (
    7: 16: . . . . . . . . BinaryExpr (
    7: 16: . . . . . . . . . UnaryExpr (
    7: 16: . . . . . . . . . . PrimaryExpr (
    7: 16: . . . . . . . . . . . Operand (
    7: 16: . . . . . . . . . . . . ArrayType (
    7: 16: . . . . . . . . . . . . . "["
    7: 17: . . . . . . . . . . . . . Expression (
    7: 17: . . . . . . . . . . . . . . BinaryExpr (
    7: 17: . . . . . . . . . . . . . . . UnaryExpr (
    7: 17: . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 17: . . . . . . . . . . . . . . . . . Operand (
    7: 17: . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    7: 18: . . . . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . "]"
 /app/parser/parser.go:902: ast.SliceLit{Elts: [0xc00012d3e0]}
    7: 20: . . . . . . . . . . . . )
    7: 20: . . . . . . . . . . . )
    7: 20: . . . . . . . . . . )
    7: 20: . . . . . . . . . )
    7: 20: . . . . . . . . )
    7: 20: . . . . . . . )
    7: 20: . . . . . . )
    7: 20: . . . . . )
    7: 20: . . . . . BlockStmt (
    7: 20: . . . . . . "{"
    8:  1: . . . . . . StatementList (
    8:  1: . . . . . . )
    8:  1: . . . . . . "}"
    8:  2: . . . . . )
    8:  2: . . . . . ";"
   10:  1: . . . . )
   10:  1: . . . )
   10:  1: . . . Statement (
   10:  1: . . . . SimpleStmt (
   10:  1: . . . . . ExpressionList (
   10:  1: . . . . . . Expression (
   10:  1: . . . . . . . BinaryExpr (
   10:  1: . . . . . . . . UnaryExpr (
   10:  1: . . . . . . . . . PrimaryExpr (
   10:  1: . . . . . . . . . . Operand (
   10:  1: . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   10:  5: . . . . . . . . . . )
   10:  5: . . . . . . . . . )
   10:  5: . . . . . . . . )
   10:  5: . . . . . . . )
   10:  5: . . . . . . )
   10:  5: . . . . . )
   10:  5: . . . . . ":="
   10:  8: . . . . . ExpressionList (
   10:  8: . . . . . . Expression (
   10:  8: . . . . . . . BinaryExpr (
   10:  8: . . . . . . . . UnaryExpr (
   10:  8: . . . . . . . . . PrimaryExpr (
   10:  8: . . . . . . . . . . Operand (
   10:  8: . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   10:  9: . . . . . . . . . . )
   10:  9: . . . . . . . . . )
   10:  9: . . . . . . . . )
   10:  9: . . . . . . . )
   10:  9: . . . . . . )
   10:  9: . . . . . )
   10:  9: . . . . )
   10:  9: . . . . ";"
   11:  1: . . . )
   11:  1: . . . Statement (
   11:  1: . . . . ForStmt (
   11:  1: . . . . . "for"
   11:  5: . . . . . SimpleStmt (
   11:  5: . . . . . . ExpressionList (
   11:  5: . . . . . . . Expression (
   11:  5: . . . . . . . . BinaryExpr (
   11:  5: . . . . . . . . . UnaryExpr (
   11:  5: . . . . . . . . . . PrimaryExpr (
   11:  5: . . . . . . . . . . . Operand (
   11:  5: . . . . . . . . . . . . IDENT _
 /app/parser/parser.go:713: ast.Ident{Name: _}
   11:  6: . . . . . . . . . . . )
   11:  6: . . . . . . . . . . )
   11:  6: . . . . . . . . . )
   11:  6: . . . . . . . . )
   11:  6: . . . . . . . )
   11:  6: . . . . . . . ","
   11:  8: . . . . . . . Expression (
   11:  8: . . . . . . . . BinaryExpr (
   11:  8: . . . . . . . . . UnaryExpr (
   11:  8: . . . . . . . . . . PrimaryExpr (
   11:  8: . . . . . . . . . . . Operand (
   11:  8: . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   11: 10: . . . . . . . . . . . )
   11: 10: . . . . . . . . . . )
   11: 10: . . . . . . . . . )
   11: 10: . . . . . . . . )
   11: 10: . . . . . . . )
   11: 10: . . . . . . )
   11: 10: . . . . . . ":="
   11: 13: . . . . . . "range"
   11: 19: . . . . . . Expression (
   11: 19: . . . . . . . RangeExpr (
   11: 19: . . . . . . . . BinaryExpr (
   11: 19: . . . . . . . . . UnaryExpr (
   11: 19: . . . . . . . . . . PrimaryExpr (
   11: 19: . . . . . . . . . . . Operand (
   11: 19: . . . . . . . . . . . . ArrayType (
   11: 19: . . . . . . . . . . . . . "["
   11: 20: . . . . . . . . . . . . . Expression (
   11: 20: . . . . . . . . . . . . . . BinaryExpr (
   11: 20: . . . . . . . . . . . . . . . UnaryExpr (
   11: 20: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 20: . . . . . . . . . . . . . . . . . Operand (
   11: 20: . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   11: 21: . . . . . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . ","
   11: 23: . . . . . . . . . . . . . Expression (
   11: 23: . . . . . . . . . . . . . . BinaryExpr (
   11: 23: . . . . . . . . . . . . . . . UnaryExpr (
   11: 23: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 23: . . . . . . . . . . . . . . . . . Operand (
   11: 23: . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
   11: 24: . . . . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . ","
   11: 26: . . . . . . . . . . . . . Expression (
   11: 26: . . . . . . . . . . . . . . BinaryExpr (
   11: 26: . . . . . . . . . . . . . . . UnaryExpr (
   11: 26: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 26: . . . . . . . . . . . . . . . . . Operand (
   11: 26: . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
   11: 27: . . . . . . . . . . . . . . . . . )
   11: 27: . . . . . . . . . . . . . . . . )
   11: 27: . . . . . . . . . . . . . . . )
   11: 27: . . . . . . . . . . . . . . )
   11: 27: . . . . . . . . . . . . . )
   11: 27: . . . . . . . . . . . . . ","
   11: 29: . . . . . . . . . . . . . Expression (
   11: 29: . . . . . . . . . . . . . . BinaryExpr (
   11: 29: . . . . . . . . . . . . . . . UnaryExpr (
   11: 29: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 29: . . . . . . . . . . . . . . . . . Operand (
   11: 29: . . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
   11: 30: . . . . . . . . . . . . . . . . . )
   11: 30: . . . . . . . . . . . . . . . . )
   11: 30: . . . . . . . . . . . . . . . )
   11: 30: . . . . . . . . . . . . . . )
   11: 30: . . . . . . . . . . . . . )
   11: 30: . . . . . . . . . . . . . ","
   11: 32: . . . . . . . . . . . . . Expression (
   11: 32: . . . . . . . . . . . . . . BinaryExpr (
   11: 32: . . . . . . . . . . . . . . . UnaryExpr (
   11: 32: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 32: . . . . . . . . . . . . . . . . . Operand (
   11: 32: . . . . . . . . . . . . . . . . . . INT 11
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 11}
   11: 34: . . . . . . . . . . . . . . . . . )
   11: 34: . . . . . . . . . . . . . . . . )
   11: 34: . . . . . . . . . . . . . . . )
   11: 34: . . . . . . . . . . . . . . )
   11: 34: . . . . . . . . . . . . . )
   11: 34: . . . . . . . . . . . . . "]"
   11: 36: . . . . . . . . . . . . )
   11: 36: . . . . . . . . . . . )
   11: 36: . . . . . . . . . . )
   11: 36: . . . . . . . . . )
   11: 36: . . . . . . . . )
   11: 36: . . . . . . . )
   11: 36: . . . . . . )
   11: 36: . . . . . )
   11: 36: . . . . . BlockStmt (
   11: 36: . . . . . . "{"
   12:  2: . . . . . . StatementList (
   12:  2: . . . . . . . Statement (
   12:  2: . . . . . . . . IfStmt (
   12:  2: . . . . . . . . . "if"
   12:  5: . . . . . . . . . SimpleStmt (
   12:  5: . . . . . . . . . . ExpressionList (
   12:  5: . . . . . . . . . . . Expression (
   12:  5: . . . . . . . . . . . . BinaryExpr (
   12:  5: . . . . . . . . . . . . . UnaryExpr (
   12:  5: . . . . . . . . . . . . . . PrimaryExpr (
   12:  5: . . . . . . . . . . . . . . . Operand (
   12:  5: . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   12:  7: . . . . . . . . . . . . . . . )
   12:  7: . . . . . . . . . . . . . . )
   12:  7: . . . . . . . . . . . . . )
   12:  7: . . . . . . . . . . . . . ">"
   12:  9: . . . . . . . . . . . . . BinaryExpr (
   12:  9: . . . . . . . . . . . . . . UnaryExpr (
   12:  9: . . . . . . . . . . . . . . . PrimaryExpr (
   12:  9: . . . . . . . . . . . . . . . . Operand (
   12:  9: . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
   12: 11: . . . . . . . . . . . . . . . . )
   12: 11: . . . . . . . . . . . . . . . )
   12: 11: . . . . . . . . . . . . . . )
   12: 11: . . . . . . . . . . . . . )
   12: 11: . . . . . . . . . . . . )
   12: 11: . . . . . . . . . . . )
   12: 11: . . . . . . . . . . )
   12: 11: . . . . . . . . . )
   12: 11: . . . . . . . . . BlockStmt (
   12: 11: . . . . . . . . . . "{"
   13:  3: . . . . . . . . . . StatementList (
   13:  3: . . . . . . . . . . . Statement (
   13:  3: . . . . . . . . . . . . SimpleStmt (
   13:  3: . . . . . . . . . . . . . ExpressionList (
   13:  3: . . . . . . . . . . . . . . Expression (
   13:  3: . . . . . . . . . . . . . . . BinaryExpr (
   13:  3: . . . . . . . . . . . . . . . . UnaryExpr (
   13:  3: . . . . . . . . . . . . . . . . . PrimaryExpr (
   13:  3: . . . . . . . . . . . . . . . . . . Operand (
   13:  3: . . . . . . . . . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   13:  7: . . . . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . "+="
   13: 10: . . . . . . . . . . . . . ExpressionList (
   13: 10: . . . . . . . . . . . . . . Expression (
   13: 10: . . . . . . . . . . . . . . . BinaryExpr (
   13: 10: . . . . . . . . . . . . . . . . UnaryExpr (
   13: 10: . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 10: . . . . . . . . . . . . . . . . . . Operand (
   13: 10: . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   13: 11: . . . . . . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . ";"
   14:  2: . . . . . . . . . . . )
   14:  2: . . . . . . . . . . )
   14:  2: . . . . . . . . . . "}"
   14:  3: . . . . . . . . . )
   14:  3: . . . . . . . . . ";"
   15:  1: . . . . . . . . )
   15:  1: . . . . . . . )
   15:  1: . . . . . . )
   15:  1: . . . . . . "}"
   15:  2: . . . . . )
   15:  2: . . . . . ";"
   16:  1: . . . . )
   16:  1: . . . )
   16:  1: . . . Statement (
   16:  1: . . . . SimpleStmt (
   16:  1: . . . . . ExpressionList (
   16:  1: . . . . . . Expression (
   16:  1: . . . . . . . BinaryExpr (
   16:  1: . . . . . . . . UnaryExpr (
   16:  1: . . . . . . . . . PrimaryExpr (
   16:  1: . . . . . . . . . . Operand (
   16:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   16:  8: . . . . . . . . . . )
   16:  8: . . . . . . . . . . CallOrConversion (
   16:  8: . . . . . . . . . . . "("
   16:  9: . . . . . . . . . . . Expression (
   16:  9: . . . . . . . . . . . . BinaryExpr (
   16:  9: . . . . . . . . . . . . . UnaryExpr (
   16:  9: . . . . . . . . . . . . . . PrimaryExpr (
   16:  9: . . . . . . . . . . . . . . . Operand (
   16:  9: . . . . . . . . . . . . . . . . STRING "sum(1,3,5,7,11):"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "sum(1,3,5,7,11):"}
   16: 27: . . . . . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . ","
   16: 29: . . . . . . . . . . . Expression (
   16: 29: . . . . . . . . . . . . BinaryExpr (
   16: 29: . . . . . . . . . . . . . UnaryExpr (
   16: 29: . . . . . . . . . . . . . . PrimaryExpr (
   16: 29: . . . . . . . . . . . . . . . Operand (
   16: 29: . . . . . . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   16: 32: . . . . . . . . . . . . . . . )
   16: 32: . . . . . . . . . . . . . . )
   16: 32: . . . . . . . . . . . . . )
   16: 32: . . . . . . . . . . . . )
   16: 32: . . . . . . . . . . . )
   16: 32: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   16: 33: . . . . . . . . . . )
   16: 33: . . . . . . . . . )
   16: 33: . . . . . . . . )
   16: 33: . . . . . . . )
   16: 33: . . . . . . )
   16: 33: . . . . . )
   16: 33: . . . . )
   16: 33: . . . . ";"
   18:  1: . . . )
   18:  1: . . . Statement (
   18:  1: . . . . SimpleStmt (
   18:  1: . . . . . ExpressionList (
   18:  1: . . . . . . Expression (
   18:  1: . . . . . . . BinaryExpr (
   18:  1: . . . . . . . . UnaryExpr (
   18:  1: . . . . . . . . . PrimaryExpr (
   18:  1: . . . . . . . . . . Operand (
   18:  1: . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   18:  5: . . . . . . . . . . )
   18:  5: . . . . . . . . . )
   18:  5: . . . . . . . . )
   18:  5: . . . . . . . )
   18:  5: . . . . . . )
   18:  5: . . . . . )
   18:  5: . . . . . "="
   18:  7: . . . . . ExpressionList (
   18:  7: . . . . . . Expression (
   18:  7: . . . . . . . BinaryExpr (
   18:  7: . . . . . . . . UnaryExpr (
   18:  7: . . . . . . . . . PrimaryExpr (
   18:  7: . . . . . . . . . . Operand (
   18:  7: . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   18:  8: . . . . . . . . . . )
   18:  8: . . . . . . . . . )
   18:  8: . . . . . . . . )
   18:  8: . . . . . . . )
   18:  8: . . . . . . )
   18:  8: . . . . . )
   18:  8: . . . . )
   18:  8: . . . . ";"
   19:  1: . . . )
   19:  1: . . . Statement (
   19:  1: . . . . ForStmt (
   19:  1: . . . . . "for"
   19:  5: . . . . . SimpleStmt (
   19:  5: . . . . . . ExpressionList (
   19:  5: . . . . . . . Expression (
   19:  5: . . . . . . . . BinaryExpr (
   19:  5: . . . . . . . . . UnaryExpr (
   19:  5: . . . . . . . . . . PrimaryExpr (
   19:  5: . . . . . . . . . . . Operand (
   19:  5: . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   19:  7: . . . . . . . . . . . )
   19:  7: . . . . . . . . . . )
   19:  7: . . . . . . . . . )
   19:  7: . . . . . . . . )
   19:  7: . . . . . . . )
   19:  7: . . . . . . )
   19:  7: . . . . . . ":="
   19: 10: . . . . . . ExpressionList (
   19: 10: . . . . . . . Expression (
   19: 10: . . . . . . . . BinaryExpr (
   19: 10: . . . . . . . . . UnaryExpr (
   19: 10: . . . . . . . . . . PrimaryExpr (
   19: 10: . . . . . . . . . . . Operand (
   19: 10: . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   19: 11: . . . . . . . . . . . )
   19: 11: . . . . . . . . . . )
   19: 11: . . . . . . . . . )
   19: 11: . . . . . . . . )
   19: 11: . . . . . . . )
   19: 11: . . . . . . )
   19: 11: . . . . . )
   19: 11: . . . . . ";"
   19: 13: . . . . . SimpleStmt (
   19: 13: . . . . . . ExpressionList (
   19: 13: . . . . . . . Expression (
   19: 13: . . . . . . . . BinaryExpr (
   19: 13: . . . . . . . . . UnaryExpr (
   19: 13: . . . . . . . . . . PrimaryExpr (
   19: 13: . . . . . . . . . . . Operand (
   19: 13: . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   19: 15: . . . . . . . . . . . )
   19: 15: . . . . . . . . . . )
   19: 15: . . . . . . . . . )
   19: 15: . . . . . . . . . "<"
   19: 17: . . . . . . . . . BinaryExpr (
   19: 17: . . . . . . . . . . UnaryExpr (
   19: 17: . . . . . . . . . . . PrimaryExpr (
   19: 17: . . . . . . . . . . . . Operand (
   19: 17: . . . . . . . . . . . . . INT 100
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
   19: 20: . . . . . . . . . . . . )
   19: 20: . . . . . . . . . . . )
   19: 20: . . . . . . . . . . )
   19: 20: . . . . . . . . . )
   19: 20: . . . . . . . . )
   19: 20: . . . . . . . )
   19: 20: . . . . . . )
   19: 20: . . . . . )
   19: 20: . . . . . ";"
   19: 22: . . . . . SimpleStmt (
   19: 22: . . . . . . ExpressionList (
   19: 22: . . . . . . . Expression (
   19: 22: . . . . . . . . BinaryExpr (
   19: 22: . . . . . . . . . UnaryExpr (
   19: 22: . . . . . . . . . . PrimaryExpr (
   19: 22: . . . . . . . . . . . Operand (
   19: 22: . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   19: 23: . . . . . . . . . . . )
   19: 23: . . . . . . . . . . )
   19: 23: . . . . . . . . . )
   19: 23: . . . . . . . . )
   19: 23: . . . . . . . )
   19: 23: . . . . . . )
   19: 23: . . . . . . "++"
   19: 26: . . . . . )
   19: 26: . . . . . BlockStmt (
   19: 26: . . . . . . "{"
   20:  2: . . . . . . StatementList (
   20:  2: . . . . . . . Statement (
   20:  2: . . . . . . . . SimpleStmt (
   20:  2: . . . . . . . . . ExpressionList (
   20:  2: . . . . . . . . . . Expression (
   20:  2: . . . . . . . . . . . BinaryExpr (
   20:  2: . . . . . . . . . . . . UnaryExpr (
   20:  2: . . . . . . . . . . . . . PrimaryExpr (
   20:  2: . . . . . . . . . . . . . . Operand (
   20:  2: . . . . . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   20:  6: . . . . . . . . . . . . . . )
   20:  6: . . . . . . . . . . . . . )
   20:  6: . . . . . . . . . . . . )
   20:  6: . . . . . . . . . . . )
   20:  6: . . . . . . . . . . )
   20:  6: . . . . . . . . . )
   20:  6: . . . . . . . . . "+="
   20:  9: . . . . . . . . . ExpressionList (
   20:  9: . . . . . . . . . . Expression (
   20:  9: . . . . . . . . . . . BinaryExpr (
   20:  9: . . . . . . . . . . . . UnaryExpr (
   20:  9: . . . . . . . . . . . . . PrimaryExpr (
   20:  9: . . . . . . . . . . . . . . Operand (
   20:  9: . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   20: 10: . . . . . . . . . . . . . . )
   20: 10: . . . . . . . . . . . . . )
   20: 10: . . . . . . . . . . . . )
   20: 10: . . . . . . . . . . . )
   20: 10: . . . . . . . . . . )
   20: 10: . . . . . . . . . )
   20: 10: . . . . . . . . )
   20: 10: . . . . . . . . ";"
   21:  1: . . . . . . . )
   21:  1: . . . . . . )
   21:  1: . . . . . . "}"
   21:  2: . . . . . )
   21:  2: . . . . . ";"
   22:  1: . . . . )
   22:  1: . . . )
   22:  1: . . . Statement (
   22:  1: . . . . SimpleStmt (
   22:  1: . . . . . ExpressionList (
   22:  1: . . . . . . Expression (
   22:  1: . . . . . . . BinaryExpr (
   22:  1: . . . . . . . . UnaryExpr (
   22:  1: . . . . . . . . . PrimaryExpr (
   22:  1: . . . . . . . . . . Operand (
   22:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   22:  8: . . . . . . . . . . )
   22:  8: . . . . . . . . . . CallOrConversion (
   22:  8: . . . . . . . . . . . "("
   22:  9: . . . . . . . . . . . Expression (
   22:  9: . . . . . . . . . . . . BinaryExpr (
   22:  9: . . . . . . . . . . . . . UnaryExpr (
   22:  9: . . . . . . . . . . . . . . PrimaryExpr (
   22:  9: . . . . . . . . . . . . . . . Operand (
   22:  9: . . . . . . . . . . . . . . . . STRING "sum(1-100):"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "sum(1-100):"}
   22: 22: . . . . . . . . . . . . . . . )
   22: 22: . . . . . . . . . . . . . . )
   22: 22: . . . . . . . . . . . . . )
   22: 22: . . . . . . . . . . . . )
   22: 22: . . . . . . . . . . . )
   22: 22: . . . . . . . . . . . ","
   22: 24: . . . . . . . . . . . Expression (
   22: 24: . . . . . . . . . . . . BinaryExpr (
   22: 24: . . . . . . . . . . . . . UnaryExpr (
   22: 24: . . . . . . . . . . . . . . PrimaryExpr (
   22: 24: . . . . . . . . . . . . . . . Operand (
   22: 24: . . . . . . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   22: 27: . . . . . . . . . . . . . . . )
   22: 27: . . . . . . . . . . . . . . )
   22: 27: . . . . . . . . . . . . . )
   22: 27: . . . . . . . . . . . . )
   22: 27: . . . . . . . . . . . )
   22: 27: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   22: 28: . . . . . . . . . . )
   22: 28: . . . . . . . . . )
   22: 28: . . . . . . . . )
   22: 28: . . . . . . . )
   22: 28: . . . . . . )
   22: 28: . . . . . )
   22: 28: . . . . )
   22: 28: . . . . ";"
   24:  1: . . . )
   24:  1: . . . Statement (
   24:  1: . . . . ForStmt (
   24:  1: . . . . . "for"
   24:  5: . . . . . SimpleStmt (
   24:  5: . . . . . . ExpressionList (
   24:  5: . . . . . . . Expression (
   24:  5: . . . . . . . . BinaryExpr (
   24:  5: . . . . . . . . . UnaryExpr (
   24:  5: . . . . . . . . . . PrimaryExpr (
   24:  5: . . . . . . . . . . . Operand (
   24:  5: . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   24:  7: . . . . . . . . . . . )
   24:  7: . . . . . . . . . . )
   24:  7: . . . . . . . . . )
   24:  7: . . . . . . . . )
   24:  7: . . . . . . . )
   24:  7: . . . . . . )
   24:  7: . . . . . . IDENT in
   24: 10: . . . . . . Expression (
   24: 10: . . . . . . . RangeExpr (
   24: 10: . . . . . . . . BinaryExpr (
   24: 10: . . . . . . . . . UnaryExpr (
   24: 10: . . . . . . . . . . PrimaryExpr (
   24: 10: . . . . . . . . . . . Operand (
   24: 10: . . . . . . . . . . . . ArrayType (
   24: 10: . . . . . . . . . . . . . "["
   24: 11: . . . . . . . . . . . . . Expression (
   24: 11: . . . . . . . . . . . . . . BinaryExpr (
   24: 11: . . . . . . . . . . . . . . . UnaryExpr (
   24: 11: . . . . . . . . . . . . . . . . PrimaryExpr (
   24: 11: . . . . . . . . . . . . . . . . . Operand (
   24: 11: . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   24: 12: . . . . . . . . . . . . . . . . . )
   24: 12: . . . . . . . . . . . . . . . . )
   24: 12: . . . . . . . . . . . . . . . )
   24: 12: . . . . . . . . . . . . . . )
   24: 12: . . . . . . . . . . . . . )
   24: 12: . . . . . . . . . . . . . "]"
 /app/parser/parser.go:902: ast.SliceLit{Elts: [0xc00012d950]}
   24: 14: . . . . . . . . . . . . )
   24: 14: . . . . . . . . . . . )
   24: 14: . . . . . . . . . . )
   24: 14: . . . . . . . . . )
   24: 14: . . . . . . . . )
   24: 14: . . . . . . . )
   24: 14: . . . . . . )
   24: 14: . . . . . )
   24: 14: . . . . . BlockStmt (
   24: 14: . . . . . . "{"
   25:  2: . . . . . . StatementList (
   25:  2: . . . . . . . Statement (
   25:  2: . . . . . . . . SimpleStmt (
   25:  2: . . . . . . . . . ExpressionList (
   25:  2: . . . . . . . . . . Expression (
   25:  2: . . . . . . . . . . . BinaryExpr (
   25:  2: . . . . . . . . . . . . UnaryExpr (
   25:  2: . . . . . . . . . . . . . PrimaryExpr (
   25:  2: . . . . . . . . . . . . . . Operand (
   25:  2: . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   25:  9: . . . . . . . . . . . . . . )
   25:  9: . . . . . . . . . . . . . . CallOrConversion (
   25:  9: . . . . . . . . . . . . . . . "("
   25: 10: . . . . . . . . . . . . . . . Expression (
   25: 10: . . . . . . . . . . . . . . . . BinaryExpr (
   25: 10: . . . . . . . . . . . . . . . . . UnaryExpr (
   25: 10: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   25: 10: . . . . . . . . . . . . . . . . . . . Operand (
   25: 10: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   25: 11: . . . . . . . . . . . . . . . . . . . )
   25: 11: . . . . . . . . . . . . . . . . . . )
   25: 11: . . . . . . . . . . . . . . . . . )
   25: 11: . . . . . . . . . . . . . . . . )
   25: 11: . . . . . . . . . . . . . . . )
   25: 11: . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   25: 12: . . . . . . . . . . . . . . )
   25: 12: . . . . . . . . . . . . . )
   25: 12: . . . . . . . . . . . . )
   25: 12: . . . . . . . . . . . )
   25: 12: . . . . . . . . . . )
   25: 12: . . . . . . . . . )
   25: 12: . . . . . . . . )
   25: 12: . . . . . . . . ";"
   26:  1: . . . . . . . )
   26:  1: . . . . . . )
   26:  1: . . . . . . "}"
   26:  2: . . . . . )
   26:  2: . . . . . ";"
   28:  1: . . . . )
   28:  1: . . . )
   28:  1: . . . Statement (
   28:  1: . . . . ForStmt (
   28:  1: . . . . . "for"
   28:  5: . . . . . SimpleStmt (
   28:  5: . . . . . . ExpressionList (
   28:  5: . . . . . . . Expression (
   28:  5: . . . . . . . . BinaryExpr (
   28:  5: . . . . . . . . . UnaryExpr (
   28:  5: . . . . . . . . . . PrimaryExpr (
   28:  5: . . . . . . . . . . . Operand (
   28:  5: . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   28:  6: . . . . . . . . . . . )
   28:  6: . . . . . . . . . . )
   28:  6: . . . . . . . . . )
   28:  6: . . . . . . . . )
   28:  6: . . . . . . . )
   28:  6: . . . . . . . ","
   28:  8: . . . . . . . Expression (
   28:  8: . . . . . . . . BinaryExpr (
   28:  8: . . . . . . . . . UnaryExpr (
   28:  8: . . . . . . . . . . PrimaryExpr (
   28:  8: . . . . . . . . . . . Operand (
   28:  8: . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   28: 10: . . . . . . . . . . . )
   28: 10: . . . . . . . . . . )
   28: 10: . . . . . . . . . )
   28: 10: . . . . . . . . )
   28: 10: . . . . . . . )
   28: 10: . . . . . . )
   28: 10: . . . . . . IDENT in
   28: 13: . . . . . . Expression (
   28: 13: . . . . . . . RangeExpr (
   28: 13: . . . . . . . . BinaryExpr (
   28: 13: . . . . . . . . . UnaryExpr (
   28: 13: . . . . . . . . . . PrimaryExpr (
   28: 13: . . . . . . . . . . . Operand (
   28: 13: . . . . . . . . . . . . ArrayType (
   28: 13: . . . . . . . . . . . . . "["
   28: 14: . . . . . . . . . . . . . Expression (
   28: 14: . . . . . . . . . . . . . . BinaryExpr (
   28: 14: . . . . . . . . . . . . . . . UnaryExpr (
   28: 14: . . . . . . . . . . . . . . . . PrimaryExpr (
   28: 14: . . . . . . . . . . . . . . . . . Operand (
   28: 14: . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   28: 15: . . . . . . . . . . . . . . . . . )
   28: 15: . . . . . . . . . . . . . . . . )
   28: 15: . . . . . . . . . . . . . . . )
   28: 15: . . . . . . . . . . . . . . )
   28: 15: . . . . . . . . . . . . . )
   28: 15: . . . . . . . . . . . . . "]"
 /app/parser/parser.go:902: ast.SliceLit{Elts: [0xc00012da40]}
   28: 17: . . . . . . . . . . . . )
   28: 17: . . . . . . . . . . . )
   28: 17: . . . . . . . . . . )
   28: 17: . . . . . . . . . )
   28: 17: . . . . . . . . )
   28: 17: . . . . . . . )
   28: 17: . . . . . . )
   28: 17: . . . . . . "if"
   28: 20: . . . . . . Expression (
   28: 20: . . . . . . . BinaryExpr (
   28: 20: . . . . . . . . UnaryExpr (
   28: 20: . . . . . . . . . PrimaryExpr (
   28: 20: . . . . . . . . . . Operand (
   28: 20: . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   28: 21: . . . . . . . . . . )
   28: 21: . . . . . . . . . )
   28: 21: . . . . . . . . )
   28: 21: . . . . . . . . "%"
   28: 22: . . . . . . . . BinaryExpr (
   28: 22: . . . . . . . . . UnaryExpr (
   28: 22: . . . . . . . . . . PrimaryExpr (
   28: 22: . . . . . . . . . . . Operand (
   28: 22: . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   28: 24: . . . . . . . . . . . )
   28: 24: . . . . . . . . . . )
   28: 24: . . . . . . . . . )
   28: 24: . . . . . . . . )
   28: 24: . . . . . . . . "=="
   28: 27: . . . . . . . . BinaryExpr (
   28: 27: . . . . . . . . . UnaryExpr (
   28: 27: . . . . . . . . . . PrimaryExpr (
   28: 27: . . . . . . . . . . . Operand (
   28: 27: . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   28: 29: . . . . . . . . . . . )
   28: 29: . . . . . . . . . . )
   28: 29: . . . . . . . . . )
   28: 29: . . . . . . . . )
   28: 29: . . . . . . . )
   28: 29: . . . . . . )
   28: 29: . . . . . )
   28: 29: . . . . . BlockStmt (
   28: 29: . . . . . . "{"
   29:  2: . . . . . . StatementList (
   29:  2: . . . . . . . Statement (
   29:  2: . . . . . . . . SimpleStmt (
   29:  2: . . . . . . . . . ExpressionList (
   29:  2: . . . . . . . . . . Expression (
   29:  2: . . . . . . . . . . . BinaryExpr (
   29:  2: . . . . . . . . . . . . UnaryExpr (
   29:  2: . . . . . . . . . . . . . PrimaryExpr (
   29:  2: . . . . . . . . . . . . . . Operand (
   29:  2: . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   29:  9: . . . . . . . . . . . . . . )
   29:  9: . . . . . . . . . . . . . . CallOrConversion (
   29:  9: . . . . . . . . . . . . . . . "("
   29: 10: . . . . . . . . . . . . . . . Expression (
   29: 10: . . . . . . . . . . . . . . . . BinaryExpr (
   29: 10: . . . . . . . . . . . . . . . . . UnaryExpr (
   29: 10: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   29: 10: . . . . . . . . . . . . . . . . . . . Operand (
   29: 10: . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   29: 11: . . . . . . . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . . . . ","
   29: 13: . . . . . . . . . . . . . . . Expression (
   29: 13: . . . . . . . . . . . . . . . . BinaryExpr (
   29: 13: . . . . . . . . . . . . . . . . . UnaryExpr (
   29: 13: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   29: 13: . . . . . . . . . . . . . . . . . . . Operand (
   29: 13: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   29: 14: . . . . . . . . . . . . . . . . . . . )
   29: 14: . . . . . . . . . . . . . . . . . . )
   29: 14: . . . . . . . . . . . . . . . . . )
   29: 14: . . . . . . . . . . . . . . . . )
   29: 14: . . . . . . . . . . . . . . . )
   29: 14: . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   29: 15: . . . . . . . . . . . . . . )
   29: 15: . . . . . . . . . . . . . )
   29: 15: . . . . . . . . . . . . )
   29: 15: . . . . . . . . . . . )
   29: 15: . . . . . . . . . . )
   29: 15: . . . . . . . . . )
   29: 15: . . . . . . . . )
   29: 15: . . . . . . . . ";"
   30:  1: . . . . . . . )
   30:  1: . . . . . . )
   30:  1: . . . . . . "}"
   30:  2: . . . . . )
   30:  2: . . . . . ";"
   30:  3: . . . . )
   30:  3: . . . )
   30:  3: . . )
   30:  3: . )
   30:  3: )
=== RUN   TestFromTestdata/funcdecl1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/funcdecl1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  5: . . . Parameters (
    1:  5: . . . . "("
    1:  6: . . . . ")"
    1:  8: . . . )
    1:  8: . . . Parameters (
    1:  8: . . . . "("
    1:  9: . . . . ParameterList (
    1:  9: . . . . . ParamDeclOrNil (
    1:  9: . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 12: . . . . . )
    1: 12: . . . . . ","
    1: 14: . . . . . ParamDeclOrNil (
    1: 14: . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 17: . . . . . )
    1: 17: . . . . )
    1: 17: . . . . ")"
    1: 19: . . . )
    1: 19: . . . Body (
    1: 19: . . . . "{"
    2:  2: . . . . StatementList (
    2:  2: . . . . . Statement (
    2:  2: . . . . . . ReturnStmt (
    2:  2: . . . . . . . "return"
    2:  9: . . . . . . . ExpressionList (
    2:  9: . . . . . . . . Expression (
    2:  9: . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2: 10: . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . )
    2: 10: . . . . . . . . . . )
    2: 10: . . . . . . . . . )
    2: 10: . . . . . . . . )
    2: 10: . . . . . . . . ","
    2: 12: . . . . . . . . Expression (
    2: 12: . . . . . . . . . BinaryExpr (
    2: 12: . . . . . . . . . . UnaryExpr (
    2: 12: . . . . . . . . . . . PrimaryExpr (
    2: 12: . . . . . . . . . . . . Operand (
    2: 12: . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2: 13: . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . )
    2: 13: . . . . . . . . . . )
    2: 13: . . . . . . . . . )
    2: 13: . . . . . . . . )
    2: 13: . . . . . . . )
    2: 13: . . . . . . . ";"
    3:  1: . . . . . . )
    3:  1: . . . . . )
    3:  1: . . . . )
    3:  1: . . . . "}"
    3:  2: . . . )
    3:  2: . . . CallOrConversion (
    3:  2: . . . . "("
    3:  3: . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{0xc0003f9d80 0xc00012def0}, Ellipsis: false, isCmd: false}
    3:  4: . . . )
    3:  4: . . . ";"
    3:  5: . . )
    3:  5: . . StatementList (
    3:  5: . . )
    3:  5: . )
    3:  5: )
=== RUN   TestFromTestdata/funcdecl2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/funcdecl2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  5: . . . Parameters (
    1:  5: . . . . "("
    1:  6: . . . . ")"
    1:  8: . . . )
    1:  8: . . . Body (
    1:  8: . . . . "{"
    2:  1: . . . . StatementList (
    2:  1: . . . . )
    2:  1: . . . . "}"
    2:  2: . . . )
    2:  2: . . . CallOrConversion (
    2:  2: . . . . "("
    2:  3: . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{0xc0003f9e60 0xc0003e82a0}, Ellipsis: false, isCmd: false}
    2:  4: . . . )
    2:  4: . . . ";"
    2:  5: . . )
    2:  5: . . StatementList (
    2:  5: . . )
    2:  5: . )
    2:  5: )
=== RUN   TestFromTestdata/funcdecl3
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/funcdecl3
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  5: . . . Parameters (
    1:  5: . . . . "("
    1:  6: . . . . ")"
    1:  8: . . . )
    1:  8: . . . TypeName (
    1:  8: . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 12: . . . )
    1: 12: . . . Body (
    1: 12: . . . . "{"
    2:  2: . . . . StatementList (
    2:  2: . . . . . Statement (
    2:  2: . . . . . . ReturnStmt (
    2:  2: . . . . . . . "return"
    2:  9: . . . . . . . ExpressionList (
    2:  9: . . . . . . . . Expression (
    2:  9: . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2: 10: . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . )
    2: 10: . . . . . . . . . . )
    2: 10: . . . . . . . . . )
    2: 10: . . . . . . . . )
    2: 10: . . . . . . . )
    2: 10: . . . . . . . ";"
    3:  1: . . . . . . )
    3:  1: . . . . . )
    3:  1: . . . . )
    3:  1: . . . . "}"
    3:  2: . . . )
    3:  2: . . . CallOrConversion (
    3:  2: . . . . "("
    3:  3: . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{0xc000118000 0xc0003e8630}, Ellipsis: false, isCmd: false}
    3:  4: . . . )
    3:  4: . . . ";"
    3:  5: . . )
    3:  5: . . StatementList (
    3:  5: . . )
    3:  5: . )
    3:  5: )
=== RUN   TestFromTestdata/funcdoc
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/funcdoc
    1:  1: File (
    1:  1: . "package"
    1:  9: . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    1: 12: . ";"
    3:  1: . COMMENT
    4:  1: . COMMENT
    5:  1: . Declaration (
    5:  1: . . FunctionDeclOrCall (
    5:  1: . . . "func"
    5:  6: . . . IDENT test
 /app/parser/parser.go:713: ast.Ident{Name: test}
    5: 10: . . . Signature (
    5: 10: . . . . Parameters (
    5: 10: . . . . . "("
    5: 11: . . . . . ParameterList (
    5: 11: . . . . . . ParamDeclOrNil (
    5: 11: . . . . . . . IDENT s
 /app/parser/parser.go:713: ast.Ident{Name: s}
    5: 13: . . . . . . . Type (
    5: 13: . . . . . . . . TypeName (
    5: 13: . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    5: 19: . . . . . . . . )
    5: 19: . . . . . . . )
    5: 19: . . . . . . )
    5: 19: . . . . . . ","
    5: 21: . . . . . . ParamDeclOrNil (
    5: 21: . . . . . . . IDENT p
 /app/parser/parser.go:713: ast.Ident{Name: p}
    5: 22: . . . . . . )
    5: 22: . . . . . . ","
    5: 24: . . . . . . ParamDeclOrNil (
    5: 24: . . . . . . . IDENT q
 /app/parser/parser.go:713: ast.Ident{Name: q}
    5: 26: . . . . . . . Type (
    5: 26: . . . . . . . . TypeName (
    5: 26: . . . . . . . . . IDENT uintptr
 /app/parser/parser.go:713: ast.Ident{Name: uintptr}
    5: 33: . . . . . . . . )
    5: 33: . . . . . . . )
    5: 33: . . . . . . )
    5: 33: . . . . . . ","
    5: 35: . . . . . . ParamDeclOrNil (
    5: 35: . . . . . . . IDENT rest
 /app/parser/parser.go:713: ast.Ident{Name: rest}
    5: 40: . . . . . . . DotsType (
    5: 40: . . . . . . . . "..."
    5: 43: . . . . . . . . Type (
    5: 43: . . . . . . . . . TypeName (
    5: 43: . . . . . . . . . . IDENT uintptr
 /app/parser/parser.go:713: ast.Ident{Name: uintptr}
    5: 50: . . . . . . . . . )
    5: 50: . . . . . . . . )
    5: 50: . . . . . . . )
    5: 50: . . . . . . )
    5: 50: . . . . . )
    5: 50: . . . . . ")"
    5: 52: . . . . )
    5: 52: . . . . Result (
    5: 52: . . . . . TypeName (
    5: 52: . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    5: 56: . . . . . )
    5: 56: . . . . )
    5: 56: . . . )
    5: 56: . . . Body (
    5: 56: . . . . "{"
    6:  1: . . . . StatementList (
    6:  1: . . . . )
    6:  1: . . . . "}"
    6:  2: . . . )
    6:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: test, ...}
    6:  3: . . )
    6:  3: . )
    6:  3: )
=== RUN   TestFromTestdata/funclit
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/funclit
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  5: . . . Parameters (
    1:  5: . . . . "("
    1:  6: . . . . ParameterList (
    1:  6: . . . . . ParamDeclOrNil (
    1:  6: . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1:  7: . . . . . )
    1:  7: . . . . . ","
    1:  9: . . . . . ParamDeclOrNil (
    1:  9: . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    1: 11: . . . . . . Type (
    1: 11: . . . . . . . TypeName (
    1: 11: . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 14: . . . . . . . )
    1: 14: . . . . . . )
    1: 14: . . . . . )
    1: 14: . . . . )
    1: 14: . . . . ")"
    1: 16: . . . )
    1: 16: . . . "*"
    1: 16: . . . PointerType (
    1: 17: . . . . Type (
    1: 17: . . . . . TypeName (
    1: 17: . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 21: . . . . . )
    1: 21: . . . . )
    1: 21: . . . )
    1: 21: . . . Body (
    1: 21: . . . . "{"
    2:  2: . . . . StatementList (
    2:  2: . . . . . Statement (
    2:  2: . . . . . . ReturnStmt (
    2:  2: . . . . . . . "return"
    2:  9: . . . . . . . ExpressionList (
    2:  9: . . . . . . . . Expression (
    2:  9: . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
    2: 12: . . . . . . . . . . . . )
    2: 12: . . . . . . . . . . . )
    2: 12: . . . . . . . . . . )
    2: 12: . . . . . . . . . )
    2: 12: . . . . . . . . )
    2: 12: . . . . . . . )
    2: 12: . . . . . . . ";"
    3:  1: . . . . . . )
    3:  1: . . . . . )
    3:  1: . . . . )
    3:  1: . . . . "}"
    3:  2: . . . )
    3:  2: . . . CallOrConversion (
    3:  2: . . . . "("
    3:  3: . . . . Expression (
    3:  3: . . . . . BinaryExpr (
    3:  3: . . . . . . UnaryExpr (
    3:  3: . . . . . . . PrimaryExpr (
    3:  3: . . . . . . . . Operand (
    3:  3: . . . . . . . . . INT 100
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
    3:  6: . . . . . . . . )
    3:  6: . . . . . . . )
    3:  6: . . . . . . )
    3:  6: . . . . . )
    3:  6: . . . . )
    3:  6: . . . . ","
    3:  8: . . . . Expression (
    3:  8: . . . . . BinaryExpr (
    3:  8: . . . . . . UnaryExpr (
    3:  8: . . . . . . . PrimaryExpr (
    3:  8: . . . . . . . . Operand (
    3:  8: . . . . . . . . . INT 200
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 200}
    3: 11: . . . . . . . . )
    3: 11: . . . . . . . )
    3: 11: . . . . . . )
    3: 11: . . . . . )
    3: 11: . . . . )
    3: 11: . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{0xc0002041e0 0xc000208330}, Ellipsis: false, isCmd: false}
    3: 12: . . . )
    3: 12: . . . ";"
    5:  1: . . )
    5:  1: . . StatementList (
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5:  9: . . . . . . . . . . )
    5:  9: . . . . . . . . . . CallOrConversion (
    5:  9: . . . . . . . . . . . Expression (
    5:  9: . . . . . . . . . . . . BinaryExpr (
    5:  9: . . . . . . . . . . . . . UnaryExpr (
    5:  9: . . . . . . . . . . . . . . PrimaryExpr (
    5:  9: . . . . . . . . . . . . . . . Operand (
    5:  9: . . . . . . . . . . . . . . . . STRING "hello"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "hello"}
    5: 16: . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    5: 16: . . . . . . . . . . )
    5: 16: . . . . . . . . . )
    5: 16: . . . . . . . . )
    5: 16: . . . . . . . )
    5: 16: . . . . . . )
    5: 16: . . . . . )
    5: 16: . . . . )
    5: 16: . . . . ";"
    5: 17: . . . )
    5: 17: . . )
    5: 17: . )
    5: 17: )
=== RUN   TestFromTestdata/functype
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/functype
    1:  1: COMMENT
   17:  1: File (
   17:  1: . Declaration (
   17:  1: . . GenDecl(type) (
   17:  1: . . . "type"
   17:  6: . . . TypeSpec (
   17:  6: . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
   17:  8: . . . . Type (
   17:  8: . . . . . StructType (
   17:  8: . . . . . . "struct"
   17: 15: . . . . . . "{"
   18:  2: . . . . . . FieldDecl (
   18:  2: . . . . . . . "*"
   18:  3: . . . . . . . QualifiedIdent (
   18:  3: . . . . . . . . TypeName (
   18:  3: . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
   18:  4: . . . . . . . . )
   18:  4: . . . . . . . )
   18:  4: . . . . . . . ";"
   19:  2: . . . . . . )
   19:  2: . . . . . . FieldDecl (
   19:  2: . . . . . . . IDENT A
 /app/parser/parser.go:713: ast.Ident{Name: A}
   19:  4: . . . . . . . Type (
   19:  4: . . . . . . . . TypeName (
   19:  4: . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   19:  8: . . . . . . . . )
   19:  8: . . . . . . . )
   19:  8: . . . . . . . STRING `json:"a"`
   19: 18: . . . . . . . ";"
   20:  1: . . . . . . )
   20:  1: . . . . . . "}"
   20:  2: . . . . . )
   20:  2: . . . . )
   20:  2: . . . . ";"
   22:  1: . . . )
   22:  1: . . )
   22:  1: . )
   22:  1: . Declaration (
   22:  1: . . FunctionDeclOrCall (
   22:  1: . . . "func"
   22:  6: . . . IDENT bar
 /app/parser/parser.go:713: ast.Ident{Name: bar}
   22:  9: . . . Signature (
   22:  9: . . . . Parameters (
   22:  9: . . . . . "("
   22: 10: . . . . . ParameterList (
   22: 10: . . . . . . ParamDeclOrNil (
   22: 10: . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   22: 12: . . . . . . . Type (
   22: 12: . . . . . . . . ChanType (
   22: 12: . . . . . . . . . "chan"
   22: 17: . . . . . . . . . Type (
   22: 17: . . . . . . . . . . TypeName (
   22: 17: . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   22: 21: . . . . . . . . . . )
   22: 21: . . . . . . . . . )
   22: 21: . . . . . . . . )
   22: 21: . . . . . . . )
   22: 21: . . . . . . )
   22: 21: . . . . . )
   22: 21: . . . . . ")"
   22: 23: . . . . )
   22: 23: . . . . Result (
   22: 23: . . . . . Parameters (
   22: 23: . . . . . . "("
   22: 24: . . . . . . ParameterList (
   22: 24: . . . . . . . ParamDeclOrNil (
   22: 24: . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   22: 27: . . . . . . . )
   22: 27: . . . . . . . ","
   22: 29: . . . . . . . ParamDeclOrNil (
   22: 29: . . . . . . . . Type (
   22: 29: . . . . . . . . . ChanType (
   22: 29: . . . . . . . . . . "<-"
   22: 31: . . . . . . . . . . "chan"
   22: 36: . . . . . . . . . . Type (
   22: 36: . . . . . . . . . . . TypeName (
   22: 36: . . . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   22: 41: . . . . . . . . . . . )
   22: 41: . . . . . . . . . . )
   22: 41: . . . . . . . . . )
   22: 41: . . . . . . . . )
   22: 41: . . . . . . . )
   22: 41: . . . . . . )
   22: 41: . . . . . . ")"
   22: 43: . . . . . )
   22: 43: . . . . )
   22: 43: . . . )
   22: 43: . . . Body (
   22: 43: . . . . "{"
   23:  2: . . . . StatementList (
   23:  2: . . . . . Statement (
   23:  2: . . . . . . SimpleStmt (
   23:  2: . . . . . . . ExpressionList (
   23:  2: . . . . . . . . Expression (
   23:  2: . . . . . . . . . BinaryExpr (
   23:  2: . . . . . . . . . . UnaryExpr (
   23:  2: . . . . . . . . . . . PrimaryExpr (
   23:  2: . . . . . . . . . . . . Operand (
   23:  2: . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   23:  4: . . . . . . . . . . . . )
   23:  4: . . . . . . . . . . . . "<-"
   23:  4: . . . . . . . . . . . )
   23:  4: . . . . . . . . . . )
   23:  4: . . . . . . . . . )
   23:  4: . . . . . . . . )
   23:  4: . . . . . . . )
   23:  7: . . . . . . . Expression (
   23:  7: . . . . . . . . BinaryExpr (
   23:  7: . . . . . . . . . UnaryExpr (
   23:  7: . . . . . . . . . . PrimaryExpr (
   23:  7: . . . . . . . . . . . Operand (
   23:  7: . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   23: 11: . . . . . . . . . . . )
   23: 11: . . . . . . . . . . )
   23: 11: . . . . . . . . . )
   23: 11: . . . . . . . . )
   23: 11: . . . . . . . )
   23: 11: . . . . . . )
   23: 11: . . . . . . ";"
   24:  2: . . . . . )
   24:  2: . . . . . Statement (
   24:  2: . . . . . . SimpleStmt (
   24:  2: . . . . . . . ExpressionList (
   24:  2: . . . . . . . . Expression (
   24:  2: . . . . . . . . . BinaryExpr (
   24:  2: . . . . . . . . . . UnaryExpr (
   24:  2: . . . . . . . . . . . "<-"
   24:  4: . . . . . . . . . . . UnaryExpr (
   24:  4: . . . . . . . . . . . . PrimaryExpr (
   24:  4: . . . . . . . . . . . . . Operand (
   24:  4: . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   24:  5: . . . . . . . . . . . . . )
   24:  5: . . . . . . . . . . . . )
   24:  5: . . . . . . . . . . . )
   24:  5: . . . . . . . . . . )
   24:  5: . . . . . . . . . )
   24:  5: . . . . . . . . )
   24:  5: . . . . . . . )
   24:  5: . . . . . . )
   24:  5: . . . . . . ";"
   25:  2: . . . . . )
   25:  2: . . . . . Statement (
   25:  2: . . . . . . ReturnStmt (
   25:  2: . . . . . . . "return"
   25:  9: . . . . . . . ExpressionList (
   25:  9: . . . . . . . . Expression (
   25:  9: . . . . . . . . . BinaryExpr (
   25:  9: . . . . . . . . . . UnaryExpr (
   25:  9: . . . . . . . . . . . PrimaryExpr (
   25:  9: . . . . . . . . . . . . Operand (
   25:  9: . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   25: 10: . . . . . . . . . . . . )
   25: 10: . . . . . . . . . . . )
   25: 10: . . . . . . . . . . )
   25: 10: . . . . . . . . . )
   25: 10: . . . . . . . . )
   25: 10: . . . . . . . . ","
   25: 12: . . . . . . . . Expression (
   25: 12: . . . . . . . . . BinaryExpr (
   25: 12: . . . . . . . . . . UnaryExpr (
   25: 12: . . . . . . . . . . . PrimaryExpr (
   25: 12: . . . . . . . . . . . . Operand (
   25: 12: . . . . . . . . . . . . . "("
   25: 13: . . . . . . . . . . . . . Expression (
   25: 13: . . . . . . . . . . . . . . BinaryExpr (
   25: 13: . . . . . . . . . . . . . . . UnaryExpr (
   25: 13: . . . . . . . . . . . . . . . . "<-"
   25: 15: . . . . . . . . . . . . . . . . UnaryExpr (
   25: 15: . . . . . . . . . . . . . . . . . PrimaryExpr (
   25: 15: . . . . . . . . . . . . . . . . . . Operand (
   25: 15: . . . . . . . . . . . . . . . . . . . ChanType (
   25: 15: . . . . . . . . . . . . . . . . . . . . "chan"
   25: 20: . . . . . . . . . . . . . . . . . . . . Type (
   25: 20: . . . . . . . . . . . . . . . . . . . . . TypeName (
   25: 20: . . . . . . . . . . . . . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   25: 25: . . . . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . )
   25: 25: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{750 750 2 error}}
   25: 26: . . . . . . . . . . . . )
   25: 26: . . . . . . . . . . . . CallOrConversion (
   25: 26: . . . . . . . . . . . . . "("
   25: 27: . . . . . . . . . . . . . Expression (
   25: 27: . . . . . . . . . . . . . . BinaryExpr (
   25: 27: . . . . . . . . . . . . . . . UnaryExpr (
   25: 27: . . . . . . . . . . . . . . . . PrimaryExpr (
   25: 27: . . . . . . . . . . . . . . . . . Operand (
   25: 27: . . . . . . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
   25: 30: . . . . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . )
   25: 30: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{749 0xc000208810 762}, Ellipsis: false, isCmd: false}
   25: 31: . . . . . . . . . . . . )
   25: 31: . . . . . . . . . . . )
   25: 31: . . . . . . . . . . )
   25: 31: . . . . . . . . . )
   25: 31: . . . . . . . . )
   25: 31: . . . . . . . )
   25: 31: . . . . . . . ";"
   26:  1: . . . . . . )
   26:  1: . . . . . )
   26:  1: . . . . )
   26:  1: . . . . "}"
   26:  2: . . . )
   26:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
   28:  1: . . )
   28:  1: . )
   28:  1: . Declaration (
   28:  1: . . FunctionDeclOrCall (
   28:  1: . . . "func"
   28:  6: . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   28:  9: . . . Signature (
   28:  9: . . . . Parameters (
   28:  9: . . . . . "("
   28: 10: . . . . . ParameterList (
   28: 10: . . . . . . ParamDeclOrNil (
   28: 10: . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   28: 12: . . . . . . . Type (
   28: 12: . . . . . . . . FuncType (
   28: 12: . . . . . . . . . "func"
   28: 16: . . . . . . . . . Signature (
   28: 16: . . . . . . . . . . Parameters (
   28: 16: . . . . . . . . . . . "("
   28: 17: . . . . . . . . . . . ParameterList (
   28: 17: . . . . . . . . . . . . ParamDeclOrNil (
   28: 17: . . . . . . . . . . . . . Type (
   28: 17: . . . . . . . . . . . . . . ArrayType (
   28: 17: . . . . . . . . . . . . . . . "["
   28: 18: . . . . . . . . . . . . . . . "]"
   28: 19: . . . . . . . . . . . . . . . Type (
   28: 19: . . . . . . . . . . . . . . . . TypeName (
   28: 19: . . . . . . . . . . . . . . . . . IDENT byte
 /app/parser/parser.go:713: ast.Ident{Name: byte}
   28: 23: . . . . . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
   28: 23: . . . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . )
   28: 23: . . . . . . . . . . . . ","
   28: 25: . . . . . . . . . . . . ParamDeclOrNil (
   28: 25: . . . . . . . . . . . . . Type (
   28: 25: . . . . . . . . . . . . . . PointerType (
   28: 25: . . . . . . . . . . . . . . . "*"
   28: 26: . . . . . . . . . . . . . . . Type (
   28: 26: . . . . . . . . . . . . . . . . TypeName (
   28: 26: . . . . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   28: 32: . . . . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . )
   28: 32: . . . . . . . . . . . . ","
   28: 34: . . . . . . . . . . . . ParamDeclOrNil (
   28: 34: . . . . . . . . . . . . . DotsType (
   28: 34: . . . . . . . . . . . . . . "..."
   28: 37: . . . . . . . . . . . . . . Type (
   28: 37: . . . . . . . . . . . . . . . TypeName (
   28: 37: . . . . . . . . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
   28: 38: . . . . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . )
   28: 38: . . . . . . . . . . . ")"
   28: 40: . . . . . . . . . . )
   28: 40: . . . . . . . . . . Result (
   28: 40: . . . . . . . . . . . ChanType (
   28: 40: . . . . . . . . . . . . "chan"
   28: 44: . . . . . . . . . . . . "<-"
   28: 47: . . . . . . . . . . . . Type (
   28: 47: . . . . . . . . . . . . . TypeName (
   28: 47: . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   28: 50: . . . . . . . . . . . . . )
   28: 50: . . . . . . . . . . . . )
   28: 50: . . . . . . . . . . . )
   28: 50: . . . . . . . . . . )
   28: 50: . . . . . . . . . )
   28: 50: . . . . . . . . )
   28: 50: . . . . . . . )
   28: 50: . . . . . . )
   28: 50: . . . . . )
   28: 50: . . . . . ")"
   28: 52: . . . . )
   28: 52: . . . . Result (
   28: 52: . . . . . Parameters (
   28: 52: . . . . . . "("
   28: 53: . . . . . . ParameterList (
   28: 53: . . . . . . . ParamDeclOrNil (
   28: 53: . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
   28: 55: . . . . . . . . Type (
   28: 55: . . . . . . . . . TypeName (
   28: 55: . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   28: 58: . . . . . . . . . )
   28: 58: . . . . . . . . )
   28: 58: . . . . . . . )
   28: 58: . . . . . . . ","
   28: 60: . . . . . . . ParamDeclOrNil (
   28: 60: . . . . . . . . IDENT err
 /app/parser/parser.go:713: ast.Ident{Name: err}
   28: 64: . . . . . . . . Type (
   28: 64: . . . . . . . . . TypeName (
   28: 64: . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   28: 69: . . . . . . . . . )
   28: 69: . . . . . . . . )
   28: 69: . . . . . . . )
   28: 69: . . . . . . )
   28: 69: . . . . . . ")"
   28: 71: . . . . . )
   28: 71: . . . . )
   28: 71: . . . )
   28: 71: . . . Body (
   28: 71: . . . . "{"
   29:  2: . . . . StatementList (
   29:  2: . . . . . Statement (
   29:  2: . . . . . . ReturnStmt (
   29:  2: . . . . . . . "return"
   29:  8: . . . . . . . ";"
   30:  1: . . . . . . )
   30:  1: . . . . . )
   30:  1: . . . . )
   30:  1: . . . . "}"
   30:  2: . . . )
   30:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
   30:  3: . . )
   30:  3: . )
   30:  3: )
=== RUN   TestFromTestdata/gmxtest
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/gmxtest
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  7: . . . . . . . . . . )
    1:  7: . . . . . . . . . )
    1:  7: . . . . . . . . )
    1:  7: . . . . . . . )
    1:  7: . . . . . . )
    1:  7: . . . . . )
    1:  7: . . . . )
    1:  7: . . . . ";"
    1:  8: . . . )
    1:  8: . . )
    1:  8: . )
    1:  8: )
=== RUN   TestFromTestdata/goto1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/goto1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . BranchStmt (
    1:  1: . . . . . "goto"
    1:  1: . . . . . SimpleStmt (
    1:  1: . . . . . . ExpressionList (
    1:  1: . . . . . . . Expression (
    1:  1: . . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . . Operand (
 /app/parser/parser.go:713: ast.Ident{Name: goto}
    1:  6: . . . . . . . . . . . )
    1:  6: . . . . . . . . . . . CallOrConversion (
    1:  6: . . . . . . . . . . . . Expression (
    1:  6: . . . . . . . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . . . . . . . STRING "a"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a"}
    1:  9: . . . . . . . . . . . . . . . . )
    1:  9: . . . . . . . . . . . . . . . )
    1:  9: . . . . . . . . . . . . . . )
    1:  9: . . . . . . . . . . . . . )
    1:  9: . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: goto, Ellipsis: false, isCmd: true}
    1:  9: . . . . . . . . . . . )
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . )
    1:  9: . . . . . . . . )
    1:  9: . . . . . . . )
    1:  9: . . . . . . )
    1:  9: . . . . . )
    1:  9: . . . . . ";"
    2:  1: . . . . )
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . BranchStmt (
    2:  1: . . . . . "goto"
    2:  1: . . . . . SimpleStmt (
    2:  1: . . . . . . ExpressionList (
    2:  1: . . . . . . . Expression (
    2:  1: . . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . . Operand (
 /app/parser/parser.go:713: ast.Ident{Name: goto}
    2:  6: . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . CallOrConversion (
    2:  6: . . . . . . . . . . . . Expression (
    2:  6: . . . . . . . . . . . . . BinaryExpr (
    2:  6: . . . . . . . . . . . . . . UnaryExpr (
    2:  6: . . . . . . . . . . . . . . . PrimaryExpr (
    2:  6: . . . . . . . . . . . . . . . . Operand (
    2:  6: . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2:  7: . . . . . . . . . . . . . . . . )
    2:  7: . . . . . . . . . . . . . . . )
    2:  7: . . . . . . . . . . . . . . )
    2:  7: . . . . . . . . . . . . . )
    2:  7: . . . . . . . . . . . . )
    2:  7: . . . . . . . . . . . . ","
    2:  9: . . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    2: 10: . . . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: goto, Ellipsis: false, isCmd: true}
    2: 10: . . . . . . . . . . . )
    2: 10: . . . . . . . . . . )
    2: 10: . . . . . . . . . )
    2: 10: . . . . . . . . )
    2: 10: . . . . . . . )
    2: 10: . . . . . . )
    2: 10: . . . . . )
    2: 10: . . . . . ";"
    3:  1: . . . . )
    3:  1: . . . )
    3:  1: . . . Statement (
    3:  1: . . . . BranchStmt (
    3:  1: . . . . . "goto"
    3:  1: . . . . . SimpleStmt (
    3:  1: . . . . . . ExpressionList (
    3:  1: . . . . . . . Expression (
    3:  1: . . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . . Operand (
 /app/parser/parser.go:713: ast.Ident{Name: goto}
    3:  6: . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . CallOrConversion (
    3:  6: . . . . . . . . . . . . Expression (
    3:  6: . . . . . . . . . . . . . BinaryExpr (
    3:  6: . . . . . . . . . . . . . . UnaryExpr (
    3:  6: . . . . . . . . . . . . . . . PrimaryExpr (
    3:  6: . . . . . . . . . . . . . . . . Operand (
    3:  6: . . . . . . . . . . . . . . . . . "("
    3:  7: . . . . . . . . . . . . . . . . . Expression (
    3:  7: . . . . . . . . . . . . . . . . . . BinaryExpr (
    3:  7: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3:  7: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3:  7: . . . . . . . . . . . . . . . . . . . . . Operand (
    3:  7: . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    3:  8: . . . . . . . . . . . . . . . . . . . . . )
    3:  8: . . . . . . . . . . . . . . . . . . . . )
    3:  8: . . . . . . . . . . . . . . . . . . . )
    3:  8: . . . . . . . . . . . . . . . . . . . "+"
    3:  9: . . . . . . . . . . . . . . . . . . . BinaryExpr (
    3:  9: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3:  9: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3:  9: . . . . . . . . . . . . . . . . . . . . . . Operand (
    3:  9: . . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    3: 10: . . . . . . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: &{0xc000208ff0 27 + 0xc000209020}}
    3: 11: . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . "*"
    3: 12: . . . . . . . . . . . . . . BinaryExpr (
    3: 12: . . . . . . . . . . . . . . . UnaryExpr (
    3: 12: . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 12: . . . . . . . . . . . . . . . . . Operand (
    3: 12: . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    3: 13: . . . . . . . . . . . . . . . . . )
    3: 13: . . . . . . . . . . . . . . . . )
    3: 13: . . . . . . . . . . . . . . . )
    3: 13: . . . . . . . . . . . . . . )
    3: 13: . . . . . . . . . . . . . )
    3: 13: . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: goto, Ellipsis: false, isCmd: true}
    3: 13: . . . . . . . . . . . )
    3: 13: . . . . . . . . . . )
    3: 13: . . . . . . . . . )
    3: 13: . . . . . . . . )
    3: 13: . . . . . . . )
    3: 13: . . . . . . )
    3: 13: . . . . . )
    3: 13: . . . . . ";"
    3: 14: . . . . )
    3: 14: . . . )
    3: 14: . . )
    3: 14: . )
    3: 14: )
=== RUN   TestFromTestdata/goto2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/goto2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . BranchStmt (
    1:  1: . . . . . "goto"
    1:  6: . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1:  6: . . . . . PrimaryExpr (
    1:  6: . . . . . . CallOrConversion (
    1:  6: . . . . . . . Expression (
    1:  6: . . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . . Operand (
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1:  7: . . . . . . . . . . . )
    1:  7: . . . . . . . . . . )
    1:  7: . . . . . . . . . )
    1:  7: . . . . . . . . . "+"
    1:  8: . . . . . . . . . BinaryExpr (
    1:  8: . . . . . . . . . . UnaryExpr (
    1:  8: . . . . . . . . . . . PrimaryExpr (
    1:  8: . . . . . . . . . . . . Operand (
    1:  8: . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    1:  9: . . . . . . . . . . . . )
    1:  9: . . . . . . . . . . . )
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . )
    1:  9: . . . . . . . . )
    1:  9: . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: goto, Ellipsis: false, isCmd: true}
    1:  9: . . . . . . )
    1:  9: . . . . . )
    1:  9: . . . . . ";"
    2:  1: . . . . )
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . BranchStmt (
    2:  1: . . . . . "goto"
    2:  6: . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2:  6: . . . . . PrimaryExpr (
    2:  6: . . . . . . CallOrConversion (
    2:  6: . . . . . . . Expression (
    2:  6: . . . . . . . . BinaryExpr (
    2:  6: . . . . . . . . . UnaryExpr (
    2:  6: . . . . . . . . . . PrimaryExpr (
    2:  6: . . . . . . . . . . . Operand (
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2:  7: . . . . . . . . . . . )
    2:  7: . . . . . . . . . . )
    2:  7: . . . . . . . . . )
    2:  7: . . . . . . . . )
    2:  7: . . . . . . . )
    2:  7: . . . . . . . ","
    2:  9: . . . . . . . Expression (
    2:  9: . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    2: 10: . . . . . . . . . . . )
    2: 10: . . . . . . . . . . )
    2: 10: . . . . . . . . . )
    2: 10: . . . . . . . . )
    2: 10: . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: goto, Ellipsis: false, isCmd: true}
    2: 10: . . . . . . )
    2: 10: . . . . . )
    2: 10: . . . . . ";"
    2: 11: . . . . )
    2: 11: . . . )
    2: 11: . . )
    2: 11: . )
    2: 11: )
=== RUN   TestFromTestdata/goxtest1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/goxtest1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . GenDecl(var) (
    1:  1: . . . "var"
    1:  5: . . . "("
    2:  2: . . . varSpec (
    2:  2: . . . . IDENT A
 /app/parser/parser.go:713: ast.Ident{Name: A}
    2:  4: . . . . STRING `json:"a"`
    2: 14: . . . . ";"
    3:  2: . . . )
    3:  2: . . . varSpec (
    3:  2: . . . . "*"
    3:  3: . . . . IDENT B
 /app/parser/parser.go:713: ast.Ident{Name: B}
    3:  4: . . . . ";"
    4:  2: . . . )
    4:  2: . . . varSpec (
    4:  2: . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4:  3: . . . . ","
    4:  5: . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    4:  7: . . . . TypeName (
    4:  7: . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    4: 13: . . . . )
    4: 13: . . . . ";"
    5:  2: . . . )
    5:  2: . . . varSpec (
    5:  2: . . . . IDENT C
 /app/parser/parser.go:713: ast.Ident{Name: C}
    5:  3: . . . . "."
    5:  4: . . . . IDENT A
 /app/parser/parser.go:713: ast.Ident{Name: A}
    5:  7: . . . . STRING `json:"ca"`
    5: 18: . . . . ";"
    6:  2: . . . )
    6:  2: . . . varSpec (
    6:  2: . . . . "*"
    6:  3: . . . . IDENT C
 /app/parser/parser.go:713: ast.Ident{Name: C}
    6:  4: . . . . "."
    6:  5: . . . . IDENT B
 /app/parser/parser.go:713: ast.Ident{Name: B}
    6:  7: . . . . STRING `json:"b"`
    6: 17: . . . . ";"
    7:  2: . . . )
    7:  2: . . . varSpec (
    7:  2: . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
    7:  7: . . . . TypeName (
    7:  7: . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    7: 11: . . . . )
    7: 11: . . . . STRING `json:"v"`
    7: 21: . . . . ";"
    8:  1: . . . )
    8:  1: . . . ")"
    8:  2: . . . ";"
   10:  1: . . )
   10:  1: . )
   10:  1: . Declaration (
   10:  1: . . GenDecl(type) (
   10:  1: . . . "type"
   10:  6: . . . TypeSpec (
   10:  6: . . . . IDENT A
 /app/parser/parser.go:713: ast.Ident{Name: A}
   10:  8: . . . . Type (
   10:  8: . . . . . StructType (
   10:  8: . . . . . . "struct"
   10: 14: . . . . . . "{"
   10: 15: . . . . . . "}"
   10: 16: . . . . . )
   10: 16: . . . . )
   10: 16: . . . . ";"
   12:  1: . . . )
   12:  1: . . )
   12:  1: . )
   12:  1: . Declaration (
   12:  1: . . GenDecl(type) (
   12:  1: . . . "type"
   12:  6: . . . TypeSpec (
   12:  6: . . . . IDENT B
 /app/parser/parser.go:713: ast.Ident{Name: B}
   12:  8: . . . . Type (
   12:  8: . . . . . StructType (
   12:  8: . . . . . . "struct"
   12: 14: . . . . . . "{"
   12: 15: . . . . . . "}"
   12: 16: . . . . . )
   12: 16: . . . . )
   12: 16: . . . . ";"
   12: 17: . . . )
   12: 17: . . )
   12: 17: . )
   12: 17: )
=== RUN   TestFromTestdata/goxtest2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/goxtest2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . GenDecl(var) (
    1:  1: . . . "var"
    1:  5: . . . "("
    2:  2: . . . varSpec (
    2:  2: . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2:  3: . . . . "."
    2:  4: . . . . IDENT App
 /app/parser/parser.go:713: ast.Ident{Name: App}
    2:  7: . . . . ";"
    3:  1: . . . )
    3:  1: . . . ")"
    3:  2: . . . ";"
    3:  3: . . )
    3:  3: . )
    3:  3: )
=== RUN   TestFromTestdata/kwargs1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/kwargs1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT playSound
 /app/parser/parser.go:713: ast.Ident{Name: playSound}
    1: 11: . . . . . . . . . . )
    1: 11: . . . . . . . . . . CallOrConversion (
    1: 11: . . . . . . . . . . . Expression (
    1: 11: . . . . . . . . . . . . BinaryExpr (
    1: 11: . . . . . . . . . . . . . UnaryExpr (
    1: 11: . . . . . . . . . . . . . . PrimaryExpr (
    1: 11: . . . . . . . . . . . . . . . Operand (
    1: 11: . . . . . . . . . . . . . . . . IDENT getUrl
 /app/parser/parser.go:713: ast.Ident{Name: getUrl}
    1: 17: . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . CallOrConversion (
    1: 17: . . . . . . . . . . . . . . . . "("
    1: 18: . . . . . . . . . . . . . . . . Expression (
    1: 18: . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 18: . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 18: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 18: . . . . . . . . . . . . . . . . . . . . Operand (
    1: 18: . . . . . . . . . . . . . . . . . . . . . STRING "1.mp3"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "1.mp3"}
    1: 25: . . . . . . . . . . . . . . . . . . . . )
    1: 25: . . . . . . . . . . . . . . . . . . . )
    1: 25: . . . . . . . . . . . . . . . . . . )
    1: 25: . . . . . . . . . . . . . . . . . )
    1: 25: . . . . . . . . . . . . . . . . )
    1: 25: . . . . . . . . . . . . . . . . ","
    1: 27: . . . . . . . . . . . . . . . . Expression (
    1: 27: . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 27: . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 27: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 27: . . . . . . . . . . . . . . . . . . . . Operand (
    1: 27: . . . . . . . . . . . . . . . . . . . . . IDENT cache
 /app/parser/parser.go:713: ast.Ident{Name: cache}
    1: 33: . . . . . . . . . . . . . . . . . . . . )
    1: 33: . . . . . . . . . . . . . . . . . . . . "="
    1: 35: . . . . . . . . . . . . . . . . . . . . Expression (
    1: 35: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 35: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 35: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 35: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    1: 35: . . . . . . . . . . . . . . . . . . . . . . . . . IDENT false
 /app/parser/parser.go:713: ast.Ident{Name: false}
    1: 40: . . . . . . . . . . . . . . . . . . . . . . . . )
    1: 40: . . . . . . . . . . . . . . . . . . . . . . . )
    1: 40: . . . . . . . . . . . . . . . . . . . . . . )
    1: 40: . . . . . . . . . . . . . . . . . . . . . )
    1: 40: . . . . . . . . . . . . . . . . . . . . )
    1: 40: . . . . . . . . . . . . . . . . . . . )
    1: 40: . . . . . . . . . . . . . . . . . . )
    1: 40: . . . . . . . . . . . . . . . . . )
    1: 40: . . . . . . . . . . . . . . . . )
    1: 40: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: getUrl, Ellipsis: false, isCmd: false}
    1: 41: . . . . . . . . . . . . . . . )
    1: 41: . . . . . . . . . . . . . . )
    1: 41: . . . . . . . . . . . . . )
    1: 41: . . . . . . . . . . . . )
    1: 41: . . . . . . . . . . . )
    1: 41: . . . . . . . . . . . ","
    1: 43: . . . . . . . . . . . Expression (
    1: 43: . . . . . . . . . . . . BinaryExpr (
    1: 43: . . . . . . . . . . . . . UnaryExpr (
    1: 43: . . . . . . . . . . . . . . PrimaryExpr (
    1: 43: . . . . . . . . . . . . . . . Operand (
    1: 43: . . . . . . . . . . . . . . . . IDENT loop
 /app/parser/parser.go:713: ast.Ident{Name: loop}
    1: 48: . . . . . . . . . . . . . . . )
    1: 48: . . . . . . . . . . . . . . . "="
    1: 50: . . . . . . . . . . . . . . . Expression (
    1: 50: . . . . . . . . . . . . . . . . BinaryExpr (
    1: 50: . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 50: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 50: . . . . . . . . . . . . . . . . . . . Operand (
    1: 50: . . . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
    1: 54: . . . . . . . . . . . . . . . . . . . )
    1: 54: . . . . . . . . . . . . . . . . . . )
    1: 54: . . . . . . . . . . . . . . . . . )
    1: 54: . . . . . . . . . . . . . . . . )
    1: 54: . . . . . . . . . . . . . . . )
    1: 54: . . . . . . . . . . . . . . )
    1: 54: . . . . . . . . . . . . . )
    1: 54: . . . . . . . . . . . . )
    1: 54: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: playSound, Ellipsis: false, isCmd: true}
    1: 54: . . . . . . . . . . )
    1: 54: . . . . . . . . . )
    1: 54: . . . . . . . . )
    1: 54: . . . . . . . )
    1: 54: . . . . . . )
    1: 54: . . . . . )
    1: 54: . . . . )
    1: 54: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT listDir
 /app/parser/parser.go:713: ast.Ident{Name: listDir}
    2:  9: . . . . . . . . . . )
    2:  9: . . . . . . . . . . CallOrConversion (
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . IDENT withHidden
 /app/parser/parser.go:713: ast.Ident{Name: withHidden}
    2: 20: . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . . "="
    2: 22: . . . . . . . . . . . . . . . Expression (
    2: 22: . . . . . . . . . . . . . . . . BinaryExpr (
    2: 22: . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 22: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 22: . . . . . . . . . . . . . . . . . . . Operand (
    2: 22: . . . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
    2: 26: . . . . . . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . ","
    2: 28: . . . . . . . . . . . Expression (
    2: 28: . . . . . . . . . . . . BinaryExpr (
    2: 28: . . . . . . . . . . . . . UnaryExpr (
    2: 28: . . . . . . . . . . . . . . PrimaryExpr (
    2: 28: . . . . . . . . . . . . . . . Operand (
    2: 28: . . . . . . . . . . . . . . . . IDENT recursive
 /app/parser/parser.go:713: ast.Ident{Name: recursive}
    2: 38: . . . . . . . . . . . . . . . )
    2: 38: . . . . . . . . . . . . . . . "="
    2: 40: . . . . . . . . . . . . . . . Expression (
    2: 40: . . . . . . . . . . . . . . . . BinaryExpr (
    2: 40: . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 40: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 40: . . . . . . . . . . . . . . . . . . . Operand (
    2: 40: . . . . . . . . . . . . . . . . . . . . IDENT false
 /app/parser/parser.go:713: ast.Ident{Name: false}
    2: 45: . . . . . . . . . . . . . . . . . . . )
    2: 45: . . . . . . . . . . . . . . . . . . )
    2: 45: . . . . . . . . . . . . . . . . . )
    2: 45: . . . . . . . . . . . . . . . . )
    2: 45: . . . . . . . . . . . . . . . )
    2: 45: . . . . . . . . . . . . . . )
    2: 45: . . . . . . . . . . . . . )
    2: 45: . . . . . . . . . . . . )
    2: 45: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: listDir, Ellipsis: false, isCmd: true}
    2: 45: . . . . . . . . . . )
    2: 45: . . . . . . . . . )
    2: 45: . . . . . . . . )
    2: 45: . . . . . . . )
    2: 45: . . . . . . )
    2: 45: . . . . . )
    2: 45: . . . . )
    2: 45: . . . . ";"
    2: 46: . . . )
    2: 46: . . )
    2: 46: . )
    2: 46: )
=== RUN   TestFromTestdata/lambda1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/lambda1
    1:  1: File (
    1:  1: . "package"
    1:  9: . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    1: 13: . ";"
    3:  1: . Declaration (
    3:  1: . . FunctionDeclOrCall (
    3:  1: . . . "func"
    3:  6: . . . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    3: 10: . . . Signature (
    3: 10: . . . . Parameters (
    3: 10: . . . . . "("
    3: 11: . . . . . ")"
    3: 13: . . . . )
    3: 13: . . . . Result (
    3: 13: . . . . )
    3: 13: . . . )
    3: 13: . . . Body (
    3: 13: . . . . "{"
    4:  2: . . . . StatementList (
    4:  2: . . . . . Statement (
    4:  2: . . . . . . SimpleStmt (
    4:  2: . . . . . . . ExpressionList (
    4:  2: . . . . . . . . Expression (
    4:  2: . . . . . . . . . BinaryExpr (
    4:  2: . . . . . . . . . . UnaryExpr (
    4:  2: . . . . . . . . . . . PrimaryExpr (
    4:  2: . . . . . . . . . . . . Operand (
    4:  2: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    4:  5: . . . . . . . . . . . . )
    4:  5: . . . . . . . . . . . . CallOrConversion (
    4:  5: . . . . . . . . . . . . . "("
    4:  6: . . . . . . . . . . . . . Expression (
    4:  6: . . . . . . . . . . . . . . "=>"
    4:  9: . . . . . . . . . . . . . . Expression (
    4:  9: . . . . . . . . . . . . . . . BinaryExpr (
    4:  9: . . . . . . . . . . . . . . . . UnaryExpr (
    4:  9: . . . . . . . . . . . . . . . . . PrimaryExpr (
    4:  9: . . . . . . . . . . . . . . . . . . Operand (
    4:  9: . . . . . . . . . . . . . . . . . . . STRING "Hi"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hi"}
    4: 13: . . . . . . . . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
    4: 13: . . . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
    4: 14: . . . . . . . . . . . . )
    4: 14: . . . . . . . . . . . )
    4: 14: . . . . . . . . . . )
    4: 14: . . . . . . . . . )
    4: 14: . . . . . . . . )
    4: 14: . . . . . . . )
    4: 14: . . . . . . )
    4: 14: . . . . . . ";"
    5:  2: . . . . . )
    5:  2: . . . . . Statement (
    5:  2: . . . . . . SimpleStmt (
    5:  2: . . . . . . . ExpressionList (
    5:  2: . . . . . . . . Expression (
    5:  2: . . . . . . . . . BinaryExpr (
    5:  2: . . . . . . . . . . UnaryExpr (
    5:  2: . . . . . . . . . . . PrimaryExpr (
    5:  2: . . . . . . . . . . . . Operand (
    5:  2: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    5:  5: . . . . . . . . . . . . )
    5:  5: . . . . . . . . . . . . CallOrConversion (
    5:  5: . . . . . . . . . . . . . "("
    5:  6: . . . . . . . . . . . . . Expression (
    5:  6: . . . . . . . . . . . . . . BinaryExpr (
    5:  6: . . . . . . . . . . . . . . . UnaryExpr (
    5:  6: . . . . . . . . . . . . . . . . PrimaryExpr (
    5:  6: . . . . . . . . . . . . . . . . . Operand (
    5:  6: . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    5:  8: . . . . . . . . . . . . . . . . . )
    5:  8: . . . . . . . . . . . . . . . . )
    5:  8: . . . . . . . . . . . . . . . )
    5:  8: . . . . . . . . . . . . . . )
    5:  8: . . . . . . . . . . . . . . "=>"
    5: 11: . . . . . . . . . . . . . . Expression (
    5: 11: . . . . . . . . . . . . . . . BinaryExpr (
    5: 11: . . . . . . . . . . . . . . . . UnaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . Operand (
    5: 11: . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    5: 13: . . . . . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . . . . "*"
    5: 15: . . . . . . . . . . . . . . . . BinaryExpr (
    5: 15: . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 15: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 15: . . . . . . . . . . . . . . . . . . . Operand (
    5: 15: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    5: 16: . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: [x]}
    5: 16: . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
    5: 17: . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . )
    5: 17: . . . . . . . . . . )
    5: 17: . . . . . . . . . )
    5: 17: . . . . . . . . )
    5: 17: . . . . . . . )
    5: 17: . . . . . . )
    5: 17: . . . . . . ";"
    6:  2: . . . . . )
    6:  2: . . . . . Statement (
    6:  2: . . . . . . SimpleStmt (
    6:  2: . . . . . . . ExpressionList (
    6:  2: . . . . . . . . Expression (
    6:  2: . . . . . . . . . BinaryExpr (
    6:  2: . . . . . . . . . . UnaryExpr (
    6:  2: . . . . . . . . . . . PrimaryExpr (
    6:  2: . . . . . . . . . . . . Operand (
    6:  2: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    6:  5: . . . . . . . . . . . . )
    6:  5: . . . . . . . . . . . . CallOrConversion (
    6:  5: . . . . . . . . . . . . . "("
    6:  6: . . . . . . . . . . . . . Expression (
    6:  6: . . . . . . . . . . . . . . BinaryExpr (
    6:  6: . . . . . . . . . . . . . . . UnaryExpr (
    6:  6: . . . . . . . . . . . . . . . . PrimaryExpr (
    6:  6: . . . . . . . . . . . . . . . . . Operand (
    6:  6: . . . . . . . . . . . . . . . . . . "("
    6:  7: . . . . . . . . . . . . . . . . . . Expression (
    6:  7: . . . . . . . . . . . . . . . . . . . BinaryExpr (
    6:  7: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    6:  7: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6:  7: . . . . . . . . . . . . . . . . . . . . . . Operand (
    6:  7: . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    6:  8: . . . . . . . . . . . . . . . . . . . . . . )
    6:  8: . . . . . . . . . . . . . . . . . . . . . )
    6:  8: . . . . . . . . . . . . . . . . . . . . )
    6:  8: . . . . . . . . . . . . . . . . . . . )
    6:  8: . . . . . . . . . . . . . . . . . . )
    6:  8: . . . . . . . . . . . . . . . . . . ","
    6: 10: . . . . . . . . . . . . . . . . . . Expression (
    6: 10: . . . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 10: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 10: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 10: . . . . . . . . . . . . . . . . . . . . . . Operand (
    6: 10: . . . . . . . . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    6: 11: . . . . . . . . . . . . . . . . . . . . . . )
    6: 11: . . . . . . . . . . . . . . . . . . . . . )
    6: 11: . . . . . . . . . . . . . . . . . . . . )
    6: 11: . . . . . . . . . . . . . . . . . . . )
    6: 11: . . . . . . . . . . . . . . . . . . )
    6: 11: . . . . . . . . . . . . . . . . . . ")"
    6: 13: . . . . . . . . . . . . . . . . . )
    6: 13: . . . . . . . . . . . . . . . . )
    6: 13: . . . . . . . . . . . . . . . )
    6: 13: . . . . . . . . . . . . . . )
    6: 13: . . . . . . . . . . . . . . "=>"
    6: 16: . . . . . . . . . . . . . . Expression (
    6: 16: . . . . . . . . . . . . . . . BinaryExpr (
    6: 16: . . . . . . . . . . . . . . . . UnaryExpr (
    6: 16: . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 16: . . . . . . . . . . . . . . . . . . Operand (
    6: 16: . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    6: 18: . . . . . . . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . . . . . . "+"
    6: 20: . . . . . . . . . . . . . . . . BinaryExpr (
    6: 20: . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 20: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 20: . . . . . . . . . . . . . . . . . . . Operand (
    6: 20: . . . . . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    6: 21: . . . . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: [x y]}
    6: 21: . . . . . . . . . . . . . )
    6: 21: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
    6: 22: . . . . . . . . . . . . )
    6: 22: . . . . . . . . . . . )
    6: 22: . . . . . . . . . . )
    6: 22: . . . . . . . . . )
    6: 22: . . . . . . . . )
    6: 22: . . . . . . . )
    6: 22: . . . . . . )
    6: 22: . . . . . . ";"
    7:  2: . . . . . )
    7:  2: . . . . . Statement (
    7:  2: . . . . . . SimpleStmt (
    7:  2: . . . . . . . ExpressionList (
    7:  2: . . . . . . . . Expression (
    7:  2: . . . . . . . . . BinaryExpr (
    7:  2: . . . . . . . . . . UnaryExpr (
    7:  2: . . . . . . . . . . . PrimaryExpr (
    7:  2: . . . . . . . . . . . . Operand (
    7:  2: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    7:  5: . . . . . . . . . . . . )
    7:  5: . . . . . . . . . . . . CallOrConversion (
    7:  5: . . . . . . . . . . . . . "("
    7:  6: . . . . . . . . . . . . . Expression (
    7:  6: . . . . . . . . . . . . . . BinaryExpr (
    7:  6: . . . . . . . . . . . . . . . UnaryExpr (
    7:  6: . . . . . . . . . . . . . . . . PrimaryExpr (
    7:  6: . . . . . . . . . . . . . . . . . Operand (
    7:  6: . . . . . . . . . . . . . . . . . . "("
    7:  7: . . . . . . . . . . . . . . . . . . Expression (
    7:  7: . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7:  7: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7:  7: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7:  7: . . . . . . . . . . . . . . . . . . . . . . Operand (
    7:  7: . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    7:  8: . . . . . . . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: x}
    7: 10: . . . . . . . . . . . . . . . . . )
    7: 10: . . . . . . . . . . . . . . . . )
    7: 10: . . . . . . . . . . . . . . . )
    7: 10: . . . . . . . . . . . . . . )
    7: 10: . . . . . . . . . . . . . . "=>"
    7: 13: . . . . . . . . . . . . . . "("
    7: 14: . . . . . . . . . . . . . . Expression (
    7: 14: . . . . . . . . . . . . . . . BinaryExpr (
    7: 14: . . . . . . . . . . . . . . . . UnaryExpr (
    7: 14: . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 14: . . . . . . . . . . . . . . . . . . Operand (
    7: 14: . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    7: 15: . . . . . . . . . . . . . . . . . . )
    7: 15: . . . . . . . . . . . . . . . . . )
    7: 15: . . . . . . . . . . . . . . . . )
    7: 15: . . . . . . . . . . . . . . . )
    7: 15: . . . . . . . . . . . . . . )
    7: 15: . . . . . . . . . . . . . . ","
    7: 17: . . . . . . . . . . . . . . Expression (
    7: 17: . . . . . . . . . . . . . . . BinaryExpr (
    7: 17: . . . . . . . . . . . . . . . . UnaryExpr (
    7: 17: . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 17: . . . . . . . . . . . . . . . . . . Operand (
    7: 17: . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    7: 19: . . . . . . . . . . . . . . . . . . )
    7: 19: . . . . . . . . . . . . . . . . . )
    7: 19: . . . . . . . . . . . . . . . . )
    7: 19: . . . . . . . . . . . . . . . . "*"
    7: 21: . . . . . . . . . . . . . . . . BinaryExpr (
    7: 21: . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 21: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 21: . . . . . . . . . . . . . . . . . . . Operand (
    7: 21: . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    7: 22: . . . . . . . . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: [x]}
    7: 23: . . . . . . . . . . . . . )
    7: 23: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
    7: 24: . . . . . . . . . . . . )
    7: 24: . . . . . . . . . . . )
    7: 24: . . . . . . . . . . )
    7: 24: . . . . . . . . . )
    7: 24: . . . . . . . . )
    7: 24: . . . . . . . )
    7: 24: . . . . . . )
    7: 24: . . . . . . ";"
    8:  2: . . . . . )
    8:  2: . . . . . Statement (
    8:  2: . . . . . . SimpleStmt (
    8:  2: . . . . . . . ExpressionList (
    8:  2: . . . . . . . . Expression (
    8:  2: . . . . . . . . . BinaryExpr (
    8:  2: . . . . . . . . . . UnaryExpr (
    8:  2: . . . . . . . . . . . PrimaryExpr (
    8:  2: . . . . . . . . . . . . Operand (
    8:  2: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    8:  5: . . . . . . . . . . . . )
    8:  5: . . . . . . . . . . . . CallOrConversion (
    8:  5: . . . . . . . . . . . . . "("
    8:  6: . . . . . . . . . . . . . Expression (
    8:  6: . . . . . . . . . . . . . . BinaryExpr (
    8:  6: . . . . . . . . . . . . . . . UnaryExpr (
    8:  6: . . . . . . . . . . . . . . . . PrimaryExpr (
    8:  6: . . . . . . . . . . . . . . . . . Operand (
    8:  6: . . . . . . . . . . . . . . . . . . "("
    8:  7: . . . . . . . . . . . . . . . . . . ")"
    8:  9: . . . . . . . . . . . . . . . . . )
    8:  9: . . . . . . . . . . . . . . . . )
    8:  9: . . . . . . . . . . . . . . . )
    8:  9: . . . . . . . . . . . . . . )
    8:  9: . . . . . . . . . . . . . . "=>"
    8: 12: . . . . . . . . . . . . . . Expression (
    8: 12: . . . . . . . . . . . . . . . BinaryExpr (
    8: 12: . . . . . . . . . . . . . . . . UnaryExpr (
    8: 12: . . . . . . . . . . . . . . . . . PrimaryExpr (
    8: 12: . . . . . . . . . . . . . . . . . . Operand (
    8: 12: . . . . . . . . . . . . . . . . . . . STRING "Hi"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hi"}
    8: 16: . . . . . . . . . . . . . . . . . . )
    8: 16: . . . . . . . . . . . . . . . . . )
    8: 16: . . . . . . . . . . . . . . . . )
    8: 16: . . . . . . . . . . . . . . . )
    8: 16: . . . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
    8: 16: . . . . . . . . . . . . . )
    8: 16: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
    8: 17: . . . . . . . . . . . . )
    8: 17: . . . . . . . . . . . )
    8: 17: . . . . . . . . . . )
    8: 17: . . . . . . . . . )
    8: 17: . . . . . . . . )
    8: 17: . . . . . . . )
    8: 17: . . . . . . )
    8: 17: . . . . . . ";"
    9:  1: . . . . . )
    9:  1: . . . . )
    9:  1: . . . . "}"
    9:  2: . . . )
    9:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: main, ...}
    9:  3: . . )
    9:  3: . )
    9:  3: )
=== RUN   TestFromTestdata/lambda2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/lambda2
    1:  1: File (
    1:  1: . "package"
    1:  9: . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    1: 13: . ";"
    3:  1: . Declaration (
    3:  1: . . FunctionDeclOrCall (
    3:  1: . . . "func"
    3:  6: . . . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    3: 10: . . . Signature (
    3: 10: . . . . Parameters (
    3: 10: . . . . . "("
    3: 11: . . . . . ")"
    3: 13: . . . . )
    3: 13: . . . . Result (
    3: 13: . . . . )
    3: 13: . . . )
    3: 13: . . . Body (
    3: 13: . . . . "{"
    4:  2: . . . . StatementList (
    4:  2: . . . . . Statement (
    4:  2: . . . . . . SimpleStmt (
    4:  2: . . . . . . . ExpressionList (
    4:  2: . . . . . . . . Expression (
    4:  2: . . . . . . . . . BinaryExpr (
    4:  2: . . . . . . . . . . UnaryExpr (
    4:  2: . . . . . . . . . . . PrimaryExpr (
    4:  2: . . . . . . . . . . . . Operand (
    4:  2: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    4:  5: . . . . . . . . . . . . )
    4:  5: . . . . . . . . . . . . CallOrConversion (
    4:  5: . . . . . . . . . . . . . "("
    4:  6: . . . . . . . . . . . . . Expression (
    4:  6: . . . . . . . . . . . . . . "=>"
    4:  9: . . . . . . . . . . . . . . BlockStmt (
    4:  9: . . . . . . . . . . . . . . . "{"
    5:  3: . . . . . . . . . . . . . . . StatementList (
    5:  3: . . . . . . . . . . . . . . . . Statement (
    5:  3: . . . . . . . . . . . . . . . . . SimpleStmt (
    5:  3: . . . . . . . . . . . . . . . . . . ExpressionList (
    5:  3: . . . . . . . . . . . . . . . . . . . Expression (
    5:  3: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5:  3: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5:  3: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5:  3: . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5:  3: . . . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5: 10: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
    5: 10: . . . . . . . . . . . . . . . . . . . . . . . . "("
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "Hi"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hi"}
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    5: 16: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . . . . ";"
    6:  2: . . . . . . . . . . . . . . . . )
    6:  2: . . . . . . . . . . . . . . . )
    6:  2: . . . . . . . . . . . . . . . "}"
    6:  3: . . . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
    6:  3: . . . . . . . . . . . . . )
    6:  3: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
    6:  4: . . . . . . . . . . . . )
    6:  4: . . . . . . . . . . . )
    6:  4: . . . . . . . . . . )
    6:  4: . . . . . . . . . )
    6:  4: . . . . . . . . )
    6:  4: . . . . . . . )
    6:  4: . . . . . . )
    6:  4: . . . . . . ";"
    7:  2: . . . . . )
    7:  2: . . . . . Statement (
    7:  2: . . . . . . SimpleStmt (
    7:  2: . . . . . . . ExpressionList (
    7:  2: . . . . . . . . Expression (
    7:  2: . . . . . . . . . BinaryExpr (
    7:  2: . . . . . . . . . . UnaryExpr (
    7:  2: . . . . . . . . . . . PrimaryExpr (
    7:  2: . . . . . . . . . . . . Operand (
    7:  2: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    7:  5: . . . . . . . . . . . . )
    7:  5: . . . . . . . . . . . . CallOrConversion (
    7:  5: . . . . . . . . . . . . . "("
    7:  6: . . . . . . . . . . . . . Expression (
    7:  6: . . . . . . . . . . . . . . BinaryExpr (
    7:  6: . . . . . . . . . . . . . . . UnaryExpr (
    7:  6: . . . . . . . . . . . . . . . . PrimaryExpr (
    7:  6: . . . . . . . . . . . . . . . . . Operand (
    7:  6: . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    7:  8: . . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . "=>"
    7: 11: . . . . . . . . . . . . . . BlockStmt (
    7: 11: . . . . . . . . . . . . . . . "{"
    8:  3: . . . . . . . . . . . . . . . StatementList (
    8:  3: . . . . . . . . . . . . . . . . Statement (
    8:  3: . . . . . . . . . . . . . . . . . SimpleStmt (
    8:  3: . . . . . . . . . . . . . . . . . . ExpressionList (
    8:  3: . . . . . . . . . . . . . . . . . . . Expression (
    8:  3: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    8:  3: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    8:  3: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    8:  3: . . . . . . . . . . . . . . . . . . . . . . . Operand (
    8:  3: . . . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    8: 10: . . . . . . . . . . . . . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
    8: 10: . . . . . . . . . . . . . . . . . . . . . . . . "("
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    8: 13: . . . . . . . . . . . . . . . . . . . . . . . )
    8: 13: . . . . . . . . . . . . . . . . . . . . . . )
    8: 13: . . . . . . . . . . . . . . . . . . . . . )
    8: 13: . . . . . . . . . . . . . . . . . . . . )
    8: 13: . . . . . . . . . . . . . . . . . . . )
    8: 13: . . . . . . . . . . . . . . . . . . )
    8: 13: . . . . . . . . . . . . . . . . . )
    8: 13: . . . . . . . . . . . . . . . . . ";"
    9:  2: . . . . . . . . . . . . . . . . )
    9:  2: . . . . . . . . . . . . . . . )
    9:  2: . . . . . . . . . . . . . . . "}"
    9:  3: . . . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: [x]}
    9:  3: . . . . . . . . . . . . . )
    9:  3: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
    9:  4: . . . . . . . . . . . . )
    9:  4: . . . . . . . . . . . )
    9:  4: . . . . . . . . . . )
    9:  4: . . . . . . . . . )
    9:  4: . . . . . . . . )
    9:  4: . . . . . . . )
    9:  4: . . . . . . )
    9:  4: . . . . . . ";"
   10:  2: . . . . . )
   10:  2: . . . . . Statement (
   10:  2: . . . . . . SimpleStmt (
   10:  2: . . . . . . . ExpressionList (
   10:  2: . . . . . . . . Expression (
   10:  2: . . . . . . . . . BinaryExpr (
   10:  2: . . . . . . . . . . UnaryExpr (
   10:  2: . . . . . . . . . . . PrimaryExpr (
   10:  2: . . . . . . . . . . . . Operand (
   10:  2: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   10:  5: . . . . . . . . . . . . )
   10:  5: . . . . . . . . . . . . CallOrConversion (
   10:  5: . . . . . . . . . . . . . "("
   10:  6: . . . . . . . . . . . . . Expression (
   10:  6: . . . . . . . . . . . . . . BinaryExpr (
   10:  6: . . . . . . . . . . . . . . . UnaryExpr (
   10:  6: . . . . . . . . . . . . . . . . PrimaryExpr (
   10:  6: . . . . . . . . . . . . . . . . . Operand (
   10:  6: . . . . . . . . . . . . . . . . . . "("
   10:  7: . . . . . . . . . . . . . . . . . . Expression (
   10:  7: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10:  7: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10:  7: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10:  7: . . . . . . . . . . . . . . . . . . . . . . Operand (
   10:  7: . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   10:  8: . . . . . . . . . . . . . . . . . . . . . . )
   10:  8: . . . . . . . . . . . . . . . . . . . . . )
   10:  8: . . . . . . . . . . . . . . . . . . . . )
   10:  8: . . . . . . . . . . . . . . . . . . . )
   10:  8: . . . . . . . . . . . . . . . . . . )
   10:  8: . . . . . . . . . . . . . . . . . . ","
   10: 10: . . . . . . . . . . . . . . . . . . Expression (
   10: 10: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 10: . . . . . . . . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
   10: 11: . . . . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . ")"
   10: 13: . . . . . . . . . . . . . . . . . )
   10: 13: . . . . . . . . . . . . . . . . )
   10: 13: . . . . . . . . . . . . . . . )
   10: 13: . . . . . . . . . . . . . . )
   10: 13: . . . . . . . . . . . . . . "=>"
   10: 16: . . . . . . . . . . . . . . BlockStmt (
   10: 16: . . . . . . . . . . . . . . . "{"
   11:  3: . . . . . . . . . . . . . . . StatementList (
   11:  3: . . . . . . . . . . . . . . . . Statement (
   11:  3: . . . . . . . . . . . . . . . . . SimpleStmt (
   11:  3: . . . . . . . . . . . . . . . . . . ExpressionList (
   11:  3: . . . . . . . . . . . . . . . . . . . Expression (
   11:  3: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   11:  3: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   11:  3: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   11:  3: . . . . . . . . . . . . . . . . . . . . . . . Operand (
   11:  3: . . . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   11: 10: . . . . . . . . . . . . . . . . . . . . . . . )
   11: 10: . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
   11: 10: . . . . . . . . . . . . . . . . . . . . . . . . "("
   11: 11: . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   11: 11: . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   11: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   11: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   11: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   11: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 12: . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 12: . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 12: . . . . . . . . . . . . . . . . . . . . . . . . ","
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
   11: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   11: 16: . . . . . . . . . . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . . . . . ";"
   12:  2: . . . . . . . . . . . . . . . . )
   12:  2: . . . . . . . . . . . . . . . )
   12:  2: . . . . . . . . . . . . . . . "}"
   12:  3: . . . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: [x y]}
   12:  3: . . . . . . . . . . . . . )
   12:  3: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: false}
   12:  4: . . . . . . . . . . . . )
   12:  4: . . . . . . . . . . . )
   12:  4: . . . . . . . . . . )
   12:  4: . . . . . . . . . )
   12:  4: . . . . . . . . )
   12:  4: . . . . . . . )
   12:  4: . . . . . . )
   12:  4: . . . . . . ";"
   13:  1: . . . . . )
   13:  1: . . . . )
   13:  1: . . . . "}"
   13:  2: . . . )
   13:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: main, ...}
   13:  3: . . )
   13:  3: . )
   13:  3: )
=== RUN   TestFromTestdata/lambda3
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/lambda3
    1:  1: File (
    1:  1: . "package"
    1:  9: . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    1: 13: . ";"
    3:  1: . Declaration (
    3:  1: . . FunctionDeclOrCall (
    3:  1: . . . "func"
    3:  6: . . . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    3: 10: . . . Signature (
    3: 10: . . . . Parameters (
    3: 10: . . . . . "("
    3: 11: . . . . . ")"
    3: 13: . . . . )
    3: 13: . . . . Result (
    3: 13: . . . . )
    3: 13: . . . )
    3: 13: . . . Body (
    3: 13: . . . . "{"
    4:  2: . . . . StatementList (
    4:  2: . . . . . Statement (
    4:  2: . . . . . . SimpleStmt (
    4:  2: . . . . . . . ExpressionList (
    4:  2: . . . . . . . . Expression (
    4:  2: . . . . . . . . . BinaryExpr (
    4:  2: . . . . . . . . . . UnaryExpr (
    4:  2: . . . . . . . . . . . PrimaryExpr (
    4:  2: . . . . . . . . . . . . Operand (
    4:  2: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    4:  6: . . . . . . . . . . . . )
    4:  6: . . . . . . . . . . . . CallOrConversion (
    4:  6: . . . . . . . . . . . . . Expression (
    4:  6: . . . . . . . . . . . . . . "=>"
    4:  9: . . . . . . . . . . . . . . BlockStmt (
    4:  9: . . . . . . . . . . . . . . . "{"
    5:  3: . . . . . . . . . . . . . . . StatementList (
    5:  3: . . . . . . . . . . . . . . . . Statement (
    5:  3: . . . . . . . . . . . . . . . . . SimpleStmt (
    5:  3: . . . . . . . . . . . . . . . . . . ExpressionList (
    5:  3: . . . . . . . . . . . . . . . . . . . Expression (
    5:  3: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5:  3: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5:  3: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5:  3: . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5:  3: . . . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "Hi"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hi"}
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    5: 15: . . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . )
    5: 15: . . . . . . . . . . . . . . . . . ";"
    6:  2: . . . . . . . . . . . . . . . . )
    6:  2: . . . . . . . . . . . . . . . )
    6:  2: . . . . . . . . . . . . . . . "}"
    6:  3: . . . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: []}
    6:  3: . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: true}
    6:  3: . . . . . . . . . . . . )
    6:  3: . . . . . . . . . . . )
    6:  3: . . . . . . . . . . )
    6:  3: . . . . . . . . . )
    6:  3: . . . . . . . . )
    6:  3: . . . . . . . )
    6:  3: . . . . . . )
    6:  3: . . . . . . ";"
    7:  2: . . . . . )
    7:  2: . . . . . Statement (
    7:  2: . . . . . . SimpleStmt (
    7:  2: . . . . . . . ExpressionList (
    7:  2: . . . . . . . . Expression (
    7:  2: . . . . . . . . . BinaryExpr (
    7:  2: . . . . . . . . . . UnaryExpr (
    7:  2: . . . . . . . . . . . PrimaryExpr (
    7:  2: . . . . . . . . . . . . Operand (
    7:  2: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    7:  6: . . . . . . . . . . . . )
    7:  6: . . . . . . . . . . . . CallOrConversion (
    7:  6: . . . . . . . . . . . . . Expression (
    7:  6: . . . . . . . . . . . . . . BinaryExpr (
    7:  6: . . . . . . . . . . . . . . . UnaryExpr (
    7:  6: . . . . . . . . . . . . . . . . PrimaryExpr (
    7:  6: . . . . . . . . . . . . . . . . . Operand (
    7:  6: . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    7:  8: . . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . "=>"
    7: 11: . . . . . . . . . . . . . . BlockStmt (
    7: 11: . . . . . . . . . . . . . . . "{"
    8:  3: . . . . . . . . . . . . . . . StatementList (
    8:  3: . . . . . . . . . . . . . . . . Statement (
    8:  3: . . . . . . . . . . . . . . . . . SimpleStmt (
    8:  3: . . . . . . . . . . . . . . . . . . ExpressionList (
    8:  3: . . . . . . . . . . . . . . . . . . . Expression (
    8:  3: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    8:  3: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    8:  3: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    8:  3: . . . . . . . . . . . . . . . . . . . . . . . Operand (
    8:  3: . . . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . )
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . Expression (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    8: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    8: 12: . . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . . . . . . ";"
    9:  2: . . . . . . . . . . . . . . . . )
    9:  2: . . . . . . . . . . . . . . . )
    9:  2: . . . . . . . . . . . . . . . "}"
    9:  3: . . . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: [x]}
    9:  3: . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: foo, Ellipsis: false, isCmd: true}
    9:  3: . . . . . . . . . . . . )
    9:  3: . . . . . . . . . . . )
    9:  3: . . . . . . . . . . )
    9:  3: . . . . . . . . . )
    9:  3: . . . . . . . . )
    9:  3: . . . . . . . )
    9:  3: . . . . . . )
    9:  3: . . . . . . ";"
   10:  1: . . . . . )
   10:  1: . . . . )
   10:  1: . . . . "}"
   10:  2: . . . )
   10:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: main, ...}
   10:  3: . . )
   10:  3: . )
   10:  3: )
=== RUN   TestFromTestdata/lambda4
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/lambda4
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . GenDecl(type) (
    1:  1: . . . "type"
    1:  6: . . . TypeSpec (
    1:  6: . . . . IDENT Foo
 /app/parser/parser.go:713: ast.Ident{Name: Foo}
    1: 10: . . . . Type (
    1: 10: . . . . . StructType (
    1: 10: . . . . . . "struct"
    1: 17: . . . . . . "{"
    2:  2: . . . . . . FieldDecl (
    2:  2: . . . . . . . IDENT Plot
 /app/parser/parser.go:713: ast.Ident{Name: Plot}
    2:  7: . . . . . . . Type (
    2:  7: . . . . . . . . FuncType (
    2:  7: . . . . . . . . . "func"
    2: 11: . . . . . . . . . Signature (
    2: 11: . . . . . . . . . . Parameters (
    2: 11: . . . . . . . . . . . "("
    2: 12: . . . . . . . . . . . ParameterList (
    2: 12: . . . . . . . . . . . . ParamDeclOrNil (
    2: 12: . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 14: . . . . . . . . . . . . . Type (
    2: 14: . . . . . . . . . . . . . . TypeName (
    2: 14: . . . . . . . . . . . . . . . IDENT float64
 /app/parser/parser.go:713: ast.Ident{Name: float64}
    2: 21: . . . . . . . . . . . . . . )
    2: 21: . . . . . . . . . . . . . )
    2: 21: . . . . . . . . . . . . )
    2: 21: . . . . . . . . . . . )
    2: 21: . . . . . . . . . . . ")"
    2: 23: . . . . . . . . . . )
    2: 23: . . . . . . . . . . Result (
    2: 23: . . . . . . . . . . . Parameters (
    2: 23: . . . . . . . . . . . . "("
    2: 24: . . . . . . . . . . . . ParameterList (
    2: 24: . . . . . . . . . . . . . ParamDeclOrNil (
    2: 24: . . . . . . . . . . . . . . IDENT float64
 /app/parser/parser.go:713: ast.Ident{Name: float64}
    2: 31: . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . ","
    2: 33: . . . . . . . . . . . . . ParamDeclOrNil (
    2: 33: . . . . . . . . . . . . . . IDENT float64
 /app/parser/parser.go:713: ast.Ident{Name: float64}
    2: 40: . . . . . . . . . . . . . )
    2: 40: . . . . . . . . . . . . )
    2: 40: . . . . . . . . . . . . ")"
    2: 41: . . . . . . . . . . . )
    2: 41: . . . . . . . . . . )
    2: 41: . . . . . . . . . )
    2: 41: . . . . . . . . )
    2: 41: . . . . . . . )
    2: 41: . . . . . . . ";"
    3:  1: . . . . . . )
    3:  1: . . . . . . "}"
    3:  2: . . . . . )
    3:  2: . . . . )
    3:  2: . . . . ";"
    5:  1: . . . )
    5:  1: . . )
    5:  1: . )
    5:  1: . Declaration (
    5:  1: . . StatementList (
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . "&"
    5:  2: . . . . . . . . . UnaryExpr (
    5:  2: . . . . . . . . . . PrimaryExpr (
    5:  2: . . . . . . . . . . . Operand (
    5:  2: . . . . . . . . . . . . IDENT Foo
 /app/parser/parser.go:713: ast.Ident{Name: Foo}
    5:  5: . . . . . . . . . . . )
    5:  5: . . . . . . . . . . . LiteralValue (
    5:  5: . . . . . . . . . . . . "{"
    6:  2: . . . . . . . . . . . . ElementList (
    6:  2: . . . . . . . . . . . . . Element (
    6:  2: . . . . . . . . . . . . . . Element (
    6:  2: . . . . . . . . . . . . . . . Expression (
    6:  2: . . . . . . . . . . . . . . . . BinaryExpr (
    6:  2: . . . . . . . . . . . . . . . . . UnaryExpr (
    6:  2: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6:  2: . . . . . . . . . . . . . . . . . . . Operand (
    6:  2: . . . . . . . . . . . . . . . . . . . . IDENT Plot
 /app/parser/parser.go:713: ast.Ident{Name: Plot}
    6:  6: . . . . . . . . . . . . . . . . . . . )
    6:  6: . . . . . . . . . . . . . . . . . . )
    6:  6: . . . . . . . . . . . . . . . . . )
    6:  6: . . . . . . . . . . . . . . . . )
    6:  6: . . . . . . . . . . . . . . . )
    6:  6: . . . . . . . . . . . . . . )
    6:  6: . . . . . . . . . . . . . . ":"
    6:  8: . . . . . . . . . . . . . . Element (
    6:  8: . . . . . . . . . . . . . . . Expression (
    6:  8: . . . . . . . . . . . . . . . . BinaryExpr (
    6:  8: . . . . . . . . . . . . . . . . . UnaryExpr (
    6:  8: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6:  8: . . . . . . . . . . . . . . . . . . . Operand (
    6:  8: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    6: 10: . . . . . . . . . . . . . . . . . . . )
    6: 10: . . . . . . . . . . . . . . . . . . )
    6: 10: . . . . . . . . . . . . . . . . . )
    6: 10: . . . . . . . . . . . . . . . . )
    6: 10: . . . . . . . . . . . . . . . . "=>"
    6: 13: . . . . . . . . . . . . . . . . "("
    6: 14: . . . . . . . . . . . . . . . . Expression (
    6: 14: . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 14: . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 14: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 14: . . . . . . . . . . . . . . . . . . . . Operand (
    6: 14: . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    6: 16: . . . . . . . . . . . . . . . . . . . . )
    6: 16: . . . . . . . . . . . . . . . . . . . )
    6: 16: . . . . . . . . . . . . . . . . . . )
    6: 16: . . . . . . . . . . . . . . . . . . "*"
    6: 18: . . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 18: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 18: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 18: . . . . . . . . . . . . . . . . . . . . . Operand (
    6: 18: . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    6: 19: . . . . . . . . . . . . . . . . . . . . . )
    6: 19: . . . . . . . . . . . . . . . . . . . . )
    6: 19: . . . . . . . . . . . . . . . . . . . )
    6: 19: . . . . . . . . . . . . . . . . . . )
    6: 19: . . . . . . . . . . . . . . . . . )
    6: 19: . . . . . . . . . . . . . . . . )
    6: 19: . . . . . . . . . . . . . . . . ","
    6: 21: . . . . . . . . . . . . . . . . Expression (
    6: 21: . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 21: . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 21: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 21: . . . . . . . . . . . . . . . . . . . . Operand (
    6: 21: . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    6: 23: . . . . . . . . . . . . . . . . . . . . )
    6: 23: . . . . . . . . . . . . . . . . . . . )
    6: 23: . . . . . . . . . . . . . . . . . . )
    6: 23: . . . . . . . . . . . . . . . . . . "*"
    6: 25: . . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 25: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 25: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 25: . . . . . . . . . . . . . . . . . . . . . Operand (
    6: 25: . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    6: 26: . . . . . . . . . . . . . . . . . . . . . )
    6: 26: . . . . . . . . . . . . . . . . . . . . )
    6: 26: . . . . . . . . . . . . . . . . . . . )
    6: 26: . . . . . . . . . . . . . . . . . . )
    6: 26: . . . . . . . . . . . . . . . . . )
    6: 26: . . . . . . . . . . . . . . . . )
    6: 26: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: [x]}
    6: 27: . . . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . )
    6: 27: . . . . . . . . . . . . . ","
    7:  1: . . . . . . . . . . . . )
    7:  1: . . . . . . . . . . . . "}"
    7:  2: . . . . . . . . . . . )
    7:  2: . . . . . . . . . . )
    7:  2: . . . . . . . . . )
    7:  2: . . . . . . . . )
    7:  2: . . . . . . . )
    7:  2: . . . . . . )
    7:  2: . . . . . )
    7:  2: . . . . )
    7:  2: . . . . ";"
    9:  1: . . . )
    9:  1: . . . Statement (
    9:  1: . . . . SimpleStmt (
    9:  1: . . . . . ExpressionList (
    9:  1: . . . . . . Expression (
    9:  1: . . . . . . . BinaryExpr (
    9:  1: . . . . . . . . UnaryExpr (
    9:  1: . . . . . . . . . "&"
    9:  2: . . . . . . . . . UnaryExpr (
    9:  2: . . . . . . . . . . PrimaryExpr (
    9:  2: . . . . . . . . . . . Operand (
    9:  2: . . . . . . . . . . . . IDENT Foo
 /app/parser/parser.go:713: ast.Ident{Name: Foo}
    9:  5: . . . . . . . . . . . )
    9:  5: . . . . . . . . . . . LiteralValue (
    9:  5: . . . . . . . . . . . . "{"
   10:  2: . . . . . . . . . . . . ElementList (
   10:  2: . . . . . . . . . . . . . Element (
   10:  2: . . . . . . . . . . . . . . Element (
   10:  2: . . . . . . . . . . . . . . . Expression (
   10:  2: . . . . . . . . . . . . . . . . BinaryExpr (
   10:  2: . . . . . . . . . . . . . . . . . UnaryExpr (
   10:  2: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10:  2: . . . . . . . . . . . . . . . . . . . Operand (
   10:  2: . . . . . . . . . . . . . . . . . . . . IDENT Plot
 /app/parser/parser.go:713: ast.Ident{Name: Plot}
   10:  6: . . . . . . . . . . . . . . . . . . . )
   10:  6: . . . . . . . . . . . . . . . . . . )
   10:  6: . . . . . . . . . . . . . . . . . )
   10:  6: . . . . . . . . . . . . . . . . )
   10:  6: . . . . . . . . . . . . . . . )
   10:  6: . . . . . . . . . . . . . . )
   10:  6: . . . . . . . . . . . . . . ":"
   10:  8: . . . . . . . . . . . . . . Element (
   10:  8: . . . . . . . . . . . . . . . Expression (
   10:  8: . . . . . . . . . . . . . . . . BinaryExpr (
   10:  8: . . . . . . . . . . . . . . . . . UnaryExpr (
   10:  8: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10:  8: . . . . . . . . . . . . . . . . . . . Operand (
   10:  8: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   10: 10: . . . . . . . . . . . . . . . . . . . )
   10: 10: . . . . . . . . . . . . . . . . . . )
   10: 10: . . . . . . . . . . . . . . . . . )
   10: 10: . . . . . . . . . . . . . . . . )
   10: 10: . . . . . . . . . . . . . . . . "=>"
   10: 13: . . . . . . . . . . . . . . . . BlockStmt (
   10: 13: . . . . . . . . . . . . . . . . . "{"
   11:  3: . . . . . . . . . . . . . . . . . StatementList (
   11:  3: . . . . . . . . . . . . . . . . . . Statement (
   11:  3: . . . . . . . . . . . . . . . . . . . ReturnStmt (
   11:  3: . . . . . . . . . . . . . . . . . . . . "return"
   11: 10: . . . . . . . . . . . . . . . . . . . . ExpressionList (
   11: 10: . . . . . . . . . . . . . . . . . . . . . Expression (
   11: 10: . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   11: 10: . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   11: 10: . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 10: . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   11: 10: . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   11: 12: . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 12: . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 12: . . . . . . . . . . . . . . . . . . . . . . . )
   11: 12: . . . . . . . . . . . . . . . . . . . . . . . "*"
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   11: 14: . . . . . . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   11: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . )
   11: 15: . . . . . . . . . . . . . . . . . . . . . ","
   11: 17: . . . . . . . . . . . . . . . . . . . . . Expression (
   11: 17: . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   11: 17: . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   11: 17: . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 17: . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   11: 17: . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   11: 19: . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 19: . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 19: . . . . . . . . . . . . . . . . . . . . . . . )
   11: 19: . . . . . . . . . . . . . . . . . . . . . . . "*"
   11: 21: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   11: 21: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   11: 21: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 21: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   11: 21: . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   11: 22: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . . . . . . . ";"
   12:  2: . . . . . . . . . . . . . . . . . . . )
   12:  2: . . . . . . . . . . . . . . . . . . )
   12:  2: . . . . . . . . . . . . . . . . . )
   12:  2: . . . . . . . . . . . . . . . . . "}"
   12:  3: . . . . . . . . . . . . . . . . )
 /app/parser/parser.go:2746: ast.LambdaExpr{Lhs: [x]}
   12:  3: . . . . . . . . . . . . . . . )
   12:  3: . . . . . . . . . . . . . . )
   12:  3: . . . . . . . . . . . . . )
   12:  3: . . . . . . . . . . . . . ","
   13:  1: . . . . . . . . . . . . )
   13:  1: . . . . . . . . . . . . "}"
   13:  2: . . . . . . . . . . . )
   13:  2: . . . . . . . . . . )
   13:  2: . . . . . . . . . )
   13:  2: . . . . . . . . )
   13:  2: . . . . . . . )
   13:  2: . . . . . . )
   13:  2: . . . . . )
   13:  2: . . . . )
   13:  2: . . . . ";"
   13:  3: . . . )
   13:  3: . . )
   13:  3: . )
   13:  3: )
=== RUN   TestFromTestdata/listcompr
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/listcompr
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . ArrayType (
    1:  6: . . . . . . . . . . . . "["
    1:  7: . . . . . . . . . . . . Expression (
    1:  7: . . . . . . . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1:  8: . . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . "*"
    1:  9: . . . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1: 11: . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . ForPhrase (
    1: 11: . . . . . . . . . . . . . "for"
    1: 15: . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1: 17: . . . . . . . . . . . . . IDENT in
    1: 20: . . . . . . . . . . . . . Expression (
    1: 20: . . . . . . . . . . . . . . RangeExpr (
    1: 20: . . . . . . . . . . . . . . . BinaryExpr (
    1: 20: . . . . . . . . . . . . . . . . UnaryExpr (
    1: 20: . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 20: . . . . . . . . . . . . . . . . . . Operand (
    1: 20: . . . . . . . . . . . . . . . . . . . ArrayType (
    1: 20: . . . . . . . . . . . . . . . . . . . . "["
    1: 21: . . . . . . . . . . . . . . . . . . . . Expression (
    1: 21: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 21: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 21: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 21: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    1: 21: . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1: 22: . . . . . . . . . . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:902: ast.SliceLit{Elts: [0xc00027ed80]}
    1: 23: . . . . . . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . "]"
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{x 8 * x}, Fors: [0xc0000142a0]}
    1: 24: . . . . . . . . . . . )
    1: 24: . . . . . . . . . . )
    1: 24: . . . . . . . . . )
    1: 24: . . . . . . . . )
    1: 24: . . . . . . . )
    1: 24: . . . . . . )
    1: 24: . . . . . )
    1: 24: . . . . )
    1: 24: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  8: . . . . . . . . . . )
    2:  8: . . . . . . . . . . CallOrConversion (
    2:  8: . . . . . . . . . . . "("
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    2: 10: . . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    2: 11: . . . . . . . . . . )
    2: 11: . . . . . . . . . )
    2: 11: . . . . . . . . )
    2: 11: . . . . . . . )
    2: 11: . . . . . . )
    2: 11: . . . . . )
    2: 11: . . . . )
    2: 11: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    4:  3: . . . . . . . . . . )
    4:  3: . . . . . . . . . )
    4:  3: . . . . . . . . )
    4:  3: . . . . . . . )
    4:  3: . . . . . . )
    4:  3: . . . . . )
    4:  3: . . . . . "="
    4:  5: . . . . . ExpressionList (
    4:  5: . . . . . . Expression (
    4:  5: . . . . . . . BinaryExpr (
    4:  5: . . . . . . . . UnaryExpr (
    4:  5: . . . . . . . . . PrimaryExpr (
    4:  5: . . . . . . . . . . Operand (
    4:  5: . . . . . . . . . . . ArrayType (
    4:  5: . . . . . . . . . . . . "["
    4:  6: . . . . . . . . . . . . Expression (
    4:  6: . . . . . . . . . . . . . BinaryExpr (
    4:  6: . . . . . . . . . . . . . . UnaryExpr (
    4:  6: . . . . . . . . . . . . . . . PrimaryExpr (
    4:  6: . . . . . . . . . . . . . . . . Operand (
    4:  6: . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4:  7: . . . . . . . . . . . . . . . . )
    4:  7: . . . . . . . . . . . . . . . )
    4:  7: . . . . . . . . . . . . . . )
    4:  7: . . . . . . . . . . . . . . "*"
    4:  8: . . . . . . . . . . . . . . BinaryExpr (
    4:  8: . . . . . . . . . . . . . . . UnaryExpr (
    4:  8: . . . . . . . . . . . . . . . . PrimaryExpr (
    4:  8: . . . . . . . . . . . . . . . . . Operand (
    4:  8: . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4: 10: . . . . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . ForPhrase (
    4: 10: . . . . . . . . . . . . . "for"
    4: 14: . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4: 16: . . . . . . . . . . . . . IDENT in
    4: 19: . . . . . . . . . . . . . Expression (
    4: 19: . . . . . . . . . . . . . . RangeExpr (
    4: 19: . . . . . . . . . . . . . . . BinaryExpr (
    4: 19: . . . . . . . . . . . . . . . . UnaryExpr (
    4: 19: . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 19: . . . . . . . . . . . . . . . . . . Operand (
    4: 19: . . . . . . . . . . . . . . . . . . . ArrayType (
    4: 19: . . . . . . . . . . . . . . . . . . . . "["
    4: 20: . . . . . . . . . . . . . . . . . . . . Expression (
    4: 20: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    4: 21: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . . . . . . . . . ","
    4: 23: . . . . . . . . . . . . . . . . . . . . Expression (
    4: 23: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 23: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 23: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 23: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 23: . . . . . . . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    4: 24: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 24: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 24: . . . . . . . . . . . . . . . . . . . . . . )
    4: 24: . . . . . . . . . . . . . . . . . . . . . )
    4: 24: . . . . . . . . . . . . . . . . . . . . )
    4: 24: . . . . . . . . . . . . . . . . . . . . ","
    4: 26: . . . . . . . . . . . . . . . . . . . . Expression (
    4: 26: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 26: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 26: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 26: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 26: . . . . . . . . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    4: 27: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 27: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 27: . . . . . . . . . . . . . . . . . . . . . . )
    4: 27: . . . . . . . . . . . . . . . . . . . . . )
    4: 27: . . . . . . . . . . . . . . . . . . . . )
    4: 27: . . . . . . . . . . . . . . . . . . . . ","
    4: 29: . . . . . . . . . . . . . . . . . . . . Expression (
    4: 29: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 29: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 29: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 29: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 29: . . . . . . . . . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . ","
    4: 32: . . . . . . . . . . . . . . . . . . . . Expression (
    4: 32: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 32: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 32: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 32: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 32: . . . . . . . . . . . . . . . . . . . . . . . . . INT 11
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 11}
    4: 34: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . . "]"
    4: 36: . . . . . . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . "if"
    4: 39: . . . . . . . . . . . . . SimpleStmt (
    4: 39: . . . . . . . . . . . . . . ExpressionList (
    4: 39: . . . . . . . . . . . . . . . Expression (
    4: 39: . . . . . . . . . . . . . . . . BinaryExpr (
    4: 39: . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 39: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 39: . . . . . . . . . . . . . . . . . . . Operand (
    4: 39: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4: 41: . . . . . . . . . . . . . . . . . . . )
    4: 41: . . . . . . . . . . . . . . . . . . )
    4: 41: . . . . . . . . . . . . . . . . . )
    4: 41: . . . . . . . . . . . . . . . . . ">"
    4: 43: . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 43: . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 43: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 43: . . . . . . . . . . . . . . . . . . . . Operand (
    4: 43: . . . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    4: 44: . . . . . . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . "]"
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{x 43 * x}, Fors: [0xc000014360]}
    4: 45: . . . . . . . . . . . )
    4: 45: . . . . . . . . . . )
    4: 45: . . . . . . . . . )
    4: 45: . . . . . . . . )
    4: 45: . . . . . . . )
    4: 45: . . . . . . )
    4: 45: . . . . . )
    4: 45: . . . . )
    4: 45: . . . . ";"
    5:  1: . . . )
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5:  8: . . . . . . . . . . )
    5:  8: . . . . . . . . . . CallOrConversion (
    5:  8: . . . . . . . . . . . "("
    5:  9: . . . . . . . . . . . Expression (
    5:  9: . . . . . . . . . . . . BinaryExpr (
    5:  9: . . . . . . . . . . . . . UnaryExpr (
    5:  9: . . . . . . . . . . . . . . PrimaryExpr (
    5:  9: . . . . . . . . . . . . . . . Operand (
    5:  9: . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    5: 10: . . . . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    5: 11: . . . . . . . . . . )
    5: 11: . . . . . . . . . )
    5: 11: . . . . . . . . )
    5: 11: . . . . . . . )
    5: 11: . . . . . . )
    5: 11: . . . . . )
    5: 11: . . . . )
    5: 11: . . . . ";"
    7:  1: . . . )
    7:  1: . . . Statement (
    7:  1: . . . . SimpleStmt (
    7:  1: . . . . . ExpressionList (
    7:  1: . . . . . . Expression (
    7:  1: . . . . . . . BinaryExpr (
    7:  1: . . . . . . . . UnaryExpr (
    7:  1: . . . . . . . . . PrimaryExpr (
    7:  1: . . . . . . . . . . Operand (
    7:  1: . . . . . . . . . . . IDENT z
 /app/parser/parser.go:713: ast.Ident{Name: z}
    7:  3: . . . . . . . . . . )
    7:  3: . . . . . . . . . )
    7:  3: . . . . . . . . )
    7:  3: . . . . . . . )
    7:  3: . . . . . . )
    7:  3: . . . . . )
    7:  3: . . . . . ":="
    7:  6: . . . . . ExpressionList (
    7:  6: . . . . . . Expression (
    7:  6: . . . . . . . BinaryExpr (
    7:  6: . . . . . . . . UnaryExpr (
    7:  6: . . . . . . . . . PrimaryExpr (
    7:  6: . . . . . . . . . . Operand (
    7:  6: . . . . . . . . . . . ArrayType (
    7:  6: . . . . . . . . . . . . "["
    7:  7: . . . . . . . . . . . . Expression (
    7:  7: . . . . . . . . . . . . . BinaryExpr (
    7:  7: . . . . . . . . . . . . . . UnaryExpr (
    7:  7: . . . . . . . . . . . . . . . PrimaryExpr (
    7:  7: . . . . . . . . . . . . . . . . Operand (
    7:  7: . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    7:  8: . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . "+"
    7:  9: . . . . . . . . . . . . . . BinaryExpr (
    7:  9: . . . . . . . . . . . . . . . UnaryExpr (
    7:  9: . . . . . . . . . . . . . . . . PrimaryExpr (
    7:  9: . . . . . . . . . . . . . . . . . Operand (
    7:  9: . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
    7: 11: . . . . . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . ForPhrase (
    7: 11: . . . . . . . . . . . . . "for"
    7: 15: . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    7: 16: . . . . . . . . . . . . . ","
    7: 18: . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
    7: 20: . . . . . . . . . . . . . IDENT in
    7: 23: . . . . . . . . . . . . . Expression (
    7: 23: . . . . . . . . . . . . . . RangeExpr (
    7: 23: . . . . . . . . . . . . . . . BinaryExpr (
    7: 23: . . . . . . . . . . . . . . . . UnaryExpr (
    7: 23: . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 23: . . . . . . . . . . . . . . . . . . Operand (
    7: 23: . . . . . . . . . . . . . . . . . . . ArrayType (
    7: 23: . . . . . . . . . . . . . . . . . . . . "["
    7: 24: . . . . . . . . . . . . . . . . . . . . Expression (
    7: 24: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 24: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 24: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 24: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    7: 24: . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    7: 25: . . . . . . . . . . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . . . . . . . ","
    7: 27: . . . . . . . . . . . . . . . . . . . . Expression (
    7: 27: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 27: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 27: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 27: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    7: 27: . . . . . . . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    7: 28: . . . . . . . . . . . . . . . . . . . . . . . . )
    7: 28: . . . . . . . . . . . . . . . . . . . . . . . )
    7: 28: . . . . . . . . . . . . . . . . . . . . . . )
    7: 28: . . . . . . . . . . . . . . . . . . . . . )
    7: 28: . . . . . . . . . . . . . . . . . . . . )
    7: 28: . . . . . . . . . . . . . . . . . . . . ","
    7: 30: . . . . . . . . . . . . . . . . . . . . Expression (
    7: 30: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 30: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 30: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 30: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    7: 30: . . . . . . . . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    7: 31: . . . . . . . . . . . . . . . . . . . . . . . . )
    7: 31: . . . . . . . . . . . . . . . . . . . . . . . )
    7: 31: . . . . . . . . . . . . . . . . . . . . . . )
    7: 31: . . . . . . . . . . . . . . . . . . . . . )
    7: 31: . . . . . . . . . . . . . . . . . . . . )
    7: 31: . . . . . . . . . . . . . . . . . . . . ","
    7: 33: . . . . . . . . . . . . . . . . . . . . Expression (
    7: 33: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 33: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 33: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 33: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    7: 33: . . . . . . . . . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    7: 34: . . . . . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . ","
    7: 36: . . . . . . . . . . . . . . . . . . . . Expression (
    7: 36: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 36: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 36: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 36: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    7: 36: . . . . . . . . . . . . . . . . . . . . . . . . . INT 11
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 11}
    7: 38: . . . . . . . . . . . . . . . . . . . . . . . . )
    7: 38: . . . . . . . . . . . . . . . . . . . . . . . )
    7: 38: . . . . . . . . . . . . . . . . . . . . . . )
    7: 38: . . . . . . . . . . . . . . . . . . . . . )
    7: 38: . . . . . . . . . . . . . . . . . . . . )
    7: 38: . . . . . . . . . . . . . . . . . . . . "]"
    7: 40: . . . . . . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . "if"
    7: 43: . . . . . . . . . . . . . SimpleStmt (
    7: 43: . . . . . . . . . . . . . . ExpressionList (
    7: 43: . . . . . . . . . . . . . . . Expression (
    7: 43: . . . . . . . . . . . . . . . . BinaryExpr (
    7: 43: . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 43: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 43: . . . . . . . . . . . . . . . . . . . Operand (
    7: 43: . . . . . . . . . . . . . . . . . . . . IDENT t
 /app/parser/parser.go:713: ast.Ident{Name: t}
    7: 45: . . . . . . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . ":="
    7: 48: . . . . . . . . . . . . . . ExpressionList (
    7: 48: . . . . . . . . . . . . . . . Expression (
    7: 48: . . . . . . . . . . . . . . . . BinaryExpr (
    7: 48: . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 48: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 48: . . . . . . . . . . . . . . . . . . . Operand (
    7: 48: . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    7: 50: . . . . . . . . . . . . . . . . . . . )
    7: 50: . . . . . . . . . . . . . . . . . . )
    7: 50: . . . . . . . . . . . . . . . . . )
    7: 50: . . . . . . . . . . . . . . . . . "%"
    7: 52: . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 52: . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 52: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 52: . . . . . . . . . . . . . . . . . . . . Operand (
    7: 52: . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    7: 53: . . . . . . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . ";"
    7: 55: . . . . . . . . . . . . . SimpleStmt (
    7: 55: . . . . . . . . . . . . . . ExpressionList (
    7: 55: . . . . . . . . . . . . . . . Expression (
    7: 55: . . . . . . . . . . . . . . . . BinaryExpr (
    7: 55: . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 55: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 55: . . . . . . . . . . . . . . . . . . . Operand (
    7: 55: . . . . . . . . . . . . . . . . . . . . IDENT t
 /app/parser/parser.go:713: ast.Ident{Name: t}
    7: 57: . . . . . . . . . . . . . . . . . . . )
    7: 57: . . . . . . . . . . . . . . . . . . )
    7: 57: . . . . . . . . . . . . . . . . . )
    7: 57: . . . . . . . . . . . . . . . . . "=="
    7: 60: . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 60: . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 60: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 60: . . . . . . . . . . . . . . . . . . . . Operand (
    7: 60: . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    7: 61: . . . . . . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . "]"
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{i 101 + v}, Fors: [0xc000014420]}
    7: 62: . . . . . . . . . . . )
    7: 62: . . . . . . . . . . )
    7: 62: . . . . . . . . . )
    7: 62: . . . . . . . . )
    7: 62: . . . . . . . )
    7: 62: . . . . . . )
    7: 62: . . . . . )
    7: 62: . . . . )
    7: 62: . . . . ";"
    8:  1: . . . )
    8:  1: . . . Statement (
    8:  1: . . . . SimpleStmt (
    8:  1: . . . . . ExpressionList (
    8:  1: . . . . . . Expression (
    8:  1: . . . . . . . BinaryExpr (
    8:  1: . . . . . . . . UnaryExpr (
    8:  1: . . . . . . . . . PrimaryExpr (
    8:  1: . . . . . . . . . . Operand (
    8:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    8:  8: . . . . . . . . . . )
    8:  8: . . . . . . . . . . CallOrConversion (
    8:  8: . . . . . . . . . . . "("
    8:  9: . . . . . . . . . . . Expression (
    8:  9: . . . . . . . . . . . . BinaryExpr (
    8:  9: . . . . . . . . . . . . . UnaryExpr (
    8:  9: . . . . . . . . . . . . . . PrimaryExpr (
    8:  9: . . . . . . . . . . . . . . . Operand (
    8:  9: . . . . . . . . . . . . . . . . IDENT z
 /app/parser/parser.go:713: ast.Ident{Name: z}
    8: 10: . . . . . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    8: 11: . . . . . . . . . . )
    8: 11: . . . . . . . . . )
    8: 11: . . . . . . . . )
    8: 11: . . . . . . . )
    8: 11: . . . . . . )
    8: 11: . . . . . )
    8: 11: . . . . )
    8: 11: . . . . ";"
   10:  1: . . . )
   10:  1: . . . Statement (
   10:  1: . . . . SimpleStmt (
   10:  1: . . . . . ExpressionList (
   10:  1: . . . . . . Expression (
   10:  1: . . . . . . . BinaryExpr (
   10:  1: . . . . . . . . UnaryExpr (
   10:  1: . . . . . . . . . PrimaryExpr (
   10:  1: . . . . . . . . . . Operand (
   10:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   10:  8: . . . . . . . . . . )
   10:  8: . . . . . . . . . . CallOrConversion (
   10:  8: . . . . . . . . . . . "("
   10:  9: . . . . . . . . . . . Expression (
   10:  9: . . . . . . . . . . . . BinaryExpr (
   10:  9: . . . . . . . . . . . . . UnaryExpr (
   10:  9: . . . . . . . . . . . . . . PrimaryExpr (
   10:  9: . . . . . . . . . . . . . . . Operand (
   10:  9: . . . . . . . . . . . . . . . . ArrayType (
   10:  9: . . . . . . . . . . . . . . . . . "["
   10: 10: . . . . . . . . . . . . . . . . . Expression (
   10: 10: . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 10: . . . . . . . . . . . . . . . . . . . . . . IDENT k
 /app/parser/parser.go:713: ast.Ident{Name: k}
   10: 11: . . . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . . "+"
   10: 12: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 12: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 12: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 12: . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 12: . . . . . . . . . . . . . . . . . . . . . . . STRING ","
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: ","}
   10: 15: . . . . . . . . . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . . . . . . . "+"
   10: 16: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 16: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 16: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 16: . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 16: . . . . . . . . . . . . . . . . . . . . . . . IDENT s
 /app/parser/parser.go:713: ast.Ident{Name: s}
   10: 18: . . . . . . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . ForPhrase (
   10: 18: . . . . . . . . . . . . . . . . . . "for"
   10: 22: . . . . . . . . . . . . . . . . . . IDENT k
 /app/parser/parser.go:713: ast.Ident{Name: k}
   10: 23: . . . . . . . . . . . . . . . . . . ","
   10: 25: . . . . . . . . . . . . . . . . . . IDENT s
 /app/parser/parser.go:713: ast.Ident{Name: s}
   10: 27: . . . . . . . . . . . . . . . . . . IDENT in
   10: 30: . . . . . . . . . . . . . . . . . . Expression (
   10: 30: . . . . . . . . . . . . . . . . . . . RangeExpr (
   10: 30: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 30: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 30: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 30: . . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 30: . . . . . . . . . . . . . . . . . . . . . . . . LiteralValue (
   10: 30: . . . . . . . . . . . . . . . . . . . . . . . . . "{"
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . ElementList (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "Hello"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hello"}
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . ":"
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "xsw"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "xsw"}
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . ","
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "Hi"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hi"}
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . ":"
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "XGo"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "XGo"}
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . "}"
   10: 59: . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{0xc00027f2c0 182 + s}, Fors: [0xc0000144e0]}
   10: 60: . . . . . . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   10: 61: . . . . . . . . . . )
   10: 61: . . . . . . . . . )
   10: 61: . . . . . . . . )
   10: 61: . . . . . . . )
   10: 61: . . . . . . )
   10: 61: . . . . . )
   10: 61: . . . . )
   10: 61: . . . . ";"
   12:  1: . . . )
   12:  1: . . . Statement (
   12:  1: . . . . SimpleStmt (
   12:  1: . . . . . ExpressionList (
   12:  1: . . . . . . Expression (
   12:  1: . . . . . . . BinaryExpr (
   12:  1: . . . . . . . . UnaryExpr (
   12:  1: . . . . . . . . . PrimaryExpr (
   12:  1: . . . . . . . . . . Operand (
   12:  1: . . . . . . . . . . . IDENT arr
 /app/parser/parser.go:713: ast.Ident{Name: arr}
   12:  5: . . . . . . . . . . )
   12:  5: . . . . . . . . . )
   12:  5: . . . . . . . . )
   12:  5: . . . . . . . )
   12:  5: . . . . . . )
   12:  5: . . . . . )
   12:  5: . . . . . ":="
   12:  8: . . . . . ExpressionList (
   12:  8: . . . . . . Expression (
   12:  8: . . . . . . . BinaryExpr (
   12:  8: . . . . . . . . UnaryExpr (
   12:  8: . . . . . . . . . PrimaryExpr (
   12:  8: . . . . . . . . . . Operand (
   12:  8: . . . . . . . . . . . ArrayType (
   12:  8: . . . . . . . . . . . . "["
   12:  9: . . . . . . . . . . . . Expression (
   12:  9: . . . . . . . . . . . . . BinaryExpr (
   12:  9: . . . . . . . . . . . . . . UnaryExpr (
   12:  9: . . . . . . . . . . . . . . . PrimaryExpr (
   12:  9: . . . . . . . . . . . . . . . . Operand (
   12:  9: . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   12: 10: . . . . . . . . . . . . . . . . )
   12: 10: . . . . . . . . . . . . . . . )
   12: 10: . . . . . . . . . . . . . . )
   12: 10: . . . . . . . . . . . . . )
   12: 10: . . . . . . . . . . . . )
   12: 10: . . . . . . . . . . . . ","
   12: 12: . . . . . . . . . . . . Expression (
   12: 12: . . . . . . . . . . . . . BinaryExpr (
   12: 12: . . . . . . . . . . . . . . UnaryExpr (
   12: 12: . . . . . . . . . . . . . . . PrimaryExpr (
   12: 12: . . . . . . . . . . . . . . . . Operand (
   12: 12: . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   12: 13: . . . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . ","
   12: 15: . . . . . . . . . . . . Expression (
   12: 15: . . . . . . . . . . . . . BinaryExpr (
   12: 15: . . . . . . . . . . . . . . UnaryExpr (
   12: 15: . . . . . . . . . . . . . . . PrimaryExpr (
   12: 15: . . . . . . . . . . . . . . . . Operand (
   12: 15: . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
   12: 16: . . . . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . ","
   12: 18: . . . . . . . . . . . . Expression (
   12: 18: . . . . . . . . . . . . . BinaryExpr (
   12: 18: . . . . . . . . . . . . . . UnaryExpr (
   12: 18: . . . . . . . . . . . . . . . PrimaryExpr (
   12: 18: . . . . . . . . . . . . . . . . Operand (
   12: 18: . . . . . . . . . . . . . . . . . INT 4
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 4}
   12: 19: . . . . . . . . . . . . . . . . )
   12: 19: . . . . . . . . . . . . . . . )
   12: 19: . . . . . . . . . . . . . . )
   12: 19: . . . . . . . . . . . . . )
   12: 19: . . . . . . . . . . . . )
   12: 19: . . . . . . . . . . . . ","
   12: 21: . . . . . . . . . . . . Expression (
   12: 21: . . . . . . . . . . . . . BinaryExpr (
   12: 21: . . . . . . . . . . . . . . UnaryExpr (
   12: 21: . . . . . . . . . . . . . . . PrimaryExpr (
   12: 21: . . . . . . . . . . . . . . . . Operand (
   12: 21: . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
   12: 22: . . . . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . ","
   12: 24: . . . . . . . . . . . . Expression (
   12: 24: . . . . . . . . . . . . . BinaryExpr (
   12: 24: . . . . . . . . . . . . . . UnaryExpr (
   12: 24: . . . . . . . . . . . . . . . PrimaryExpr (
   12: 24: . . . . . . . . . . . . . . . . Operand (
   12: 24: . . . . . . . . . . . . . . . . . INT 6
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 6}
   12: 25: . . . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . "]"
   12: 26: . . . . . . . . . . . )
   12: 26: . . . . . . . . . . )
   12: 26: . . . . . . . . . )
   12: 26: . . . . . . . . )
   12: 26: . . . . . . . )
   12: 26: . . . . . . )
   12: 26: . . . . . )
   12: 26: . . . . )
   12: 26: . . . . ";"
   13:  1: . . . )
   13:  1: . . . Statement (
   13:  1: . . . . SimpleStmt (
   13:  1: . . . . . ExpressionList (
   13:  1: . . . . . . Expression (
   13:  1: . . . . . . . BinaryExpr (
   13:  1: . . . . . . . . UnaryExpr (
   13:  1: . . . . . . . . . PrimaryExpr (
   13:  1: . . . . . . . . . . Operand (
   13:  1: . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   13:  3: . . . . . . . . . . )
   13:  3: . . . . . . . . . )
   13:  3: . . . . . . . . )
   13:  3: . . . . . . . )
   13:  3: . . . . . . )
   13:  3: . . . . . )
   13:  3: . . . . . ":="
   13:  6: . . . . . ExpressionList (
   13:  6: . . . . . . Expression (
   13:  6: . . . . . . . BinaryExpr (
   13:  6: . . . . . . . . UnaryExpr (
   13:  6: . . . . . . . . . PrimaryExpr (
   13:  6: . . . . . . . . . . Operand (
   13:  6: . . . . . . . . . . . ArrayType (
   13:  6: . . . . . . . . . . . . "["
   13:  7: . . . . . . . . . . . . Expression (
   13:  7: . . . . . . . . . . . . . BinaryExpr (
   13:  7: . . . . . . . . . . . . . . UnaryExpr (
   13:  7: . . . . . . . . . . . . . . . PrimaryExpr (
   13:  7: . . . . . . . . . . . . . . . . Operand (
   13:  7: . . . . . . . . . . . . . . . . . ArrayType (
   13:  7: . . . . . . . . . . . . . . . . . . "["
   13:  8: . . . . . . . . . . . . . . . . . . Expression (
   13:  8: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   13:  8: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   13:  8: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13:  8: . . . . . . . . . . . . . . . . . . . . . . Operand (
   13:  8: . . . . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   13:  9: . . . . . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . ","
   13: 11: . . . . . . . . . . . . . . . . . . Expression (
   13: 11: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . . . Operand (
   13: 11: . . . . . . . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   13: 12: . . . . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . "]"
   13: 14: . . . . . . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . ForPhrase (
   13: 14: . . . . . . . . . . . . . "for"
   13: 18: . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   13: 20: . . . . . . . . . . . . . IDENT in
   13: 23: . . . . . . . . . . . . . Expression (
   13: 23: . . . . . . . . . . . . . . RangeExpr (
   13: 23: . . . . . . . . . . . . . . . BinaryExpr (
   13: 23: . . . . . . . . . . . . . . . . UnaryExpr (
   13: 23: . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 23: . . . . . . . . . . . . . . . . . . Operand (
   13: 23: . . . . . . . . . . . . . . . . . . . IDENT arr
 /app/parser/parser.go:713: ast.Ident{Name: arr}
   13: 27: . . . . . . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . "if"
   13: 30: . . . . . . . . . . . . . SimpleStmt (
   13: 30: . . . . . . . . . . . . . . ExpressionList (
   13: 30: . . . . . . . . . . . . . . . Expression (
   13: 30: . . . . . . . . . . . . . . . . BinaryExpr (
   13: 30: . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 30: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 30: . . . . . . . . . . . . . . . . . . . Operand (
   13: 30: . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   13: 32: . . . . . . . . . . . . . . . . . . . )
   13: 32: . . . . . . . . . . . . . . . . . . )
   13: 32: . . . . . . . . . . . . . . . . . )
   13: 32: . . . . . . . . . . . . . . . . . "<"
   13: 34: . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 34: . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 34: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 34: . . . . . . . . . . . . . . . . . . . . Operand (
   13: 34: . . . . . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   13: 36: . . . . . . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . ForPhrase (
   13: 36: . . . . . . . . . . . . . "for"
   13: 40: . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   13: 42: . . . . . . . . . . . . . IDENT in
   13: 45: . . . . . . . . . . . . . Expression (
   13: 45: . . . . . . . . . . . . . . RangeExpr (
   13: 45: . . . . . . . . . . . . . . . BinaryExpr (
   13: 45: . . . . . . . . . . . . . . . . UnaryExpr (
   13: 45: . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 45: . . . . . . . . . . . . . . . . . . Operand (
   13: 45: . . . . . . . . . . . . . . . . . . . IDENT arr
 /app/parser/parser.go:713: ast.Ident{Name: arr}
   13: 49: . . . . . . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . "if"
   13: 52: . . . . . . . . . . . . . SimpleStmt (
   13: 52: . . . . . . . . . . . . . . ExpressionList (
   13: 52: . . . . . . . . . . . . . . . Expression (
   13: 52: . . . . . . . . . . . . . . . . BinaryExpr (
   13: 52: . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 52: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 52: . . . . . . . . . . . . . . . . . . . Operand (
   13: 52: . . . . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   13: 54: . . . . . . . . . . . . . . . . . . . )
   13: 54: . . . . . . . . . . . . . . . . . . )
   13: 54: . . . . . . . . . . . . . . . . . )
   13: 54: . . . . . . . . . . . . . . . . . ">"
   13: 56: . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 56: . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 56: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 56: . . . . . . . . . . . . . . . . . . . . Operand (
   13: 56: . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   13: 57: . . . . . . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . "]"
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{262 [a b] 267 false}, Fors: [0xc0000145a0 0xc000014600]}
   13: 58: . . . . . . . . . . . )
   13: 58: . . . . . . . . . . )
   13: 58: . . . . . . . . . )
   13: 58: . . . . . . . . )
   13: 58: . . . . . . . )
   13: 58: . . . . . . )
   13: 58: . . . . . )
   13: 58: . . . . )
   13: 58: . . . . ";"
   14:  1: . . . )
   14:  1: . . . Statement (
   14:  1: . . . . SimpleStmt (
   14:  1: . . . . . ExpressionList (
   14:  1: . . . . . . Expression (
   14:  1: . . . . . . . BinaryExpr (
   14:  1: . . . . . . . . UnaryExpr (
   14:  1: . . . . . . . . . PrimaryExpr (
   14:  1: . . . . . . . . . . Operand (
   14:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   14:  8: . . . . . . . . . . )
   14:  8: . . . . . . . . . . CallOrConversion (
   14:  8: . . . . . . . . . . . "("
   14:  9: . . . . . . . . . . . Expression (
   14:  9: . . . . . . . . . . . . BinaryExpr (
   14:  9: . . . . . . . . . . . . . UnaryExpr (
   14:  9: . . . . . . . . . . . . . . PrimaryExpr (
   14:  9: . . . . . . . . . . . . . . . Operand (
   14:  9: . . . . . . . . . . . . . . . . STRING "x:"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "x:"}
   14: 13: . . . . . . . . . . . . . . . )
   14: 13: . . . . . . . . . . . . . . )
   14: 13: . . . . . . . . . . . . . )
   14: 13: . . . . . . . . . . . . )
   14: 13: . . . . . . . . . . . )
   14: 13: . . . . . . . . . . . ","
   14: 15: . . . . . . . . . . . Expression (
   14: 15: . . . . . . . . . . . . BinaryExpr (
   14: 15: . . . . . . . . . . . . . UnaryExpr (
   14: 15: . . . . . . . . . . . . . . PrimaryExpr (
   14: 15: . . . . . . . . . . . . . . . Operand (
   14: 15: . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   14: 16: . . . . . . . . . . . . . . . )
   14: 16: . . . . . . . . . . . . . . )
   14: 16: . . . . . . . . . . . . . )
   14: 16: . . . . . . . . . . . . )
   14: 16: . . . . . . . . . . . )
   14: 16: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   14: 17: . . . . . . . . . . )
   14: 17: . . . . . . . . . )
   14: 17: . . . . . . . . )
   14: 17: . . . . . . . )
   14: 17: . . . . . . )
   14: 17: . . . . . )
   14: 17: . . . . )
   14: 17: . . . . ";"
   14: 18: . . . )
   14: 18: . . )
   14: 18: . )
   14: 18: )
=== RUN   TestFromTestdata/mapfunc
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/mapfunc
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . "map"
 /app/parser/parser.go:713: ast.Ident{Name: map}
    1:  5: . . . . . . . . . . )
    1:  5: . . . . . . . . . . CallOrConversion (
    1:  5: . . . . . . . . . . . Expression (
    1:  5: . . . . . . . . . . . . BinaryExpr (
    1:  5: . . . . . . . . . . . . . UnaryExpr (
    1:  5: . . . . . . . . . . . . . . PrimaryExpr (
    1:  5: . . . . . . . . . . . . . . . Operand (
    1:  5: . . . . . . . . . . . . . . . . IDENT strs
 /app/parser/parser.go:713: ast.Ident{Name: strs}
    1:  9: . . . . . . . . . . . . . . . )
    1:  9: . . . . . . . . . . . . . . )
    1:  9: . . . . . . . . . . . . . )
    1:  9: . . . . . . . . . . . . )
    1:  9: . . . . . . . . . . . )
    1:  9: . . . . . . . . . . . ","
    1: 11: . . . . . . . . . . . Expression (
    1: 11: . . . . . . . . . . . . BinaryExpr (
    1: 11: . . . . . . . . . . . . . UnaryExpr (
    1: 11: . . . . . . . . . . . . . . PrimaryExpr (
    1: 11: . . . . . . . . . . . . . . . Operand (
    1: 11: . . . . . . . . . . . . . . . . IDENT toUpper
 /app/parser/parser.go:713: ast.Ident{Name: toUpper}
    1: 18: . . . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: map, Ellipsis: false, isCmd: true}
    1: 18: . . . . . . . . . . )
    1: 18: . . . . . . . . . )
    1: 18: . . . . . . . . )
    1: 18: . . . . . . . )
    1: 18: . . . . . . )
    1: 18: . . . . . )
    1: 18: . . . . )
    1: 18: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . "map"
 /app/parser/parser.go:713: ast.Ident{Name: map}
    2:  5: . . . . . . . . . . )
    2:  5: . . . . . . . . . . CallOrConversion (
    2:  5: . . . . . . . . . . . Expression (
    2:  5: . . . . . . . . . . . . BinaryExpr (
    2:  5: . . . . . . . . . . . . . UnaryExpr (
    2:  5: . . . . . . . . . . . . . . PrimaryExpr (
    2:  5: . . . . . . . . . . . . . . . Operand (
    2:  5: . . . . . . . . . . . . . . . . ArrayType (
    2:  5: . . . . . . . . . . . . . . . . . "["
    2:  6: . . . . . . . . . . . . . . . . . Expression (
    2:  6: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  6: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  6: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  6: . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  6: . . . . . . . . . . . . . . . . . . . . . . STRING "hello"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "hello"}
    2: 13: . . . . . . . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . . . . ","
    2: 15: . . . . . . . . . . . . . . . . . Expression (
    2: 15: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 15: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 15: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 15: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 15: . . . . . . . . . . . . . . . . . . . . . . STRING "world"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "world"}
    2: 22: . . . . . . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . . . "]"
    2: 23: . . . . . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . ","
    2: 25: . . . . . . . . . . . Expression (
    2: 25: . . . . . . . . . . . . BinaryExpr (
    2: 25: . . . . . . . . . . . . . UnaryExpr (
    2: 25: . . . . . . . . . . . . . . PrimaryExpr (
    2: 25: . . . . . . . . . . . . . . . Operand (
    2: 25: . . . . . . . . . . . . . . . . IDENT toUpper
 /app/parser/parser.go:713: ast.Ident{Name: toUpper}
    2: 32: . . . . . . . . . . . . . . . )
    2: 32: . . . . . . . . . . . . . . )
    2: 32: . . . . . . . . . . . . . )
    2: 32: . . . . . . . . . . . . )
    2: 32: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: map, Ellipsis: false, isCmd: true}
    2: 32: . . . . . . . . . . )
    2: 32: . . . . . . . . . )
    2: 32: . . . . . . . . )
    2: 32: . . . . . . . )
    2: 32: . . . . . . )
    2: 32: . . . . . )
    2: 32: . . . . )
    2: 32: . . . . ";"
    3:  1: . . . )
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . "map"
    3:  1: . . . . . . . . . . . MapType (
    3:  4: . . . . . . . . . . . . "["
    3:  5: . . . . . . . . . . . . Type (
    3:  5: . . . . . . . . . . . . . TypeName (
    3:  5: . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    3: 11: . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . "]"
    3: 12: . . . . . . . . . . . . Type (
    3: 12: . . . . . . . . . . . . . TypeName (
    3: 12: . . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    3: 15: . . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . . )
 /app/parser/parser.go:1455: ast.MapType{Key: string, Value: int}
    3: 15: . . . . . . . . . . . )
    3: 15: . . . . . . . . . . )
    3: 15: . . . . . . . . . . LiteralValue (
    3: 15: . . . . . . . . . . . "{"
    3: 16: . . . . . . . . . . . ElementList (
    3: 16: . . . . . . . . . . . . Element (
    3: 16: . . . . . . . . . . . . . Element (
    3: 16: . . . . . . . . . . . . . . Expression (
    3: 16: . . . . . . . . . . . . . . . BinaryExpr (
    3: 16: . . . . . . . . . . . . . . . . UnaryExpr (
    3: 16: . . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 16: . . . . . . . . . . . . . . . . . . Operand (
    3: 16: . . . . . . . . . . . . . . . . . . . STRING "Hi"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hi"}
    3: 20: . . . . . . . . . . . . . . . . . . )
    3: 20: . . . . . . . . . . . . . . . . . )
    3: 20: . . . . . . . . . . . . . . . . )
    3: 20: . . . . . . . . . . . . . . . )
    3: 20: . . . . . . . . . . . . . . )
    3: 20: . . . . . . . . . . . . . )
    3: 20: . . . . . . . . . . . . . ":"
    3: 22: . . . . . . . . . . . . . Element (
    3: 22: . . . . . . . . . . . . . . Expression (
    3: 22: . . . . . . . . . . . . . . . BinaryExpr (
    3: 22: . . . . . . . . . . . . . . . . UnaryExpr (
    3: 22: . . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 22: . . . . . . . . . . . . . . . . . . Operand (
    3: 22: . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    3: 23: . . . . . . . . . . . . . . . . . . )
    3: 23: . . . . . . . . . . . . . . . . . )
    3: 23: . . . . . . . . . . . . . . . . )
    3: 23: . . . . . . . . . . . . . . . )
    3: 23: . . . . . . . . . . . . . . )
    3: 23: . . . . . . . . . . . . . )
    3: 23: . . . . . . . . . . . . )
    3: 23: . . . . . . . . . . . )
    3: 23: . . . . . . . . . . . "}"
    3: 24: . . . . . . . . . . )
    3: 24: . . . . . . . . . )
    3: 24: . . . . . . . . )
    3: 24: . . . . . . . )
    3: 24: . . . . . . )
    3: 24: . . . . . )
    3: 24: . . . . )
    3: 24: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    4:  9: . . . . . . . . . . )
    4:  9: . . . . . . . . . . CallOrConversion (
    4:  9: . . . . . . . . . . . Expression (
    4:  9: . . . . . . . . . . . . BinaryExpr (
    4:  9: . . . . . . . . . . . . . UnaryExpr (
    4:  9: . . . . . . . . . . . . . . PrimaryExpr (
    4:  9: . . . . . . . . . . . . . . . Operand (
    4:  9: . . . . . . . . . . . . . . . . "map"
 /app/parser/parser.go:713: ast.Ident{Name: map}
    4: 12: . . . . . . . . . . . . . . . )
    4: 12: . . . . . . . . . . . . . . . CallOrConversion (
    4: 12: . . . . . . . . . . . . . . . . "("
    4: 13: . . . . . . . . . . . . . . . . Expression (
    4: 13: . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 13: . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 13: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 13: . . . . . . . . . . . . . . . . . . . . Operand (
    4: 13: . . . . . . . . . . . . . . . . . . . . . IDENT strs
 /app/parser/parser.go:713: ast.Ident{Name: strs}
    4: 17: . . . . . . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . . . ","
    4: 19: . . . . . . . . . . . . . . . . Expression (
    4: 19: . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 19: . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 19: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 19: . . . . . . . . . . . . . . . . . . . . Operand (
    4: 19: . . . . . . . . . . . . . . . . . . . . . IDENT strings
 /app/parser/parser.go:713: ast.Ident{Name: strings}
    4: 26: . . . . . . . . . . . . . . . . . . . . )
    4: 26: . . . . . . . . . . . . . . . . . . . . "."
    4: 27: . . . . . . . . . . . . . . . . . . . . Selector (
    4: 27: . . . . . . . . . . . . . . . . . . . . . IDENT ToUpper
 /app/parser/parser.go:713: ast.Ident{Name: ToUpper}
    4: 34: . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: map, Ellipsis: false, isCmd: false}
    4: 35: . . . . . . . . . . . . . . . )
    4: 35: . . . . . . . . . . . . . . )
    4: 35: . . . . . . . . . . . . . )
    4: 35: . . . . . . . . . . . . )
    4: 35: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    4: 35: . . . . . . . . . . )
    4: 35: . . . . . . . . . )
    4: 35: . . . . . . . . )
    4: 35: . . . . . . . )
    4: 35: . . . . . . )
    4: 35: . . . . . )
    4: 35: . . . . )
    4: 35: . . . . ";"
    4: 36: . . . )
    4: 36: . . )
    4: 36: . )
    4: 36: )
=== RUN   TestFromTestdata/matrix1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/matrix1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT echo
 /app/parser/parser.go:713: ast.Ident{Name: echo}
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . . CallOrConversion (
    1:  6: . . . . . . . . . . . Expression (
    1:  6: . . . . . . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . . . . . . ArrayType (
    1:  6: . . . . . . . . . . . . . . . . . "["
    2:  2: . . . . . . . . . . . . . . . . . Expression (
    2:  2: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  2: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  2: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  2: . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  2: . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2:  3: . . . . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . ","
    2:  5: . . . . . . . . . . . . . . . . . Expression (
    2:  5: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  5: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  5: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  5: . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  5: . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    2:  6: . . . . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . ","
    2:  8: . . . . . . . . . . . . . . . . . Expression (
    2:  8: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  8: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  8: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  8: . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  8: . . . . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    2:  9: . . . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . ";"
    3:  2: . . . . . . . . . . . . . . . . . Expression (
    3:  2: . . . . . . . . . . . . . . . . . . BinaryExpr (
    3:  2: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3:  2: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3:  2: . . . . . . . . . . . . . . . . . . . . . Operand (
    3:  2: . . . . . . . . . . . . . . . . . . . . . . INT 4
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 4}
    3:  3: . . . . . . . . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . . . . . ","
    3:  5: . . . . . . . . . . . . . . . . . Expression (
    3:  5: . . . . . . . . . . . . . . . . . . BinaryExpr (
    3:  5: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3:  5: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3:  5: . . . . . . . . . . . . . . . . . . . . . Operand (
    3:  5: . . . . . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    3:  6: . . . . . . . . . . . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . . . . . . . ","
    3:  8: . . . . . . . . . . . . . . . . . Expression (
    3:  8: . . . . . . . . . . . . . . . . . . BinaryExpr (
    3:  8: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3:  8: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3:  8: . . . . . . . . . . . . . . . . . . . . . Operand (
    3:  8: . . . . . . . . . . . . . . . . . . . . . . INT 6
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 6}
    3:  9: . . . . . . . . . . . . . . . . . . . . . )
    3:  9: . . . . . . . . . . . . . . . . . . . . )
    3:  9: . . . . . . . . . . . . . . . . . . . )
    3:  9: . . . . . . . . . . . . . . . . . . )
    3:  9: . . . . . . . . . . . . . . . . . )
    3:  9: . . . . . . . . . . . . . . . . . ";"
    4:  1: . . . . . . . . . . . . . . . . . "]"
    4:  2: . . . . . . . . . . . . . . . . )
    4:  2: . . . . . . . . . . . . . . . )
    4:  2: . . . . . . . . . . . . . . )
    4:  2: . . . . . . . . . . . . . )
    4:  2: . . . . . . . . . . . . )
    4:  2: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: echo, Ellipsis: false, isCmd: true}
    4:  2: . . . . . . . . . . )
    4:  2: . . . . . . . . . )
    4:  2: . . . . . . . . )
    4:  2: . . . . . . . )
    4:  2: . . . . . . )
    4:  2: . . . . . )
    4:  2: . . . . )
    4:  2: . . . . ";"
    4:  3: . . . )
    4:  3: . . )
    4:  3: . )
    4:  3: )
=== RUN   TestFromTestdata/matrix2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/matrix2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT echo
 /app/parser/parser.go:713: ast.Ident{Name: echo}
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . . CallOrConversion (
    1:  6: . . . . . . . . . . . Expression (
    1:  6: . . . . . . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . . . . . . ArrayType (
    1:  6: . . . . . . . . . . . . . . . . . "["
    2:  2: . . . . . . . . . . . . . . . . . Expression (
    2:  2: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  2: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  2: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  2: . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  2: . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2:  3: . . . . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . ","
    2:  5: . . . . . . . . . . . . . . . . . Expression (
    2:  5: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  5: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  5: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  5: . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  5: . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    2:  6: . . . . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . ","
    2:  8: . . . . . . . . . . . . . . . . . Expression (
    2:  8: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  8: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  8: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  8: . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  8: . . . . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    2:  9: . . . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . ";"
    3:  2: . . . . . . . . . . . . . . . . . Expression (
    3:  2: . . . . . . . . . . . . . . . . . . BinaryExpr (
    3:  2: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3:  2: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3:  2: . . . . . . . . . . . . . . . . . . . . . Operand (
    3:  2: . . . . . . . . . . . . . . . . . . . . . . IDENT row
 /app/parser/parser.go:713: ast.Ident{Name: row}
    3:  5: . . . . . . . . . . . . . . . . . . . . . )
    3:  5: . . . . . . . . . . . . . . . . . . . . )
    3:  5: . . . . . . . . . . . . . . . . . . . )
    3:  5: . . . . . . . . . . . . . . . . . . )
    3:  5: . . . . . . . . . . . . . . . . . )
    3:  5: . . . . . . . . . . . . . . . . . "..."
    3:  8: . . . . . . . . . . . . . . . . . ";"
    4:  2: . . . . . . . . . . . . . . . . . Expression (
    4:  2: . . . . . . . . . . . . . . . . . . BinaryExpr (
    4:  2: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4:  2: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4:  2: . . . . . . . . . . . . . . . . . . . . . Operand (
    4:  2: . . . . . . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    4:  3: . . . . . . . . . . . . . . . . . . . . . )
    4:  3: . . . . . . . . . . . . . . . . . . . . )
    4:  3: . . . . . . . . . . . . . . . . . . . )
    4:  3: . . . . . . . . . . . . . . . . . . )
    4:  3: . . . . . . . . . . . . . . . . . )
    4:  3: . . . . . . . . . . . . . . . . . ","
    4:  5: . . . . . . . . . . . . . . . . . Expression (
    4:  5: . . . . . . . . . . . . . . . . . . BinaryExpr (
    4:  5: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4:  5: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4:  5: . . . . . . . . . . . . . . . . . . . . . Operand (
    4:  5: . . . . . . . . . . . . . . . . . . . . . . INT 8
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 8}
    4:  6: . . . . . . . . . . . . . . . . . . . . . )
    4:  6: . . . . . . . . . . . . . . . . . . . . )
    4:  6: . . . . . . . . . . . . . . . . . . . )
    4:  6: . . . . . . . . . . . . . . . . . . )
    4:  6: . . . . . . . . . . . . . . . . . )
    4:  6: . . . . . . . . . . . . . . . . . ","
    4:  8: . . . . . . . . . . . . . . . . . Expression (
    4:  8: . . . . . . . . . . . . . . . . . . BinaryExpr (
    4:  8: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4:  8: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4:  8: . . . . . . . . . . . . . . . . . . . . . Operand (
    4:  8: . . . . . . . . . . . . . . . . . . . . . . INT 9
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 9}
    4:  9: . . . . . . . . . . . . . . . . . . . . . )
    4:  9: . . . . . . . . . . . . . . . . . . . . )
    4:  9: . . . . . . . . . . . . . . . . . . . )
    4:  9: . . . . . . . . . . . . . . . . . . )
    4:  9: . . . . . . . . . . . . . . . . . )
    4:  9: . . . . . . . . . . . . . . . . . ";"
    5:  1: . . . . . . . . . . . . . . . . . "]"
    5:  2: . . . . . . . . . . . . . . . . )
    5:  2: . . . . . . . . . . . . . . . )
    5:  2: . . . . . . . . . . . . . . )
    5:  2: . . . . . . . . . . . . . )
    5:  2: . . . . . . . . . . . . )
    5:  2: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: echo, Ellipsis: false, isCmd: true}
    5:  2: . . . . . . . . . . )
    5:  2: . . . . . . . . . )
    5:  2: . . . . . . . . )
    5:  2: . . . . . . . )
    5:  2: . . . . . . )
    5:  2: . . . . . )
    5:  2: . . . . )
    5:  2: . . . . ";"
    5:  3: . . . )
    5:  3: . . )
    5:  3: . )
    5:  3: )
=== RUN   TestFromTestdata/mytest
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/mytest
    1:  1: File (
    1:  1: . "package"
    1:  9: . IDENT demo
 /app/parser/parser.go:713: ast.Ident{Name: demo}
    1: 13: . ";"
    3:  1: . GenDecl(import) (
    3:  1: . . "import"
    3:  8: . . "("
    4:  2: . . ImportSpec (
    4:  2: . . . STRING "go/token"
    4: 12: . . . ";"
    5:  2: . . )
    5:  2: . . ImportSpec (
    5:  2: . . . STRING "os"
    5:  6: . . . ";"
    6:  1: . . )
    6:  1: . . ")"
    6:  2: . . ";"
    8:  1: . )
    8:  1: . Declaration (
    8:  1: . . GenDecl(var) (
    8:  1: . . . "var"
    8:  5: . . . varSpec (
    8:  5: . . . . IdentList (
    8:  5: . . . . . IDENT stmtStart
 /app/parser/parser.go:713: ast.Ident{Name: stmtStart}
    8: 15: . . . . )
    8: 15: . . . . "="
    8: 17: . . . . ExpressionList (
    8: 17: . . . . . Expression (
    8: 17: . . . . . . BinaryExpr (
    8: 17: . . . . . . . UnaryExpr (
    8: 17: . . . . . . . . PrimaryExpr (
    8: 17: . . . . . . . . . Operand (
    8: 17: . . . . . . . . . . "map"
    8: 17: . . . . . . . . . . MapType (
    8: 20: . . . . . . . . . . . "["
    8: 21: . . . . . . . . . . . Type (
    8: 21: . . . . . . . . . . . . TypeName (
    8: 21: . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
    8: 26: . . . . . . . . . . . . . "."
    8: 27: . . . . . . . . . . . . . IDENT Token
 /app/parser/parser.go:713: ast.Ident{Name: Token}
    8: 32: . . . . . . . . . . . . )
    8: 32: . . . . . . . . . . . )
    8: 32: . . . . . . . . . . . "]"
    8: 33: . . . . . . . . . . . Type (
    8: 33: . . . . . . . . . . . . TypeName (
    8: 33: . . . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
    8: 37: . . . . . . . . . . . . )
    8: 37: . . . . . . . . . . . )
 /app/parser/parser.go:1455: ast.MapType{Key: &{token Token}, Value: bool}
    8: 37: . . . . . . . . . . )
    8: 37: . . . . . . . . . )
    8: 37: . . . . . . . . . LiteralValue (
    8: 37: . . . . . . . . . . "{"
    9:  2: . . . . . . . . . . ElementList (
    9:  2: . . . . . . . . . . . Element (
    9:  2: . . . . . . . . . . . . Element (
    9:  2: . . . . . . . . . . . . . Expression (
    9:  2: . . . . . . . . . . . . . . BinaryExpr (
    9:  2: . . . . . . . . . . . . . . . UnaryExpr (
    9:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
    9:  2: . . . . . . . . . . . . . . . . . Operand (
    9:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
    9:  7: . . . . . . . . . . . . . . . . . )
    9:  7: . . . . . . . . . . . . . . . . . "."
    9:  8: . . . . . . . . . . . . . . . . . Selector (
    9:  8: . . . . . . . . . . . . . . . . . . IDENT BREAK
 /app/parser/parser.go:713: ast.Ident{Name: BREAK}
    9: 13: . . . . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . ":"
    9: 21: . . . . . . . . . . . . Element (
    9: 21: . . . . . . . . . . . . . Expression (
    9: 21: . . . . . . . . . . . . . . BinaryExpr (
    9: 21: . . . . . . . . . . . . . . . UnaryExpr (
    9: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 21: . . . . . . . . . . . . . . . . . Operand (
    9: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
    9: 25: . . . . . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . ","
   10:  2: . . . . . . . . . . . Element (
   10:  2: . . . . . . . . . . . . Element (
   10:  2: . . . . . . . . . . . . . Expression (
   10:  2: . . . . . . . . . . . . . . BinaryExpr (
   10:  2: . . . . . . . . . . . . . . . UnaryExpr (
   10:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   10:  2: . . . . . . . . . . . . . . . . . Operand (
   10:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   10:  7: . . . . . . . . . . . . . . . . . )
   10:  7: . . . . . . . . . . . . . . . . . "."
   10:  8: . . . . . . . . . . . . . . . . . Selector (
   10:  8: . . . . . . . . . . . . . . . . . . IDENT CONST
 /app/parser/parser.go:713: ast.Ident{Name: CONST}
   10: 13: . . . . . . . . . . . . . . . . . )
   10: 13: . . . . . . . . . . . . . . . . )
   10: 13: . . . . . . . . . . . . . . . )
   10: 13: . . . . . . . . . . . . . . )
   10: 13: . . . . . . . . . . . . . )
   10: 13: . . . . . . . . . . . . )
   10: 13: . . . . . . . . . . . . ":"
   10: 21: . . . . . . . . . . . . Element (
   10: 21: . . . . . . . . . . . . . Expression (
   10: 21: . . . . . . . . . . . . . . BinaryExpr (
   10: 21: . . . . . . . . . . . . . . . UnaryExpr (
   10: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 21: . . . . . . . . . . . . . . . . . Operand (
   10: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   10: 25: . . . . . . . . . . . . . . . . . )
   10: 25: . . . . . . . . . . . . . . . . )
   10: 25: . . . . . . . . . . . . . . . )
   10: 25: . . . . . . . . . . . . . . )
   10: 25: . . . . . . . . . . . . . )
   10: 25: . . . . . . . . . . . . )
   10: 25: . . . . . . . . . . . )
   10: 25: . . . . . . . . . . . ","
   11:  2: . . . . . . . . . . . Element (
   11:  2: . . . . . . . . . . . . Element (
   11:  2: . . . . . . . . . . . . . Expression (
   11:  2: . . . . . . . . . . . . . . BinaryExpr (
   11:  2: . . . . . . . . . . . . . . . UnaryExpr (
   11:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   11:  2: . . . . . . . . . . . . . . . . . Operand (
   11:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   11:  7: . . . . . . . . . . . . . . . . . )
   11:  7: . . . . . . . . . . . . . . . . . "."
   11:  8: . . . . . . . . . . . . . . . . . Selector (
   11:  8: . . . . . . . . . . . . . . . . . . IDENT CONTINUE
 /app/parser/parser.go:713: ast.Ident{Name: CONTINUE}
   11: 16: . . . . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . )
   11: 16: . . . . . . . . . . . . ":"
   11: 21: . . . . . . . . . . . . Element (
   11: 21: . . . . . . . . . . . . . Expression (
   11: 21: . . . . . . . . . . . . . . BinaryExpr (
   11: 21: . . . . . . . . . . . . . . . UnaryExpr (
   11: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 21: . . . . . . . . . . . . . . . . . Operand (
   11: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   11: 25: . . . . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . ","
   12:  2: . . . . . . . . . . . Element (
   12:  2: . . . . . . . . . . . . Element (
   12:  2: . . . . . . . . . . . . . Expression (
   12:  2: . . . . . . . . . . . . . . BinaryExpr (
   12:  2: . . . . . . . . . . . . . . . UnaryExpr (
   12:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   12:  2: . . . . . . . . . . . . . . . . . Operand (
   12:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   12:  7: . . . . . . . . . . . . . . . . . )
   12:  7: . . . . . . . . . . . . . . . . . "."
   12:  8: . . . . . . . . . . . . . . . . . Selector (
   12:  8: . . . . . . . . . . . . . . . . . . IDENT DEFER
 /app/parser/parser.go:713: ast.Ident{Name: DEFER}
   12: 13: . . . . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . ":"
   12: 21: . . . . . . . . . . . . Element (
   12: 21: . . . . . . . . . . . . . Expression (
   12: 21: . . . . . . . . . . . . . . BinaryExpr (
   12: 21: . . . . . . . . . . . . . . . UnaryExpr (
   12: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   12: 21: . . . . . . . . . . . . . . . . . Operand (
   12: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   12: 25: . . . . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . ","
   13:  2: . . . . . . . . . . . Element (
   13:  2: . . . . . . . . . . . . Element (
   13:  2: . . . . . . . . . . . . . Expression (
   13:  2: . . . . . . . . . . . . . . BinaryExpr (
   13:  2: . . . . . . . . . . . . . . . UnaryExpr (
   13:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   13:  2: . . . . . . . . . . . . . . . . . Operand (
   13:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   13:  7: . . . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . . . . "."
   13:  8: . . . . . . . . . . . . . . . . . Selector (
   13:  8: . . . . . . . . . . . . . . . . . . IDENT FALLTHROUGH
 /app/parser/parser.go:713: ast.Ident{Name: FALLTHROUGH}
   13: 19: . . . . . . . . . . . . . . . . . )
   13: 19: . . . . . . . . . . . . . . . . )
   13: 19: . . . . . . . . . . . . . . . )
   13: 19: . . . . . . . . . . . . . . )
   13: 19: . . . . . . . . . . . . . )
   13: 19: . . . . . . . . . . . . )
   13: 19: . . . . . . . . . . . . ":"
   13: 21: . . . . . . . . . . . . Element (
   13: 21: . . . . . . . . . . . . . Expression (
   13: 21: . . . . . . . . . . . . . . BinaryExpr (
   13: 21: . . . . . . . . . . . . . . . UnaryExpr (
   13: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 21: . . . . . . . . . . . . . . . . . Operand (
   13: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   13: 25: . . . . . . . . . . . . . . . . . )
   13: 25: . . . . . . . . . . . . . . . . )
   13: 25: . . . . . . . . . . . . . . . )
   13: 25: . . . . . . . . . . . . . . )
   13: 25: . . . . . . . . . . . . . )
   13: 25: . . . . . . . . . . . . )
   13: 25: . . . . . . . . . . . )
   13: 25: . . . . . . . . . . . ","
   14:  2: . . . . . . . . . . . Element (
   14:  2: . . . . . . . . . . . . Element (
   14:  2: . . . . . . . . . . . . . Expression (
   14:  2: . . . . . . . . . . . . . . BinaryExpr (
   14:  2: . . . . . . . . . . . . . . . UnaryExpr (
   14:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   14:  2: . . . . . . . . . . . . . . . . . Operand (
   14:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   14:  7: . . . . . . . . . . . . . . . . . )
   14:  7: . . . . . . . . . . . . . . . . . "."
   14:  8: . . . . . . . . . . . . . . . . . Selector (
   14:  8: . . . . . . . . . . . . . . . . . . IDENT FOR
 /app/parser/parser.go:713: ast.Ident{Name: FOR}
   14: 11: . . . . . . . . . . . . . . . . . )
   14: 11: . . . . . . . . . . . . . . . . )
   14: 11: . . . . . . . . . . . . . . . )
   14: 11: . . . . . . . . . . . . . . )
   14: 11: . . . . . . . . . . . . . )
   14: 11: . . . . . . . . . . . . )
   14: 11: . . . . . . . . . . . . ":"
   14: 21: . . . . . . . . . . . . Element (
   14: 21: . . . . . . . . . . . . . Expression (
   14: 21: . . . . . . . . . . . . . . BinaryExpr (
   14: 21: . . . . . . . . . . . . . . . UnaryExpr (
   14: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   14: 21: . . . . . . . . . . . . . . . . . Operand (
   14: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   14: 25: . . . . . . . . . . . . . . . . . )
   14: 25: . . . . . . . . . . . . . . . . )
   14: 25: . . . . . . . . . . . . . . . )
   14: 25: . . . . . . . . . . . . . . )
   14: 25: . . . . . . . . . . . . . )
   14: 25: . . . . . . . . . . . . )
   14: 25: . . . . . . . . . . . )
   14: 25: . . . . . . . . . . . ","
   15:  2: . . . . . . . . . . . Element (
   15:  2: . . . . . . . . . . . . Element (
   15:  2: . . . . . . . . . . . . . Expression (
   15:  2: . . . . . . . . . . . . . . BinaryExpr (
   15:  2: . . . . . . . . . . . . . . . UnaryExpr (
   15:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   15:  2: . . . . . . . . . . . . . . . . . Operand (
   15:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   15:  7: . . . . . . . . . . . . . . . . . )
   15:  7: . . . . . . . . . . . . . . . . . "."
   15:  8: . . . . . . . . . . . . . . . . . Selector (
   15:  8: . . . . . . . . . . . . . . . . . . IDENT GO
 /app/parser/parser.go:713: ast.Ident{Name: GO}
   15: 10: . . . . . . . . . . . . . . . . . )
   15: 10: . . . . . . . . . . . . . . . . )
   15: 10: . . . . . . . . . . . . . . . )
   15: 10: . . . . . . . . . . . . . . )
   15: 10: . . . . . . . . . . . . . )
   15: 10: . . . . . . . . . . . . )
   15: 10: . . . . . . . . . . . . ":"
   15: 21: . . . . . . . . . . . . Element (
   15: 21: . . . . . . . . . . . . . Expression (
   15: 21: . . . . . . . . . . . . . . BinaryExpr (
   15: 21: . . . . . . . . . . . . . . . UnaryExpr (
   15: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   15: 21: . . . . . . . . . . . . . . . . . Operand (
   15: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   15: 25: . . . . . . . . . . . . . . . . . )
   15: 25: . . . . . . . . . . . . . . . . )
   15: 25: . . . . . . . . . . . . . . . )
   15: 25: . . . . . . . . . . . . . . )
   15: 25: . . . . . . . . . . . . . )
   15: 25: . . . . . . . . . . . . )
   15: 25: . . . . . . . . . . . )
   15: 25: . . . . . . . . . . . ","
   16:  2: . . . . . . . . . . . Element (
   16:  2: . . . . . . . . . . . . Element (
   16:  2: . . . . . . . . . . . . . Expression (
   16:  2: . . . . . . . . . . . . . . BinaryExpr (
   16:  2: . . . . . . . . . . . . . . . UnaryExpr (
   16:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   16:  2: . . . . . . . . . . . . . . . . . Operand (
   16:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   16:  7: . . . . . . . . . . . . . . . . . )
   16:  7: . . . . . . . . . . . . . . . . . "."
   16:  8: . . . . . . . . . . . . . . . . . Selector (
   16:  8: . . . . . . . . . . . . . . . . . . IDENT GOTO
 /app/parser/parser.go:713: ast.Ident{Name: GOTO}
   16: 12: . . . . . . . . . . . . . . . . . )
   16: 12: . . . . . . . . . . . . . . . . )
   16: 12: . . . . . . . . . . . . . . . )
   16: 12: . . . . . . . . . . . . . . )
   16: 12: . . . . . . . . . . . . . )
   16: 12: . . . . . . . . . . . . )
   16: 12: . . . . . . . . . . . . ":"
   16: 21: . . . . . . . . . . . . Element (
   16: 21: . . . . . . . . . . . . . Expression (
   16: 21: . . . . . . . . . . . . . . BinaryExpr (
   16: 21: . . . . . . . . . . . . . . . UnaryExpr (
   16: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   16: 21: . . . . . . . . . . . . . . . . . Operand (
   16: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   16: 25: . . . . . . . . . . . . . . . . . )
   16: 25: . . . . . . . . . . . . . . . . )
   16: 25: . . . . . . . . . . . . . . . )
   16: 25: . . . . . . . . . . . . . . )
   16: 25: . . . . . . . . . . . . . )
   16: 25: . . . . . . . . . . . . )
   16: 25: . . . . . . . . . . . )
   16: 25: . . . . . . . . . . . ","
   17:  2: . . . . . . . . . . . Element (
   17:  2: . . . . . . . . . . . . Element (
   17:  2: . . . . . . . . . . . . . Expression (
   17:  2: . . . . . . . . . . . . . . BinaryExpr (
   17:  2: . . . . . . . . . . . . . . . UnaryExpr (
   17:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   17:  2: . . . . . . . . . . . . . . . . . Operand (
   17:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   17:  7: . . . . . . . . . . . . . . . . . )
   17:  7: . . . . . . . . . . . . . . . . . "."
   17:  8: . . . . . . . . . . . . . . . . . Selector (
   17:  8: . . . . . . . . . . . . . . . . . . IDENT IF
 /app/parser/parser.go:713: ast.Ident{Name: IF}
   17: 10: . . . . . . . . . . . . . . . . . )
   17: 10: . . . . . . . . . . . . . . . . )
   17: 10: . . . . . . . . . . . . . . . )
   17: 10: . . . . . . . . . . . . . . )
   17: 10: . . . . . . . . . . . . . )
   17: 10: . . . . . . . . . . . . )
   17: 10: . . . . . . . . . . . . ":"
   17: 21: . . . . . . . . . . . . Element (
   17: 21: . . . . . . . . . . . . . Expression (
   17: 21: . . . . . . . . . . . . . . BinaryExpr (
   17: 21: . . . . . . . . . . . . . . . UnaryExpr (
   17: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   17: 21: . . . . . . . . . . . . . . . . . Operand (
   17: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   17: 25: . . . . . . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . )
   17: 25: . . . . . . . . . . . ","
   18:  2: . . . . . . . . . . . Element (
   18:  2: . . . . . . . . . . . . Element (
   18:  2: . . . . . . . . . . . . . Expression (
   18:  2: . . . . . . . . . . . . . . BinaryExpr (
   18:  2: . . . . . . . . . . . . . . . UnaryExpr (
   18:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   18:  2: . . . . . . . . . . . . . . . . . Operand (
   18:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   18:  7: . . . . . . . . . . . . . . . . . )
   18:  7: . . . . . . . . . . . . . . . . . "."
   18:  8: . . . . . . . . . . . . . . . . . Selector (
   18:  8: . . . . . . . . . . . . . . . . . . IDENT RETURN
 /app/parser/parser.go:713: ast.Ident{Name: RETURN}
   18: 14: . . . . . . . . . . . . . . . . . )
   18: 14: . . . . . . . . . . . . . . . . )
   18: 14: . . . . . . . . . . . . . . . )
   18: 14: . . . . . . . . . . . . . . )
   18: 14: . . . . . . . . . . . . . )
   18: 14: . . . . . . . . . . . . )
   18: 14: . . . . . . . . . . . . ":"
   18: 21: . . . . . . . . . . . . Element (
   18: 21: . . . . . . . . . . . . . Expression (
   18: 21: . . . . . . . . . . . . . . BinaryExpr (
   18: 21: . . . . . . . . . . . . . . . UnaryExpr (
   18: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   18: 21: . . . . . . . . . . . . . . . . . Operand (
   18: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   18: 25: . . . . . . . . . . . . . . . . . )
   18: 25: . . . . . . . . . . . . . . . . )
   18: 25: . . . . . . . . . . . . . . . )
   18: 25: . . . . . . . . . . . . . . )
   18: 25: . . . . . . . . . . . . . )
   18: 25: . . . . . . . . . . . . )
   18: 25: . . . . . . . . . . . )
   18: 25: . . . . . . . . . . . ","
   19:  2: . . . . . . . . . . . Element (
   19:  2: . . . . . . . . . . . . Element (
   19:  2: . . . . . . . . . . . . . Expression (
   19:  2: . . . . . . . . . . . . . . BinaryExpr (
   19:  2: . . . . . . . . . . . . . . . UnaryExpr (
   19:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   19:  2: . . . . . . . . . . . . . . . . . Operand (
   19:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   19:  7: . . . . . . . . . . . . . . . . . )
   19:  7: . . . . . . . . . . . . . . . . . "."
   19:  8: . . . . . . . . . . . . . . . . . Selector (
   19:  8: . . . . . . . . . . . . . . . . . . IDENT SELECT
 /app/parser/parser.go:713: ast.Ident{Name: SELECT}
   19: 14: . . . . . . . . . . . . . . . . . )
   19: 14: . . . . . . . . . . . . . . . . )
   19: 14: . . . . . . . . . . . . . . . )
   19: 14: . . . . . . . . . . . . . . )
   19: 14: . . . . . . . . . . . . . )
   19: 14: . . . . . . . . . . . . )
   19: 14: . . . . . . . . . . . . ":"
   19: 21: . . . . . . . . . . . . Element (
   19: 21: . . . . . . . . . . . . . Expression (
   19: 21: . . . . . . . . . . . . . . BinaryExpr (
   19: 21: . . . . . . . . . . . . . . . UnaryExpr (
   19: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   19: 21: . . . . . . . . . . . . . . . . . Operand (
   19: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   19: 25: . . . . . . . . . . . . . . . . . )
   19: 25: . . . . . . . . . . . . . . . . )
   19: 25: . . . . . . . . . . . . . . . )
   19: 25: . . . . . . . . . . . . . . )
   19: 25: . . . . . . . . . . . . . )
   19: 25: . . . . . . . . . . . . )
   19: 25: . . . . . . . . . . . )
   19: 25: . . . . . . . . . . . ","
   20:  2: . . . . . . . . . . . Element (
   20:  2: . . . . . . . . . . . . Element (
   20:  2: . . . . . . . . . . . . . Expression (
   20:  2: . . . . . . . . . . . . . . BinaryExpr (
   20:  2: . . . . . . . . . . . . . . . UnaryExpr (
   20:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   20:  2: . . . . . . . . . . . . . . . . . Operand (
   20:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   20:  7: . . . . . . . . . . . . . . . . . )
   20:  7: . . . . . . . . . . . . . . . . . "."
   20:  8: . . . . . . . . . . . . . . . . . Selector (
   20:  8: . . . . . . . . . . . . . . . . . . IDENT SWITCH
 /app/parser/parser.go:713: ast.Ident{Name: SWITCH}
   20: 14: . . . . . . . . . . . . . . . . . )
   20: 14: . . . . . . . . . . . . . . . . )
   20: 14: . . . . . . . . . . . . . . . )
   20: 14: . . . . . . . . . . . . . . )
   20: 14: . . . . . . . . . . . . . )
   20: 14: . . . . . . . . . . . . )
   20: 14: . . . . . . . . . . . . ":"
   20: 21: . . . . . . . . . . . . Element (
   20: 21: . . . . . . . . . . . . . Expression (
   20: 21: . . . . . . . . . . . . . . BinaryExpr (
   20: 21: . . . . . . . . . . . . . . . UnaryExpr (
   20: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   20: 21: . . . . . . . . . . . . . . . . . Operand (
   20: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   20: 25: . . . . . . . . . . . . . . . . . )
   20: 25: . . . . . . . . . . . . . . . . )
   20: 25: . . . . . . . . . . . . . . . )
   20: 25: . . . . . . . . . . . . . . )
   20: 25: . . . . . . . . . . . . . )
   20: 25: . . . . . . . . . . . . )
   20: 25: . . . . . . . . . . . )
   20: 25: . . . . . . . . . . . ","
   21:  2: . . . . . . . . . . . Element (
   21:  2: . . . . . . . . . . . . Element (
   21:  2: . . . . . . . . . . . . . Expression (
   21:  2: . . . . . . . . . . . . . . BinaryExpr (
   21:  2: . . . . . . . . . . . . . . . UnaryExpr (
   21:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   21:  2: . . . . . . . . . . . . . . . . . Operand (
   21:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   21:  7: . . . . . . . . . . . . . . . . . )
   21:  7: . . . . . . . . . . . . . . . . . "."
   21:  8: . . . . . . . . . . . . . . . . . Selector (
   21:  8: . . . . . . . . . . . . . . . . . . IDENT TYPE
 /app/parser/parser.go:713: ast.Ident{Name: TYPE}
   21: 12: . . . . . . . . . . . . . . . . . )
   21: 12: . . . . . . . . . . . . . . . . )
   21: 12: . . . . . . . . . . . . . . . )
   21: 12: . . . . . . . . . . . . . . )
   21: 12: . . . . . . . . . . . . . )
   21: 12: . . . . . . . . . . . . )
   21: 12: . . . . . . . . . . . . ":"
   21: 21: . . . . . . . . . . . . Element (
   21: 21: . . . . . . . . . . . . . Expression (
   21: 21: . . . . . . . . . . . . . . BinaryExpr (
   21: 21: . . . . . . . . . . . . . . . UnaryExpr (
   21: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   21: 21: . . . . . . . . . . . . . . . . . Operand (
   21: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   21: 25: . . . . . . . . . . . . . . . . . )
   21: 25: . . . . . . . . . . . . . . . . )
   21: 25: . . . . . . . . . . . . . . . )
   21: 25: . . . . . . . . . . . . . . )
   21: 25: . . . . . . . . . . . . . )
   21: 25: . . . . . . . . . . . . )
   21: 25: . . . . . . . . . . . )
   21: 25: . . . . . . . . . . . ","
   22:  2: . . . . . . . . . . . Element (
   22:  2: . . . . . . . . . . . . Element (
   22:  2: . . . . . . . . . . . . . Expression (
   22:  2: . . . . . . . . . . . . . . BinaryExpr (
   22:  2: . . . . . . . . . . . . . . . UnaryExpr (
   22:  2: . . . . . . . . . . . . . . . . PrimaryExpr (
   22:  2: . . . . . . . . . . . . . . . . . Operand (
   22:  2: . . . . . . . . . . . . . . . . . . IDENT token
 /app/parser/parser.go:713: ast.Ident{Name: token}
   22:  7: . . . . . . . . . . . . . . . . . )
   22:  7: . . . . . . . . . . . . . . . . . "."
   22:  8: . . . . . . . . . . . . . . . . . Selector (
   22:  8: . . . . . . . . . . . . . . . . . . IDENT VAR
 /app/parser/parser.go:713: ast.Ident{Name: VAR}
   22: 11: . . . . . . . . . . . . . . . . . )
   22: 11: . . . . . . . . . . . . . . . . )
   22: 11: . . . . . . . . . . . . . . . )
   22: 11: . . . . . . . . . . . . . . )
   22: 11: . . . . . . . . . . . . . )
   22: 11: . . . . . . . . . . . . )
   22: 11: . . . . . . . . . . . . ":"
   22: 21: . . . . . . . . . . . . Element (
   22: 21: . . . . . . . . . . . . . Expression (
   22: 21: . . . . . . . . . . . . . . BinaryExpr (
   22: 21: . . . . . . . . . . . . . . . UnaryExpr (
   22: 21: . . . . . . . . . . . . . . . . PrimaryExpr (
   22: 21: . . . . . . . . . . . . . . . . . Operand (
   22: 21: . . . . . . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   22: 25: . . . . . . . . . . . . . . . . . )
   22: 25: . . . . . . . . . . . . . . . . )
   22: 25: . . . . . . . . . . . . . . . )
   22: 25: . . . . . . . . . . . . . . )
   22: 25: . . . . . . . . . . . . . )
   22: 25: . . . . . . . . . . . . )
   22: 25: . . . . . . . . . . . )
   22: 25: . . . . . . . . . . . ","
   23:  1: . . . . . . . . . . )
   23:  1: . . . . . . . . . . "}"
   23:  2: . . . . . . . . . )
   23:  2: . . . . . . . . )
   23:  2: . . . . . . . )
   23:  2: . . . . . . )
   23:  2: . . . . . )
   23:  2: . . . . )
   23:  2: . . . . ";"
   25:  1: . . . )
   25:  1: . . )
   25:  1: . )
   25:  1: . Declaration (
   25:  1: . . GenDecl(type) (
   25:  1: . . . "type"
   25:  6: . . . TypeSpec (
   25:  6: . . . . IDENT Mode
 /app/parser/parser.go:713: ast.Ident{Name: Mode}
   25: 11: . . . . Type (
   25: 11: . . . . . TypeName (
   25: 11: . . . . . . IDENT uint
 /app/parser/parser.go:713: ast.Ident{Name: uint}
   25: 15: . . . . . )
   25: 15: . . . . )
   25: 15: . . . . ";"
   27:  1: . . . )
   27:  1: . . )
   27:  1: . )
   27:  1: . Declaration (
   27:  1: . . GenDecl(const) (
   27:  1: . . . "const"
   27:  7: . . . "("
   28:  2: . . . COMMENT
   29:  2: . . . constSpec (
   29:  2: . . . . IdentList (
   29:  2: . . . . . IDENT PackageClauseOnly
 /app/parser/parser.go:713: ast.Ident{Name: PackageClauseOnly}
   29: 20: . . . . )
   29: 20: . . . . TypeName (
   29: 20: . . . . . IDENT Mode
 /app/parser/parser.go:713: ast.Ident{Name: Mode}
   29: 25: . . . . )
   29: 25: . . . . "="
   29: 27: . . . . ExpressionList (
   29: 27: . . . . . Expression (
   29: 27: . . . . . . BinaryExpr (
   29: 27: . . . . . . . UnaryExpr (
   29: 27: . . . . . . . . PrimaryExpr (
   29: 27: . . . . . . . . . Operand (
   29: 27: . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   29: 29: . . . . . . . . . )
   29: 29: . . . . . . . . )
   29: 29: . . . . . . . )
   29: 29: . . . . . . . "<<"
   29: 32: . . . . . . . BinaryExpr (
   29: 32: . . . . . . . . UnaryExpr (
   29: 32: . . . . . . . . . PrimaryExpr (
   29: 32: . . . . . . . . . . Operand (
   29: 32: . . . . . . . . . . . IDENT iota
 /app/parser/parser.go:713: ast.Ident{Name: iota}
   29: 36: . . . . . . . . . . )
   29: 36: . . . . . . . . . )
   29: 36: . . . . . . . . )
   29: 36: . . . . . . . )
   29: 36: . . . . . . )
   29: 36: . . . . . )
   29: 36: . . . . )
   29: 36: . . . . ";"
   30:  2: . . . . COMMENT
   31:  2: . . . )
   31:  2: . . . constSpec (
   31:  2: . . . . IdentList (
   31:  2: . . . . . IDENT ImportsOnly
 /app/parser/parser.go:713: ast.Ident{Name: ImportsOnly}
   31: 13: . . . . )
   31: 13: . . . . ";"
   32:  2: . . . . COMMENT
   33:  2: . . . )
   33:  2: . . . constSpec (
   33:  2: . . . . IdentList (
   33:  2: . . . . . IDENT ParseComments
 /app/parser/parser.go:713: ast.Ident{Name: ParseComments}
   33: 15: . . . . )
   33: 15: . . . . ";"
   34:  2: . . . . COMMENT
   35:  2: . . . )
   35:  2: . . . constSpec (
   35:  2: . . . . IdentList (
   35:  2: . . . . . IDENT Trace
 /app/parser/parser.go:713: ast.Ident{Name: Trace}
   35:  7: . . . . )
   35:  7: . . . . ";"
   36:  2: . . . . COMMENT
   37:  2: . . . )
   37:  2: . . . constSpec (
   37:  2: . . . . IdentList (
   37:  2: . . . . . IDENT DeclarationErrors
 /app/parser/parser.go:713: ast.Ident{Name: DeclarationErrors}
   37: 19: . . . . )
   37: 19: . . . . ";"
   38:  2: . . . . COMMENT
   39:  2: . . . )
   39:  2: . . . constSpec (
   39:  2: . . . . IdentList (
   39:  2: . . . . . IDENT AllErrors
 /app/parser/parser.go:713: ast.Ident{Name: AllErrors}
   39: 11: . . . . )
   39: 11: . . . . ";"
   40:  1: . . . )
   40:  1: . . . ")"
   40:  2: . . . ";"
   42:  1: . . . COMMENT
   43:  1: . . )
   43:  1: . )
   43:  1: . Declaration (
   43:  1: . . GenDecl(type) (
   43:  1: . . . "type"
   43:  6: . . . TypeSpec (
   43:  6: . . . . IDENT FileSystem
 /app/parser/parser.go:713: ast.Ident{Name: FileSystem}
   43: 17: . . . . Type (
   43: 17: . . . . . InterfaceType (
   43: 17: . . . . . . "interface"
   43: 27: . . . . . . "{"
   44:  2: . . . . . . MethodSpec (
   44:  2: . . . . . . . TypeName (
   44:  2: . . . . . . . . IDENT ReadDir
 /app/parser/parser.go:713: ast.Ident{Name: ReadDir}
   44:  9: . . . . . . . )
   44:  9: . . . . . . . Signature (
   44:  9: . . . . . . . . Parameters (
   44:  9: . . . . . . . . . "("
   44: 10: . . . . . . . . . ParameterList (
   44: 10: . . . . . . . . . . ParamDeclOrNil (
   44: 10: . . . . . . . . . . . IDENT dirname
 /app/parser/parser.go:713: ast.Ident{Name: dirname}
   44: 18: . . . . . . . . . . . Type (
   44: 18: . . . . . . . . . . . . TypeName (
   44: 18: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   44: 24: . . . . . . . . . . . . )
   44: 24: . . . . . . . . . . . )
   44: 24: . . . . . . . . . . )
   44: 24: . . . . . . . . . )
   44: 24: . . . . . . . . . ")"
   44: 26: . . . . . . . . )
   44: 26: . . . . . . . . Result (
   44: 26: . . . . . . . . . Parameters (
   44: 26: . . . . . . . . . . "("
   44: 27: . . . . . . . . . . ParameterList (
   44: 27: . . . . . . . . . . . ParamDeclOrNil (
   44: 27: . . . . . . . . . . . . Type (
   44: 27: . . . . . . . . . . . . . ArrayType (
   44: 27: . . . . . . . . . . . . . . "["
   44: 28: . . . . . . . . . . . . . . "]"
   44: 29: . . . . . . . . . . . . . . Type (
   44: 29: . . . . . . . . . . . . . . . TypeName (
   44: 29: . . . . . . . . . . . . . . . . IDENT os
 /app/parser/parser.go:713: ast.Ident{Name: os}
   44: 31: . . . . . . . . . . . . . . . . "."
   44: 32: . . . . . . . . . . . . . . . . IDENT FileInfo
 /app/parser/parser.go:713: ast.Ident{Name: FileInfo}
   44: 40: . . . . . . . . . . . . . . . )
   44: 40: . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: &{os FileInfo}}
   44: 40: . . . . . . . . . . . . . )
   44: 40: . . . . . . . . . . . . )
   44: 40: . . . . . . . . . . . )
   44: 40: . . . . . . . . . . . ","
   44: 42: . . . . . . . . . . . ParamDeclOrNil (
   44: 42: . . . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   44: 47: . . . . . . . . . . . )
   44: 47: . . . . . . . . . . )
   44: 47: . . . . . . . . . . ")"
   44: 48: . . . . . . . . . )
   44: 48: . . . . . . . . )
   44: 48: . . . . . . . )
   44: 48: . . . . . . . ";"
   45:  2: . . . . . . )
   45:  2: . . . . . . MethodSpec (
   45:  2: . . . . . . . TypeName (
   45:  2: . . . . . . . . IDENT ReadFile
 /app/parser/parser.go:713: ast.Ident{Name: ReadFile}
   45: 10: . . . . . . . )
   45: 10: . . . . . . . Signature (
   45: 10: . . . . . . . . Parameters (
   45: 10: . . . . . . . . . "("
   45: 11: . . . . . . . . . ParameterList (
   45: 11: . . . . . . . . . . ParamDeclOrNil (
   45: 11: . . . . . . . . . . . IDENT filename
 /app/parser/parser.go:713: ast.Ident{Name: filename}
   45: 20: . . . . . . . . . . . Type (
   45: 20: . . . . . . . . . . . . TypeName (
   45: 20: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   45: 26: . . . . . . . . . . . . )
   45: 26: . . . . . . . . . . . )
   45: 26: . . . . . . . . . . )
   45: 26: . . . . . . . . . )
   45: 26: . . . . . . . . . ")"
   45: 28: . . . . . . . . )
   45: 28: . . . . . . . . Result (
   45: 28: . . . . . . . . . Parameters (
   45: 28: . . . . . . . . . . "("
   45: 29: . . . . . . . . . . ParameterList (
   45: 29: . . . . . . . . . . . ParamDeclOrNil (
   45: 29: . . . . . . . . . . . . Type (
   45: 29: . . . . . . . . . . . . . ArrayType (
   45: 29: . . . . . . . . . . . . . . "["
   45: 30: . . . . . . . . . . . . . . "]"
   45: 31: . . . . . . . . . . . . . . Type (
   45: 31: . . . . . . . . . . . . . . . TypeName (
   45: 31: . . . . . . . . . . . . . . . . IDENT byte
 /app/parser/parser.go:713: ast.Ident{Name: byte}
   45: 35: . . . . . . . . . . . . . . . )
   45: 35: . . . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: byte}
   45: 35: . . . . . . . . . . . . . )
   45: 35: . . . . . . . . . . . . )
   45: 35: . . . . . . . . . . . )
   45: 35: . . . . . . . . . . . ","
   45: 37: . . . . . . . . . . . ParamDeclOrNil (
   45: 37: . . . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   45: 42: . . . . . . . . . . . )
   45: 42: . . . . . . . . . . )
   45: 42: . . . . . . . . . . ")"
   45: 43: . . . . . . . . . )
   45: 43: . . . . . . . . )
   45: 43: . . . . . . . )
   45: 43: . . . . . . . ";"
   46:  2: . . . . . . )
   46:  2: . . . . . . MethodSpec (
   46:  2: . . . . . . . TypeName (
   46:  2: . . . . . . . . IDENT Join
 /app/parser/parser.go:713: ast.Ident{Name: Join}
   46:  6: . . . . . . . )
   46:  6: . . . . . . . Signature (
   46:  6: . . . . . . . . Parameters (
   46:  6: . . . . . . . . . "("
   46:  7: . . . . . . . . . ParameterList (
   46:  7: . . . . . . . . . . ParamDeclOrNil (
   46:  7: . . . . . . . . . . . IDENT elem
 /app/parser/parser.go:713: ast.Ident{Name: elem}
   46: 12: . . . . . . . . . . . DotsType (
   46: 12: . . . . . . . . . . . . "..."
   46: 15: . . . . . . . . . . . . Type (
   46: 15: . . . . . . . . . . . . . TypeName (
   46: 15: . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   46: 21: . . . . . . . . . . . . . )
   46: 21: . . . . . . . . . . . . )
   46: 21: . . . . . . . . . . . )
   46: 21: . . . . . . . . . . )
   46: 21: . . . . . . . . . )
   46: 21: . . . . . . . . . ")"
   46: 23: . . . . . . . . )
   46: 23: . . . . . . . . Result (
   46: 23: . . . . . . . . . TypeName (
   46: 23: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   46: 29: . . . . . . . . . )
   46: 29: . . . . . . . . )
   46: 29: . . . . . . . )
   46: 29: . . . . . . . ";"
   47:  1: . . . . . . )
   47:  1: . . . . . . "}"
   47:  2: . . . . . )
   47:  2: . . . . )
   47:  2: . . . . ";"
   49:  1: . . . )
   49:  1: . . )
   49:  1: . )
   49:  1: . Declaration (
   49:  1: . . GenDecl(type) (
   49:  1: . . . "type"
   49:  6: . . . TypeSpec (
   49:  6: . . . . IDENT IF
 /app/parser/parser.go:713: ast.Ident{Name: IF}
   49:  9: . . . . "="
   49: 11: . . . . Type (
   49: 11: . . . . . TypeName (
   49: 11: . . . . . . IDENT FileSystem
 /app/parser/parser.go:713: ast.Ident{Name: FileSystem}
   49: 21: . . . . . )
   49: 21: . . . . )
   49: 21: . . . . ";"
   51:  1: . . . )
   51:  1: . . )
   51:  1: . )
   51:  1: . Declaration (
   51:  1: . . GenDecl(type) (
   51:  1: . . . "type"
   51:  6: . . . TypeSpec (
   51:  6: . . . . IDENT Foo
 /app/parser/parser.go:713: ast.Ident{Name: Foo}
   51: 10: . . . . Type (
   51: 10: . . . . . StructType (
   51: 10: . . . . . . "struct"
   51: 17: . . . . . . "{"
   52:  2: . . . . . . FieldDecl (
   52:  2: . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   52:  3: . . . . . . . ","
   52:  5: . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   52:  7: . . . . . . . Type (
   52:  7: . . . . . . . . MapType (
   52:  7: . . . . . . . . . "map"
   52: 10: . . . . . . . . . "["
   52: 11: . . . . . . . . . Type (
   52: 11: . . . . . . . . . . TypeName (
   52: 11: . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   52: 17: . . . . . . . . . . )
   52: 17: . . . . . . . . . )
   52: 17: . . . . . . . . . "]"
   52: 18: . . . . . . . . . Type (
   52: 18: . . . . . . . . . . StructType (
   52: 18: . . . . . . . . . . . "struct"
   52: 24: . . . . . . . . . . . "{"
   52: 25: . . . . . . . . . . . "}"
   52: 26: . . . . . . . . . . )
   52: 26: . . . . . . . . . )
 /app/parser/parser.go:1455: ast.MapType{Key: string, Value: &{1171 0xc000300240 false}}
   52: 26: . . . . . . . . )
   52: 26: . . . . . . . )
   52: 26: . . . . . . . ";"
   53:  1: . . . . . . )
   53:  1: . . . . . . "}"
   53:  2: . . . . . )
   53:  2: . . . . )
   53:  2: . . . . ";"
   55:  1: . . . )
   55:  1: . . )
   55:  1: . )
   55:  1: . Declaration (
   55:  1: . . FunctionDeclOrCall (
   55:  1: . . . "func"
   55:  6: . . . Parameters (
   55:  6: . . . . "("
   55:  7: . . . . ParameterList (
   55:  7: . . . . . ParamDeclOrNil (
   55:  7: . . . . . . IDENT p
 /app/parser/parser.go:713: ast.Ident{Name: p}
   55:  9: . . . . . . Type (
   55:  9: . . . . . . . PointerType (
   55:  9: . . . . . . . . "*"
   55: 10: . . . . . . . . Type (
   55: 10: . . . . . . . . . TypeName (
   55: 10: . . . . . . . . . . IDENT Foo
 /app/parser/parser.go:713: ast.Ident{Name: Foo}
   55: 13: . . . . . . . . . )
   55: 13: . . . . . . . . )
   55: 13: . . . . . . . )
   55: 13: . . . . . . )
   55: 13: . . . . . )
   55: 13: . . . . )
   55: 13: . . . . ")"
   55: 15: . . . )
   55: 15: . . . TypeName (
   55: 15: . . . . IDENT bar
 /app/parser/parser.go:713: ast.Ident{Name: bar}
   55: 18: . . . )
   55: 18: . . . Signature (
   55: 18: . . . . Parameters (
   55: 18: . . . . . "("
   55: 19: . . . . . ")"
   55: 21: . . . . )
   55: 21: . . . . Result (
   55: 21: . . . . )
   55: 21: . . . )
   55: 21: . . . Body (
   55: 21: . . . . "{"
   56:  1: . . . . StatementList (
   56:  1: . . . . )
   56:  1: . . . . "}"
   56:  2: . . . )
   56:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: bar, ...}
   58:  1: . . )
   58:  1: . )
   58:  1: . Declaration (
   58:  1: . . FunctionDeclOrCall (
   58:  1: . . . "func"
   58:  6: . . . IDENT init
 /app/parser/parser.go:713: ast.Ident{Name: init}
   58: 10: . . . Signature (
   58: 10: . . . . Parameters (
   58: 10: . . . . . "("
   58: 11: . . . . . ")"
   58: 13: . . . . )
   58: 13: . . . . Result (
   58: 13: . . . . )
   58: 13: . . . )
   58: 13: . . . Body (
   58: 13: . . . . "{"
   59:  2: . . . . StatementList (
   59:  2: . . . . . Statement (
   59:  2: . . . . . . SimpleStmt (
   59:  2: . . . . . . . ExpressionList (
   59:  2: . . . . . . . . Expression (
   59:  2: . . . . . . . . . BinaryExpr (
   59:  2: . . . . . . . . . . UnaryExpr (
   59:  2: . . . . . . . . . . . PrimaryExpr (
   59:  2: . . . . . . . . . . . . Operand (
   59:  2: . . . . . . . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   59:  3: . . . . . . . . . . . . )
   59:  3: . . . . . . . . . . . )
   59:  3: . . . . . . . . . . )
   59:  3: . . . . . . . . . )
   59:  3: . . . . . . . . )
   59:  3: . . . . . . . . ","
   59:  5: . . . . . . . . Expression (
   59:  5: . . . . . . . . . BinaryExpr (
   59:  5: . . . . . . . . . . UnaryExpr (
   59:  5: . . . . . . . . . . . PrimaryExpr (
   59:  5: . . . . . . . . . . . . Operand (
   59:  5: . . . . . . . . . . . . . IDENT err
 /app/parser/parser.go:713: ast.Ident{Name: err}
   59:  9: . . . . . . . . . . . . )
   59:  9: . . . . . . . . . . . )
   59:  9: . . . . . . . . . . )
   59:  9: . . . . . . . . . )
   59:  9: . . . . . . . . )
   59:  9: . . . . . . . )
   59:  9: . . . . . . . ":="
   59: 12: . . . . . . . ExpressionList (
   59: 12: . . . . . . . . Expression (
   59: 12: . . . . . . . . . BinaryExpr (
   59: 12: . . . . . . . . . . UnaryExpr (
   59: 12: . . . . . . . . . . . PrimaryExpr (
   59: 12: . . . . . . . . . . . . Operand (
   59: 12: . . . . . . . . . . . . . IDENT os
 /app/parser/parser.go:713: ast.Ident{Name: os}
   59: 14: . . . . . . . . . . . . )
   59: 14: . . . . . . . . . . . . "."
   59: 15: . . . . . . . . . . . . Selector (
   59: 15: . . . . . . . . . . . . . IDENT Open
 /app/parser/parser.go:713: ast.Ident{Name: Open}
   59: 19: . . . . . . . . . . . . )
   59: 19: . . . . . . . . . . . . CallOrConversion (
   59: 19: . . . . . . . . . . . . . "("
   59: 20: . . . . . . . . . . . . . Expression (
   59: 20: . . . . . . . . . . . . . . BinaryExpr (
   59: 20: . . . . . . . . . . . . . . . UnaryExpr (
   59: 20: . . . . . . . . . . . . . . . . PrimaryExpr (
   59: 20: . . . . . . . . . . . . . . . . . Operand (
   59: 20: . . . . . . . . . . . . . . . . . . STRING "a"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a"}
   59: 23: . . . . . . . . . . . . . . . . . )
   59: 23: . . . . . . . . . . . . . . . . )
   59: 23: . . . . . . . . . . . . . . . )
   59: 23: . . . . . . . . . . . . . . )
   59: 23: . . . . . . . . . . . . . )
   59: 23: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{os Open}, Ellipsis: false, isCmd: false}
   59: 24: . . . . . . . . . . . . )
   59: 24: . . . . . . . . . . . )
   59: 24: . . . . . . . . . . )
   59: 24: . . . . . . . . . )
   59: 24: . . . . . . . . )
   59: 24: . . . . . . . )
   59: 24: . . . . . . )
   59: 24: . . . . . . ";"
   60:  2: . . . . . )
   60:  2: . . . . . Statement (
   60:  2: . . . . . . IfStmt (
   60:  2: . . . . . . . "if"
   60:  5: . . . . . . . SimpleStmt (
   60:  5: . . . . . . . . ExpressionList (
   60:  5: . . . . . . . . . Expression (
   60:  5: . . . . . . . . . . BinaryExpr (
   60:  5: . . . . . . . . . . . UnaryExpr (
   60:  5: . . . . . . . . . . . . PrimaryExpr (
   60:  5: . . . . . . . . . . . . . Operand (
   60:  5: . . . . . . . . . . . . . . IDENT err
 /app/parser/parser.go:713: ast.Ident{Name: err}
   60:  9: . . . . . . . . . . . . . )
   60:  9: . . . . . . . . . . . . )
   60:  9: . . . . . . . . . . . )
   60:  9: . . . . . . . . . . . "!="
   60: 12: . . . . . . . . . . . BinaryExpr (
   60: 12: . . . . . . . . . . . . UnaryExpr (
   60: 12: . . . . . . . . . . . . . PrimaryExpr (
   60: 12: . . . . . . . . . . . . . . Operand (
   60: 12: . . . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
   60: 16: . . . . . . . . . . . . . . )
   60: 16: . . . . . . . . . . . . . )
   60: 16: . . . . . . . . . . . . )
   60: 16: . . . . . . . . . . . )
   60: 16: . . . . . . . . . . )
   60: 16: . . . . . . . . . )
   60: 16: . . . . . . . . )
   60: 16: . . . . . . . )
   60: 16: . . . . . . . BlockStmt (
   60: 16: . . . . . . . . "{"
   61:  3: . . . . . . . . StatementList (
   61:  3: . . . . . . . . . Statement (
   61:  3: . . . . . . . . . . ReturnStmt (
   61:  3: . . . . . . . . . . . "return"
   61:  9: . . . . . . . . . . . ";"
   62:  2: . . . . . . . . . . )
   62:  2: . . . . . . . . . )
   62:  2: . . . . . . . . )
   62:  2: . . . . . . . . "}"
   62:  3: . . . . . . . )
   62:  3: . . . . . . . ";"
   63:  2: . . . . . . )
   63:  2: . . . . . )
   63:  2: . . . . . Statement (
   63:  2: . . . . . . DeferStmt (
   63:  2: . . . . . . . "defer"
   63:  8: . . . . . . . Expression (
   63:  8: . . . . . . . . BinaryExpr (
   63:  8: . . . . . . . . . UnaryExpr (
   63:  8: . . . . . . . . . . PrimaryExpr (
   63:  8: . . . . . . . . . . . Operand (
   63:  8: . . . . . . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   63:  9: . . . . . . . . . . . )
   63:  9: . . . . . . . . . . . "."
   63: 10: . . . . . . . . . . . Selector (
   63: 10: . . . . . . . . . . . . IDENT Close
 /app/parser/parser.go:713: ast.Ident{Name: Close}
   63: 15: . . . . . . . . . . . )
   63: 15: . . . . . . . . . . . CallOrConversion (
   63: 15: . . . . . . . . . . . . "("
   63: 16: . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{f Close}, Ellipsis: false, isCmd: false}
   63: 17: . . . . . . . . . . . )
   63: 17: . . . . . . . . . . )
   63: 17: . . . . . . . . . )
   63: 17: . . . . . . . . )
   63: 17: . . . . . . . )
   63: 17: . . . . . . . ";"
   65:  2: . . . . . . )
   65:  2: . . . . . )
   65:  2: . . . . . Statement (
   65:  2: . . . . . . SimpleStmt (
   65:  2: . . . . . . . ExpressionList (
   65:  2: . . . . . . . . Expression (
   65:  2: . . . . . . . . . BinaryExpr (
   65:  2: . . . . . . . . . . UnaryExpr (
   65:  2: . . . . . . . . . . . PrimaryExpr (
   65:  2: . . . . . . . . . . . . Operand (
   65:  2: . . . . . . . . . . . . . IDENT ch
 /app/parser/parser.go:713: ast.Ident{Name: ch}
   65:  5: . . . . . . . . . . . . )
   65:  5: . . . . . . . . . . . )
   65:  5: . . . . . . . . . . )
   65:  5: . . . . . . . . . )
   65:  5: . . . . . . . . )
   65:  5: . . . . . . . )
   65:  5: . . . . . . . ":="
   65:  8: . . . . . . . ExpressionList (
   65:  8: . . . . . . . . Expression (
   65:  8: . . . . . . . . . BinaryExpr (
   65:  8: . . . . . . . . . . UnaryExpr (
   65:  8: . . . . . . . . . . . PrimaryExpr (
   65:  8: . . . . . . . . . . . . Operand (
   65:  8: . . . . . . . . . . . . . IDENT make
 /app/parser/parser.go:713: ast.Ident{Name: make}
   65: 12: . . . . . . . . . . . . )
   65: 12: . . . . . . . . . . . . CallOrConversion (
   65: 12: . . . . . . . . . . . . . "("
   65: 13: . . . . . . . . . . . . . Expression (
   65: 13: . . . . . . . . . . . . . . BinaryExpr (
   65: 13: . . . . . . . . . . . . . . . UnaryExpr (
   65: 13: . . . . . . . . . . . . . . . . PrimaryExpr (
   65: 13: . . . . . . . . . . . . . . . . . Operand (
   65: 13: . . . . . . . . . . . . . . . . . . ChanType (
   65: 13: . . . . . . . . . . . . . . . . . . . "chan"
   65: 18: . . . . . . . . . . . . . . . . . . . Type (
   65: 18: . . . . . . . . . . . . . . . . . . . . TypeName (
   65: 18: . . . . . . . . . . . . . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   65: 22: . . . . . . . . . . . . . . . . . . . . )
   65: 22: . . . . . . . . . . . . . . . . . . . )
   65: 22: . . . . . . . . . . . . . . . . . . )
   65: 22: . . . . . . . . . . . . . . . . . )
   65: 22: . . . . . . . . . . . . . . . . )
   65: 22: . . . . . . . . . . . . . . . )
   65: 22: . . . . . . . . . . . . . . )
   65: 22: . . . . . . . . . . . . . )
   65: 22: . . . . . . . . . . . . . ","
   65: 24: . . . . . . . . . . . . . Expression (
   65: 24: . . . . . . . . . . . . . . BinaryExpr (
   65: 24: . . . . . . . . . . . . . . . UnaryExpr (
   65: 24: . . . . . . . . . . . . . . . . PrimaryExpr (
   65: 24: . . . . . . . . . . . . . . . . . Operand (
   65: 24: . . . . . . . . . . . . . . . . . . INT 100
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
   65: 27: . . . . . . . . . . . . . . . . . )
   65: 27: . . . . . . . . . . . . . . . . )
   65: 27: . . . . . . . . . . . . . . . )
   65: 27: . . . . . . . . . . . . . . )
   65: 27: . . . . . . . . . . . . . )
   65: 27: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: make, Ellipsis: false, isCmd: false}
   65: 28: . . . . . . . . . . . . )
   65: 28: . . . . . . . . . . . )
   65: 28: . . . . . . . . . . )
   65: 28: . . . . . . . . . )
   65: 28: . . . . . . . . )
   65: 28: . . . . . . . )
   65: 28: . . . . . . )
   65: 28: . . . . . . ";"
   66:  2: . . . . . )
   66:  2: . . . . . Statement (
   66:  2: . . . . . . SelectStmt (
   66:  2: . . . . . . . "select"
   66:  9: . . . . . . . "{"
   67:  2: . . . . . . . CommClause (
   67:  2: . . . . . . . . "case"
   67:  7: . . . . . . . . ExpressionList (
   67:  7: . . . . . . . . . Expression (
   67:  7: . . . . . . . . . . BinaryExpr (
   67:  7: . . . . . . . . . . . UnaryExpr (
   67:  7: . . . . . . . . . . . . "<-"
   67:  9: . . . . . . . . . . . . UnaryExpr (
   67:  9: . . . . . . . . . . . . . PrimaryExpr (
   67:  9: . . . . . . . . . . . . . . Operand (
   67:  9: . . . . . . . . . . . . . . . IDENT ch
 /app/parser/parser.go:713: ast.Ident{Name: ch}
   67: 11: . . . . . . . . . . . . . . )
   67: 11: . . . . . . . . . . . . . )
   67: 11: . . . . . . . . . . . . )
   67: 11: . . . . . . . . . . . )
   67: 11: . . . . . . . . . . )
   67: 11: . . . . . . . . . )
   67: 11: . . . . . . . . )
   67: 11: . . . . . . . . ":"
   68:  3: . . . . . . . . StatementList (
   68:  3: . . . . . . . . . Statement (
   68:  3: . . . . . . . . . . SimpleStmt (
   68:  3: . . . . . . . . . . . ExpressionList (
   68:  3: . . . . . . . . . . . . Expression (
   68:  3: . . . . . . . . . . . . . BinaryExpr (
   68:  3: . . . . . . . . . . . . . . UnaryExpr (
   68:  3: . . . . . . . . . . . . . . . PrimaryExpr (
   68:  3: . . . . . . . . . . . . . . . . Operand (
   68:  3: . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   68: 10: . . . . . . . . . . . . . . . . )
   68: 10: . . . . . . . . . . . . . . . . CallOrConversion (
   68: 10: . . . . . . . . . . . . . . . . . "("
   68: 11: . . . . . . . . . . . . . . . . . Expression (
   68: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
   68: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   68: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   68: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
   68: 11: . . . . . . . . . . . . . . . . . . . . . . STRING "1"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "1"}
   68: 14: . . . . . . . . . . . . . . . . . . . . . )
   68: 14: . . . . . . . . . . . . . . . . . . . . )
   68: 14: . . . . . . . . . . . . . . . . . . . )
   68: 14: . . . . . . . . . . . . . . . . . . )
   68: 14: . . . . . . . . . . . . . . . . . )
   68: 14: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   68: 15: . . . . . . . . . . . . . . . . )
   68: 15: . . . . . . . . . . . . . . . )
   68: 15: . . . . . . . . . . . . . . )
   68: 15: . . . . . . . . . . . . . )
   68: 15: . . . . . . . . . . . . )
   68: 15: . . . . . . . . . . . )
   68: 15: . . . . . . . . . . )
   68: 15: . . . . . . . . . . ";"
   69:  2: . . . . . . . . . )
   69:  2: . . . . . . . . )
   69:  2: . . . . . . . )
   69:  2: . . . . . . . CommClause (
   69:  2: . . . . . . . . "case"
   69:  7: . . . . . . . . ExpressionList (
   69:  7: . . . . . . . . . Expression (
   69:  7: . . . . . . . . . . BinaryExpr (
   69:  7: . . . . . . . . . . . UnaryExpr (
   69:  7: . . . . . . . . . . . . PrimaryExpr (
   69:  7: . . . . . . . . . . . . . Operand (
   69:  7: . . . . . . . . . . . . . . IDENT ch
 /app/parser/parser.go:713: ast.Ident{Name: ch}
   69: 10: . . . . . . . . . . . . . )
   69: 10: . . . . . . . . . . . . )
   69: 10: . . . . . . . . . . . )
   69: 10: . . . . . . . . . . )
   69: 10: . . . . . . . . . )
   69: 10: . . . . . . . . )
   69: 10: . . . . . . . . "<-"
   69: 13: . . . . . . . . Expression (
   69: 13: . . . . . . . . . BinaryExpr (
   69: 13: . . . . . . . . . . UnaryExpr (
   69: 13: . . . . . . . . . . . PrimaryExpr (
   69: 13: . . . . . . . . . . . . Operand (
   69: 13: . . . . . . . . . . . . . IDENT true
 /app/parser/parser.go:713: ast.Ident{Name: true}
   69: 17: . . . . . . . . . . . . )
   69: 17: . . . . . . . . . . . )
   69: 17: . . . . . . . . . . )
   69: 17: . . . . . . . . . )
   69: 17: . . . . . . . . )
   69: 17: . . . . . . . . ":"
   70:  3: . . . . . . . . StatementList (
   70:  3: . . . . . . . . . Statement (
   70:  3: . . . . . . . . . . SimpleStmt (
   70:  3: . . . . . . . . . . . ExpressionList (
   70:  3: . . . . . . . . . . . . Expression (
   70:  3: . . . . . . . . . . . . . BinaryExpr (
   70:  3: . . . . . . . . . . . . . . UnaryExpr (
   70:  3: . . . . . . . . . . . . . . . PrimaryExpr (
   70:  3: . . . . . . . . . . . . . . . . Operand (
   70:  3: . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   70: 10: . . . . . . . . . . . . . . . . )
   70: 10: . . . . . . . . . . . . . . . . CallOrConversion (
   70: 10: . . . . . . . . . . . . . . . . . "("
   70: 11: . . . . . . . . . . . . . . . . . Expression (
   70: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
   70: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   70: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   70: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
   70: 11: . . . . . . . . . . . . . . . . . . . . . . STRING "2"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "2"}
   70: 14: . . . . . . . . . . . . . . . . . . . . . )
   70: 14: . . . . . . . . . . . . . . . . . . . . )
   70: 14: . . . . . . . . . . . . . . . . . . . )
   70: 14: . . . . . . . . . . . . . . . . . . )
   70: 14: . . . . . . . . . . . . . . . . . )
   70: 14: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   70: 15: . . . . . . . . . . . . . . . . )
   70: 15: . . . . . . . . . . . . . . . )
   70: 15: . . . . . . . . . . . . . . )
   70: 15: . . . . . . . . . . . . . )
   70: 15: . . . . . . . . . . . . )
   70: 15: . . . . . . . . . . . )
   70: 15: . . . . . . . . . . )
   70: 15: . . . . . . . . . . ";"
   71:  2: . . . . . . . . . )
   71:  2: . . . . . . . . )
   71:  2: . . . . . . . )
   71:  2: . . . . . . . "}"
   71:  3: . . . . . . . ";"
   73:  2: . . . . . . )
   73:  2: . . . . . )
   73:  2: . . . . . Statement (
   73:  2: . . . . . . GoStmt (
   73:  2: . . . . . . . "go"
   73:  5: . . . . . . . Expression (
   73:  5: . . . . . . . . BinaryExpr (
   73:  5: . . . . . . . . . UnaryExpr (
   73:  5: . . . . . . . . . . PrimaryExpr (
   73:  5: . . . . . . . . . . . Operand (
   73:  5: . . . . . . . . . . . . FuncTypeOrLit (
   73:  5: . . . . . . . . . . . . . FuncType (
   73:  5: . . . . . . . . . . . . . . "func"
   73:  9: . . . . . . . . . . . . . . Signature (
   73:  9: . . . . . . . . . . . . . . . Parameters (
   73:  9: . . . . . . . . . . . . . . . . "("
   73: 10: . . . . . . . . . . . . . . . . ParameterList (
   73: 10: . . . . . . . . . . . . . . . . . ParamDeclOrNil (
   73: 10: . . . . . . . . . . . . . . . . . . IDENT fs
 /app/parser/parser.go:713: ast.Ident{Name: fs}
   73: 13: . . . . . . . . . . . . . . . . . . Type (
   73: 13: . . . . . . . . . . . . . . . . . . . TypeName (
   73: 13: . . . . . . . . . . . . . . . . . . . . IDENT FileSystem
 /app/parser/parser.go:713: ast.Ident{Name: FileSystem}
   73: 23: . . . . . . . . . . . . . . . . . . . )
   73: 23: . . . . . . . . . . . . . . . . . . )
   73: 23: . . . . . . . . . . . . . . . . . )
   73: 23: . . . . . . . . . . . . . . . . )
   73: 23: . . . . . . . . . . . . . . . . ")"
   73: 25: . . . . . . . . . . . . . . . )
   73: 25: . . . . . . . . . . . . . . . Result (
   73: 25: . . . . . . . . . . . . . . . )
   73: 25: . . . . . . . . . . . . . . )
   73: 25: . . . . . . . . . . . . . )
   73: 25: . . . . . . . . . . . . . Body (
   73: 25: . . . . . . . . . . . . . . "{"
   74:  3: . . . . . . . . . . . . . . StatementList (
   74:  3: . . . . . . . . . . . . . . . Statement (
   74:  3: . . . . . . . . . . . . . . . . IfStmt (
   74:  3: . . . . . . . . . . . . . . . . . "if"
   74:  6: . . . . . . . . . . . . . . . . . SimpleStmt (
   74:  6: . . . . . . . . . . . . . . . . . . ExpressionList (
   74:  6: . . . . . . . . . . . . . . . . . . . Expression (
   74:  6: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   74:  6: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   74:  6: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   74:  6: . . . . . . . . . . . . . . . . . . . . . . . Operand (
   74:  6: . . . . . . . . . . . . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   74:  9: . . . . . . . . . . . . . . . . . . . . . . . )
   74:  9: . . . . . . . . . . . . . . . . . . . . . . )
   74:  9: . . . . . . . . . . . . . . . . . . . . . )
   74:  9: . . . . . . . . . . . . . . . . . . . . )
   74:  9: . . . . . . . . . . . . . . . . . . . )
   74:  9: . . . . . . . . . . . . . . . . . . . ","
   74: 11: . . . . . . . . . . . . . . . . . . . Expression (
   74: 11: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   74: 11: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   74: 11: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   74: 11: . . . . . . . . . . . . . . . . . . . . . . . Operand (
   74: 11: . . . . . . . . . . . . . . . . . . . . . . . . IDENT ok
 /app/parser/parser.go:713: ast.Ident{Name: ok}
   74: 14: . . . . . . . . . . . . . . . . . . . . . . . )
   74: 14: . . . . . . . . . . . . . . . . . . . . . . )
   74: 14: . . . . . . . . . . . . . . . . . . . . . )
   74: 14: . . . . . . . . . . . . . . . . . . . . )
   74: 14: . . . . . . . . . . . . . . . . . . . )
   74: 14: . . . . . . . . . . . . . . . . . . )
   74: 14: . . . . . . . . . . . . . . . . . . ":="
   74: 17: . . . . . . . . . . . . . . . . . . ExpressionList (
   74: 17: . . . . . . . . . . . . . . . . . . . Expression (
   74: 17: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   74: 17: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   74: 17: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   74: 17: . . . . . . . . . . . . . . . . . . . . . . . Operand (
   74: 17: . . . . . . . . . . . . . . . . . . . . . . . . IDENT fs
 /app/parser/parser.go:713: ast.Ident{Name: fs}
   74: 19: . . . . . . . . . . . . . . . . . . . . . . . )
   74: 19: . . . . . . . . . . . . . . . . . . . . . . . "."
   74: 20: . . . . . . . . . . . . . . . . . . . . . . . TypeAssertion (
   74: 20: . . . . . . . . . . . . . . . . . . . . . . . . "("
   74: 21: . . . . . . . . . . . . . . . . . . . . . . . . Type (
   74: 21: . . . . . . . . . . . . . . . . . . . . . . . . . PointerType (
   74: 21: . . . . . . . . . . . . . . . . . . . . . . . . . . "*"
   74: 22: . . . . . . . . . . . . . . . . . . . . . . . . . . Type (
   74: 22: . . . . . . . . . . . . . . . . . . . . . . . . . . . TypeName (
   74: 22: . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT Foo
 /app/parser/parser.go:713: ast.Ident{Name: Foo}
   74: 25: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   74: 25: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   74: 25: . . . . . . . . . . . . . . . . . . . . . . . . . )
   74: 25: . . . . . . . . . . . . . . . . . . . . . . . . )
   74: 25: . . . . . . . . . . . . . . . . . . . . . . . . ")"
   74: 26: . . . . . . . . . . . . . . . . . . . . . . . )
   74: 26: . . . . . . . . . . . . . . . . . . . . . . )
   74: 26: . . . . . . . . . . . . . . . . . . . . . )
   74: 26: . . . . . . . . . . . . . . . . . . . . )
   74: 26: . . . . . . . . . . . . . . . . . . . )
   74: 26: . . . . . . . . . . . . . . . . . . )
   74: 26: . . . . . . . . . . . . . . . . . )
   74: 26: . . . . . . . . . . . . . . . . . ";"
   74: 28: . . . . . . . . . . . . . . . . . SimpleStmt (
   74: 28: . . . . . . . . . . . . . . . . . . ExpressionList (
   74: 28: . . . . . . . . . . . . . . . . . . . Expression (
   74: 28: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   74: 28: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   74: 28: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   74: 28: . . . . . . . . . . . . . . . . . . . . . . . Operand (
   74: 28: . . . . . . . . . . . . . . . . . . . . . . . . IDENT ok
 /app/parser/parser.go:713: ast.Ident{Name: ok}
   74: 31: . . . . . . . . . . . . . . . . . . . . . . . )
   74: 31: . . . . . . . . . . . . . . . . . . . . . . )
   74: 31: . . . . . . . . . . . . . . . . . . . . . )
   74: 31: . . . . . . . . . . . . . . . . . . . . )
   74: 31: . . . . . . . . . . . . . . . . . . . )
   74: 31: . . . . . . . . . . . . . . . . . . )
   74: 31: . . . . . . . . . . . . . . . . . )
   74: 31: . . . . . . . . . . . . . . . . . BlockStmt (
   74: 31: . . . . . . . . . . . . . . . . . . "{"
   75:  4: . . . . . . . . . . . . . . . . . . StatementList (
   75:  4: . . . . . . . . . . . . . . . . . . . Statement (
   75:  4: . . . . . . . . . . . . . . . . . . . . SimpleStmt (
   75:  4: . . . . . . . . . . . . . . . . . . . . . ExpressionList (
   75:  4: . . . . . . . . . . . . . . . . . . . . . . Expression (
   75:  4: . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   75:  4: . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   75:  4: . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   75:  4: . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   75:  4: . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   75: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   75: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . CallOrConversion (
   75: 11: . . . . . . . . . . . . . . . . . . . . . . . . . . . "("
   75: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   75: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   75: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   75: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   75: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   75: 12: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   75: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   75: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   75: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   75: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   75: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   75: 15: . . . . . . . . . . . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   75: 16: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   75: 16: . . . . . . . . . . . . . . . . . . . . . . . . . )
   75: 16: . . . . . . . . . . . . . . . . . . . . . . . . )
   75: 16: . . . . . . . . . . . . . . . . . . . . . . . )
   75: 16: . . . . . . . . . . . . . . . . . . . . . . )
   75: 16: . . . . . . . . . . . . . . . . . . . . . )
   75: 16: . . . . . . . . . . . . . . . . . . . . )
   75: 16: . . . . . . . . . . . . . . . . . . . . ";"
   76:  3: . . . . . . . . . . . . . . . . . . . )
   76:  3: . . . . . . . . . . . . . . . . . . )
   76:  3: . . . . . . . . . . . . . . . . . . "}"
   76:  4: . . . . . . . . . . . . . . . . . )
   76:  4: . . . . . . . . . . . . . . . . . ";"
   77:  2: . . . . . . . . . . . . . . . . )
   77:  2: . . . . . . . . . . . . . . . )
   77:  2: . . . . . . . . . . . . . . )
   77:  2: . . . . . . . . . . . . . . "}"
   77:  3: . . . . . . . . . . . . . )
   77:  3: . . . . . . . . . . . . )
   77:  3: . . . . . . . . . . . )
   77:  3: . . . . . . . . . . . CallOrConversion (
   77:  3: . . . . . . . . . . . . "("
   77:  4: . . . . . . . . . . . . Expression (
   77:  4: . . . . . . . . . . . . . BinaryExpr (
   77:  4: . . . . . . . . . . . . . . UnaryExpr (
   77:  4: . . . . . . . . . . . . . . . PrimaryExpr (
   77:  4: . . . . . . . . . . . . . . . . Operand (
   77:  4: . . . . . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
   77:  7: . . . . . . . . . . . . . . . . )
   77:  7: . . . . . . . . . . . . . . . )
   77:  7: . . . . . . . . . . . . . . )
   77:  7: . . . . . . . . . . . . . )
   77:  7: . . . . . . . . . . . . )
   77:  7: . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{0xc00030c900 0xc000300840}, Ellipsis: false, isCmd: false}
   77:  8: . . . . . . . . . . . )
   77:  8: . . . . . . . . . . )
   77:  8: . . . . . . . . . )
   77:  8: . . . . . . . . )
   77:  8: . . . . . . . )
   77:  8: . . . . . . . ";"
   78:  1: . . . . . . )
   78:  1: . . . . . )
   78:  1: . . . . )
   78:  1: . . . . "}"
   78:  2: . . . )
   78:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: init, ...}
   78:  3: . . )
   78:  3: . )
   78:  3: )
=== RUN   TestFromTestdata/optparam
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/optparam
    1:  1: COMMENT
    2:  1: File (
    2:  1: . Declaration (
    2:  1: . . FunctionDeclOrCall (
    2:  1: . . . "func"
    2:  6: . . . IDENT single
 /app/parser/parser.go:713: ast.Ident{Name: single}
    2: 12: . . . Signature (
    2: 12: . . . . Parameters (
    2: 12: . . . . . "("
    2: 13: . . . . . ParameterList (
    2: 13: . . . . . . ParamDeclOrNil (
    2: 13: . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2: 15: . . . . . . . Type (
    2: 15: . . . . . . . . TypeName (
    2: 15: . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    2: 18: . . . . . . . . )
    2: 18: . . . . . . . )
    2: 18: . . . . . . . "?"
    2: 19: . . . . . . )
    2: 19: . . . . . )
    2: 19: . . . . . ")"
    2: 20: . . . . )
    2: 20: . . . . Result (
    2: 20: . . . . )
    2: 20: . . . )
    2: 20: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: single, ...}
    4:  1: . . )
    4:  1: . )
    4:  1: . Declaration (
    4:  1: . . FunctionDeclOrCall (
    4:  1: . . . "func"
    4:  6: . . . IDENT multiple
 /app/parser/parser.go:713: ast.Ident{Name: multiple}
    4: 14: . . . Signature (
    4: 14: . . . . Parameters (
    4: 14: . . . . . "("
    4: 15: . . . . . ParameterList (
    4: 15: . . . . . . ParamDeclOrNil (
    4: 15: . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    4: 17: . . . . . . . Type (
    4: 17: . . . . . . . . TypeName (
    4: 17: . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    4: 20: . . . . . . . . )
    4: 20: . . . . . . . )
    4: 20: . . . . . . )
    4: 20: . . . . . . ","
    4: 22: . . . . . . ParamDeclOrNil (
    4: 22: . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    4: 24: . . . . . . . Type (
    4: 24: . . . . . . . . TypeName (
    4: 24: . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    4: 30: . . . . . . . . )
    4: 30: . . . . . . . )
    4: 30: . . . . . . . "?"
    4: 31: . . . . . . )
    4: 31: . . . . . . ","
    4: 33: . . . . . . ParamDeclOrNil (
    4: 33: . . . . . . . IDENT c
 /app/parser/parser.go:713: ast.Ident{Name: c}
    4: 35: . . . . . . . Type (
    4: 35: . . . . . . . . TypeName (
    4: 35: . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
    4: 39: . . . . . . . . )
    4: 39: . . . . . . . )
    4: 39: . . . . . . . "?"
    4: 40: . . . . . . )
    4: 40: . . . . . )
    4: 40: . . . . . ")"
    4: 41: . . . . )
    4: 41: . . . . Result (
    4: 41: . . . . )
    4: 41: . . . )
    4: 41: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: multiple, ...}
    6:  1: . . )
    6:  1: . )
    6:  1: . Declaration (
    6:  1: . . FunctionDeclOrCall (
    6:  1: . . . "func"
    6:  6: . . . IDENT mixed
 /app/parser/parser.go:713: ast.Ident{Name: mixed}
    6: 11: . . . Signature (
    6: 11: . . . . Parameters (
    6: 11: . . . . . "("
    6: 12: . . . . . ParameterList (
    6: 12: . . . . . . ParamDeclOrNil (
    6: 12: . . . . . . . IDENT name
 /app/parser/parser.go:713: ast.Ident{Name: name}
    6: 17: . . . . . . . Type (
    6: 17: . . . . . . . . TypeName (
    6: 17: . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    6: 23: . . . . . . . . )
    6: 23: . . . . . . . )
    6: 23: . . . . . . )
    6: 23: . . . . . . ","
    6: 25: . . . . . . ParamDeclOrNil (
    6: 25: . . . . . . . IDENT age
 /app/parser/parser.go:713: ast.Ident{Name: age}
    6: 29: . . . . . . . Type (
    6: 29: . . . . . . . . TypeName (
    6: 29: . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    6: 32: . . . . . . . . )
    6: 32: . . . . . . . )
    6: 32: . . . . . . . "?"
    6: 33: . . . . . . )
    6: 33: . . . . . . ","
    6: 35: . . . . . . ParamDeclOrNil (
    6: 35: . . . . . . . IDENT active
 /app/parser/parser.go:713: ast.Ident{Name: active}
    6: 42: . . . . . . . Type (
    6: 42: . . . . . . . . TypeName (
    6: 42: . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
    6: 46: . . . . . . . . )
    6: 46: . . . . . . . )
    6: 46: . . . . . . . "?"
    6: 47: . . . . . . )
    6: 47: . . . . . . ","
    6: 49: . . . . . . ParamDeclOrNil (
    6: 49: . . . . . . . IDENT data
 /app/parser/parser.go:713: ast.Ident{Name: data}
    6: 54: . . . . . . . ArrayFieldOrTypeInstance (
    6: 54: . . . . . . . . "["
    6: 55: . . . . . . . . "]"
    6: 56: . . . . . . . . Type (
    6: 56: . . . . . . . . . TypeName (
    6: 56: . . . . . . . . . . IDENT byte
 /app/parser/parser.go:713: ast.Ident{Name: byte}
    6: 60: . . . . . . . . . )
    6: 60: . . . . . . . . )
    6: 60: . . . . . . . )
    6: 60: . . . . . . )
    6: 60: . . . . . )
    6: 60: . . . . . ")"
    6: 61: . . . . )
    6: 61: . . . . Result (
    6: 61: . . . . )
    6: 61: . . . )
    6: 61: . . . ";"
    8:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: mixed, ...}
    9:  1: . . )
    9:  1: . )
    9:  1: . Declaration (
    9:  1: . . FunctionDeclOrCall (
    9:  1: . . . "func"
    9:  6: . . . IDENT pointer
 /app/parser/parser.go:713: ast.Ident{Name: pointer}
    9: 13: . . . Signature (
    9: 13: . . . . Parameters (
    9: 13: . . . . . "("
    9: 14: . . . . . ParameterList (
    9: 14: . . . . . . ParamDeclOrNil (
    9: 14: . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    9: 16: . . . . . . . Type (
    9: 16: . . . . . . . . PointerType (
    9: 16: . . . . . . . . . "*"
    9: 17: . . . . . . . . . Type (
    9: 17: . . . . . . . . . . TypeName (
    9: 17: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    9: 20: . . . . . . . . . . )
    9: 20: . . . . . . . . . )
    9: 20: . . . . . . . . )
    9: 20: . . . . . . . )
    9: 20: . . . . . . . "?"
    9: 21: . . . . . . )
    9: 21: . . . . . . ","
    9: 23: . . . . . . ParamDeclOrNil (
    9: 23: . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    9: 25: . . . . . . . Type (
    9: 25: . . . . . . . . PointerType (
    9: 25: . . . . . . . . . "*"
    9: 26: . . . . . . . . . Type (
    9: 26: . . . . . . . . . . PointerType (
    9: 26: . . . . . . . . . . . "*"
    9: 27: . . . . . . . . . . . Type (
    9: 27: . . . . . . . . . . . . TypeName (
    9: 27: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    9: 33: . . . . . . . . . . . . )
    9: 33: . . . . . . . . . . . )
    9: 33: . . . . . . . . . . )
    9: 33: . . . . . . . . . )
    9: 33: . . . . . . . . )
    9: 33: . . . . . . . )
    9: 33: . . . . . . . "?"
    9: 34: . . . . . . )
    9: 34: . . . . . )
    9: 34: . . . . . ")"
    9: 35: . . . . )
    9: 35: . . . . Result (
    9: 35: . . . . )
    9: 35: . . . )
    9: 35: . . . ";"
   11:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: pointer, ...}
   12:  1: . . )
   12:  1: . )
   12:  1: . Declaration (
   12:  1: . . FunctionDeclOrCall (
   12:  1: . . . "func"
   12:  6: . . . IDENT complex
 /app/parser/parser.go:713: ast.Ident{Name: complex}
   12: 13: . . . Signature (
   12: 13: . . . . Parameters (
   12: 13: . . . . . "("
   12: 14: . . . . . ParameterList (
   12: 14: . . . . . . ParamDeclOrNil (
   12: 14: . . . . . . . IDENT m
 /app/parser/parser.go:713: ast.Ident{Name: m}
   12: 16: . . . . . . . Type (
   12: 16: . . . . . . . . MapType (
   12: 16: . . . . . . . . . "map"
   12: 19: . . . . . . . . . "["
   12: 20: . . . . . . . . . Type (
   12: 20: . . . . . . . . . . TypeName (
   12: 20: . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   12: 26: . . . . . . . . . . )
   12: 26: . . . . . . . . . )
   12: 26: . . . . . . . . . "]"
   12: 27: . . . . . . . . . Type (
   12: 27: . . . . . . . . . . TypeName (
   12: 27: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   12: 30: . . . . . . . . . . )
   12: 30: . . . . . . . . . )
 /app/parser/parser.go:1455: ast.MapType{Key: string, Value: int}
   12: 30: . . . . . . . . )
   12: 30: . . . . . . . )
   12: 30: . . . . . . . "?"
   12: 31: . . . . . . )
   12: 31: . . . . . . ","
   12: 33: . . . . . . ParamDeclOrNil (
   12: 33: . . . . . . . IDENT s
 /app/parser/parser.go:713: ast.Ident{Name: s}
   12: 35: . . . . . . . ArrayFieldOrTypeInstance (
   12: 35: . . . . . . . . "["
   12: 36: . . . . . . . . "]"
   12: 37: . . . . . . . . Type (
   12: 37: . . . . . . . . . TypeName (
   12: 37: . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   12: 40: . . . . . . . . . )
   12: 40: . . . . . . . . )
   12: 40: . . . . . . . )
   12: 40: . . . . . . . "?"
   12: 41: . . . . . . )
   12: 41: . . . . . . ","
   12: 43: . . . . . . ParamDeclOrNil (
   12: 43: . . . . . . . IDENT ch
 /app/parser/parser.go:713: ast.Ident{Name: ch}
   12: 46: . . . . . . . Type (
   12: 46: . . . . . . . . ChanType (
   12: 46: . . . . . . . . . "chan"
   12: 51: . . . . . . . . . Type (
   12: 51: . . . . . . . . . . TypeName (
   12: 51: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   12: 54: . . . . . . . . . . )
   12: 54: . . . . . . . . . )
   12: 54: . . . . . . . . )
   12: 54: . . . . . . . )
   12: 54: . . . . . . . "?"
   12: 55: . . . . . . )
   12: 55: . . . . . )
   12: 55: . . . . . ")"
   12: 56: . . . . )
   12: 56: . . . . Result (
   12: 56: . . . . )
   12: 56: . . . )
   12: 56: . . . ";"
   14:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: complex, ...}
   15:  1: . . )
   15:  1: . )
   15:  1: . Declaration (
   15:  1: . . FunctionDeclOrCall (
   15:  1: . . . "func"
   15:  6: . . . IDENT arrays
 /app/parser/parser.go:713: ast.Ident{Name: arrays}
   15: 12: . . . Signature (
   15: 12: . . . . Parameters (
   15: 12: . . . . . "("
   15: 13: . . . . . ParameterList (
   15: 13: . . . . . . ParamDeclOrNil (
   15: 13: . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   15: 15: . . . . . . . ArrayFieldOrTypeInstance (
   15: 15: . . . . . . . . "["
   15: 16: . . . . . . . . Expression (
   15: 16: . . . . . . . . . BinaryExpr (
   15: 16: . . . . . . . . . . UnaryExpr (
   15: 16: . . . . . . . . . . . PrimaryExpr (
   15: 16: . . . . . . . . . . . . Operand (
   15: 16: . . . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
   15: 18: . . . . . . . . . . . . )
   15: 18: . . . . . . . . . . . )
   15: 18: . . . . . . . . . . )
   15: 18: . . . . . . . . . )
   15: 18: . . . . . . . . )
   15: 18: . . . . . . . . "]"
   15: 19: . . . . . . . . TypeName (
   15: 19: . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   15: 22: . . . . . . . . )
   15: 22: . . . . . . . )
   15: 22: . . . . . . . "?"
   15: 23: . . . . . . )
   15: 23: . . . . . . ","
   15: 25: . . . . . . ParamDeclOrNil (
   15: 25: . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   15: 27: . . . . . . . ArrayFieldOrTypeInstance (
   15: 27: . . . . . . . . "["
   15: 28: . . . . . . . . Expression (
   15: 28: . . . . . . . . . BinaryExpr (
   15: 28: . . . . . . . . . . UnaryExpr (
   15: 28: . . . . . . . . . . . PrimaryExpr (
   15: 28: . . . . . . . . . . . . Operand (
   15: 28: . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
   15: 29: . . . . . . . . . . . . )
   15: 29: . . . . . . . . . . . )
   15: 29: . . . . . . . . . . )
   15: 29: . . . . . . . . . )
   15: 29: . . . . . . . . )
   15: 29: . . . . . . . . "]"
   15: 30: . . . . . . . . TypeName (
   15: 30: . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   15: 36: . . . . . . . . )
   15: 36: . . . . . . . )
   15: 36: . . . . . . . "?"
   15: 37: . . . . . . )
   15: 37: . . . . . )
   15: 37: . . . . . ")"
   15: 38: . . . . )
   15: 38: . . . . Result (
   15: 38: . . . . )
   15: 38: . . . )
   15: 38: . . . ";"
   17:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: arrays, ...}
   18:  1: . . )
   18:  1: . )
   18:  1: . Declaration (
   18:  1: . . FunctionDeclOrCall (
   18:  1: . . . "func"
   18:  6: . . . IDENT interfaces
 /app/parser/parser.go:713: ast.Ident{Name: interfaces}
   18: 16: . . . Signature (
   18: 16: . . . . Parameters (
   18: 16: . . . . . "("
   18: 17: . . . . . ParameterList (
   18: 17: . . . . . . ParamDeclOrNil (
   18: 17: . . . . . . . IDENT io
 /app/parser/parser.go:713: ast.Ident{Name: io}
   18: 19: . . . . . . . QualifiedIdent (
   18: 19: . . . . . . . . TypeName (
   18: 19: . . . . . . . . . "."
   18: 20: . . . . . . . . . IDENT Reader
 /app/parser/parser.go:713: ast.Ident{Name: Reader}
   18: 26: . . . . . . . . )
   18: 26: . . . . . . . )
   18: 26: . . . . . . . "?"
   18: 27: . . . . . . )
   18: 27: . . . . . . ","
   18: 29: . . . . . . ParamDeclOrNil (
   18: 29: . . . . . . . IDENT io
 /app/parser/parser.go:713: ast.Ident{Name: io}
   18: 31: . . . . . . . QualifiedIdent (
   18: 31: . . . . . . . . TypeName (
   18: 31: . . . . . . . . . "."
   18: 32: . . . . . . . . . IDENT Writer
 /app/parser/parser.go:713: ast.Ident{Name: Writer}
   18: 38: . . . . . . . . )
   18: 38: . . . . . . . )
   18: 38: . . . . . . . "?"
   18: 39: . . . . . . )
   18: 39: . . . . . )
   18: 39: . . . . . ")"
   18: 40: . . . . )
   18: 40: . . . . Result (
   18: 40: . . . . )
   18: 40: . . . )
   18: 40: . . . ";"
   20:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: interfaces, ...}
   21:  1: . . )
   21:  1: . )
   21:  1: . Declaration (
   21:  1: . . FunctionDeclOrCall (
   21:  1: . . . "func"
   21:  6: . . . IDENT structs
 /app/parser/parser.go:713: ast.Ident{Name: structs}
   21: 13: . . . Signature (
   21: 13: . . . . Parameters (
   21: 13: . . . . . "("
   21: 14: . . . . . ParameterList (
   21: 14: . . . . . . ParamDeclOrNil (
   21: 14: . . . . . . . IDENT p
 /app/parser/parser.go:713: ast.Ident{Name: p}
   21: 16: . . . . . . . Type (
   21: 16: . . . . . . . . StructType (
   21: 16: . . . . . . . . . "struct"
   21: 22: . . . . . . . . . "{"
   21: 24: . . . . . . . . . FieldDecl (
   21: 24: . . . . . . . . . . IDENT X
 /app/parser/parser.go:713: ast.Ident{Name: X}
   21: 26: . . . . . . . . . . Type (
   21: 26: . . . . . . . . . . . TypeName (
   21: 26: . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   21: 30: . . . . . . . . . . . )
   21: 30: . . . . . . . . . . )
   21: 30: . . . . . . . . . )
   21: 30: . . . . . . . . . "}"
   21: 31: . . . . . . . . )
   21: 31: . . . . . . . )
   21: 31: . . . . . . . "?"
   21: 32: . . . . . . )
   21: 32: . . . . . . ","
   21: 34: . . . . . . ParamDeclOrNil (
   21: 34: . . . . . . . IDENT q
 /app/parser/parser.go:713: ast.Ident{Name: q}
   21: 36: . . . . . . . Type (
   21: 36: . . . . . . . . StructType (
   21: 36: . . . . . . . . . "struct"
   21: 42: . . . . . . . . . "{"
   21: 44: . . . . . . . . . FieldDecl (
   21: 44: . . . . . . . . . . IDENT Y
 /app/parser/parser.go:713: ast.Ident{Name: Y}
   21: 46: . . . . . . . . . . Type (
   21: 46: . . . . . . . . . . . TypeName (
   21: 46: . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   21: 53: . . . . . . . . . . . )
   21: 53: . . . . . . . . . . )
   21: 53: . . . . . . . . . )
   21: 53: . . . . . . . . . "}"
   21: 54: . . . . . . . . )
   21: 54: . . . . . . . )
   21: 54: . . . . . . . "?"
   21: 55: . . . . . . )
   21: 55: . . . . . )
   21: 55: . . . . . ")"
   21: 56: . . . . )
   21: 56: . . . . Result (
   21: 56: . . . . )
   21: 56: . . . )
   21: 56: . . . ";"
   23:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: structs, ...}
   24:  1: . . )
   24:  1: . )
   24:  1: . Declaration (
   24:  1: . . FunctionDeclOrCall (
   24:  1: . . . "func"
   24:  6: . . . IDENT funcs
 /app/parser/parser.go:713: ast.Ident{Name: funcs}
   24: 11: . . . Signature (
   24: 11: . . . . Parameters (
   24: 11: . . . . . "("
   24: 12: . . . . . ParameterList (
   24: 12: . . . . . . ParamDeclOrNil (
   24: 12: . . . . . . . IDENT f
 /app/parser/parser.go:713: ast.Ident{Name: f}
   24: 14: . . . . . . . Type (
   24: 14: . . . . . . . . FuncType (
   24: 14: . . . . . . . . . "func"
   24: 18: . . . . . . . . . Signature (
   24: 18: . . . . . . . . . . Parameters (
   24: 18: . . . . . . . . . . . "("
   24: 19: . . . . . . . . . . . ParameterList (
   24: 19: . . . . . . . . . . . . ParamDeclOrNil (
   24: 19: . . . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   24: 22: . . . . . . . . . . . . )
   24: 22: . . . . . . . . . . . )
   24: 22: . . . . . . . . . . . ")"
   24: 24: . . . . . . . . . . )
   24: 24: . . . . . . . . . . Result (
   24: 24: . . . . . . . . . . . TypeName (
   24: 24: . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   24: 30: . . . . . . . . . . . )
   24: 30: . . . . . . . . . . )
   24: 30: . . . . . . . . . )
   24: 30: . . . . . . . . )
   24: 30: . . . . . . . )
   24: 30: . . . . . . . "?"
   24: 31: . . . . . . )
   24: 31: . . . . . . ","
   24: 33: . . . . . . ParamDeclOrNil (
   24: 33: . . . . . . . IDENT g
 /app/parser/parser.go:713: ast.Ident{Name: g}
   24: 35: . . . . . . . Type (
   24: 35: . . . . . . . . FuncType (
   24: 35: . . . . . . . . . "func"
   24: 39: . . . . . . . . . Signature (
   24: 39: . . . . . . . . . . Parameters (
   24: 39: . . . . . . . . . . . "("
   24: 40: . . . . . . . . . . . ParameterList (
   24: 40: . . . . . . . . . . . . ParamDeclOrNil (
   24: 40: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   24: 46: . . . . . . . . . . . . )
   24: 46: . . . . . . . . . . . )
   24: 46: . . . . . . . . . . . ")"
   24: 48: . . . . . . . . . . )
   24: 48: . . . . . . . . . . Result (
   24: 48: . . . . . . . . . . . TypeName (
   24: 48: . . . . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   24: 53: . . . . . . . . . . . )
   24: 53: . . . . . . . . . . )
   24: 53: . . . . . . . . . )
   24: 53: . . . . . . . . )
   24: 53: . . . . . . . )
   24: 53: . . . . . . . "?"
   24: 54: . . . . . . )
   24: 54: . . . . . )
   24: 54: . . . . . ")"
   24: 55: . . . . )
   24: 55: . . . . Result (
   24: 55: . . . . )
   24: 55: . . . )
   24: 55: . . . ";"
   26:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: funcs, ...}
   27:  1: . . )
   27:  1: . )
   27:  1: . Declaration (
   27:  1: . . FunctionDeclOrCall (
   27:  1: . . . "func"
   27:  6: . . . IDENT qualified
 /app/parser/parser.go:713: ast.Ident{Name: qualified}
   27: 15: . . . Signature (
   27: 15: . . . . Parameters (
   27: 15: . . . . . "("
   27: 16: . . . . . ParameterList (
   27: 16: . . . . . . ParamDeclOrNil (
   27: 16: . . . . . . . IDENT t
 /app/parser/parser.go:713: ast.Ident{Name: t}
   27: 18: . . . . . . . Type (
   27: 18: . . . . . . . . TypeName (
   27: 18: . . . . . . . . . IDENT time
 /app/parser/parser.go:713: ast.Ident{Name: time}
   27: 22: . . . . . . . . . "."
   27: 23: . . . . . . . . . IDENT Time
 /app/parser/parser.go:713: ast.Ident{Name: Time}
   27: 27: . . . . . . . . )
   27: 27: . . . . . . . )
   27: 27: . . . . . . . "?"
   27: 28: . . . . . . )
   27: 28: . . . . . . ","
   27: 30: . . . . . . ParamDeclOrNil (
   27: 30: . . . . . . . IDENT d
 /app/parser/parser.go:713: ast.Ident{Name: d}
   27: 32: . . . . . . . Type (
   27: 32: . . . . . . . . TypeName (
   27: 32: . . . . . . . . . IDENT time
 /app/parser/parser.go:713: ast.Ident{Name: time}
   27: 36: . . . . . . . . . "."
   27: 37: . . . . . . . . . IDENT Duration
 /app/parser/parser.go:713: ast.Ident{Name: Duration}
   27: 45: . . . . . . . . )
   27: 45: . . . . . . . )
   27: 45: . . . . . . . "?"
   27: 46: . . . . . . )
   27: 46: . . . . . )
   27: 46: . . . . . ")"
   27: 47: . . . . )
   27: 47: . . . . Result (
   27: 47: . . . . )
   27: 47: . . . )
   27: 47: . . . ";"
   29:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: qualified, ...}
   30:  1: . . )
   30:  1: . )
   30:  1: . Declaration (
   30:  1: . . FunctionDeclOrCall (
   30:  1: . . . "func"
   30:  6: . . . IDENT unnamed
 /app/parser/parser.go:713: ast.Ident{Name: unnamed}
   30: 13: . . . Signature (
   30: 13: . . . . Parameters (
   30: 13: . . . . . "("
   30: 14: . . . . . ParameterList (
   30: 14: . . . . . . ParamDeclOrNil (
   30: 14: . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   30: 17: . . . . . . . "?"
   30: 18: . . . . . . )
   30: 18: . . . . . . ","
   30: 20: . . . . . . ParamDeclOrNil (
   30: 20: . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   30: 26: . . . . . . . "?"
   30: 27: . . . . . . )
   30: 27: . . . . . . ","
   30: 29: . . . . . . ParamDeclOrNil (
   30: 29: . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   30: 33: . . . . . . )
   30: 33: . . . . . )
   30: 33: . . . . . ")"
   30: 34: . . . . )
   30: 34: . . . . Result (
   30: 34: . . . . )
   30: 34: . . . )
   30: 34: . . . ";"
   32:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: unnamed, ...}
   33:  1: . . )
   33:  1: . )
   33:  1: . Declaration (
   33:  1: . . FunctionDeclOrCall (
   33:  1: . . . "func"
   33:  6: . . . IDENT allOptional
 /app/parser/parser.go:713: ast.Ident{Name: allOptional}
   33: 17: . . . Signature (
   33: 17: . . . . Parameters (
   33: 17: . . . . . "("
   33: 18: . . . . . ParameterList (
   33: 18: . . . . . . ParamDeclOrNil (
   33: 18: . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   33: 20: . . . . . . . Type (
   33: 20: . . . . . . . . TypeName (
   33: 20: . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   33: 23: . . . . . . . . )
   33: 23: . . . . . . . )
   33: 23: . . . . . . . "?"
   33: 24: . . . . . . )
   33: 24: . . . . . . ","
   33: 26: . . . . . . ParamDeclOrNil (
   33: 26: . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   33: 28: . . . . . . . Type (
   33: 28: . . . . . . . . TypeName (
   33: 28: . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   33: 34: . . . . . . . . )
   33: 34: . . . . . . . )
   33: 34: . . . . . . . "?"
   33: 35: . . . . . . )
   33: 35: . . . . . . ","
   33: 37: . . . . . . ParamDeclOrNil (
   33: 37: . . . . . . . IDENT c
 /app/parser/parser.go:713: ast.Ident{Name: c}
   33: 39: . . . . . . . Type (
   33: 39: . . . . . . . . TypeName (
   33: 39: . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   33: 43: . . . . . . . . )
   33: 43: . . . . . . . )
   33: 43: . . . . . . . "?"
   33: 44: . . . . . . )
   33: 44: . . . . . )
   33: 44: . . . . . ")"
   33: 45: . . . . )
   33: 45: . . . . Result (
   33: 45: . . . . )
   33: 45: . . . )
   33: 45: . . . ";"
   35:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: allOptional, ...}
   36:  1: . . )
   36:  1: . )
   36:  1: . Declaration (
   36:  1: . . FunctionDeclOrCall (
   36:  1: . . . "func"
   36:  6: . . . IDENT withVariadic
 /app/parser/parser.go:713: ast.Ident{Name: withVariadic}
   36: 18: . . . Signature (
   36: 18: . . . . Parameters (
   36: 18: . . . . . "("
   36: 19: . . . . . ParameterList (
   36: 19: . . . . . . ParamDeclOrNil (
   36: 19: . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   36: 21: . . . . . . . Type (
   36: 21: . . . . . . . . TypeName (
   36: 21: . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   36: 24: . . . . . . . . )
   36: 24: . . . . . . . )
   36: 24: . . . . . . . "?"
   36: 25: . . . . . . )
   36: 25: . . . . . . ","
   36: 27: . . . . . . ParamDeclOrNil (
   36: 27: . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   36: 29: . . . . . . . DotsType (
   36: 29: . . . . . . . . "..."
   36: 32: . . . . . . . . Type (
   36: 32: . . . . . . . . . TypeName (
   36: 32: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   36: 38: . . . . . . . . . )
   36: 38: . . . . . . . . )
   36: 38: . . . . . . . )
   36: 38: . . . . . . )
   36: 38: . . . . . )
   36: 38: . . . . . ")"
   36: 39: . . . . )
   36: 39: . . . . Result (
   36: 39: . . . . )
   36: 39: . . . )
   36: 39: . . . ";"
   38:  1: . . . COMMENT
 /app/parser/parser.go:4088: ast.FuncDecl{Name: withVariadic, ...}
   39:  1: . . )
   39:  1: . )
   39:  1: . Declaration (
   39:  1: . . GenDecl(type) (
   39:  1: . . . "type"
   39:  6: . . . TypeSpec (
   39:  6: . . . . IDENT Handler
 /app/parser/parser.go:713: ast.Ident{Name: Handler}
   39: 14: . . . . Type (
   39: 14: . . . . . FuncType (
   39: 14: . . . . . . "func"
   39: 18: . . . . . . Signature (
   39: 18: . . . . . . . Parameters (
   39: 18: . . . . . . . . "("
   39: 19: . . . . . . . . ParameterList (
   39: 19: . . . . . . . . . ParamDeclOrNil (
   39: 19: . . . . . . . . . . IDENT req
 /app/parser/parser.go:713: ast.Ident{Name: req}
   39: 23: . . . . . . . . . . Type (
   39: 23: . . . . . . . . . . . PointerType (
   39: 23: . . . . . . . . . . . . "*"
   39: 24: . . . . . . . . . . . . Type (
   39: 24: . . . . . . . . . . . . . TypeName (
   39: 24: . . . . . . . . . . . . . . IDENT Request
 /app/parser/parser.go:713: ast.Ident{Name: Request}
   39: 31: . . . . . . . . . . . . . )
   39: 31: . . . . . . . . . . . . )
   39: 31: . . . . . . . . . . . )
   39: 31: . . . . . . . . . . )
   39: 31: . . . . . . . . . . "?"
   39: 32: . . . . . . . . . )
   39: 32: . . . . . . . . . ","
   39: 34: . . . . . . . . . ParamDeclOrNil (
   39: 34: . . . . . . . . . . IDENT resp
 /app/parser/parser.go:713: ast.Ident{Name: resp}
   39: 39: . . . . . . . . . . Type (
   39: 39: . . . . . . . . . . . PointerType (
   39: 39: . . . . . . . . . . . . "*"
   39: 40: . . . . . . . . . . . . Type (
   39: 40: . . . . . . . . . . . . . TypeName (
   39: 40: . . . . . . . . . . . . . . IDENT Response
 /app/parser/parser.go:713: ast.Ident{Name: Response}
   39: 48: . . . . . . . . . . . . . )
   39: 48: . . . . . . . . . . . . )
   39: 48: . . . . . . . . . . . )
   39: 48: . . . . . . . . . . )
   39: 48: . . . . . . . . . . "?"
   39: 49: . . . . . . . . . )
   39: 49: . . . . . . . . )
   39: 49: . . . . . . . . ")"
   39: 51: . . . . . . . )
   39: 51: . . . . . . . Result (
   39: 51: . . . . . . . . TypeName (
   39: 51: . . . . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   39: 56: . . . . . . . . )
   39: 56: . . . . . . . )
   39: 56: . . . . . . )
   39: 56: . . . . . )
   39: 56: . . . . )
   39: 56: . . . . ";"
   41:  1: . . . )
   41:  1: . . )
   41:  1: . )
   41:  1: . Declaration (
   41:  1: . . GenDecl(type) (
   41:  1: . . . "type"
   41:  6: . . . TypeSpec (
   41:  6: . . . . IDENT Callback
 /app/parser/parser.go:713: ast.Ident{Name: Callback}
   41: 15: . . . . Type (
   41: 15: . . . . . FuncType (
   41: 15: . . . . . . "func"
   41: 19: . . . . . . Signature (
   41: 19: . . . . . . . Parameters (
   41: 19: . . . . . . . . "("
   41: 20: . . . . . . . . ParameterList (
   41: 20: . . . . . . . . . ParamDeclOrNil (
   41: 20: . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
   41: 23: . . . . . . . . . . "?"
   41: 24: . . . . . . . . . )
   41: 24: . . . . . . . . . ","
   41: 26: . . . . . . . . . ParamDeclOrNil (
   41: 26: . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
   41: 32: . . . . . . . . . . "?"
   41: 33: . . . . . . . . . )
   41: 33: . . . . . . . . )
   41: 33: . . . . . . . . ")"
   41: 35: . . . . . . . )
   41: 35: . . . . . . . Result (
   41: 35: . . . . . . . . TypeName (
   41: 35: . . . . . . . . . IDENT bool
 /app/parser/parser.go:713: ast.Ident{Name: bool}
   41: 39: . . . . . . . . )
   41: 39: . . . . . . . )
   41: 39: . . . . . . )
   41: 39: . . . . . )
   41: 39: . . . . )
   41: 39: . . . . ";"
   43:  1: . . . . COMMENT
   44:  1: . . . )
   44:  1: . . )
   44:  1: . )
   44:  1: . Declaration (
   44:  1: . . GenDecl(type) (
   44:  1: . . . "type"
   44:  6: . . . TypeSpec (
   44:  6: . . . . IDENT Server
 /app/parser/parser.go:713: ast.Ident{Name: Server}
   44: 13: . . . . Type (
   44: 13: . . . . . StructType (
   44: 13: . . . . . . "struct"
   44: 19: . . . . . . "{"
   44: 20: . . . . . . "}"
   44: 21: . . . . . )
   44: 21: . . . . )
   44: 21: . . . . ";"
   46:  1: . . . )
   46:  1: . . )
   46:  1: . )
   46:  1: . Declaration (
   46:  1: . . FunctionDeclOrCall (
   46:  1: . . . "func"
   46:  6: . . . Parameters (
   46:  6: . . . . "("
   46:  7: . . . . ParameterList (
   46:  7: . . . . . ParamDeclOrNil (
   46:  7: . . . . . . IDENT s
 /app/parser/parser.go:713: ast.Ident{Name: s}
   46:  9: . . . . . . Type (
   46:  9: . . . . . . . PointerType (
   46:  9: . . . . . . . . "*"
   46: 10: . . . . . . . . Type (
   46: 10: . . . . . . . . . TypeName (
   46: 10: . . . . . . . . . . IDENT Server
 /app/parser/parser.go:713: ast.Ident{Name: Server}
   46: 16: . . . . . . . . . )
   46: 16: . . . . . . . . )
   46: 16: . . . . . . . )
   46: 16: . . . . . . )
   46: 16: . . . . . )
   46: 16: . . . . )
   46: 16: . . . . ")"
   46: 18: . . . )
   46: 18: . . . TypeName (
   46: 18: . . . . IDENT Handle
 /app/parser/parser.go:713: ast.Ident{Name: Handle}
   46: 24: . . . )
   46: 24: . . . Signature (
   46: 24: . . . . Parameters (
   46: 24: . . . . . "("
   46: 25: . . . . . ParameterList (
   46: 25: . . . . . . ParamDeclOrNil (
   46: 25: . . . . . . . IDENT req
 /app/parser/parser.go:713: ast.Ident{Name: req}
   46: 29: . . . . . . . Type (
   46: 29: . . . . . . . . PointerType (
   46: 29: . . . . . . . . . "*"
   46: 30: . . . . . . . . . Type (
   46: 30: . . . . . . . . . . TypeName (
   46: 30: . . . . . . . . . . . IDENT Request
 /app/parser/parser.go:713: ast.Ident{Name: Request}
   46: 37: . . . . . . . . . . )
   46: 37: . . . . . . . . . )
   46: 37: . . . . . . . . )
   46: 37: . . . . . . . )
   46: 37: . . . . . . . "?"
   46: 38: . . . . . . )
   46: 38: . . . . . . ","
   46: 40: . . . . . . ParamDeclOrNil (
   46: 40: . . . . . . . IDENT opts
 /app/parser/parser.go:713: ast.Ident{Name: opts}
   46: 45: . . . . . . . Type (
   46: 45: . . . . . . . . PointerType (
   46: 45: . . . . . . . . . "*"
   46: 46: . . . . . . . . . Type (
   46: 46: . . . . . . . . . . TypeName (
   46: 46: . . . . . . . . . . . IDENT Options
 /app/parser/parser.go:713: ast.Ident{Name: Options}
   46: 53: . . . . . . . . . . )
   46: 53: . . . . . . . . . )
   46: 53: . . . . . . . . )
   46: 53: . . . . . . . )
   46: 53: . . . . . . . "?"
   46: 54: . . . . . . )
   46: 54: . . . . . )
   46: 54: . . . . . ")"
   46: 56: . . . . )
   46: 56: . . . . Result (
   46: 56: . . . . . TypeName (
   46: 56: . . . . . . IDENT error
 /app/parser/parser.go:713: ast.Ident{Name: error}
   46: 62: . . . . . )
   46: 62: . . . . )
   46: 62: . . . )
   46: 62: . . . Body (
   46: 62: . . . . "{"
   47:  2: . . . . StatementList (
   47:  2: . . . . . Statement (
   47:  2: . . . . . . ReturnStmt (
   47:  2: . . . . . . . "return"
   47:  9: . . . . . . . ExpressionList (
   47:  9: . . . . . . . . Expression (
   47:  9: . . . . . . . . . BinaryExpr (
   47:  9: . . . . . . . . . . UnaryExpr (
   47:  9: . . . . . . . . . . . PrimaryExpr (
   47:  9: . . . . . . . . . . . . Operand (
   47:  9: . . . . . . . . . . . . . IDENT nil
 /app/parser/parser.go:713: ast.Ident{Name: nil}
   47: 12: . . . . . . . . . . . . )
   47: 12: . . . . . . . . . . . )
   47: 12: . . . . . . . . . . )
   47: 12: . . . . . . . . . )
   47: 12: . . . . . . . . )
   47: 12: . . . . . . . )
   47: 12: . . . . . . . ";"
   48:  1: . . . . . . )
   48:  1: . . . . . )
   48:  1: . . . . )
   48:  1: . . . . "}"
   48:  2: . . . )
   48:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: Handle, ...}
   48:  3: . . )
   48:  3: . )
   48:  3: )
=== RUN   TestFromTestdata/overload1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/overload1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  6: . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    1: 10: . . . "="
    1: 12: . . . "("
    2:  2: . . . FuncTypeOrLit (
    2:  2: . . . . FuncType (
    2:  2: . . . . . "func"
    2:  6: . . . . . Signature (
    2:  6: . . . . . . Parameters (
    2:  6: . . . . . . . "("
    2:  7: . . . . . . . ParameterList (
    2:  7: . . . . . . . . ParamDeclOrNil (
    2:  7: . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2:  8: . . . . . . . . )
    2:  8: . . . . . . . . ","
    2: 10: . . . . . . . . ParamDeclOrNil (
    2: 10: . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    2: 12: . . . . . . . . . Type (
    2: 12: . . . . . . . . . . TypeName (
    2: 12: . . . . . . . . . . . IDENT float64
 /app/parser/parser.go:713: ast.Ident{Name: float64}
    2: 19: . . . . . . . . . . )
    2: 19: . . . . . . . . . )
    2: 19: . . . . . . . . )
    2: 19: . . . . . . . )
    2: 19: . . . . . . . ")"
    2: 21: . . . . . . )
    2: 21: . . . . . . Result (
    2: 21: . . . . . . . TypeName (
    2: 21: . . . . . . . . IDENT float64
 /app/parser/parser.go:713: ast.Ident{Name: float64}
    2: 29: . . . . . . . )
    2: 29: . . . . . . )
    2: 29: . . . . . )
    2: 29: . . . . )
    2: 29: . . . . Body (
    2: 29: . . . . . "{"
    3:  3: . . . . . StatementList (
    3:  3: . . . . . . Statement (
    3:  3: . . . . . . . ReturnStmt (
    3:  3: . . . . . . . . "return"
    3: 10: . . . . . . . . ExpressionList (
    3: 10: . . . . . . . . . Expression (
    3: 10: . . . . . . . . . . BinaryExpr (
    3: 10: . . . . . . . . . . . UnaryExpr (
    3: 10: . . . . . . . . . . . . PrimaryExpr (
    3: 10: . . . . . . . . . . . . . Operand (
    3: 10: . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    3: 12: . . . . . . . . . . . . . )
    3: 12: . . . . . . . . . . . . )
    3: 12: . . . . . . . . . . . )
    3: 12: . . . . . . . . . . . "+"
    3: 14: . . . . . . . . . . . BinaryExpr (
    3: 14: . . . . . . . . . . . . UnaryExpr (
    3: 14: . . . . . . . . . . . . . PrimaryExpr (
    3: 14: . . . . . . . . . . . . . . Operand (
    3: 14: . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    3: 15: . . . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . )
    3: 15: . . . . . . . . . . )
    3: 15: . . . . . . . . . )
    3: 15: . . . . . . . . )
    3: 15: . . . . . . . . ";"
    4:  2: . . . . . . . )
    4:  2: . . . . . . )
    4:  2: . . . . . )
    4:  2: . . . . . "}"
    4:  3: . . . . )
    4:  3: . . . )
    4:  3: . . . ";"
    5:  2: . . . FuncTypeOrLit (
    5:  2: . . . . FuncType (
    5:  2: . . . . . "func"
    5:  6: . . . . . Signature (
    5:  6: . . . . . . Parameters (
    5:  6: . . . . . . . "("
    5:  7: . . . . . . . ParameterList (
    5:  7: . . . . . . . . ParamDeclOrNil (
    5:  7: . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    5:  8: . . . . . . . . )
    5:  8: . . . . . . . . ","
    5: 10: . . . . . . . . ParamDeclOrNil (
    5: 10: . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    5: 12: . . . . . . . . . Type (
    5: 12: . . . . . . . . . . TypeName (
    5: 12: . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    5: 18: . . . . . . . . . . )
    5: 18: . . . . . . . . . )
    5: 18: . . . . . . . . )
    5: 18: . . . . . . . )
    5: 18: . . . . . . . ")"
    5: 20: . . . . . . )
    5: 20: . . . . . . Result (
    5: 20: . . . . . . . TypeName (
    5: 20: . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    5: 27: . . . . . . . )
    5: 27: . . . . . . )
    5: 27: . . . . . )
    5: 27: . . . . )
    5: 27: . . . . Body (
    5: 27: . . . . . "{"
    6:  3: . . . . . StatementList (
    6:  3: . . . . . . Statement (
    6:  3: . . . . . . . ReturnStmt (
    6:  3: . . . . . . . . "return"
    6: 10: . . . . . . . . ExpressionList (
    6: 10: . . . . . . . . . Expression (
    6: 10: . . . . . . . . . . BinaryExpr (
    6: 10: . . . . . . . . . . . UnaryExpr (
    6: 10: . . . . . . . . . . . . PrimaryExpr (
    6: 10: . . . . . . . . . . . . . Operand (
    6: 10: . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    6: 12: . . . . . . . . . . . . . )
    6: 12: . . . . . . . . . . . . )
    6: 12: . . . . . . . . . . . )
    6: 12: . . . . . . . . . . . "+"
    6: 14: . . . . . . . . . . . BinaryExpr (
    6: 14: . . . . . . . . . . . . UnaryExpr (
    6: 14: . . . . . . . . . . . . . PrimaryExpr (
    6: 14: . . . . . . . . . . . . . . Operand (
    6: 14: . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    6: 15: . . . . . . . . . . . . . . )
    6: 15: . . . . . . . . . . . . . )
    6: 15: . . . . . . . . . . . . )
    6: 15: . . . . . . . . . . . )
    6: 15: . . . . . . . . . . )
    6: 15: . . . . . . . . . )
    6: 15: . . . . . . . . )
    6: 15: . . . . . . . . ";"
    7:  2: . . . . . . . )
    7:  2: . . . . . . )
    7:  2: . . . . . )
    7:  2: . . . . . "}"
    7:  3: . . . . )
    7:  3: . . . )
    7:  3: . . . ";"
    8:  1: . . . ")"
    8:  2: . . . ";"
 /app/parser/parser.go:3917: ast.OverloadFuncDecl{Recv: <nil>, Name: foo, ...}
   10:  1: . . )
   10:  1: . )
   10:  1: . Declaration (
   10:  1: . . FunctionDeclOrCall (
   10:  1: . . . "func"
   10:  6: . . . IDENT bar
 /app/parser/parser.go:713: ast.Ident{Name: bar}
   10: 10: . . . "="
   10: 12: . . . "("
   11:  2: . . . IDENT addComplex
 /app/parser/parser.go:713: ast.Ident{Name: addComplex}
   11: 12: . . . ";"
   12:  2: . . . PrimaryExpr (
   12:  2: . . . . Operand (
   12:  2: . . . . . "("
   12:  3: . . . . . Expression (
   12:  3: . . . . . . BinaryExpr (
   12:  3: . . . . . . . UnaryExpr (
   12:  3: . . . . . . . . PrimaryExpr (
   12:  3: . . . . . . . . . Operand (
   12:  3: . . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
   12:  4: . . . . . . . . . )
   12:  4: . . . . . . . . )
   12:  4: . . . . . . . )
   12:  4: . . . . . . )
   12:  4: . . . . . )
   12:  4: . . . . . ")"
 /app/parser/parser.go:1897: ast.ParenExpr{X: T}
   12:  5: . . . . )
   12:  5: . . . . "."
   12:  6: . . . . Selector (
   12:  6: . . . . . IDENT add
 /app/parser/parser.go:713: ast.Ident{Name: add}
   12:  9: . . . . )
   12:  9: . . . )
   12:  9: . . . ";"
   13:  1: . . . ")"
   13:  2: . . . ";"
 /app/parser/parser.go:3917: ast.OverloadFuncDecl{Recv: <nil>, Name: bar, ...}
   13:  3: . . )
   13:  3: . )
   13:  3: )
=== RUN   TestFromTestdata/overload2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/overload2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  6: . . . Parameters (
    1:  6: . . . . "("
    1:  7: . . . . ParameterList (
    1:  7: . . . . . ParamDeclOrNil (
    1:  7: . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
    1:  8: . . . . . )
    1:  8: . . . . )
    1:  8: . . . . ")"
    1:  9: . . . )
    1:  9: . . . "."
    1: 10: . . . "*"
 /app/parser/parser.go:639: ast.Ident{Tok: *}
    1: 12: . . . "="
    1: 14: . . . "("
    2:  2: . . . IDENT mul1
 /app/parser/parser.go:713: ast.Ident{Name: mul1}
    2:  6: . . . ";"
    3:  2: . . . IDENT mul2
 /app/parser/parser.go:713: ast.Ident{Name: mul2}
    3:  6: . . . ";"
    4:  1: . . . ")"
    4:  2: . . . ";"
 /app/parser/parser.go:3917: ast.OverloadFuncDecl{Recv: T, Name: *, ...}
    6:  1: . . )
    6:  1: . )
    6:  1: . Declaration (
    6:  1: . . FunctionDeclOrCall (
    6:  1: . . . "func"
    6:  6: . . . Parameters (
    6:  6: . . . . "("
    6:  7: . . . . ParameterList (
    6:  7: . . . . . ParamDeclOrNil (
    6:  7: . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
    6:  8: . . . . . )
    6:  8: . . . . )
    6:  8: . . . . ")"
    6:  9: . . . )
    6:  9: . . . "."
    6: 10: . . . IDENT add
 /app/parser/parser.go:713: ast.Ident{Name: add}
    6: 14: . . . "="
    6: 16: . . . "("
    7:  2: . . . IDENT add1
 /app/parser/parser.go:713: ast.Ident{Name: add1}
    7:  6: . . . ";"
    8:  2: . . . FuncTypeOrLit (
    8:  2: . . . . FuncType (
    8:  2: . . . . . "func"
    8:  6: . . . . . Signature (
    8:  6: . . . . . . Parameters (
    8:  6: . . . . . . . "("
    8:  7: . . . . . . . ParameterList (
    8:  7: . . . . . . . . ParamDeclOrNil (
    8:  7: . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    8:  8: . . . . . . . . )
    8:  8: . . . . . . . . ","
    8: 10: . . . . . . . . ParamDeclOrNil (
    8: 10: . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    8: 12: . . . . . . . . . Type (
    8: 12: . . . . . . . . . . TypeName (
    8: 12: . . . . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
    8: 13: . . . . . . . . . . )
    8: 13: . . . . . . . . . )
    8: 13: . . . . . . . . )
    8: 13: . . . . . . . )
    8: 13: . . . . . . . ")"
    8: 15: . . . . . . )
    8: 15: . . . . . . Result (
    8: 15: . . . . . . . TypeName (
    8: 15: . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
    8: 17: . . . . . . . )
    8: 17: . . . . . . )
    8: 17: . . . . . )
    8: 17: . . . . )
    8: 17: . . . . Body (
    8: 17: . . . . . "{"
    9:  3: . . . . . StatementList (
    9:  3: . . . . . . Statement (
    9:  3: . . . . . . . ReturnStmt (
    9:  3: . . . . . . . . "return"
    9: 10: . . . . . . . . ExpressionList (
    9: 10: . . . . . . . . . Expression (
    9: 10: . . . . . . . . . . BinaryExpr (
    9: 10: . . . . . . . . . . . UnaryExpr (
    9: 10: . . . . . . . . . . . . PrimaryExpr (
    9: 10: . . . . . . . . . . . . . Operand (
    9: 10: . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    9: 12: . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . "+"
    9: 14: . . . . . . . . . . . BinaryExpr (
    9: 14: . . . . . . . . . . . . UnaryExpr (
    9: 14: . . . . . . . . . . . . . PrimaryExpr (
    9: 14: . . . . . . . . . . . . . . Operand (
    9: 14: . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    9: 15: . . . . . . . . . . . . . . )
    9: 15: . . . . . . . . . . . . . )
    9: 15: . . . . . . . . . . . . )
    9: 15: . . . . . . . . . . . )
    9: 15: . . . . . . . . . . )
    9: 15: . . . . . . . . . )
    9: 15: . . . . . . . . )
    9: 15: . . . . . . . . ";"
   10:  2: . . . . . . . )
   10:  2: . . . . . . )
   10:  2: . . . . . )
   10:  2: . . . . . "}"
   10:  3: . . . . )
   10:  3: . . . )
   10:  3: . . . ";"
   11:  1: . . . ")"
   11:  2: . . . ";"
 /app/parser/parser.go:3917: ast.OverloadFuncDecl{Recv: T, Name: add, ...}
   11:  3: . . )
   11:  3: . )
   11:  3: )
=== RUN   TestFromTestdata/overloadop
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/overloadop
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . GenDecl(type) (
    1:  1: . . . "type"
    1:  6: . . . TypeSpec (
    1:  6: . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    1: 10: . . . . Type (
    1: 10: . . . . . StructType (
    1: 10: . . . . . . "struct"
    1: 17: . . . . . . "{"
    2:  1: . . . . . . "}"
    2:  2: . . . . . )
    2:  2: . . . . )
    2:  2: . . . . ";"
    4:  1: . . . )
    4:  1: . . )
    4:  1: . )
    4:  1: . Declaration (
    4:  1: . . FunctionDeclOrCall (
    4:  1: . . . "func"
    4:  6: . . . Parameters (
    4:  6: . . . . "("
    4:  7: . . . . ParameterList (
    4:  7: . . . . . ParamDeclOrNil (
    4:  7: . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    4:  9: . . . . . . Type (
    4:  9: . . . . . . . PointerType (
    4:  9: . . . . . . . . "*"
    4: 10: . . . . . . . . Type (
    4: 10: . . . . . . . . . TypeName (
    4: 10: . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    4: 13: . . . . . . . . . )
    4: 13: . . . . . . . . )
    4: 13: . . . . . . . )
    4: 13: . . . . . . )
    4: 13: . . . . . )
    4: 13: . . . . )
    4: 13: . . . . ")"
    4: 15: . . . )
    4: 15: . . . "*"
    4: 17: . . . Signature (
    4: 17: . . . . Parameters (
    4: 17: . . . . . "("
    4: 18: . . . . . ParameterList (
    4: 18: . . . . . . ParamDeclOrNil (
    4: 18: . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    4: 20: . . . . . . . Type (
    4: 20: . . . . . . . . PointerType (
    4: 20: . . . . . . . . . "*"
    4: 21: . . . . . . . . . Type (
    4: 21: . . . . . . . . . . TypeName (
    4: 21: . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    4: 24: . . . . . . . . . . )
    4: 24: . . . . . . . . . )
    4: 24: . . . . . . . . )
    4: 24: . . . . . . . )
    4: 24: . . . . . . )
    4: 24: . . . . . )
    4: 24: . . . . . ")"
    4: 26: . . . . )
    4: 26: . . . . Result (
    4: 26: . . . . . PointerType (
    4: 26: . . . . . . "*"
    4: 27: . . . . . . Type (
    4: 27: . . . . . . . TypeName (
    4: 27: . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    4: 30: . . . . . . . )
    4: 30: . . . . . . )
    4: 30: . . . . . )
    4: 30: . . . . )
    4: 30: . . . )
    4: 30: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: *, ...}
    6:  1: . . )
    6:  1: . )
    6:  1: . Declaration (
    6:  1: . . FunctionDeclOrCall (
    6:  1: . . . "func"
    6:  6: . . . Parameters (
    6:  6: . . . . "("
    6:  7: . . . . ParameterList (
    6:  7: . . . . . ParamDeclOrNil (
    6:  7: . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    6:  9: . . . . . . Type (
    6:  9: . . . . . . . PointerType (
    6:  9: . . . . . . . . "*"
    6: 10: . . . . . . . . Type (
    6: 10: . . . . . . . . . TypeName (
    6: 10: . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    6: 13: . . . . . . . . . )
    6: 13: . . . . . . . . )
    6: 13: . . . . . . . )
    6: 13: . . . . . . )
    6: 13: . . . . . )
    6: 13: . . . . )
    6: 13: . . . . ")"
    6: 15: . . . )
    6: 15: . . . "+"
    6: 17: . . . Signature (
    6: 17: . . . . Parameters (
    6: 17: . . . . . "("
    6: 18: . . . . . ParameterList (
    6: 18: . . . . . . ParamDeclOrNil (
    6: 18: . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    6: 20: . . . . . . . Type (
    6: 20: . . . . . . . . PointerType (
    6: 20: . . . . . . . . . "*"
    6: 21: . . . . . . . . . Type (
    6: 21: . . . . . . . . . . TypeName (
    6: 21: . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    6: 24: . . . . . . . . . . )
    6: 24: . . . . . . . . . )
    6: 24: . . . . . . . . )
    6: 24: . . . . . . . )
    6: 24: . . . . . . )
    6: 24: . . . . . )
    6: 24: . . . . . ")"
    6: 26: . . . . )
    6: 26: . . . . Result (
    6: 26: . . . . . PointerType (
    6: 26: . . . . . . "*"
    6: 27: . . . . . . Type (
    6: 27: . . . . . . . TypeName (
    6: 27: . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    6: 31: . . . . . . . )
    6: 31: . . . . . . )
    6: 31: . . . . . )
    6: 31: . . . . )
    6: 31: . . . )
    6: 31: . . . Body (
    6: 31: . . . . "{"
    7:  2: . . . . StatementList (
    7:  2: . . . . . Statement (
    7:  2: . . . . . . SimpleStmt (
    7:  2: . . . . . . . ExpressionList (
    7:  2: . . . . . . . . Expression (
    7:  2: . . . . . . . . . BinaryExpr (
    7:  2: . . . . . . . . . . UnaryExpr (
    7:  2: . . . . . . . . . . . PrimaryExpr (
    7:  2: . . . . . . . . . . . . Operand (
    7:  2: . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    7:  9: . . . . . . . . . . . . )
    7:  9: . . . . . . . . . . . . CallOrConversion (
    7:  9: . . . . . . . . . . . . . "("
    7: 10: . . . . . . . . . . . . . Expression (
    7: 10: . . . . . . . . . . . . . . BinaryExpr (
    7: 10: . . . . . . . . . . . . . . . UnaryExpr (
    7: 10: . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 10: . . . . . . . . . . . . . . . . . Operand (
    7: 10: . . . . . . . . . . . . . . . . . . STRING "a + b"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a + b"}
    7: 17: . . . . . . . . . . . . . . . . . )
    7: 17: . . . . . . . . . . . . . . . . )
    7: 17: . . . . . . . . . . . . . . . )
    7: 17: . . . . . . . . . . . . . . )
    7: 17: . . . . . . . . . . . . . )
    7: 17: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    7: 18: . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . )
    7: 18: . . . . . . . . . . )
    7: 18: . . . . . . . . . )
    7: 18: . . . . . . . . )
    7: 18: . . . . . . . )
    7: 18: . . . . . . )
    7: 18: . . . . . . ";"
    8:  2: . . . . . )
    8:  2: . . . . . Statement (
    8:  2: . . . . . . ReturnStmt (
    8:  2: . . . . . . . "return"
    8:  9: . . . . . . . ExpressionList (
    8:  9: . . . . . . . . Expression (
    8:  9: . . . . . . . . . BinaryExpr (
    8:  9: . . . . . . . . . . UnaryExpr (
    8:  9: . . . . . . . . . . . "&"
    8: 10: . . . . . . . . . . . UnaryExpr (
    8: 10: . . . . . . . . . . . . PrimaryExpr (
    8: 10: . . . . . . . . . . . . . Operand (
    8: 10: . . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    8: 13: . . . . . . . . . . . . . )
    8: 13: . . . . . . . . . . . . . LiteralValue (
    8: 13: . . . . . . . . . . . . . . "{"
    8: 14: . . . . . . . . . . . . . . "}"
    8: 15: . . . . . . . . . . . . . )
    8: 15: . . . . . . . . . . . . )
    8: 15: . . . . . . . . . . . )
    8: 15: . . . . . . . . . . )
    8: 15: . . . . . . . . . )
    8: 15: . . . . . . . . )
    8: 15: . . . . . . . )
    8: 15: . . . . . . . ";"
    9:  1: . . . . . . )
    9:  1: . . . . . )
    9:  1: . . . . )
    9:  1: . . . . "}"
    9:  2: . . . )
    9:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: +, ...}
   11:  1: . . )
   11:  1: . )
   11:  1: . Declaration (
   11:  1: . . FunctionDeclOrCall (
   11:  1: . . . "func"
   11:  6: . . . Parameters (
   11:  6: . . . . "("
   11:  7: . . . . ParameterList (
   11:  7: . . . . . ParamDeclOrNil (
   11:  7: . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   11:  9: . . . . . . Type (
   11:  9: . . . . . . . TypeName (
   11:  9: . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   11: 12: . . . . . . . )
   11: 12: . . . . . . )
   11: 12: . . . . . )
   11: 12: . . . . )
   11: 12: . . . . ")"
   11: 14: . . . )
   11: 14: . . . "/"
   11: 16: . . . Signature (
   11: 16: . . . . Parameters (
   11: 16: . . . . . "("
   11: 17: . . . . . ParameterList (
   11: 17: . . . . . . ParamDeclOrNil (
   11: 17: . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   11: 19: . . . . . . . Type (
   11: 19: . . . . . . . . TypeName (
   11: 19: . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   11: 22: . . . . . . . . )
   11: 22: . . . . . . . )
   11: 22: . . . . . . )
   11: 22: . . . . . )
   11: 22: . . . . . ")"
   11: 24: . . . . )
   11: 24: . . . . Result (
   11: 24: . . . . . TypeName (
   11: 24: . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   11: 28: . . . . . )
   11: 28: . . . . )
   11: 28: . . . )
   11: 28: . . . Body (
   11: 28: . . . . "{"
   12:  2: . . . . StatementList (
   12:  2: . . . . . Statement (
   12:  2: . . . . . . SimpleStmt (
   12:  2: . . . . . . . ExpressionList (
   12:  2: . . . . . . . . Expression (
   12:  2: . . . . . . . . . BinaryExpr (
   12:  2: . . . . . . . . . . UnaryExpr (
   12:  2: . . . . . . . . . . . PrimaryExpr (
   12:  2: . . . . . . . . . . . . Operand (
   12:  2: . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   12:  9: . . . . . . . . . . . . )
   12:  9: . . . . . . . . . . . . CallOrConversion (
   12:  9: . . . . . . . . . . . . . "("
   12: 10: . . . . . . . . . . . . . Expression (
   12: 10: . . . . . . . . . . . . . . BinaryExpr (
   12: 10: . . . . . . . . . . . . . . . UnaryExpr (
   12: 10: . . . . . . . . . . . . . . . . PrimaryExpr (
   12: 10: . . . . . . . . . . . . . . . . . Operand (
   12: 10: . . . . . . . . . . . . . . . . . . STRING "a / b"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a / b"}
   12: 17: . . . . . . . . . . . . . . . . . )
   12: 17: . . . . . . . . . . . . . . . . )
   12: 17: . . . . . . . . . . . . . . . )
   12: 17: . . . . . . . . . . . . . . )
   12: 17: . . . . . . . . . . . . . )
   12: 17: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   12: 18: . . . . . . . . . . . . )
   12: 18: . . . . . . . . . . . )
   12: 18: . . . . . . . . . . )
   12: 18: . . . . . . . . . )
   12: 18: . . . . . . . . )
   12: 18: . . . . . . . )
   12: 18: . . . . . . )
   12: 18: . . . . . . ";"
   13:  2: . . . . . )
   13:  2: . . . . . Statement (
   13:  2: . . . . . . ReturnStmt (
   13:  2: . . . . . . . "return"
   13:  9: . . . . . . . ExpressionList (
   13:  9: . . . . . . . . Expression (
   13:  9: . . . . . . . . . BinaryExpr (
   13:  9: . . . . . . . . . . UnaryExpr (
   13:  9: . . . . . . . . . . . PrimaryExpr (
   13:  9: . . . . . . . . . . . . Operand (
   13:  9: . . . . . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   13: 12: . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . LiteralValue (
   13: 12: . . . . . . . . . . . . . "{"
   13: 13: . . . . . . . . . . . . . "}"
   13: 14: . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . )
   13: 14: . . . . . . . . . . )
   13: 14: . . . . . . . . . )
   13: 14: . . . . . . . . )
   13: 14: . . . . . . . )
   13: 14: . . . . . . . ";"
   14:  1: . . . . . . )
   14:  1: . . . . . )
   14:  1: . . . . )
   14:  1: . . . . "}"
   14:  2: . . . )
   14:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: /, ...}
   16:  1: . . )
   16:  1: . )
   16:  1: . Declaration (
   16:  1: . . FunctionDeclOrCall (
   16:  1: . . . "func"
   16:  6: . . . "-"
 /app/parser/parser.go:639: ast.Ident{Tok: -}
   16:  7: . . . Signature (
   16:  7: . . . . Parameters (
   16:  7: . . . . . "("
   16:  8: . . . . . ParameterList (
   16:  8: . . . . . . ParamDeclOrNil (
   16:  8: . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   16: 10: . . . . . . . Type (
   16: 10: . . . . . . . . TypeName (
   16: 10: . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   16: 13: . . . . . . . . )
   16: 13: . . . . . . . )
   16: 13: . . . . . . )
   16: 13: . . . . . )
   16: 13: . . . . . ")"
   16: 15: . . . . )
   16: 15: . . . . Result (
   16: 15: . . . . )
   16: 15: . . . )
   16: 15: . . . Body (
   16: 15: . . . . "{"
   17:  2: . . . . StatementList (
   17:  2: . . . . . Statement (
   17:  2: . . . . . . SimpleStmt (
   17:  2: . . . . . . . ExpressionList (
   17:  2: . . . . . . . . Expression (
   17:  2: . . . . . . . . . BinaryExpr (
   17:  2: . . . . . . . . . . UnaryExpr (
   17:  2: . . . . . . . . . . . PrimaryExpr (
   17:  2: . . . . . . . . . . . . Operand (
   17:  2: . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   17:  9: . . . . . . . . . . . . )
   17:  9: . . . . . . . . . . . . CallOrConversion (
   17:  9: . . . . . . . . . . . . . "("
   17: 10: . . . . . . . . . . . . . Expression (
   17: 10: . . . . . . . . . . . . . . BinaryExpr (
   17: 10: . . . . . . . . . . . . . . . UnaryExpr (
   17: 10: . . . . . . . . . . . . . . . . PrimaryExpr (
   17: 10: . . . . . . . . . . . . . . . . . Operand (
   17: 10: . . . . . . . . . . . . . . . . . . STRING "-a"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "-a"}
   17: 14: . . . . . . . . . . . . . . . . . )
   17: 14: . . . . . . . . . . . . . . . . )
   17: 14: . . . . . . . . . . . . . . . )
   17: 14: . . . . . . . . . . . . . . )
   17: 14: . . . . . . . . . . . . . )
   17: 14: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   17: 15: . . . . . . . . . . . . )
   17: 15: . . . . . . . . . . . )
   17: 15: . . . . . . . . . . )
   17: 15: . . . . . . . . . )
   17: 15: . . . . . . . . )
   17: 15: . . . . . . . )
   17: 15: . . . . . . )
   17: 15: . . . . . . ";"
   18:  1: . . . . . )
   18:  1: . . . . )
   18:  1: . . . . "}"
   18:  2: . . . )
   18:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: -, ...}
   20:  1: . . )
   20:  1: . )
   20:  1: . Declaration (
   20:  1: . . FunctionDeclOrCall (
   20:  1: . . . "func"
   20:  6: . . . "++"
 /app/parser/parser.go:639: ast.Ident{Tok: ++}
   20:  8: . . . Signature (
   20:  8: . . . . Parameters (
   20:  8: . . . . . "("
   20:  9: . . . . . ParameterList (
   20:  9: . . . . . . ParamDeclOrNil (
   20:  9: . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   20: 11: . . . . . . . Type (
   20: 11: . . . . . . . . TypeName (
   20: 11: . . . . . . . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
   20: 14: . . . . . . . . )
   20: 14: . . . . . . . )
   20: 14: . . . . . . )
   20: 14: . . . . . )
   20: 14: . . . . . ")"
   20: 16: . . . . )
   20: 16: . . . . Result (
   20: 16: . . . . )
   20: 16: . . . )
   20: 16: . . . Body (
   20: 16: . . . . "{"
   21:  2: . . . . StatementList (
   21:  2: . . . . . Statement (
   21:  2: . . . . . . SimpleStmt (
   21:  2: . . . . . . . ExpressionList (
   21:  2: . . . . . . . . Expression (
   21:  2: . . . . . . . . . BinaryExpr (
   21:  2: . . . . . . . . . . UnaryExpr (
   21:  2: . . . . . . . . . . . PrimaryExpr (
   21:  2: . . . . . . . . . . . . Operand (
   21:  2: . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   21:  9: . . . . . . . . . . . . )
   21:  9: . . . . . . . . . . . . CallOrConversion (
   21:  9: . . . . . . . . . . . . . "("
   21: 10: . . . . . . . . . . . . . Expression (
   21: 10: . . . . . . . . . . . . . . BinaryExpr (
   21: 10: . . . . . . . . . . . . . . . UnaryExpr (
   21: 10: . . . . . . . . . . . . . . . . PrimaryExpr (
   21: 10: . . . . . . . . . . . . . . . . . Operand (
   21: 10: . . . . . . . . . . . . . . . . . . STRING "a++"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a++"}
   21: 15: . . . . . . . . . . . . . . . . . )
   21: 15: . . . . . . . . . . . . . . . . )
   21: 15: . . . . . . . . . . . . . . . )
   21: 15: . . . . . . . . . . . . . . )
   21: 15: . . . . . . . . . . . . . )
   21: 15: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   21: 16: . . . . . . . . . . . . )
   21: 16: . . . . . . . . . . . )
   21: 16: . . . . . . . . . . )
   21: 16: . . . . . . . . . )
   21: 16: . . . . . . . . )
   21: 16: . . . . . . . )
   21: 16: . . . . . . )
   21: 16: . . . . . . ";"
   22:  1: . . . . . )
   22:  1: . . . . )
   22:  1: . . . . "}"
   22:  2: . . . )
   22:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: ++, ...}
   22:  3: . . )
   22:  3: . )
   22:  3: )
=== RUN   TestFromTestdata/printvariadic
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/printvariadic
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . . CallOrConversion (
    1:  9: . . . . . . . . . . . Expression (
    1:  9: . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1: 10: . . . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . "..."
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: true, isCmd: true}
    1: 13: . . . . . . . . . . )
    1: 13: . . . . . . . . . )
    1: 13: . . . . . . . . )
    1: 13: . . . . . . . )
    1: 13: . . . . . . )
    1: 13: . . . . . )
    1: 13: . . . . )
    1: 13: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  9: . . . . . . . . . . )
    2:  9: . . . . . . . . . . CallOrConversion (
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    2: 10: . . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . "..."
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: true, isCmd: true}
    2: 13: . . . . . . . . . . )
    2: 13: . . . . . . . . . )
    2: 13: . . . . . . . . )
    2: 13: . . . . . . . )
    2: 13: . . . . . . )
    2: 13: . . . . . )
    2: 13: . . . . )
    2: 13: . . . . ";"
    2: 14: . . . )
    2: 14: . . )
    2: 14: . )
    2: 14: )
=== RUN   TestFromTestdata/pystr
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/pystr
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT print
 /app/parser/parser.go:713: ast.Ident{Name: print}
    1:  7: . . . . . . . . . . )
    1:  7: . . . . . . . . . . CallOrConversion (
    1:  7: . . . . . . . . . . . Expression (
    1:  7: . . . . . . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . . . . . . PYSTRING "Hello"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: PYSTRING, Value: "Hello"}
    1: 16: . . . . . . . . . . . . . . . )
    1: 16: . . . . . . . . . . . . . . )
    1: 16: . . . . . . . . . . . . . )
    1: 16: . . . . . . . . . . . . )
    1: 16: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: print, Ellipsis: false, isCmd: true}
    1: 16: . . . . . . . . . . )
    1: 16: . . . . . . . . . )
    1: 16: . . . . . . . . )
    1: 16: . . . . . . . )
    1: 16: . . . . . . )
    1: 16: . . . . . )
    1: 16: . . . . )
    1: 16: . . . . ";"
    1: 17: . . . )
    1: 17: . . )
    1: 17: . )
    1: 17: )
=== RUN   TestFromTestdata/rangeexpr1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/rangeexpr1
    1:  1: File (
    1:  1: . "package"
    1:  9: . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    1: 13: . ";"
    3:  1: . Declaration (
    3:  1: . . FunctionDeclOrCall (
    3:  1: . . . "func"
    3:  6: . . . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    3: 10: . . . Signature (
    3: 10: . . . . Parameters (
    3: 10: . . . . . "("
    3: 11: . . . . . ")"
    3: 13: . . . . )
    3: 13: . . . . Result (
    3: 13: . . . . )
    3: 13: . . . )
    3: 13: . . . Body (
    3: 13: . . . . "{"
    4:  2: . . . . StatementList (
    4:  2: . . . . . Statement (
    4:  2: . . . . . . ForStmt (
    4:  2: . . . . . . . "for"
    4:  6: . . . . . . . SimpleStmt (
    4:  6: . . . . . . . . ExpressionList (
    4:  6: . . . . . . . . . Expression (
    4:  6: . . . . . . . . . . BinaryExpr (
    4:  6: . . . . . . . . . . . UnaryExpr (
    4:  6: . . . . . . . . . . . . PrimaryExpr (
    4:  6: . . . . . . . . . . . . . Operand (
    4:  6: . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    4:  8: . . . . . . . . . . . . . )
    4:  8: . . . . . . . . . . . . )
    4:  8: . . . . . . . . . . . )
    4:  8: . . . . . . . . . . )
    4:  8: . . . . . . . . . )
    4:  8: . . . . . . . . )
    4:  8: . . . . . . . . ":="
    4: 11: . . . . . . . . "range"
    4: 17: . . . . . . . . Expression (
    4: 17: . . . . . . . . . RangeExpr (
    4: 17: . . . . . . . . . . ":"
    4: 18: . . . . . . . . . . BinaryExpr (
    4: 18: . . . . . . . . . . . UnaryExpr (
    4: 18: . . . . . . . . . . . . PrimaryExpr (
    4: 18: . . . . . . . . . . . . . Operand (
    4: 18: . . . . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
    4: 21: . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . )
    4: 21: . . . . . . . . . . )
 /app/parser/parser.go:2669: ast.RangeExpr{First: <nil>, Last: &{46 INT 10 <nil>}, Expr3: <nil>}
    4: 21: . . . . . . . . . )
    4: 21: . . . . . . . . )
    4: 21: . . . . . . . )
    4: 21: . . . . . . . BlockStmt (
    4: 21: . . . . . . . . "{"
    5:  3: . . . . . . . . StatementList (
    5:  3: . . . . . . . . . Statement (
    5:  3: . . . . . . . . . . SimpleStmt (
    5:  3: . . . . . . . . . . . ExpressionList (
    5:  3: . . . . . . . . . . . . Expression (
    5:  3: . . . . . . . . . . . . . BinaryExpr (
    5:  3: . . . . . . . . . . . . . . UnaryExpr (
    5:  3: . . . . . . . . . . . . . . . PrimaryExpr (
    5:  3: . . . . . . . . . . . . . . . . Operand (
    5:  3: . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5: 10: . . . . . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . . . . . . CallOrConversion (
    5: 10: . . . . . . . . . . . . . . . . . "("
    5: 11: . . . . . . . . . . . . . . . . . Expression (
    5: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    5: 12: . . . . . . . . . . . . . . . . . . . . . )
    5: 12: . . . . . . . . . . . . . . . . . . . . )
    5: 12: . . . . . . . . . . . . . . . . . . . )
    5: 12: . . . . . . . . . . . . . . . . . . )
    5: 12: . . . . . . . . . . . . . . . . . )
    5: 12: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    5: 13: . . . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . )
    5: 13: . . . . . . . . . . )
    5: 13: . . . . . . . . . . ";"
    6:  2: . . . . . . . . . )
    6:  2: . . . . . . . . )
    6:  2: . . . . . . . . "}"
    6:  3: . . . . . . . )
    6:  3: . . . . . . . ";"
    8:  2: . . . . . . )
    8:  2: . . . . . )
    8:  2: . . . . . Statement (
    8:  2: . . . . . . ForStmt (
    8:  2: . . . . . . . "for"
    8:  6: . . . . . . . SimpleStmt (
    8:  6: . . . . . . . . ExpressionList (
    8:  6: . . . . . . . . . Expression (
    8:  6: . . . . . . . . . . BinaryExpr (
    8:  6: . . . . . . . . . . . UnaryExpr (
    8:  6: . . . . . . . . . . . . PrimaryExpr (
    8:  6: . . . . . . . . . . . . . Operand (
    8:  6: . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    8:  8: . . . . . . . . . . . . . )
    8:  8: . . . . . . . . . . . . )
    8:  8: . . . . . . . . . . . )
    8:  8: . . . . . . . . . . )
    8:  8: . . . . . . . . . )
    8:  8: . . . . . . . . )
    8:  8: . . . . . . . . IDENT in
    8: 11: . . . . . . . . Expression (
    8: 11: . . . . . . . . . RangeExpr (
    8: 11: . . . . . . . . . . BinaryExpr (
    8: 11: . . . . . . . . . . . UnaryExpr (
    8: 11: . . . . . . . . . . . . PrimaryExpr (
    8: 11: . . . . . . . . . . . . . Operand (
    8: 11: . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    8: 12: . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . )
    8: 12: . . . . . . . . . . )
    8: 12: . . . . . . . . . . ":"
    8: 13: . . . . . . . . . . BinaryExpr (
    8: 13: . . . . . . . . . . . UnaryExpr (
    8: 13: . . . . . . . . . . . . PrimaryExpr (
    8: 13: . . . . . . . . . . . . . Operand (
    8: 13: . . . . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
    8: 16: . . . . . . . . . . . . . )
    8: 16: . . . . . . . . . . . . )
    8: 16: . . . . . . . . . . . )
    8: 16: . . . . . . . . . . )
 /app/parser/parser.go:2669: ast.RangeExpr{First: &{78 INT 1 <nil>}, Last: &{80 INT 10 <nil>}, Expr3: <nil>}
    8: 16: . . . . . . . . . )
    8: 16: . . . . . . . . )
    8: 16: . . . . . . . )
    8: 16: . . . . . . . BlockStmt (
    8: 16: . . . . . . . . "{"
    9:  3: . . . . . . . . StatementList (
    9:  3: . . . . . . . . . Statement (
    9:  3: . . . . . . . . . . SimpleStmt (
    9:  3: . . . . . . . . . . . ExpressionList (
    9:  3: . . . . . . . . . . . . Expression (
    9:  3: . . . . . . . . . . . . . BinaryExpr (
    9:  3: . . . . . . . . . . . . . . UnaryExpr (
    9:  3: . . . . . . . . . . . . . . . PrimaryExpr (
    9:  3: . . . . . . . . . . . . . . . . Operand (
    9:  3: . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    9: 10: . . . . . . . . . . . . . . . . )
    9: 10: . . . . . . . . . . . . . . . . CallOrConversion (
    9: 10: . . . . . . . . . . . . . . . . . "("
    9: 11: . . . . . . . . . . . . . . . . . Expression (
    9: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
    9: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    9: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
    9: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    9: 12: . . . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    9: 13: . . . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . )
    9: 13: . . . . . . . . . . )
    9: 13: . . . . . . . . . . ";"
   10:  2: . . . . . . . . . )
   10:  2: . . . . . . . . )
   10:  2: . . . . . . . . "}"
   10:  3: . . . . . . . )
   10:  3: . . . . . . . ";"
   12:  2: . . . . . . )
   12:  2: . . . . . )
   12:  2: . . . . . Statement (
   12:  2: . . . . . . ForStmt (
   12:  2: . . . . . . . "for"
   12:  6: . . . . . . . SimpleStmt (
   12:  6: . . . . . . . . ExpressionList (
   12:  6: . . . . . . . . . Expression (
   12:  6: . . . . . . . . . . BinaryExpr (
   12:  6: . . . . . . . . . . . UnaryExpr (
   12:  6: . . . . . . . . . . . . PrimaryExpr (
   12:  6: . . . . . . . . . . . . . Operand (
   12:  6: . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   12:  8: . . . . . . . . . . . . . )
   12:  8: . . . . . . . . . . . . )
   12:  8: . . . . . . . . . . . )
   12:  8: . . . . . . . . . . )
   12:  8: . . . . . . . . . )
   12:  8: . . . . . . . . )
   12:  8: . . . . . . . . ":="
   12: 11: . . . . . . . . "range"
   12: 17: . . . . . . . . Expression (
   12: 17: . . . . . . . . . RangeExpr (
   12: 17: . . . . . . . . . . ":"
   12: 18: . . . . . . . . . . BinaryExpr (
   12: 18: . . . . . . . . . . . UnaryExpr (
   12: 18: . . . . . . . . . . . . PrimaryExpr (
   12: 18: . . . . . . . . . . . . . Operand (
   12: 18: . . . . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
   12: 20: . . . . . . . . . . . . . )
   12: 20: . . . . . . . . . . . . )
   12: 20: . . . . . . . . . . . )
   12: 20: . . . . . . . . . . )
   12: 20: . . . . . . . . . . ":"
   12: 21: . . . . . . . . . . BinaryExpr (
   12: 21: . . . . . . . . . . . UnaryExpr (
   12: 21: . . . . . . . . . . . . PrimaryExpr (
   12: 21: . . . . . . . . . . . . . Operand (
   12: 21: . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   12: 23: . . . . . . . . . . . . . )
   12: 23: . . . . . . . . . . . . )
   12: 23: . . . . . . . . . . . )
   12: 23: . . . . . . . . . . )
 /app/parser/parser.go:2669: ast.RangeExpr{First: <nil>, Last: &{119 INT 10 <nil>}, Expr3: &{122 INT 2 <nil>}}
   12: 23: . . . . . . . . . )
   12: 23: . . . . . . . . )
   12: 23: . . . . . . . )
   12: 23: . . . . . . . BlockStmt (
   12: 23: . . . . . . . . "{"
   13:  3: . . . . . . . . StatementList (
   13:  3: . . . . . . . . . Statement (
   13:  3: . . . . . . . . . . SimpleStmt (
   13:  3: . . . . . . . . . . . ExpressionList (
   13:  3: . . . . . . . . . . . . Expression (
   13:  3: . . . . . . . . . . . . . BinaryExpr (
   13:  3: . . . . . . . . . . . . . . UnaryExpr (
   13:  3: . . . . . . . . . . . . . . . PrimaryExpr (
   13:  3: . . . . . . . . . . . . . . . . Operand (
   13:  3: . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   13: 10: . . . . . . . . . . . . . . . . )
   13: 10: . . . . . . . . . . . . . . . . CallOrConversion (
   13: 10: . . . . . . . . . . . . . . . . . "("
   13: 11: . . . . . . . . . . . . . . . . . Expression (
   13: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
   13: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   13: 12: . . . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   13: 13: . . . . . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . )
   13: 13: . . . . . . . . . . )
   13: 13: . . . . . . . . . . ";"
   14:  2: . . . . . . . . . )
   14:  2: . . . . . . . . )
   14:  2: . . . . . . . . "}"
   14:  3: . . . . . . . )
   14:  3: . . . . . . . ";"
   16:  2: . . . . . . )
   16:  2: . . . . . )
   16:  2: . . . . . Statement (
   16:  2: . . . . . . ForStmt (
   16:  2: . . . . . . . "for"
   16:  6: . . . . . . . "range"
   16: 12: . . . . . . . Expression (
   16: 12: . . . . . . . . RangeExpr (
   16: 12: . . . . . . . . . ":"
   16: 13: . . . . . . . . . BinaryExpr (
   16: 13: . . . . . . . . . . UnaryExpr (
   16: 13: . . . . . . . . . . . PrimaryExpr (
   16: 13: . . . . . . . . . . . . Operand (
   16: 13: . . . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
   16: 16: . . . . . . . . . . . . )
   16: 16: . . . . . . . . . . . )
   16: 16: . . . . . . . . . . )
   16: 16: . . . . . . . . . )
 /app/parser/parser.go:2669: ast.RangeExpr{First: <nil>, Last: &{155 INT 10 <nil>}, Expr3: <nil>}
   16: 16: . . . . . . . . )
   16: 16: . . . . . . . )
   16: 16: . . . . . . . BlockStmt (
   16: 16: . . . . . . . . "{"
   17:  3: . . . . . . . . StatementList (
   17:  3: . . . . . . . . . Statement (
   17:  3: . . . . . . . . . . SimpleStmt (
   17:  3: . . . . . . . . . . . ExpressionList (
   17:  3: . . . . . . . . . . . . Expression (
   17:  3: . . . . . . . . . . . . . BinaryExpr (
   17:  3: . . . . . . . . . . . . . . UnaryExpr (
   17:  3: . . . . . . . . . . . . . . . PrimaryExpr (
   17:  3: . . . . . . . . . . . . . . . . Operand (
   17:  3: . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   17: 10: . . . . . . . . . . . . . . . . )
   17: 10: . . . . . . . . . . . . . . . . CallOrConversion (
   17: 10: . . . . . . . . . . . . . . . . . "("
   17: 11: . . . . . . . . . . . . . . . . . Expression (
   17: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
   17: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   17: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   17: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
   17: 11: . . . . . . . . . . . . . . . . . . . . . . STRING "Range expression"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Range expression"}
   17: 29: . . . . . . . . . . . . . . . . . . . . . )
   17: 29: . . . . . . . . . . . . . . . . . . . . )
   17: 29: . . . . . . . . . . . . . . . . . . . )
   17: 29: . . . . . . . . . . . . . . . . . . )
   17: 29: . . . . . . . . . . . . . . . . . )
   17: 29: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   17: 30: . . . . . . . . . . . . . . . . )
   17: 30: . . . . . . . . . . . . . . . )
   17: 30: . . . . . . . . . . . . . . )
   17: 30: . . . . . . . . . . . . . )
   17: 30: . . . . . . . . . . . . )
   17: 30: . . . . . . . . . . . )
   17: 30: . . . . . . . . . . )
   17: 30: . . . . . . . . . . ";"
   18:  2: . . . . . . . . . )
   18:  2: . . . . . . . . )
   18:  2: . . . . . . . . "}"
   18:  3: . . . . . . . )
   18:  3: . . . . . . . ";"
   19:  1: . . . . . . )
   19:  1: . . . . . )
   19:  1: . . . . )
   19:  1: . . . . "}"
   19:  2: . . . )
   19:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: main, ...}
   19:  3: . . )
   19:  3: . )
   19:  3: )
=== RUN   TestFromTestdata/rangeexpr2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/rangeexpr2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . ForStmt (
    1:  1: . . . . . "for"
    1:  5: . . . . . SimpleStmt (
    1:  5: . . . . . . RangeExpr (
    1:  5: . . . . . . . ":"
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . )
    1:  9: . . . . . . . . )
    1:  9: . . . . . . . )
 /app/parser/parser.go:2669: ast.RangeExpr{First: <nil>, Last: &{6 INT 10 <nil>}, Expr3: <nil>}
    1:  9: . . . . . . )
    1:  9: . . . . . )
    1:  9: . . . . . BlockStmt (
    1:  9: . . . . . . "{"
    2:  1: . . . . . . StatementList (
    2:  1: . . . . . . )
    2:  1: . . . . . . "}"
    2:  2: . . . . . )
    2:  2: . . . . . ";"
    2:  3: . . . . )
    2:  3: . . . )
    2:  3: . . )
    2:  3: . )
    2:  3: )
=== RUN   TestFromTestdata/rangeexpr3
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/rangeexpr3
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . ForStmt (
    1:  1: . . . . . "for"
    1:  5: . . . . . SimpleStmt (
    1:  5: . . . . . . ExpressionList (
    1:  5: . . . . . . . Expression (
    1:  5: . . . . . . . . BinaryExpr (
    1:  5: . . . . . . . . . UnaryExpr (
    1:  5: . . . . . . . . . . PrimaryExpr (
    1:  5: . . . . . . . . . . . Operand (
    1:  5: . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  6: . . . . . . . . . . . )
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . )
    1:  6: . . . . . . . . )
    1:  6: . . . . . . . )
    1:  6: . . . . . . )
    1:  6: . . . . . . RangeExpr (
    1:  6: . . . . . . . ":"
    1:  7: . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
    1: 10: . . . . . . . . . . )
    1: 10: . . . . . . . . . )
    1: 10: . . . . . . . . )
    1: 10: . . . . . . . )
 /app/parser/parser.go:2669: ast.RangeExpr{First: &{5 INT 1 <nil>}, Last: &{7 INT 10 <nil>}, Expr3: <nil>}
    1: 10: . . . . . . )
    1: 10: . . . . . )
    1: 10: . . . . . BlockStmt (
    1: 10: . . . . . . "{"
    2:  1: . . . . . . StatementList (
    2:  1: . . . . . . )
    2:  1: . . . . . . "}"
    2:  2: . . . . . )
    2:  2: . . . . . ";"
    2:  3: . . . . )
    2:  3: . . . )
    2:  3: . . )
    2:  3: . )
    2:  3: )
=== RUN   TestFromTestdata/rational
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/rational
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . RAT 1r
 /app/parser/parser.go:1862: ast.BasicLit{Kind: RAT, Value: 1r}
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . )
    1:  9: . . . . . . . . )
    1:  9: . . . . . . . . "<<"
    1: 12: . . . . . . . . BinaryExpr (
    1: 12: . . . . . . . . . UnaryExpr (
    1: 12: . . . . . . . . . . PrimaryExpr (
    1: 12: . . . . . . . . . . . Operand (
    1: 12: . . . . . . . . . . . . INT 65
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 65}
    1: 15: . . . . . . . . . . . )
    1: 15: . . . . . . . . . . )
    1: 15: . . . . . . . . . )
    1: 15: . . . . . . . . )
    1: 15: . . . . . . . )
    1: 15: . . . . . . )
    1: 15: . . . . . )
    1: 15: . . . . )
    1: 15: . . . . ";"
    1: 15: . . . . COMMENT
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    2:  3: . . . . . . . . . . )
    2:  3: . . . . . . . . . )
    2:  3: . . . . . . . . )
    2:  3: . . . . . . . )
    2:  3: . . . . . . )
    2:  3: . . . . . )
    2:  3: . . . . . ":="
    2:  6: . . . . . ExpressionList (
    2:  6: . . . . . . Expression (
    2:  6: . . . . . . . BinaryExpr (
    2:  6: . . . . . . . . UnaryExpr (
    2:  6: . . . . . . . . . PrimaryExpr (
    2:  6: . . . . . . . . . . Operand (
    2:  6: . . . . . . . . . . . INT 4
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 4}
    2:  7: . . . . . . . . . . )
    2:  7: . . . . . . . . . )
    2:  7: . . . . . . . . )
    2:  7: . . . . . . . . "/"
    2:  8: . . . . . . . . BinaryExpr (
    2:  8: . . . . . . . . . UnaryExpr (
    2:  8: . . . . . . . . . . PrimaryExpr (
    2:  8: . . . . . . . . . . . Operand (
    2:  8: . . . . . . . . . . . . RAT 5r
 /app/parser/parser.go:1862: ast.BasicLit{Kind: RAT, Value: 5r}
    2: 15: . . . . . . . . . . . )
    2: 15: . . . . . . . . . . )
    2: 15: . . . . . . . . . )
    2: 15: . . . . . . . . )
    2: 15: . . . . . . . )
    2: 15: . . . . . . )
    2: 15: . . . . . )
    2: 15: . . . . )
    2: 15: . . . . ";"
    2: 15: . . . . COMMENT
    3:  1: . . . )
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . IDENT c
 /app/parser/parser.go:713: ast.Ident{Name: c}
    3:  3: . . . . . . . . . . )
    3:  3: . . . . . . . . . )
    3:  3: . . . . . . . . )
    3:  3: . . . . . . . )
    3:  3: . . . . . . )
    3:  3: . . . . . )
    3:  3: . . . . . ":="
    3:  6: . . . . . ExpressionList (
    3:  6: . . . . . . Expression (
    3:  6: . . . . . . . BinaryExpr (
    3:  6: . . . . . . . . UnaryExpr (
    3:  6: . . . . . . . . . PrimaryExpr (
    3:  6: . . . . . . . . . . Operand (
    3:  6: . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    3:  8: . . . . . . . . . . )
    3:  8: . . . . . . . . . )
    3:  8: . . . . . . . . )
    3:  8: . . . . . . . . "-"
    3: 10: . . . . . . . . BinaryExpr (
    3: 10: . . . . . . . . . UnaryExpr (
    3: 10: . . . . . . . . . . PrimaryExpr (
    3: 10: . . . . . . . . . . . Operand (
    3: 10: . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    3: 11: . . . . . . . . . . . )
    3: 11: . . . . . . . . . . )
    3: 11: . . . . . . . . . )
    3: 11: . . . . . . . . . "/"
    3: 12: . . . . . . . . . BinaryExpr (
    3: 12: . . . . . . . . . . UnaryExpr (
    3: 12: . . . . . . . . . . . PrimaryExpr (
    3: 12: . . . . . . . . . . . . Operand (
    3: 12: . . . . . . . . . . . . . RAT 3r
 /app/parser/parser.go:1862: ast.BasicLit{Kind: RAT, Value: 3r}
    3: 15: . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . )
    3: 15: . . . . . . . . . . )
    3: 15: . . . . . . . . . )
    3: 15: . . . . . . . . )
    3: 15: . . . . . . . . "+"
    3: 17: . . . . . . . . BinaryExpr (
    3: 17: . . . . . . . . . UnaryExpr (
    3: 17: . . . . . . . . . . PrimaryExpr (
    3: 17: . . . . . . . . . . . Operand (
    3: 17: . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    3: 18: . . . . . . . . . . . )
    3: 18: . . . . . . . . . . )
    3: 18: . . . . . . . . . )
    3: 18: . . . . . . . . . "*"
    3: 19: . . . . . . . . . BinaryExpr (
    3: 19: . . . . . . . . . . UnaryExpr (
    3: 19: . . . . . . . . . . . PrimaryExpr (
    3: 19: . . . . . . . . . . . . Operand (
    3: 19: . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    3: 20: . . . . . . . . . . . . )
    3: 20: . . . . . . . . . . . )
    3: 20: . . . . . . . . . . )
    3: 20: . . . . . . . . . )
    3: 20: . . . . . . . . . "/"
    3: 21: . . . . . . . . . BinaryExpr (
    3: 21: . . . . . . . . . . UnaryExpr (
    3: 21: . . . . . . . . . . . PrimaryExpr (
    3: 21: . . . . . . . . . . . . Operand (
    3: 21: . . . . . . . . . . . . . RAT 2r
 /app/parser/parser.go:1862: ast.BasicLit{Kind: RAT, Value: 2r}
    3: 23: . . . . . . . . . . . . )
    3: 23: . . . . . . . . . . . )
    3: 23: . . . . . . . . . . )
    3: 23: . . . . . . . . . )
    3: 23: . . . . . . . . )
    3: 23: . . . . . . . )
    3: 23: . . . . . . )
    3: 23: . . . . . )
    3: 23: . . . . )
    3: 23: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    4:  8: . . . . . . . . . . )
    4:  8: . . . . . . . . . . CallOrConversion (
    4:  8: . . . . . . . . . . . "("
    4:  9: . . . . . . . . . . . Expression (
    4:  9: . . . . . . . . . . . . BinaryExpr (
    4:  9: . . . . . . . . . . . . . UnaryExpr (
    4:  9: . . . . . . . . . . . . . . PrimaryExpr (
    4:  9: . . . . . . . . . . . . . . . Operand (
    4:  9: . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    4: 10: . . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . ","
    4: 12: . . . . . . . . . . . Expression (
    4: 12: . . . . . . . . . . . . BinaryExpr (
    4: 12: . . . . . . . . . . . . . UnaryExpr (
    4: 12: . . . . . . . . . . . . . . PrimaryExpr (
    4: 12: . . . . . . . . . . . . . . . Operand (
    4: 12: . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    4: 13: . . . . . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . ","
    4: 15: . . . . . . . . . . . Expression (
    4: 15: . . . . . . . . . . . . BinaryExpr (
    4: 15: . . . . . . . . . . . . . UnaryExpr (
    4: 15: . . . . . . . . . . . . . . PrimaryExpr (
    4: 15: . . . . . . . . . . . . . . . Operand (
    4: 15: . . . . . . . . . . . . . . . . IDENT c
 /app/parser/parser.go:713: ast.Ident{Name: c}
    4: 16: . . . . . . . . . . . . . . . )
    4: 16: . . . . . . . . . . . . . . )
    4: 16: . . . . . . . . . . . . . )
    4: 16: . . . . . . . . . . . . )
    4: 16: . . . . . . . . . . . )
    4: 16: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    4: 17: . . . . . . . . . . )
    4: 17: . . . . . . . . . )
    4: 17: . . . . . . . . )
    4: 17: . . . . . . . )
    4: 17: . . . . . . )
    4: 17: . . . . . )
    4: 17: . . . . )
    4: 17: . . . . ";"
    4: 18: . . . )
    4: 18: . . )
    4: 18: . )
    4: 18: )
=== RUN   TestFromTestdata/selectdata
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/selectdata
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . ArrayType (
    1:  6: . . . . . . . . . . . . "["
    1:  7: . . . . . . . . . . . . Expression (
    1:  7: . . . . . . . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  8: . . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . ","
    1: 10: . . . . . . . . . . . . Expression (
    1: 10: . . . . . . . . . . . . . BinaryExpr (
    1: 10: . . . . . . . . . . . . . . UnaryExpr (
    1: 10: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 10: . . . . . . . . . . . . . . . . Operand (
    1: 10: . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    1: 11: . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . ","
    1: 13: . . . . . . . . . . . . Expression (
    1: 13: . . . . . . . . . . . . . BinaryExpr (
    1: 13: . . . . . . . . . . . . . . UnaryExpr (
    1: 13: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 13: . . . . . . . . . . . . . . . . Operand (
    1: 13: . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    1: 14: . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . ","
    1: 16: . . . . . . . . . . . . Expression (
    1: 16: . . . . . . . . . . . . . BinaryExpr (
    1: 16: . . . . . . . . . . . . . . UnaryExpr (
    1: 16: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 16: . . . . . . . . . . . . . . . . Operand (
    1: 16: . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    1: 17: . . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . ","
    1: 19: . . . . . . . . . . . . Expression (
    1: 19: . . . . . . . . . . . . . BinaryExpr (
    1: 19: . . . . . . . . . . . . . . UnaryExpr (
    1: 19: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 19: . . . . . . . . . . . . . . . . Operand (
    1: 19: . . . . . . . . . . . . . . . . . INT 8
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 8}
    1: 20: . . . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . ","
    1: 22: . . . . . . . . . . . . Expression (
    1: 22: . . . . . . . . . . . . . BinaryExpr (
    1: 22: . . . . . . . . . . . . . . UnaryExpr (
    1: 22: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 22: . . . . . . . . . . . . . . . . Operand (
    1: 22: . . . . . . . . . . . . . . . . . INT 19
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 19}
    1: 24: . . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . "]"
    1: 25: . . . . . . . . . . . )
    1: 25: . . . . . . . . . . )
    1: 25: . . . . . . . . . )
    1: 25: . . . . . . . . )
    1: 25: . . . . . . . )
    1: 25: . . . . . . )
    1: 25: . . . . . )
    1: 25: . . . . )
    1: 25: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    2:  3: . . . . . . . . . . )
    2:  3: . . . . . . . . . )
    2:  3: . . . . . . . . )
    2:  3: . . . . . . . )
    2:  3: . . . . . . )
    2:  3: . . . . . )
    2:  3: . . . . . ":="
    2:  6: . . . . . ExpressionList (
    2:  6: . . . . . . Expression (
    2:  6: . . . . . . . BinaryExpr (
    2:  6: . . . . . . . . UnaryExpr (
    2:  6: . . . . . . . . . PrimaryExpr (
    2:  6: . . . . . . . . . . Operand (
    2:  6: . . . . . . . . . . . LiteralValue (
    2:  6: . . . . . . . . . . . . "{"
    2:  7: . . . . . . . . . . . . ElementList (
    2:  7: . . . . . . . . . . . . . Element (
    2:  7: . . . . . . . . . . . . . . Element (
    2:  7: . . . . . . . . . . . . . . . Expression (
    2:  7: . . . . . . . . . . . . . . . . BinaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . . . Operand (
    2:  7: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2:  9: . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . ForPhrase (
    2:  9: . . . . . . . . . . . . . . "for"
    2: 13: . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 15: . . . . . . . . . . . . . . IDENT in
    2: 18: . . . . . . . . . . . . . . Expression (
    2: 18: . . . . . . . . . . . . . . . RangeExpr (
    2: 18: . . . . . . . . . . . . . . . . BinaryExpr (
    2: 18: . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 18: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 18: . . . . . . . . . . . . . . . . . . . Operand (
    2: 18: . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2: 20: . . . . . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . "if"
    2: 23: . . . . . . . . . . . . . . SimpleStmt (
    2: 23: . . . . . . . . . . . . . . . ExpressionList (
    2: 23: . . . . . . . . . . . . . . . . Expression (
    2: 23: . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 23: . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 23: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 23: . . . . . . . . . . . . . . . . . . . . Operand (
    2: 23: . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 24: . . . . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . . . "%"
    2: 25: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 25: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 25: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 25: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 25: . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    2: 27: . . . . . . . . . . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . . . . . . . . "=="
    2: 30: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 30: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 30: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 30: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 30: . . . . . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    2: 31: . . . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . "}"
    2: 32: . . . . . . . . . . . )
    2: 32: . . . . . . . . . . )
    2: 32: . . . . . . . . . )
    2: 32: . . . . . . . . )
    2: 32: . . . . . . . )
    2: 32: . . . . . . )
    2: 32: . . . . . )
    2: 32: . . . . )
    2: 32: . . . . ";"
    2: 33: . . . )
    2: 33: . . )
    2: 33: . )
    2: 33: )
=== RUN   TestFromTestdata/slice1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/slice1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    1:  8: . . . . . . . . . . )
    1:  8: . . . . . . . . . . CallOrConversion (
    1:  8: . . . . . . . . . . . "("
    1:  9: . . . . . . . . . . . Expression (
    1:  9: . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . . . . . . . ArrayType (
    1:  9: . . . . . . . . . . . . . . . . . "["
    1: 10: . . . . . . . . . . . . . . . . . Expression (
    1: 10: . . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 10: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 10: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 10: . . . . . . . . . . . . . . . . . . . . . Operand (
    1: 10: . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1: 11: . . . . . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . "]"
    1: 12: . . . . . . . . . . . . . . . . . ArrayType (
    1: 12: . . . . . . . . . . . . . . . . . . "["
    1: 13: . . . . . . . . . . . . . . . . . . Expression (
    1: 13: . . . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 13: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 13: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 13: . . . . . . . . . . . . . . . . . . . . . . Operand (
    1: 13: . . . . . . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    1: 14: . . . . . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:916: ast.IndexExpr{X: &{9 [0xc00042e6f0] 11 false}, Index: &{13 INT 0 <nil>}}
    1: 15: . . . . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . )
    1: 15: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    1: 16: . . . . . . . . . . )
    1: 16: . . . . . . . . . )
    1: 16: . . . . . . . . )
    1: 16: . . . . . . . )
    1: 16: . . . . . . )
    1: 16: . . . . . )
    1: 16: . . . . )
    1: 16: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  8: . . . . . . . . . . )
    2:  8: . . . . . . . . . . CallOrConversion (
    2:  8: . . . . . . . . . . . "("
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . ArrayType (
    2:  9: . . . . . . . . . . . . . . . . . "["
    2: 10: . . . . . . . . . . . . . . . . . Expression (
    2: 10: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 10: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 10: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 10: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 10: . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2: 11: . . . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . "]"
    2: 12: . . . . . . . . . . . . . . . . . ArrayType (
    2: 12: . . . . . . . . . . . . . . . . . . "["
    2: 13: . . . . . . . . . . . . . . . . . . Expression (
    2: 13: . . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 13: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 13: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 13: . . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 13: . . . . . . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    2: 14: . . . . . . . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . . . ":"
    2: 15: . . . . . . . . . . . . . . . . . . Expression (
    2: 15: . . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 15: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 15: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 15: . . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 15: . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2: 16: . . . . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . . . . "]"
    2: 17: . . . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    2: 18: . . . . . . . . . . )
    2: 18: . . . . . . . . . )
    2: 18: . . . . . . . . )
    2: 18: . . . . . . . )
    2: 18: . . . . . . )
    2: 18: . . . . . )
    2: 18: . . . . )
    2: 18: . . . . ";"
    3:  1: . . . )
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    3:  8: . . . . . . . . . . )
    3:  8: . . . . . . . . . . CallOrConversion (
    3:  8: . . . . . . . . . . . "("
    3:  9: . . . . . . . . . . . Expression (
    3:  9: . . . . . . . . . . . . BinaryExpr (
    3:  9: . . . . . . . . . . . . . UnaryExpr (
    3:  9: . . . . . . . . . . . . . . PrimaryExpr (
    3:  9: . . . . . . . . . . . . . . . Operand (
    3:  9: . . . . . . . . . . . . . . . . ArrayType (
    3:  9: . . . . . . . . . . . . . . . . . "["
    3: 10: . . . . . . . . . . . . . . . . . Expression (
    3: 10: . . . . . . . . . . . . . . . . . . BinaryExpr (
    3: 10: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3: 10: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 10: . . . . . . . . . . . . . . . . . . . . . Operand (
    3: 10: . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    3: 11: . . . . . . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . . ","
    3: 13: . . . . . . . . . . . . . . . . . Expression (
    3: 13: . . . . . . . . . . . . . . . . . . BinaryExpr (
    3: 13: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3: 13: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 13: . . . . . . . . . . . . . . . . . . . . . Operand (
    3: 13: . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    3: 14: . . . . . . . . . . . . . . . . . . . . . )
    3: 14: . . . . . . . . . . . . . . . . . . . . )
    3: 14: . . . . . . . . . . . . . . . . . . . )
    3: 14: . . . . . . . . . . . . . . . . . . )
    3: 14: . . . . . . . . . . . . . . . . . )
    3: 14: . . . . . . . . . . . . . . . . . "]"
    3: 15: . . . . . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . . . . . IndexOrSlice (
    3: 15: . . . . . . . . . . . . . . . . "["
    3: 16: . . . . . . . . . . . . . . . . Expression (
    3: 16: . . . . . . . . . . . . . . . . . BinaryExpr (
    3: 16: . . . . . . . . . . . . . . . . . . UnaryExpr (
    3: 16: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 16: . . . . . . . . . . . . . . . . . . . . Operand (
    3: 16: . . . . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    3: 17: . . . . . . . . . . . . . . . . . . . . )
    3: 17: . . . . . . . . . . . . . . . . . . . )
    3: 17: . . . . . . . . . . . . . . . . . . )
    3: 17: . . . . . . . . . . . . . . . . . )
    3: 17: . . . . . . . . . . . . . . . . )
    3: 17: . . . . . . . . . . . . . . . . ":"
    3: 18: . . . . . . . . . . . . . . . . Expression (
    3: 18: . . . . . . . . . . . . . . . . . BinaryExpr (
    3: 18: . . . . . . . . . . . . . . . . . . UnaryExpr (
    3: 18: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 18: . . . . . . . . . . . . . . . . . . . . Operand (
    3: 18: . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    3: 19: . . . . . . . . . . . . . . . . . . . . )
    3: 19: . . . . . . . . . . . . . . . . . . . )
    3: 19: . . . . . . . . . . . . . . . . . . )
    3: 19: . . . . . . . . . . . . . . . . . )
    3: 19: . . . . . . . . . . . . . . . . )
    3: 19: . . . . . . . . . . . . . . . . ":"
    3: 20: . . . . . . . . . . . . . . . . Expression (
    3: 20: . . . . . . . . . . . . . . . . . BinaryExpr (
    3: 20: . . . . . . . . . . . . . . . . . . UnaryExpr (
    3: 20: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 20: . . . . . . . . . . . . . . . . . . . . Operand (
    3: 20: . . . . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    3: 21: . . . . . . . . . . . . . . . . . . . . )
    3: 21: . . . . . . . . . . . . . . . . . . . )
    3: 21: . . . . . . . . . . . . . . . . . . )
    3: 21: . . . . . . . . . . . . . . . . . )
    3: 21: . . . . . . . . . . . . . . . . )
    3: 21: . . . . . . . . . . . . . . . . "]"
    3: 22: . . . . . . . . . . . . . . . )
    3: 22: . . . . . . . . . . . . . . )
    3: 22: . . . . . . . . . . . . . )
    3: 22: . . . . . . . . . . . . )
    3: 22: . . . . . . . . . . . )
    3: 22: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    3: 23: . . . . . . . . . . )
    3: 23: . . . . . . . . . )
    3: 23: . . . . . . . . )
    3: 23: . . . . . . . )
    3: 23: . . . . . . )
    3: 23: . . . . . )
    3: 23: . . . . )
    3: 23: . . . . ";"
    5:  1: . . . )
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    5:  3: . . . . . . . . . . )
    5:  3: . . . . . . . . . )
    5:  3: . . . . . . . . )
    5:  3: . . . . . . . )
    5:  3: . . . . . . )
    5:  3: . . . . . )
    5:  3: . . . . . ":="
    5:  6: . . . . . ExpressionList (
    5:  6: . . . . . . Expression (
    5:  6: . . . . . . . BinaryExpr (
    5:  6: . . . . . . . . UnaryExpr (
    5:  6: . . . . . . . . . PrimaryExpr (
    5:  6: . . . . . . . . . . Operand (
    5:  6: . . . . . . . . . . . ArrayType (
    5:  6: . . . . . . . . . . . . "["
    5:  7: . . . . . . . . . . . . Expression (
    5:  7: . . . . . . . . . . . . . BinaryExpr (
    5:  7: . . . . . . . . . . . . . . UnaryExpr (
    5:  7: . . . . . . . . . . . . . . . PrimaryExpr (
    5:  7: . . . . . . . . . . . . . . . . Operand (
    5:  7: . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    5:  8: . . . . . . . . . . . . . . . . )
    5:  8: . . . . . . . . . . . . . . . )
    5:  8: . . . . . . . . . . . . . . )
    5:  8: . . . . . . . . . . . . . )
    5:  8: . . . . . . . . . . . . )
    5:  8: . . . . . . . . . . . . "]"
 /app/parser/parser.go:902: ast.SliceLit{Elts: [0xc00042e9f0]}
    5:  9: . . . . . . . . . . . )
    5:  9: . . . . . . . . . . )
    5:  9: . . . . . . . . . )
    5:  9: . . . . . . . . )
    5:  9: . . . . . . . )
    5:  9: . . . . . . )
    5:  9: . . . . . )
    5:  9: . . . . )
    5:  9: . . . . ";"
    6:  1: . . . )
    6:  1: . . . Statement (
    6:  1: . . . . SimpleStmt (
    6:  1: . . . . . ExpressionList (
    6:  1: . . . . . . Expression (
    6:  1: . . . . . . . BinaryExpr (
    6:  1: . . . . . . . . UnaryExpr (
    6:  1: . . . . . . . . . PrimaryExpr (
    6:  1: . . . . . . . . . . Operand (
    6:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    6:  8: . . . . . . . . . . )
    6:  8: . . . . . . . . . . CallOrConversion (
    6:  8: . . . . . . . . . . . "("
    6:  9: . . . . . . . . . . . Expression (
    6:  9: . . . . . . . . . . . . BinaryExpr (
    6:  9: . . . . . . . . . . . . . UnaryExpr (
    6:  9: . . . . . . . . . . . . . . PrimaryExpr (
    6:  9: . . . . . . . . . . . . . . . Operand (
    6:  9: . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    6: 10: . . . . . . . . . . . . . . . )
    6: 10: . . . . . . . . . . . . . . . IndexOrSlice (
    6: 10: . . . . . . . . . . . . . . . . "["
    6: 11: . . . . . . . . . . . . . . . . Expression (
    6: 11: . . . . . . . . . . . . . . . . . BinaryExpr (
    6: 11: . . . . . . . . . . . . . . . . . . UnaryExpr (
    6: 11: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 11: . . . . . . . . . . . . . . . . . . . . Operand (
    6: 11: . . . . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    6: 12: . . . . . . . . . . . . . . . . . . . . )
    6: 12: . . . . . . . . . . . . . . . . . . . )
    6: 12: . . . . . . . . . . . . . . . . . . )
    6: 12: . . . . . . . . . . . . . . . . . )
    6: 12: . . . . . . . . . . . . . . . . )
    6: 12: . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: a, Index: &{78 INT 0 <nil>}}
    6: 13: . . . . . . . . . . . . . . . )
    6: 13: . . . . . . . . . . . . . . )
    6: 13: . . . . . . . . . . . . . )
    6: 13: . . . . . . . . . . . . )
    6: 13: . . . . . . . . . . . )
    6: 13: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    6: 14: . . . . . . . . . . )
    6: 14: . . . . . . . . . )
    6: 14: . . . . . . . . )
    6: 14: . . . . . . . )
    6: 14: . . . . . . )
    6: 14: . . . . . )
    6: 14: . . . . )
    6: 14: . . . . ";"
    6: 15: . . . )
    6: 15: . . )
    6: 15: . )
    6: 15: )
=== RUN   TestFromTestdata/slice2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/slice2
    1:  1: File (
    1:  1: . "package"
    1:  9: . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    1: 13: . ";"
    3:  1: . Declaration (
    3:  1: . . FunctionDeclOrCall (
    3:  1: . . . "func"
    3:  6: . . . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    3: 10: . . . Signature (
    3: 10: . . . . Parameters (
    3: 10: . . . . . "("
    3: 11: . . . . . ")"
    3: 13: . . . . )
    3: 13: . . . . Result (
    3: 13: . . . . )
    3: 13: . . . )
    3: 13: . . . Body (
    3: 13: . . . . "{"
    4:  2: . . . . StatementList (
    4:  2: . . . . . Statement (
    4:  2: . . . . . . SimpleStmt (
    4:  2: . . . . . . . ExpressionList (
    4:  2: . . . . . . . . Expression (
    4:  2: . . . . . . . . . BinaryExpr (
    4:  2: . . . . . . . . . . UnaryExpr (
    4:  2: . . . . . . . . . . . PrimaryExpr (
    4:  2: . . . . . . . . . . . . Operand (
    4:  2: . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    4:  4: . . . . . . . . . . . . )
    4:  4: . . . . . . . . . . . )
    4:  4: . . . . . . . . . . )
    4:  4: . . . . . . . . . )
    4:  4: . . . . . . . . )
    4:  4: . . . . . . . )
    4:  4: . . . . . . . ":="
    4:  7: . . . . . . . ExpressionList (
    4:  7: . . . . . . . . Expression (
    4:  7: . . . . . . . . . BinaryExpr (
    4:  7: . . . . . . . . . . UnaryExpr (
    4:  7: . . . . . . . . . . . PrimaryExpr (
    4:  7: . . . . . . . . . . . . Operand (
    4:  7: . . . . . . . . . . . . . ArrayType (
    4:  7: . . . . . . . . . . . . . . "["
    5:  3: . . . . . . . . . . . . . . Expression (
    5:  3: . . . . . . . . . . . . . . . BinaryExpr (
    5:  3: . . . . . . . . . . . . . . . . UnaryExpr (
    5:  3: . . . . . . . . . . . . . . . . . PrimaryExpr (
    5:  3: . . . . . . . . . . . . . . . . . . Operand (
    5:  3: . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    5:  4: . . . . . . . . . . . . . . . . . . )
    5:  4: . . . . . . . . . . . . . . . . . )
    5:  4: . . . . . . . . . . . . . . . . )
    5:  4: . . . . . . . . . . . . . . . )
    5:  4: . . . . . . . . . . . . . . )
    5:  4: . . . . . . . . . . . . . . ","
    6:  3: . . . . . . . . . . . . . . Expression (
    6:  3: . . . . . . . . . . . . . . . BinaryExpr (
    6:  3: . . . . . . . . . . . . . . . . UnaryExpr (
    6:  3: . . . . . . . . . . . . . . . . . PrimaryExpr (
    6:  3: . . . . . . . . . . . . . . . . . . Operand (
    6:  3: . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    6:  4: . . . . . . . . . . . . . . . . . . )
    6:  4: . . . . . . . . . . . . . . . . . )
    6:  4: . . . . . . . . . . . . . . . . )
    6:  4: . . . . . . . . . . . . . . . )
    6:  4: . . . . . . . . . . . . . . )
    6:  4: . . . . . . . . . . . . . . ","
    7:  3: . . . . . . . . . . . . . . Expression (
    7:  3: . . . . . . . . . . . . . . . BinaryExpr (
    7:  3: . . . . . . . . . . . . . . . . UnaryExpr (
    7:  3: . . . . . . . . . . . . . . . . . PrimaryExpr (
    7:  3: . . . . . . . . . . . . . . . . . . Operand (
    7:  3: . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    7:  4: . . . . . . . . . . . . . . . . . . )
    7:  4: . . . . . . . . . . . . . . . . . )
    7:  4: . . . . . . . . . . . . . . . . )
    7:  4: . . . . . . . . . . . . . . . )
    7:  4: . . . . . . . . . . . . . . )
    7:  4: . . . . . . . . . . . . . . ","
    8:  2: . . . . . . . . . . . . . . "]"
    8:  3: . . . . . . . . . . . . . )
    8:  3: . . . . . . . . . . . . )
    8:  3: . . . . . . . . . . . )
    8:  3: . . . . . . . . . . )
    8:  3: . . . . . . . . . )
    8:  3: . . . . . . . . )
    8:  3: . . . . . . . )
    8:  3: . . . . . . )
    8:  3: . . . . . . ";"
    9:  2: . . . . . )
    9:  2: . . . . . Statement (
    9:  2: . . . . . . SimpleStmt (
    9:  2: . . . . . . . ExpressionList (
    9:  2: . . . . . . . . Expression (
    9:  2: . . . . . . . . . BinaryExpr (
    9:  2: . . . . . . . . . . UnaryExpr (
    9:  2: . . . . . . . . . . . PrimaryExpr (
    9:  2: . . . . . . . . . . . . Operand (
    9:  2: . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    9:  9: . . . . . . . . . . . . )
    9:  9: . . . . . . . . . . . . CallOrConversion (
    9:  9: . . . . . . . . . . . . . "("
    9: 10: . . . . . . . . . . . . . Expression (
    9: 10: . . . . . . . . . . . . . . BinaryExpr (
    9: 10: . . . . . . . . . . . . . . . UnaryExpr (
    9: 10: . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 10: . . . . . . . . . . . . . . . . . Operand (
    9: 10: . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    9: 11: . . . . . . . . . . . . . . . . . )
    9: 11: . . . . . . . . . . . . . . . . )
    9: 11: . . . . . . . . . . . . . . . )
    9: 11: . . . . . . . . . . . . . . )
    9: 11: . . . . . . . . . . . . . )
    9: 11: . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    9: 12: . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . )
    9: 12: . . . . . . . . . . )
    9: 12: . . . . . . . . . )
    9: 12: . . . . . . . . )
    9: 12: . . . . . . . )
    9: 12: . . . . . . )
    9: 12: . . . . . . ";"
   10:  1: . . . . . )
   10:  1: . . . . )
   10:  1: . . . . "}"
   10:  2: . . . )
   10:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: main, ...}
   10:  3: . . )
   10:  3: . )
   10:  3: )
=== RUN   TestFromTestdata/spxtest
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/spxtest
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  7: . . . . . . . . . . )
    1:  7: . . . . . . . . . )
    1:  7: . . . . . . . . )
    1:  7: . . . . . . . )
    1:  7: . . . . . . )
    1:  7: . . . . . )
    1:  7: . . . . )
    1:  7: . . . . ";"
    1:  8: . . . )
    1:  8: . . )
    1:  8: . )
    1:  8: )
=== RUN   TestFromTestdata/staticmthd1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/staticmthd1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  6: . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
    1:  7: . . . "."
    1:  8: . . . IDENT foo
 /app/parser/parser.go:713: ast.Ident{Name: foo}
    1: 11: . . . Signature (
    1: 11: . . . . Parameters (
    1: 11: . . . . . "("
    1: 12: . . . . . ParameterList (
    1: 12: . . . . . . ParamDeclOrNil (
    1: 12: . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1: 13: . . . . . . )
    1: 13: . . . . . . ","
    1: 15: . . . . . . ParamDeclOrNil (
    1: 15: . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
    1: 17: . . . . . . . Type (
    1: 17: . . . . . . . . TypeName (
    1: 17: . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    1: 20: . . . . . . . . )
    1: 20: . . . . . . . )
    1: 20: . . . . . . )
    1: 20: . . . . . )
    1: 20: . . . . . ")"
    1: 22: . . . . )
    1: 22: . . . . Result (
    1: 22: . . . . . TypeName (
    1: 22: . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    1: 29: . . . . . )
    1: 29: . . . . )
    1: 29: . . . )
    1: 29: . . . Body (
    1: 29: . . . . "{"
    2:  1: . . . . StatementList (
    2:  1: . . . . )
    2:  1: . . . . "}"
    2:  2: . . . )
    2:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: foo, ...}
    2:  3: . . )
    2:  3: . )
    2:  3: )
=== RUN   TestFromTestdata/staticmthd2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/staticmthd2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  6: . . . "."
    1:  7: . . . IDENT New
 /app/parser/parser.go:713: ast.Ident{Name: New}
    1: 10: . . . Signature (
    1: 10: . . . . Parameters (
    1: 10: . . . . . "("
    1: 11: . . . . . ")"
    1: 13: . . . . )
    1: 13: . . . . Result (
    1: 13: . . . . . PointerType (
    1: 13: . . . . . . "*"
    1: 14: . . . . . . Type (
    1: 14: . . . . . . . TypeName (
    1: 14: . . . . . . . . IDENT T
 /app/parser/parser.go:713: ast.Ident{Name: T}
    1: 16: . . . . . . . )
    1: 16: . . . . . . )
    1: 16: . . . . . )
    1: 16: . . . . )
    1: 16: . . . )
    1: 16: . . . Body (
    1: 16: . . . . "{"
    2:  1: . . . . StatementList (
    2:  1: . . . . )
    2:  1: . . . . "}"
    2:  2: . . . )
    2:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: New, ...}
    2:  3: . . )
    2:  3: . )
    2:  3: )
=== RUN   TestFromTestdata/stdtype
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/stdtype
    1:  1: File (
    1:  1: . "package"
    1:  9: . IDENT bar
 /app/parser/parser.go:713: ast.Ident{Name: bar}
    1: 12: . ";"
    3:  1: . GenDecl(import) (
    3:  1: . . "import"
    3:  8: . . ImportSpec (
    3:  8: . . . STRING "io"
    3: 12: . . . ";"
    5:  1: . . )
    5:  1: . )
    5:  1: . Declaration (
    5:  1: . . StatementList (
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    5:  3: . . . . . . . . . . )
    5:  3: . . . . . . . . . )
    5:  3: . . . . . . . . )
    5:  3: . . . . . . . )
    5:  3: . . . . . . )
    5:  3: . . . . . )
    5:  3: . . . . . ":="
    5:  6: . . . . . ExpressionList (
    5:  6: . . . . . . Expression (
    5:  6: . . . . . . . BinaryExpr (
    5:  6: . . . . . . . . UnaryExpr (
    5:  6: . . . . . . . . . PrimaryExpr (
    5:  6: . . . . . . . . . . Operand (
    5:  6: . . . . . . . . . . . ArrayType (
    5:  6: . . . . . . . . . . . . "["
    5:  7: . . . . . . . . . . . . "]"
    5:  8: . . . . . . . . . . . . TypeName (
    5:  8: . . . . . . . . . . . . . IDENT float64
 /app/parser/parser.go:713: ast.Ident{Name: float64}
    5: 15: . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: float64}
    5: 15: . . . . . . . . . . . )
    5: 15: . . . . . . . . . . )
    5: 15: . . . . . . . . . . LiteralValue (
    5: 15: . . . . . . . . . . . "{"
    5: 16: . . . . . . . . . . . ElementList (
    5: 16: . . . . . . . . . . . . Element (
    5: 16: . . . . . . . . . . . . . Element (
    5: 16: . . . . . . . . . . . . . . Expression (
    5: 16: . . . . . . . . . . . . . . . BinaryExpr (
    5: 16: . . . . . . . . . . . . . . . . UnaryExpr (
    5: 16: . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 16: . . . . . . . . . . . . . . . . . . Operand (
    5: 16: . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    5: 17: . . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . ","
    5: 19: . . . . . . . . . . . . Element (
    5: 19: . . . . . . . . . . . . . Element (
    5: 19: . . . . . . . . . . . . . . Expression (
    5: 19: . . . . . . . . . . . . . . . BinaryExpr (
    5: 19: . . . . . . . . . . . . . . . . UnaryExpr (
    5: 19: . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 19: . . . . . . . . . . . . . . . . . . Operand (
    5: 19: . . . . . . . . . . . . . . . . . . . FLOAT 3.4
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 3.4}
    5: 22: . . . . . . . . . . . . . . . . . . )
    5: 22: . . . . . . . . . . . . . . . . . )
    5: 22: . . . . . . . . . . . . . . . . )
    5: 22: . . . . . . . . . . . . . . . )
    5: 22: . . . . . . . . . . . . . . )
    5: 22: . . . . . . . . . . . . . )
    5: 22: . . . . . . . . . . . . )
    5: 22: . . . . . . . . . . . . ","
    5: 24: . . . . . . . . . . . . Element (
    5: 24: . . . . . . . . . . . . . Element (
    5: 24: . . . . . . . . . . . . . . Expression (
    5: 24: . . . . . . . . . . . . . . . BinaryExpr (
    5: 24: . . . . . . . . . . . . . . . . UnaryExpr (
    5: 24: . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 24: . . . . . . . . . . . . . . . . . . Operand (
    5: 24: . . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    5: 25: . . . . . . . . . . . . . . . . . . )
    5: 25: . . . . . . . . . . . . . . . . . )
    5: 25: . . . . . . . . . . . . . . . . )
    5: 25: . . . . . . . . . . . . . . . )
    5: 25: . . . . . . . . . . . . . . )
    5: 25: . . . . . . . . . . . . . )
    5: 25: . . . . . . . . . . . . )
    5: 25: . . . . . . . . . . . )
    5: 25: . . . . . . . . . . . "}"
    5: 26: . . . . . . . . . . )
    5: 26: . . . . . . . . . )
    5: 26: . . . . . . . . )
    5: 26: . . . . . . . )
    5: 26: . . . . . . )
    5: 26: . . . . . )
    5: 26: . . . . )
    5: 26: . . . . ";"
    6:  1: . . . )
    6:  1: . . . Statement (
    6:  1: . . . . SimpleStmt (
    6:  1: . . . . . ExpressionList (
    6:  1: . . . . . . Expression (
    6:  1: . . . . . . . BinaryExpr (
    6:  1: . . . . . . . . UnaryExpr (
    6:  1: . . . . . . . . . PrimaryExpr (
    6:  1: . . . . . . . . . . Operand (
    6:  1: . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    6:  3: . . . . . . . . . . )
    6:  3: . . . . . . . . . )
    6:  3: . . . . . . . . )
    6:  3: . . . . . . . )
    6:  3: . . . . . . )
    6:  3: . . . . . )
    6:  3: . . . . . ":="
    6:  6: . . . . . ExpressionList (
    6:  6: . . . . . . Expression (
    6:  6: . . . . . . . BinaryExpr (
    6:  6: . . . . . . . . UnaryExpr (
    6:  6: . . . . . . . . . PrimaryExpr (
    6:  6: . . . . . . . . . . Operand (
    6:  6: . . . . . . . . . . . "map"
    6:  6: . . . . . . . . . . . MapType (
    6:  9: . . . . . . . . . . . . "["
    6: 10: . . . . . . . . . . . . Type (
    6: 10: . . . . . . . . . . . . . TypeName (
    6: 10: . . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    6: 16: . . . . . . . . . . . . . )
    6: 16: . . . . . . . . . . . . )
    6: 16: . . . . . . . . . . . . "]"
    6: 17: . . . . . . . . . . . . Type (
    6: 17: . . . . . . . . . . . . . TypeName (
    6: 17: . . . . . . . . . . . . . . IDENT float64
 /app/parser/parser.go:713: ast.Ident{Name: float64}
    6: 24: . . . . . . . . . . . . . )
    6: 24: . . . . . . . . . . . . )
 /app/parser/parser.go:1455: ast.MapType{Key: string, Value: float64}
    6: 24: . . . . . . . . . . . )
    6: 24: . . . . . . . . . . )
    6: 24: . . . . . . . . . . LiteralValue (
    6: 24: . . . . . . . . . . . "{"
    6: 25: . . . . . . . . . . . ElementList (
    6: 25: . . . . . . . . . . . . Element (
    6: 25: . . . . . . . . . . . . . Element (
    6: 25: . . . . . . . . . . . . . . Expression (
    6: 25: . . . . . . . . . . . . . . . BinaryExpr (
    6: 25: . . . . . . . . . . . . . . . . UnaryExpr (
    6: 25: . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 25: . . . . . . . . . . . . . . . . . . Operand (
    6: 25: . . . . . . . . . . . . . . . . . . . STRING "Hello"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hello"}
    6: 32: . . . . . . . . . . . . . . . . . . )
    6: 32: . . . . . . . . . . . . . . . . . )
    6: 32: . . . . . . . . . . . . . . . . )
    6: 32: . . . . . . . . . . . . . . . )
    6: 32: . . . . . . . . . . . . . . )
    6: 32: . . . . . . . . . . . . . )
    6: 32: . . . . . . . . . . . . . ":"
    6: 34: . . . . . . . . . . . . . Element (
    6: 34: . . . . . . . . . . . . . . Expression (
    6: 34: . . . . . . . . . . . . . . . BinaryExpr (
    6: 34: . . . . . . . . . . . . . . . . UnaryExpr (
    6: 34: . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 34: . . . . . . . . . . . . . . . . . . Operand (
    6: 34: . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    6: 35: . . . . . . . . . . . . . . . . . . )
    6: 35: . . . . . . . . . . . . . . . . . )
    6: 35: . . . . . . . . . . . . . . . . )
    6: 35: . . . . . . . . . . . . . . . )
    6: 35: . . . . . . . . . . . . . . )
    6: 35: . . . . . . . . . . . . . )
    6: 35: . . . . . . . . . . . . )
    6: 35: . . . . . . . . . . . . ","
    6: 37: . . . . . . . . . . . . Element (
    6: 37: . . . . . . . . . . . . . Element (
    6: 37: . . . . . . . . . . . . . . Expression (
    6: 37: . . . . . . . . . . . . . . . BinaryExpr (
    6: 37: . . . . . . . . . . . . . . . . UnaryExpr (
    6: 37: . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 37: . . . . . . . . . . . . . . . . . . Operand (
    6: 37: . . . . . . . . . . . . . . . . . . . STRING "xsw"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "xsw"}
    6: 42: . . . . . . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . )
    6: 42: . . . . . . . . . . . . . ":"
    6: 44: . . . . . . . . . . . . . Element (
    6: 44: . . . . . . . . . . . . . . Expression (
    6: 44: . . . . . . . . . . . . . . . BinaryExpr (
    6: 44: . . . . . . . . . . . . . . . . UnaryExpr (
    6: 44: . . . . . . . . . . . . . . . . . PrimaryExpr (
    6: 44: . . . . . . . . . . . . . . . . . . Operand (
    6: 44: . . . . . . . . . . . . . . . . . . . FLOAT 3.4
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 3.4}
    6: 47: . . . . . . . . . . . . . . . . . . )
    6: 47: . . . . . . . . . . . . . . . . . )
    6: 47: . . . . . . . . . . . . . . . . )
    6: 47: . . . . . . . . . . . . . . . )
    6: 47: . . . . . . . . . . . . . . )
    6: 47: . . . . . . . . . . . . . )
    6: 47: . . . . . . . . . . . . )
    6: 47: . . . . . . . . . . . )
    6: 47: . . . . . . . . . . . "}"
    6: 48: . . . . . . . . . . )
    6: 48: . . . . . . . . . )
    6: 48: . . . . . . . . )
    6: 48: . . . . . . . )
    6: 48: . . . . . . )
    6: 48: . . . . . )
    6: 48: . . . . )
    6: 48: . . . . ";"
    7:  1: . . . )
    7:  1: . . . Statement (
    7:  1: . . . . SimpleStmt (
    7:  1: . . . . . ExpressionList (
    7:  1: . . . . . . Expression (
    7:  1: . . . . . . . BinaryExpr (
    7:  1: . . . . . . . . UnaryExpr (
    7:  1: . . . . . . . . . PrimaryExpr (
    7:  1: . . . . . . . . . . Operand (
    7:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    7:  8: . . . . . . . . . . )
    7:  8: . . . . . . . . . . CallOrConversion (
    7:  8: . . . . . . . . . . . "("
    7:  9: . . . . . . . . . . . Expression (
    7:  9: . . . . . . . . . . . . BinaryExpr (
    7:  9: . . . . . . . . . . . . . UnaryExpr (
    7:  9: . . . . . . . . . . . . . . PrimaryExpr (
    7:  9: . . . . . . . . . . . . . . . Operand (
    7:  9: . . . . . . . . . . . . . . . . STRING "x:"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "x:"}
    7: 13: . . . . . . . . . . . . . . . )
    7: 13: . . . . . . . . . . . . . . )
    7: 13: . . . . . . . . . . . . . )
    7: 13: . . . . . . . . . . . . )
    7: 13: . . . . . . . . . . . )
    7: 13: . . . . . . . . . . . ","
    7: 15: . . . . . . . . . . . Expression (
    7: 15: . . . . . . . . . . . . BinaryExpr (
    7: 15: . . . . . . . . . . . . . UnaryExpr (
    7: 15: . . . . . . . . . . . . . . PrimaryExpr (
    7: 15: . . . . . . . . . . . . . . . Operand (
    7: 15: . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    7: 16: . . . . . . . . . . . . . . . )
    7: 16: . . . . . . . . . . . . . . )
    7: 16: . . . . . . . . . . . . . )
    7: 16: . . . . . . . . . . . . )
    7: 16: . . . . . . . . . . . )
    7: 16: . . . . . . . . . . . ","
    7: 18: . . . . . . . . . . . Expression (
    7: 18: . . . . . . . . . . . . BinaryExpr (
    7: 18: . . . . . . . . . . . . . UnaryExpr (
    7: 18: . . . . . . . . . . . . . . PrimaryExpr (
    7: 18: . . . . . . . . . . . . . . . Operand (
    7: 18: . . . . . . . . . . . . . . . . STRING "y:"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "y:"}
    7: 22: . . . . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . )
    7: 22: . . . . . . . . . . . ","
    7: 24: . . . . . . . . . . . Expression (
    7: 24: . . . . . . . . . . . . BinaryExpr (
    7: 24: . . . . . . . . . . . . . UnaryExpr (
    7: 24: . . . . . . . . . . . . . . PrimaryExpr (
    7: 24: . . . . . . . . . . . . . . . Operand (
    7: 24: . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    7: 25: . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    7: 26: . . . . . . . . . . )
    7: 26: . . . . . . . . . )
    7: 26: . . . . . . . . )
    7: 26: . . . . . . . )
    7: 26: . . . . . . )
    7: 26: . . . . . )
    7: 26: . . . . )
    7: 26: . . . . ";"
    9:  1: . . . )
    9:  1: . . . Statement (
    9:  1: . . . . SimpleStmt (
    9:  1: . . . . . ExpressionList (
    9:  1: . . . . . . Expression (
    9:  1: . . . . . . . BinaryExpr (
    9:  1: . . . . . . . . UnaryExpr (
    9:  1: . . . . . . . . . PrimaryExpr (
    9:  1: . . . . . . . . . . Operand (
    9:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    9:  3: . . . . . . . . . . )
    9:  3: . . . . . . . . . )
    9:  3: . . . . . . . . )
    9:  3: . . . . . . . )
    9:  3: . . . . . . )
    9:  3: . . . . . )
    9:  3: . . . . . ":="
    9:  6: . . . . . ExpressionList (
    9:  6: . . . . . . Expression (
    9:  6: . . . . . . . BinaryExpr (
    9:  6: . . . . . . . . UnaryExpr (
    9:  6: . . . . . . . . . PrimaryExpr (
    9:  6: . . . . . . . . . . Operand (
    9:  6: . . . . . . . . . . . ArrayType (
    9:  6: . . . . . . . . . . . . "["
    9:  7: . . . . . . . . . . . . "..."
    9: 10: . . . . . . . . . . . . "]"
    9: 11: . . . . . . . . . . . . TypeName (
    9: 11: . . . . . . . . . . . . . IDENT float64
 /app/parser/parser.go:713: ast.Ident{Name: float64}
    9: 18: . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: &{134 <nil>}, Elt: float64}
    9: 18: . . . . . . . . . . . )
    9: 18: . . . . . . . . . . )
    9: 18: . . . . . . . . . . LiteralValue (
    9: 18: . . . . . . . . . . . "{"
    9: 19: . . . . . . . . . . . ElementList (
    9: 19: . . . . . . . . . . . . Element (
    9: 19: . . . . . . . . . . . . . Element (
    9: 19: . . . . . . . . . . . . . . Expression (
    9: 19: . . . . . . . . . . . . . . . BinaryExpr (
    9: 19: . . . . . . . . . . . . . . . . UnaryExpr (
    9: 19: . . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 19: . . . . . . . . . . . . . . . . . . Operand (
    9: 19: . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    9: 20: . . . . . . . . . . . . . . . . . . )
    9: 20: . . . . . . . . . . . . . . . . . )
    9: 20: . . . . . . . . . . . . . . . . )
    9: 20: . . . . . . . . . . . . . . . )
    9: 20: . . . . . . . . . . . . . . )
    9: 20: . . . . . . . . . . . . . )
    9: 20: . . . . . . . . . . . . )
    9: 20: . . . . . . . . . . . . ","
    9: 22: . . . . . . . . . . . . Element (
    9: 22: . . . . . . . . . . . . . Element (
    9: 22: . . . . . . . . . . . . . . Expression (
    9: 22: . . . . . . . . . . . . . . . BinaryExpr (
    9: 22: . . . . . . . . . . . . . . . . UnaryExpr (
    9: 22: . . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 22: . . . . . . . . . . . . . . . . . . Operand (
    9: 22: . . . . . . . . . . . . . . . . . . . FLOAT 3.4
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 3.4}
    9: 25: . . . . . . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . )
    9: 25: . . . . . . . . . . . . ","
    9: 27: . . . . . . . . . . . . Element (
    9: 27: . . . . . . . . . . . . . Element (
    9: 27: . . . . . . . . . . . . . . Expression (
    9: 27: . . . . . . . . . . . . . . . BinaryExpr (
    9: 27: . . . . . . . . . . . . . . . . UnaryExpr (
    9: 27: . . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 27: . . . . . . . . . . . . . . . . . . Operand (
    9: 27: . . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    9: 28: . . . . . . . . . . . . . . . . . . )
    9: 28: . . . . . . . . . . . . . . . . . )
    9: 28: . . . . . . . . . . . . . . . . )
    9: 28: . . . . . . . . . . . . . . . )
    9: 28: . . . . . . . . . . . . . . )
    9: 28: . . . . . . . . . . . . . )
    9: 28: . . . . . . . . . . . . )
    9: 28: . . . . . . . . . . . )
    9: 28: . . . . . . . . . . . "}"
    9: 29: . . . . . . . . . . )
    9: 29: . . . . . . . . . )
    9: 29: . . . . . . . . )
    9: 29: . . . . . . . )
    9: 29: . . . . . . )
    9: 29: . . . . . )
    9: 29: . . . . )
    9: 29: . . . . ";"
   10:  1: . . . )
   10:  1: . . . Statement (
   10:  1: . . . . SimpleStmt (
   10:  1: . . . . . ExpressionList (
   10:  1: . . . . . . Expression (
   10:  1: . . . . . . . BinaryExpr (
   10:  1: . . . . . . . . UnaryExpr (
   10:  1: . . . . . . . . . PrimaryExpr (
   10:  1: . . . . . . . . . . Operand (
   10:  1: . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   10:  3: . . . . . . . . . . )
   10:  3: . . . . . . . . . )
   10:  3: . . . . . . . . )
   10:  3: . . . . . . . )
   10:  3: . . . . . . )
   10:  3: . . . . . )
   10:  3: . . . . . ":="
   10:  6: . . . . . ExpressionList (
   10:  6: . . . . . . Expression (
   10:  6: . . . . . . . BinaryExpr (
   10:  6: . . . . . . . . UnaryExpr (
   10:  6: . . . . . . . . . PrimaryExpr (
   10:  6: . . . . . . . . . . Operand (
   10:  6: . . . . . . . . . . . ArrayType (
   10:  6: . . . . . . . . . . . . "["
   10:  7: . . . . . . . . . . . . "..."
   10: 10: . . . . . . . . . . . . "]"
   10: 11: . . . . . . . . . . . . TypeName (
   10: 11: . . . . . . . . . . . . . IDENT float64
 /app/parser/parser.go:713: ast.Ident{Name: float64}
   10: 18: . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: &{163 <nil>}, Elt: float64}
   10: 18: . . . . . . . . . . . )
   10: 18: . . . . . . . . . . )
   10: 18: . . . . . . . . . . LiteralValue (
   10: 18: . . . . . . . . . . . "{"
   10: 19: . . . . . . . . . . . ElementList (
   10: 19: . . . . . . . . . . . . Element (
   10: 19: . . . . . . . . . . . . . Element (
   10: 19: . . . . . . . . . . . . . . Expression (
   10: 19: . . . . . . . . . . . . . . . BinaryExpr (
   10: 19: . . . . . . . . . . . . . . . . UnaryExpr (
   10: 19: . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 19: . . . . . . . . . . . . . . . . . . Operand (
   10: 19: . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   10: 20: . . . . . . . . . . . . . . . . . . )
   10: 20: . . . . . . . . . . . . . . . . . )
   10: 20: . . . . . . . . . . . . . . . . )
   10: 20: . . . . . . . . . . . . . . . )
   10: 20: . . . . . . . . . . . . . . )
   10: 20: . . . . . . . . . . . . . )
   10: 20: . . . . . . . . . . . . )
   10: 20: . . . . . . . . . . . . ","
   10: 22: . . . . . . . . . . . . Element (
   10: 22: . . . . . . . . . . . . . Element (
   10: 22: . . . . . . . . . . . . . . Expression (
   10: 22: . . . . . . . . . . . . . . . BinaryExpr (
   10: 22: . . . . . . . . . . . . . . . . UnaryExpr (
   10: 22: . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 22: . . . . . . . . . . . . . . . . . . Operand (
   10: 22: . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
   10: 23: . . . . . . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . )
   10: 23: . . . . . . . . . . . . . ":"
   10: 25: . . . . . . . . . . . . . Element (
   10: 25: . . . . . . . . . . . . . . Expression (
   10: 25: . . . . . . . . . . . . . . . BinaryExpr (
   10: 25: . . . . . . . . . . . . . . . . UnaryExpr (
   10: 25: . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 25: . . . . . . . . . . . . . . . . . . Operand (
   10: 25: . . . . . . . . . . . . . . . . . . . FLOAT 3.4
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 3.4}
   10: 28: . . . . . . . . . . . . . . . . . . )
   10: 28: . . . . . . . . . . . . . . . . . )
   10: 28: . . . . . . . . . . . . . . . . )
   10: 28: . . . . . . . . . . . . . . . )
   10: 28: . . . . . . . . . . . . . . )
   10: 28: . . . . . . . . . . . . . )
   10: 28: . . . . . . . . . . . . )
   10: 28: . . . . . . . . . . . . ","
   10: 30: . . . . . . . . . . . . Element (
   10: 30: . . . . . . . . . . . . . Element (
   10: 30: . . . . . . . . . . . . . . Expression (
   10: 30: . . . . . . . . . . . . . . . BinaryExpr (
   10: 30: . . . . . . . . . . . . . . . . UnaryExpr (
   10: 30: . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 30: . . . . . . . . . . . . . . . . . . Operand (
   10: 30: . . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
   10: 31: . . . . . . . . . . . . . . . . . . )
   10: 31: . . . . . . . . . . . . . . . . . )
   10: 31: . . . . . . . . . . . . . . . . )
   10: 31: . . . . . . . . . . . . . . . )
   10: 31: . . . . . . . . . . . . . . )
   10: 31: . . . . . . . . . . . . . )
   10: 31: . . . . . . . . . . . . )
   10: 31: . . . . . . . . . . . )
   10: 31: . . . . . . . . . . . "}"
   10: 32: . . . . . . . . . . )
   10: 32: . . . . . . . . . )
   10: 32: . . . . . . . . )
   10: 32: . . . . . . . )
   10: 32: . . . . . . )
   10: 32: . . . . . )
   10: 32: . . . . )
   10: 32: . . . . ";"
   11:  1: . . . )
   11:  1: . . . Statement (
   11:  1: . . . . SimpleStmt (
   11:  1: . . . . . ExpressionList (
   11:  1: . . . . . . Expression (
   11:  1: . . . . . . . BinaryExpr (
   11:  1: . . . . . . . . UnaryExpr (
   11:  1: . . . . . . . . . PrimaryExpr (
   11:  1: . . . . . . . . . . Operand (
   11:  1: . . . . . . . . . . . IDENT c
 /app/parser/parser.go:713: ast.Ident{Name: c}
   11:  3: . . . . . . . . . . )
   11:  3: . . . . . . . . . )
   11:  3: . . . . . . . . )
   11:  3: . . . . . . . )
   11:  3: . . . . . . )
   11:  3: . . . . . )
   11:  3: . . . . . ":="
   11:  6: . . . . . ExpressionList (
   11:  6: . . . . . . Expression (
   11:  6: . . . . . . . BinaryExpr (
   11:  6: . . . . . . . . UnaryExpr (
   11:  6: . . . . . . . . . PrimaryExpr (
   11:  6: . . . . . . . . . . Operand (
   11:  6: . . . . . . . . . . . ArrayType (
   11:  6: . . . . . . . . . . . . "["
   11:  7: . . . . . . . . . . . . "]"
   11:  8: . . . . . . . . . . . . TypeName (
   11:  8: . . . . . . . . . . . . . IDENT float64
 /app/parser/parser.go:713: ast.Ident{Name: float64}
   11: 15: . . . . . . . . . . . . )
 /app/parser/parser.go:925: ast.ArrayType{Len: <nil>, Elt: float64}
   11: 15: . . . . . . . . . . . )
   11: 15: . . . . . . . . . . )
   11: 15: . . . . . . . . . . LiteralValue (
   11: 15: . . . . . . . . . . . "{"
   11: 16: . . . . . . . . . . . ElementList (
   11: 16: . . . . . . . . . . . . Element (
   11: 16: . . . . . . . . . . . . . Element (
   11: 16: . . . . . . . . . . . . . . Expression (
   11: 16: . . . . . . . . . . . . . . . BinaryExpr (
   11: 16: . . . . . . . . . . . . . . . . UnaryExpr (
   11: 16: . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 16: . . . . . . . . . . . . . . . . . . Operand (
   11: 16: . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   11: 17: . . . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . )
   11: 17: . . . . . . . . . . . . . ":"
   11: 19: . . . . . . . . . . . . . Element (
   11: 19: . . . . . . . . . . . . . . Expression (
   11: 19: . . . . . . . . . . . . . . . BinaryExpr (
   11: 19: . . . . . . . . . . . . . . . . UnaryExpr (
   11: 19: . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 19: . . . . . . . . . . . . . . . . . . Operand (
   11: 19: . . . . . . . . . . . . . . . . . . . FLOAT 1.2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 1.2}
   11: 22: . . . . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . )
   11: 22: . . . . . . . . . . . . ","
   11: 24: . . . . . . . . . . . . Element (
   11: 24: . . . . . . . . . . . . . Element (
   11: 24: . . . . . . . . . . . . . . Expression (
   11: 24: . . . . . . . . . . . . . . . BinaryExpr (
   11: 24: . . . . . . . . . . . . . . . . UnaryExpr (
   11: 24: . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 24: . . . . . . . . . . . . . . . . . . Operand (
   11: 24: . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
   11: 25: . . . . . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . )
   11: 25: . . . . . . . . . . . . ","
   11: 27: . . . . . . . . . . . . Element (
   11: 27: . . . . . . . . . . . . . Element (
   11: 27: . . . . . . . . . . . . . . Expression (
   11: 27: . . . . . . . . . . . . . . . BinaryExpr (
   11: 27: . . . . . . . . . . . . . . . . UnaryExpr (
   11: 27: . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 27: . . . . . . . . . . . . . . . . . . Operand (
   11: 27: . . . . . . . . . . . . . . . . . . . INT 6
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 6}
   11: 28: . . . . . . . . . . . . . . . . . . )
   11: 28: . . . . . . . . . . . . . . . . . )
   11: 28: . . . . . . . . . . . . . . . . )
   11: 28: . . . . . . . . . . . . . . . )
   11: 28: . . . . . . . . . . . . . . )
   11: 28: . . . . . . . . . . . . . )
   11: 28: . . . . . . . . . . . . . ":"
   11: 30: . . . . . . . . . . . . . Element (
   11: 30: . . . . . . . . . . . . . . Expression (
   11: 30: . . . . . . . . . . . . . . . BinaryExpr (
   11: 30: . . . . . . . . . . . . . . . . UnaryExpr (
   11: 30: . . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 30: . . . . . . . . . . . . . . . . . . Operand (
   11: 30: . . . . . . . . . . . . . . . . . . . FLOAT 4.5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 4.5}
   11: 33: . . . . . . . . . . . . . . . . . . )
   11: 33: . . . . . . . . . . . . . . . . . )
   11: 33: . . . . . . . . . . . . . . . . )
   11: 33: . . . . . . . . . . . . . . . )
   11: 33: . . . . . . . . . . . . . . )
   11: 33: . . . . . . . . . . . . . )
   11: 33: . . . . . . . . . . . . )
   11: 33: . . . . . . . . . . . )
   11: 33: . . . . . . . . . . . "}"
   11: 34: . . . . . . . . . . )
   11: 34: . . . . . . . . . )
   11: 34: . . . . . . . . )
   11: 34: . . . . . . . )
   11: 34: . . . . . . )
   11: 34: . . . . . )
   11: 34: . . . . )
   11: 34: . . . . ";"
   12:  1: . . . )
   12:  1: . . . Statement (
   12:  1: . . . . SimpleStmt (
   12:  1: . . . . . ExpressionList (
   12:  1: . . . . . . Expression (
   12:  1: . . . . . . . BinaryExpr (
   12:  1: . . . . . . . . UnaryExpr (
   12:  1: . . . . . . . . . PrimaryExpr (
   12:  1: . . . . . . . . . . Operand (
   12:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   12:  8: . . . . . . . . . . )
   12:  8: . . . . . . . . . . CallOrConversion (
   12:  8: . . . . . . . . . . . "("
   12:  9: . . . . . . . . . . . Expression (
   12:  9: . . . . . . . . . . . . BinaryExpr (
   12:  9: . . . . . . . . . . . . . UnaryExpr (
   12:  9: . . . . . . . . . . . . . . PrimaryExpr (
   12:  9: . . . . . . . . . . . . . . . Operand (
   12:  9: . . . . . . . . . . . . . . . . STRING "a:"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a:"}
   12: 13: . . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . ","
   12: 15: . . . . . . . . . . . Expression (
   12: 15: . . . . . . . . . . . . BinaryExpr (
   12: 15: . . . . . . . . . . . . . UnaryExpr (
   12: 15: . . . . . . . . . . . . . . PrimaryExpr (
   12: 15: . . . . . . . . . . . . . . . Operand (
   12: 15: . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   12: 16: . . . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . ","
   12: 18: . . . . . . . . . . . Expression (
   12: 18: . . . . . . . . . . . . BinaryExpr (
   12: 18: . . . . . . . . . . . . . UnaryExpr (
   12: 18: . . . . . . . . . . . . . . PrimaryExpr (
   12: 18: . . . . . . . . . . . . . . . Operand (
   12: 18: . . . . . . . . . . . . . . . . STRING "b:"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "b:"}
   12: 22: . . . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . ","
   12: 24: . . . . . . . . . . . Expression (
   12: 24: . . . . . . . . . . . . BinaryExpr (
   12: 24: . . . . . . . . . . . . . UnaryExpr (
   12: 24: . . . . . . . . . . . . . . PrimaryExpr (
   12: 24: . . . . . . . . . . . . . . . Operand (
   12: 24: . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   12: 25: . . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . ","
   12: 27: . . . . . . . . . . . Expression (
   12: 27: . . . . . . . . . . . . BinaryExpr (
   12: 27: . . . . . . . . . . . . . UnaryExpr (
   12: 27: . . . . . . . . . . . . . . PrimaryExpr (
   12: 27: . . . . . . . . . . . . . . . Operand (
   12: 27: . . . . . . . . . . . . . . . . STRING "c:"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "c:"}
   12: 31: . . . . . . . . . . . . . . . )
   12: 31: . . . . . . . . . . . . . . )
   12: 31: . . . . . . . . . . . . . )
   12: 31: . . . . . . . . . . . . )
   12: 31: . . . . . . . . . . . )
   12: 31: . . . . . . . . . . . ","
   12: 33: . . . . . . . . . . . Expression (
   12: 33: . . . . . . . . . . . . BinaryExpr (
   12: 33: . . . . . . . . . . . . . UnaryExpr (
   12: 33: . . . . . . . . . . . . . . PrimaryExpr (
   12: 33: . . . . . . . . . . . . . . . Operand (
   12: 33: . . . . . . . . . . . . . . . . IDENT c
 /app/parser/parser.go:713: ast.Ident{Name: c}
   12: 34: . . . . . . . . . . . . . . . )
   12: 34: . . . . . . . . . . . . . . )
   12: 34: . . . . . . . . . . . . . )
   12: 34: . . . . . . . . . . . . )
   12: 34: . . . . . . . . . . . )
   12: 34: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   12: 35: . . . . . . . . . . )
   12: 35: . . . . . . . . . )
   12: 35: . . . . . . . . )
   12: 35: . . . . . . . )
   12: 35: . . . . . . )
   12: 35: . . . . . )
   12: 35: . . . . )
   12: 35: . . . . ";"
   12: 36: . . . )
   12: 36: . . )
   12: 36: . )
   12: 36: )
=== RUN   TestFromTestdata/stringex1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/stringex1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . . CallOrConversion (
    1:  9: . . . . . . . . . . . Expression (
    1:  9: . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . . . . . . . STRING "$"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "$"}
    1: 12: . . . . . . . . . . . . . . . )
    1: 12: . . . . . . . . . . . . . . )
    1: 12: . . . . . . . . . . . . . )
    1: 12: . . . . . . . . . . . . )
    1: 12: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    1: 12: . . . . . . . . . . )
    1: 12: . . . . . . . . . )
    1: 12: . . . . . . . . )
    1: 12: . . . . . . . )
    1: 12: . . . . . . )
    1: 12: . . . . . )
    1: 12: . . . . )
    1: 12: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  9: . . . . . . . . . . )
    2:  9: . . . . . . . . . . CallOrConversion (
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . STRING "$$"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "$$"}
    2: 13: . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    2: 13: . . . . . . . . . . )
    2: 13: . . . . . . . . . )
    2: 13: . . . . . . . . )
    2: 13: . . . . . . . )
    2: 13: . . . . . . )
    2: 13: . . . . . )
    2: 13: . . . . )
    2: 13: . . . . ";"
    3:  1: . . . )
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    3:  9: . . . . . . . . . . )
    3:  9: . . . . . . . . . . CallOrConversion (
    3:  9: . . . . . . . . . . . Expression (
    3:  9: . . . . . . . . . . . . BinaryExpr (
    3:  9: . . . . . . . . . . . . . UnaryExpr (
    3:  9: . . . . . . . . . . . . . . PrimaryExpr (
    3:  9: . . . . . . . . . . . . . . . Operand (
    3:  9: . . . . . . . . . . . . . . . . STRING "a$$b$"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a$$b$"}
    3: 16: . . . . . . . . . . . . . . . )
    3: 16: . . . . . . . . . . . . . . )
    3: 16: . . . . . . . . . . . . . )
    3: 16: . . . . . . . . . . . . )
    3: 16: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    3: 16: . . . . . . . . . . )
    3: 16: . . . . . . . . . )
    3: 16: . . . . . . . . )
    3: 16: . . . . . . . )
    3: 16: . . . . . . )
    3: 16: . . . . . )
    3: 16: . . . . )
    3: 16: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    4:  9: . . . . . . . . . . )
    4:  9: . . . . . . . . . . CallOrConversion (
    4:  9: . . . . . . . . . . . Expression (
    4:  9: . . . . . . . . . . . . BinaryExpr (
    4:  9: . . . . . . . . . . . . . UnaryExpr (
    4:  9: . . . . . . . . . . . . . . PrimaryExpr (
    4:  9: . . . . . . . . . . . . . . . Operand (
    4:  9: . . . . . . . . . . . . . . . . STRING "a$$b$$"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a$$b$$"}
    4: 17: . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    4: 17: . . . . . . . . . . )
    4: 17: . . . . . . . . . )
    4: 17: . . . . . . . . )
    4: 17: . . . . . . . )
    4: 17: . . . . . . )
    4: 17: . . . . . )
    4: 17: . . . . )
    4: 17: . . . . ";"
    5:  1: . . . )
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5:  9: . . . . . . . . . . )
    5:  9: . . . . . . . . . . CallOrConversion (
    5:  9: . . . . . . . . . . . Expression (
    5:  9: . . . . . . . . . . . . BinaryExpr (
    5:  9: . . . . . . . . . . . . . UnaryExpr (
    5:  9: . . . . . . . . . . . . . . PrimaryExpr (
    5:  9: . . . . . . . . . . . . . . . Operand (
    5:  9: . . . . . . . . . . . . . . . . STRING "a$b$%"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a$b$%"}
    5: 16: . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    5: 16: . . . . . . . . . . )
    5: 16: . . . . . . . . . )
    5: 16: . . . . . . . . )
    5: 16: . . . . . . . )
    5: 16: . . . . . . )
    5: 16: . . . . . )
    5: 16: . . . . )
    5: 16: . . . . ";"
    5: 17: . . . )
    5: 17: . . )
    5: 17: . )
    5: 17: )
=== RUN   TestFromTestdata/stringex2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/stringex2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . . CallOrConversion (
    1:  9: . . . . . . . . . . . Expression (
    1:  9: . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . . . . . . . STRING "${"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "${"}
    1: 13: . . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    1: 13: . . . . . . . . . . )
    1: 13: . . . . . . . . . )
    1: 13: . . . . . . . . )
    1: 13: . . . . . . . )
    1: 13: . . . . . . )
    1: 13: . . . . . )
    1: 13: . . . . )
    1: 13: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  9: . . . . . . . . . . )
    2:  9: . . . . . . . . . . CallOrConversion (
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
 /app/parser/parser.go:713: ast.Ident{Name: b}
    2:  9: . . . . . . . . . . . . . . . . STRING "${ b }"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "${ b }"}
    2: 17: . . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . . )
    2: 17: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    2: 17: . . . . . . . . . . )
    2: 17: . . . . . . . . . )
    2: 17: . . . . . . . . )
    2: 17: . . . . . . . )
    2: 17: . . . . . . )
    2: 17: . . . . . )
    2: 17: . . . . )
    2: 17: . . . . ";"
    3:  1: . . . )
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    3:  9: . . . . . . . . . . )
    3:  9: . . . . . . . . . . CallOrConversion (
    3:  9: . . . . . . . . . . . Expression (
    3:  9: . . . . . . . . . . . . BinaryExpr (
    3:  9: . . . . . . . . . . . . . UnaryExpr (
    3:  9: . . . . . . . . . . . . . . PrimaryExpr (
    3:  9: . . . . . . . . . . . . . . . Operand (
    3:  9: . . . . . . . . . . . . . . . . STRING "a${"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a${"}
    3: 14: . . . . . . . . . . . . . . . )
    3: 14: . . . . . . . . . . . . . . )
    3: 14: . . . . . . . . . . . . . )
    3: 14: . . . . . . . . . . . . )
    3: 14: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    3: 14: . . . . . . . . . . )
    3: 14: . . . . . . . . . )
    3: 14: . . . . . . . . )
    3: 14: . . . . . . . )
    3: 14: . . . . . . )
    3: 14: . . . . . )
    3: 14: . . . . )
    3: 14: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    4:  9: . . . . . . . . . . )
    4:  9: . . . . . . . . . . CallOrConversion (
    4:  9: . . . . . . . . . . . Expression (
    4:  9: . . . . . . . . . . . . BinaryExpr (
    4:  9: . . . . . . . . . . . . . UnaryExpr (
    4:  9: . . . . . . . . . . . . . . PrimaryExpr (
    4:  9: . . . . . . . . . . . . . . . Operand (
 /app/parser/parser.go:713: ast.Ident{Name: b}
    4:  9: . . . . . . . . . . . . . . . . STRING "a${b}c"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "a${b}c"}
    4: 17: . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    4: 17: . . . . . . . . . . )
    4: 17: . . . . . . . . . )
    4: 17: . . . . . . . . )
    4: 17: . . . . . . . )
    4: 17: . . . . . . )
    4: 17: . . . . . )
    4: 17: . . . . )
    4: 17: . . . . ";"
    4: 18: . . . )
    4: 18: . . )
    4: 18: . )
    4: 18: )
=== RUN   TestFromTestdata/stringex3
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/stringex3
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . . CallOrConversion (
    1:  9: . . . . . . . . . . . Expression (
    1:  9: . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . . . . . . Operand (
 /app/parser/parser.go:713: ast.Ident{Name: args}
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
 /app/parser/parser.go:2064: ast.IndexExpr{X: args, Index: &{22 INT 0 <nil>}}
 /app/parser/parser.go:713: ast.Ident{Name: query}
    1:  9: . . . . . . . . . . . . . . . . STRING "file:${args[0]}?${query}"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "file:${args[0]}?${query}"}
    1: 35: . . . . . . . . . . . . . . . )
    1: 35: . . . . . . . . . . . . . . )
    1: 35: . . . . . . . . . . . . . )
    1: 35: . . . . . . . . . . . . )
    1: 35: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    1: 35: . . . . . . . . . . )
    1: 35: . . . . . . . . . )
    1: 35: . . . . . . . . )
    1: 35: . . . . . . . )
    1: 35: . . . . . . )
    1: 35: . . . . . )
    1: 35: . . . . )
    1: 35: . . . . ";"
    1: 36: . . . )
    1: 36: . . )
    1: 36: . )
    1: 36: )
=== RUN   TestFromTestdata/typeof
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/typeof
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT echo
 /app/parser/parser.go:713: ast.Ident{Name: echo}
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . . CallOrConversion (
    1:  6: . . . . . . . . . . . Expression (
    1:  6: . . . . . . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . . . . . . IDENT type
 /app/parser/parser.go:713: ast.Ident{Name: type}
    1: 10: . . . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . . . . CallOrConversion (
    1: 10: . . . . . . . . . . . . . . . . "("
    1: 11: . . . . . . . . . . . . . . . . Expression (
    1: 11: . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 11: . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 11: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 11: . . . . . . . . . . . . . . . . . . . . Operand (
    1: 11: . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1: 12: . . . . . . . . . . . . . . . . . . . . )
    1: 12: . . . . . . . . . . . . . . . . . . . )
    1: 12: . . . . . . . . . . . . . . . . . . )
    1: 12: . . . . . . . . . . . . . . . . . )
    1: 12: . . . . . . . . . . . . . . . . )
    1: 12: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: type, Ellipsis: false, isCmd: false}
    1: 13: . . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . ","
    1: 15: . . . . . . . . . . . Expression (
    1: 15: . . . . . . . . . . . . BinaryExpr (
    1: 15: . . . . . . . . . . . . . UnaryExpr (
    1: 15: . . . . . . . . . . . . . . PrimaryExpr (
    1: 15: . . . . . . . . . . . . . . . Operand (
    1: 15: . . . . . . . . . . . . . . . . IDENT type
 /app/parser/parser.go:713: ast.Ident{Name: type}
    1: 19: . . . . . . . . . . . . . . . )
    1: 19: . . . . . . . . . . . . . . . CallOrConversion (
    1: 19: . . . . . . . . . . . . . . . . "("
    1: 20: . . . . . . . . . . . . . . . . Expression (
    1: 20: . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 20: . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 20: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 20: . . . . . . . . . . . . . . . . . . . . Operand (
    1: 20: . . . . . . . . . . . . . . . . . . . . . STRING "Hi"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hi"}
    1: 24: . . . . . . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: type, Ellipsis: false, isCmd: false}
    1: 25: . . . . . . . . . . . . . . . )
    1: 25: . . . . . . . . . . . . . . )
    1: 25: . . . . . . . . . . . . . )
    1: 25: . . . . . . . . . . . . )
    1: 25: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: echo, Ellipsis: false, isCmd: true}
    1: 25: . . . . . . . . . . )
    1: 25: . . . . . . . . . )
    1: 25: . . . . . . . . )
    1: 25: . . . . . . . )
    1: 25: . . . . . . )
    1: 25: . . . . . )
    1: 25: . . . . )
    1: 25: . . . . ";"
    1: 26: . . . )
    1: 26: . . )
    1: 26: . )
    1: 26: )
=== RUN   TestFromTestdata/typeswitch
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/typeswitch
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . FunctionDeclOrCall (
    1:  1: . . . "func"
    1:  6: . . . IDENT add
 /app/parser/parser.go:713: ast.Ident{Name: add}
    1:  9: . . . Signature (
    1:  9: . . . . Parameters (
    1:  9: . . . . . "("
    1: 10: . . . . . ParameterList (
    1: 10: . . . . . . ParamDeclOrNil (
    1: 10: . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
    1: 12: . . . . . . . Type (
    1: 12: . . . . . . . . InterfaceType (
    1: 12: . . . . . . . . . "interface"
    1: 21: . . . . . . . . . "{"
    1: 22: . . . . . . . . . "}"
    1: 23: . . . . . . . . )
    1: 23: . . . . . . . )
    1: 23: . . . . . . )
    1: 23: . . . . . )
    1: 23: . . . . . ")"
    1: 25: . . . . )
    1: 25: . . . . Result (
    1: 25: . . . . )
    1: 25: . . . )
    1: 25: . . . Body (
    1: 25: . . . . "{"
    2:  2: . . . . StatementList (
    2:  2: . . . . . Statement (
    2:  2: . . . . . . SwitchStmt (
    2:  2: . . . . . . . "switch"
    2:  9: . . . . . . . SimpleStmt (
    2:  9: . . . . . . . . ExpressionList (
    2:  9: . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2: 11: . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . )
    2: 11: . . . . . . . . . . )
    2: 11: . . . . . . . . . )
    2: 11: . . . . . . . . )
    2: 11: . . . . . . . . ":="
    2: 14: . . . . . . . . ExpressionList (
    2: 14: . . . . . . . . . Expression (
    2: 14: . . . . . . . . . . BinaryExpr (
    2: 14: . . . . . . . . . . . UnaryExpr (
    2: 14: . . . . . . . . . . . . PrimaryExpr (
    2: 14: . . . . . . . . . . . . . Operand (
    2: 14: . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
    2: 15: . . . . . . . . . . . . . )
    2: 15: . . . . . . . . . . . . . "."
    2: 16: . . . . . . . . . . . . . TypeAssertion (
    2: 16: . . . . . . . . . . . . . . "("
    2: 17: . . . . . . . . . . . . . . "type"
    2: 21: . . . . . . . . . . . . . . ")"
    2: 23: . . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . . )
    2: 23: . . . . . . . . . . . )
    2: 23: . . . . . . . . . . )
    2: 23: . . . . . . . . . )
    2: 23: . . . . . . . . )
    2: 23: . . . . . . . )
    2: 23: . . . . . . . "{"
    3:  2: . . . . . . . CaseClause (
    3:  2: . . . . . . . . "case"
    3:  7: . . . . . . . . TypeList (
    3:  7: . . . . . . . . . Type (
    3:  7: . . . . . . . . . . TypeName (
    3:  7: . . . . . . . . . . . IDENT int
 /app/parser/parser.go:713: ast.Ident{Name: int}
    3: 10: . . . . . . . . . . )
    3: 10: . . . . . . . . . )
    3: 10: . . . . . . . . . ","
    3: 12: . . . . . . . . . Type (
    3: 12: . . . . . . . . . . InterfaceType (
    3: 12: . . . . . . . . . . . "interface"
    3: 21: . . . . . . . . . . . "{"
    3: 23: . . . . . . . . . . . MethodSpec (
    3: 23: . . . . . . . . . . . . TypeName (
    3: 23: . . . . . . . . . . . . . IDENT Foo
 /app/parser/parser.go:713: ast.Ident{Name: Foo}
    3: 26: . . . . . . . . . . . . )
    3: 26: . . . . . . . . . . . . Signature (
    3: 26: . . . . . . . . . . . . . Parameters (
    3: 26: . . . . . . . . . . . . . . "("
    3: 27: . . . . . . . . . . . . . . ")"
    3: 29: . . . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . . . Result (
    3: 29: . . . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . )
    3: 29: . . . . . . . . . . . "}"
    3: 30: . . . . . . . . . . )
    3: 30: . . . . . . . . . )
    3: 30: . . . . . . . . )
    3: 30: . . . . . . . . ":"
    4:  2: . . . . . . . . StatementList (
    4:  2: . . . . . . . . )
    4:  2: . . . . . . . )
    4:  2: . . . . . . . CaseClause (
    4:  2: . . . . . . . . "case"
    4:  7: . . . . . . . . TypeList (
    4:  7: . . . . . . . . . Type (
    4:  7: . . . . . . . . . . PointerType (
    4:  7: . . . . . . . . . . . "*"
    4:  8: . . . . . . . . . . . Type (
    4:  8: . . . . . . . . . . . . TypeName (
    4:  8: . . . . . . . . . . . . . IDENT string
 /app/parser/parser.go:713: ast.Ident{Name: string}
    4: 14: . . . . . . . . . . . . )
    4: 14: . . . . . . . . . . . )
    4: 14: . . . . . . . . . . )
    4: 14: . . . . . . . . . )
    4: 14: . . . . . . . . )
    4: 14: . . . . . . . . ":"
    5:  2: . . . . . . . . StatementList (
    5:  2: . . . . . . . . )
    5:  2: . . . . . . . )
    5:  2: . . . . . . . CaseClause (
    5:  2: . . . . . . . . "default"
    5:  9: . . . . . . . . ":"
    6:  2: . . . . . . . . StatementList (
    6:  2: . . . . . . . . )
    6:  2: . . . . . . . )
    6:  2: . . . . . . . "}"
    6:  3: . . . . . . . ";"
    7:  1: . . . . . . )
    7:  1: . . . . . )
    7:  1: . . . . )
    7:  1: . . . . "}"
    7:  2: . . . )
    7:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: add, ...}
    7:  3: . . )
    7:  3: . )
    7:  3: )
=== RUN   TestFromTestdata/unit
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_testdata/unit
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT wait
 /app/parser/parser.go:713: ast.Ident{Name: wait}
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . . CallOrConversion (
    1:  6: . . . . . . . . . . . Expression (
    1:  6: . . . . . . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1856: ast.NumberUnitLit{Kind: INT, Value: 1, Unit: s}
    1:  7: . . . . . . . . . . . . . . . . UNIT
    1: 10: . . . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . . )
    1: 10: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: wait, Ellipsis: false, isCmd: true}
    1: 10: . . . . . . . . . . )
    1: 10: . . . . . . . . . )
    1: 10: . . . . . . . . )
    1: 10: . . . . . . . )
    1: 10: . . . . . . )
    1: 10: . . . . . )
    1: 10: . . . . )
    1: 10: . . . . ";"
    1: 11: . . . )
    1: 11: . . )
    1: 11: . )
    1: 11: )
--- PASS: TestFromTestdata (0.13s)
    --- PASS: TestFromTestdata/append1 (0.00s)
    --- PASS: TestFromTestdata/append2 (0.00s)
    --- PASS: TestFromTestdata/arrowop (0.00s)
    --- PASS: TestFromTestdata/autoprop (0.00s)
    --- PASS: TestFromTestdata/build (0.00s)
    --- PASS: TestFromTestdata/c2gohello (0.00s)
    --- PASS: TestFromTestdata/cmdlinestyle1 (0.00s)
    --- PASS: TestFromTestdata/cmdlinestyle2 (0.00s)
    --- PASS: TestFromTestdata/cmdlinestyle3 (0.00s)
    --- PASS: TestFromTestdata/cmdlinestyle4 (0.00s)
    --- PASS: TestFromTestdata/collection (0.01s)
    --- PASS: TestFromTestdata/complit (0.00s)
    --- PASS: TestFromTestdata/domainhuh (0.00s)
    --- PASS: TestFromTestdata/domaintext (0.00s)
    --- PASS: TestFromTestdata/domaintpl (0.00s)
    --- PASS: TestFromTestdata/embedded1 (0.00s)
    --- PASS: TestFromTestdata/envop1 (0.00s)
    --- PASS: TestFromTestdata/envop2 (0.00s)
    --- PASS: TestFromTestdata/errwrap1 (0.00s)
    --- PASS: TestFromTestdata/errwrap2 (0.00s)
    --- PASS: TestFromTestdata/errwrap3 (0.00s)
    --- PASS: TestFromTestdata/exists (0.00s)
    --- PASS: TestFromTestdata/fnbody (0.00s)
    --- PASS: TestFromTestdata/fncall (0.00s)
    --- PASS: TestFromTestdata/forloop (0.01s)
    --- PASS: TestFromTestdata/funcdecl1 (0.00s)
    --- PASS: TestFromTestdata/funcdecl2 (0.00s)
    --- PASS: TestFromTestdata/funcdecl3 (0.00s)
    --- PASS: TestFromTestdata/funcdoc (0.00s)
    --- PASS: TestFromTestdata/funclit (0.00s)
    --- PASS: TestFromTestdata/functype (0.00s)
    --- PASS: TestFromTestdata/gmxtest (0.00s)
    --- PASS: TestFromTestdata/goto1 (0.00s)
    --- PASS: TestFromTestdata/goto2 (0.00s)
    --- PASS: TestFromTestdata/goxtest1 (0.00s)
    --- PASS: TestFromTestdata/goxtest2 (0.00s)
    --- PASS: TestFromTestdata/kwargs1 (0.00s)
    --- PASS: TestFromTestdata/lambda1 (0.00s)
    --- PASS: TestFromTestdata/lambda2 (0.00s)
    --- PASS: TestFromTestdata/lambda3 (0.00s)
    --- PASS: TestFromTestdata/lambda4 (0.00s)
    --- PASS: TestFromTestdata/listcompr (0.01s)
    --- PASS: TestFromTestdata/mapfunc (0.00s)
    --- PASS: TestFromTestdata/matrix1 (0.00s)
    --- PASS: TestFromTestdata/matrix2 (0.00s)
    --- PASS: TestFromTestdata/mytest (0.01s)
    --- PASS: TestFromTestdata/optparam (0.01s)
    --- PASS: TestFromTestdata/overload1 (0.00s)
    --- PASS: TestFromTestdata/overload2 (0.00s)
    --- PASS: TestFromTestdata/overloadop (0.00s)
    --- PASS: TestFromTestdata/printvariadic (0.00s)
    --- PASS: TestFromTestdata/pystr (0.00s)
    --- PASS: TestFromTestdata/rangeexpr1 (0.00s)
    --- PASS: TestFromTestdata/rangeexpr2 (0.00s)
    --- PASS: TestFromTestdata/rangeexpr3 (0.00s)
    --- PASS: TestFromTestdata/rational (0.00s)
    --- PASS: TestFromTestdata/selectdata (0.00s)
    --- PASS: TestFromTestdata/slice1 (0.00s)
    --- PASS: TestFromTestdata/slice2 (0.00s)
    --- PASS: TestFromTestdata/spxtest (0.00s)
    --- PASS: TestFromTestdata/staticmthd1 (0.00s)
    --- PASS: TestFromTestdata/staticmthd2 (0.00s)
    --- PASS: TestFromTestdata/stdtype (0.00s)
    --- PASS: TestFromTestdata/stringex1 (0.00s)
    --- PASS: TestFromTestdata/stringex2 (0.00s)
    --- PASS: TestFromTestdata/stringex3 (0.00s)
    --- PASS: TestFromTestdata/typeof (0.00s)
    --- PASS: TestFromTestdata/typeswitch (0.00s)
    --- PASS: TestFromTestdata/unit (0.00s)
=== RUN   TestFromNofmt
=== RUN   TestFromNofmt/cmdlinestyle1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_nofmt/cmdlinestyle1
    1:  1: File (
    1:  1: . "package"
    1:  9: . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    1: 13: . ";"
    3:  1: . Declaration (
    3:  1: . . FunctionDeclOrCall (
    3:  1: . . . "func"
    3:  6: . . . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    3: 10: . . . Signature (
    3: 10: . . . . Parameters (
    3: 10: . . . . . "("
    3: 11: . . . . . ")"
    3: 13: . . . . )
    3: 13: . . . . Result (
    3: 13: . . . . )
    3: 13: . . . )
    3: 13: . . . Body (
    3: 13: . . . . "{"
    4:  2: . . . . StatementList (
    4:  2: . . . . . Statement (
    4:  2: . . . . . . SimpleStmt (
    4:  2: . . . . . . . ExpressionList (
    4:  2: . . . . . . . . Expression (
    4:  2: . . . . . . . . . BinaryExpr (
    4:  2: . . . . . . . . . . UnaryExpr (
    4:  2: . . . . . . . . . . . PrimaryExpr (
    4:  2: . . . . . . . . . . . . Operand (
    4:  2: . . . . . . . . . . . . . IDENT changeYpos
 /app/parser/parser.go:713: ast.Ident{Name: changeYpos}
    4: 13: . . . . . . . . . . . . )
    4: 13: . . . . . . . . . . . . "-"
    4: 13: . . . . . . . . . . . . CallOrConversion (
    4: 13: . . . . . . . . . . . . . Expression (
    4: 13: . . . . . . . . . . . . . . BinaryExpr (
    4: 13: . . . . . . . . . . . . . . . UnaryExpr (
    4: 14: . . . . . . . . . . . . . . . . UnaryExpr (
    4: 14: . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 14: . . . . . . . . . . . . . . . . . . Operand (
    4: 14: . . . . . . . . . . . . . . . . . . . FLOAT 0.7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 0.7}
    4: 17: . . . . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . )
    4: 17: . . . . . . . . . . . . . ","
    4: 19: . . . . . . . . . . . . . Expression (
    4: 19: . . . . . . . . . . . . . . BinaryExpr (
    4: 19: . . . . . . . . . . . . . . . UnaryExpr (
    4: 19: . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 19: . . . . . . . . . . . . . . . . . Operand (
    4: 19: . . . . . . . . . . . . . . . . . . INT 8
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 8}
    4: 20: . . . . . . . . . . . . . . . . . )
    4: 20: . . . . . . . . . . . . . . . . )
    4: 20: . . . . . . . . . . . . . . . )
    4: 20: . . . . . . . . . . . . . . )
    4: 20: . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: changeYpos, Ellipsis: false, isCmd: true}
    4: 20: . . . . . . . . . . . . )
    4: 20: . . . . . . . . . . . )
    4: 20: . . . . . . . . . . )
    4: 20: . . . . . . . . . )
    4: 20: . . . . . . . . )
    4: 20: . . . . . . . )
    4: 20: . . . . . . )
    4: 20: . . . . . . ";"
    5:  2: . . . . . )
    5:  2: . . . . . Statement (
    5:  2: . . . . . . SimpleStmt (
    5:  2: . . . . . . . ExpressionList (
    5:  2: . . . . . . . . Expression (
    5:  2: . . . . . . . . . BinaryExpr (
    5:  2: . . . . . . . . . . UnaryExpr (
    5:  2: . . . . . . . . . . . PrimaryExpr (
    5:  2: . . . . . . . . . . . . Operand (
    5:  2: . . . . . . . . . . . . . IDENT changeYpos
 /app/parser/parser.go:713: ast.Ident{Name: changeYpos}
    5: 13: . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . "-"
    5: 13: . . . . . . . . . . . . CallOrConversion (
    5: 13: . . . . . . . . . . . . . Expression (
    5: 13: . . . . . . . . . . . . . . BinaryExpr (
    5: 13: . . . . . . . . . . . . . . . UnaryExpr (
    5: 14: . . . . . . . . . . . . . . . . UnaryExpr (
    5: 14: . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 14: . . . . . . . . . . . . . . . . . . Operand (
    5: 14: . . . . . . . . . . . . . . . . . . . FLOAT 0.7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 0.7}
    5: 17: . . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: changeYpos, Ellipsis: false, isCmd: true}
    5: 17: . . . . . . . . . . . . )
    5: 17: . . . . . . . . . . . )
    5: 17: . . . . . . . . . . )
    5: 17: . . . . . . . . . )
    5: 17: . . . . . . . . )
    5: 17: . . . . . . . )
    5: 17: . . . . . . )
    5: 17: . . . . . . ";"
    6:  2: . . . . . )
    6:  2: . . . . . Statement (
    6:  2: . . . . . . SimpleStmt (
    6:  2: . . . . . . . ExpressionList (
    6:  2: . . . . . . . . Expression (
    6:  2: . . . . . . . . . BinaryExpr (
    6:  2: . . . . . . . . . . UnaryExpr (
    6:  2: . . . . . . . . . . . PrimaryExpr (
    6:  2: . . . . . . . . . . . . Operand (
    6:  2: . . . . . . . . . . . . . IDENT changeYpos
 /app/parser/parser.go:713: ast.Ident{Name: changeYpos}
    6: 13: . . . . . . . . . . . . )
    6: 13: . . . . . . . . . . . . "-"
    6: 13: . . . . . . . . . . . )
    6: 13: . . . . . . . . . . )
    6: 15: . . . . . . . . . . BinaryExpr (
    6: 15: . . . . . . . . . . . UnaryExpr (
    6: 15: . . . . . . . . . . . . PrimaryExpr (
    6: 15: . . . . . . . . . . . . . Operand (
    6: 15: . . . . . . . . . . . . . . FLOAT 0.7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 0.7}
    6: 18: . . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . . )
    6: 18: . . . . . . . . . . . )
    6: 18: . . . . . . . . . . )
    6: 18: . . . . . . . . . )
    6: 18: . . . . . . . . )
    6: 18: . . . . . . . )
    6: 18: . . . . . . )
    6: 18: . . . . . . ";"
    7:  2: . . . . . )
    7:  2: . . . . . Statement (
    7:  2: . . . . . . SimpleStmt (
    7:  2: . . . . . . . ExpressionList (
    7:  2: . . . . . . . . Expression (
    7:  2: . . . . . . . . . BinaryExpr (
    7:  2: . . . . . . . . . . UnaryExpr (
    7:  2: . . . . . . . . . . . PrimaryExpr (
    7:  2: . . . . . . . . . . . . Operand (
    7:  2: . . . . . . . . . . . . . IDENT changeYpos
 /app/parser/parser.go:713: ast.Ident{Name: changeYpos}
    7: 12: . . . . . . . . . . . . )
    7: 12: . . . . . . . . . . . )
    7: 12: . . . . . . . . . . )
    7: 12: . . . . . . . . . . "-"
    7: 13: . . . . . . . . . . BinaryExpr (
    7: 13: . . . . . . . . . . . UnaryExpr (
    7: 13: . . . . . . . . . . . . PrimaryExpr (
    7: 13: . . . . . . . . . . . . . Operand (
    7: 13: . . . . . . . . . . . . . . FLOAT 0.7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: FLOAT, Value: 0.7}
    7: 16: . . . . . . . . . . . . . )
    7: 16: . . . . . . . . . . . . )
    7: 16: . . . . . . . . . . . )
    7: 16: . . . . . . . . . . )
    7: 16: . . . . . . . . . )
    7: 16: . . . . . . . . )
    7: 16: . . . . . . . )
    7: 16: . . . . . . )
    7: 16: . . . . . . ";"
    8:  2: . . . . . )
    8:  2: . . . . . Statement (
    8:  2: . . . . . . SimpleStmt (
    8:  2: . . . . . . . ExpressionList (
    8:  2: . . . . . . . . Expression (
    8:  2: . . . . . . . . . BinaryExpr (
    8:  2: . . . . . . . . . . UnaryExpr (
    8:  2: . . . . . . . . . . . PrimaryExpr (
    8:  2: . . . . . . . . . . . . Operand (
    8:  2: . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    8:  3: . . . . . . . . . . . . )
    8:  3: . . . . . . . . . . . . IndexOrSlice (
    8:  3: . . . . . . . . . . . . . "["
    8:  4: . . . . . . . . . . . . . Expression (
    8:  4: . . . . . . . . . . . . . . BinaryExpr (
    8:  4: . . . . . . . . . . . . . . . UnaryExpr (
    8:  4: . . . . . . . . . . . . . . . . PrimaryExpr (
    8:  4: . . . . . . . . . . . . . . . . . Operand (
    8:  4: . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    8:  5: . . . . . . . . . . . . . . . . . )
    8:  5: . . . . . . . . . . . . . . . . )
    8:  5: . . . . . . . . . . . . . . . )
    8:  5: . . . . . . . . . . . . . . )
    8:  5: . . . . . . . . . . . . . )
    8:  5: . . . . . . . . . . . . . "]"
 /app/parser/parser.go:2064: ast.IndexExpr{X: x, Index: &{103 INT 1 <nil>}}
    8:  6: . . . . . . . . . . . . )
    8:  6: . . . . . . . . . . . )
    8:  6: . . . . . . . . . . )
    8:  6: . . . . . . . . . )
    8:  6: . . . . . . . . )
    8:  6: . . . . . . . )
    8:  6: . . . . . . )
    8:  6: . . . . . . ";"
    9:  2: . . . . . )
    9:  2: . . . . . Statement (
    9:  2: . . . . . . SimpleStmt (
    9:  2: . . . . . . . ExpressionList (
    9:  2: . . . . . . . . Expression (
    9:  2: . . . . . . . . . BinaryExpr (
    9:  2: . . . . . . . . . . UnaryExpr (
    9:  2: . . . . . . . . . . . PrimaryExpr (
    9:  2: . . . . . . . . . . . . Operand (
    9:  2: . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    9:  4: . . . . . . . . . . . . )
    9:  4: . . . . . . . . . . . . CallOrConversion (
    9:  4: . . . . . . . . . . . . . Expression (
    9:  4: . . . . . . . . . . . . . . BinaryExpr (
    9:  4: . . . . . . . . . . . . . . . UnaryExpr (
    9:  4: . . . . . . . . . . . . . . . . PrimaryExpr (
    9:  4: . . . . . . . . . . . . . . . . . Operand (
    9:  4: . . . . . . . . . . . . . . . . . . ArrayType (
    9:  4: . . . . . . . . . . . . . . . . . . . "["
    9:  5: . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:902: ast.SliceLit{Elts: []}
    9:  6: . . . . . . . . . . . . . . . . . . )
    9:  6: . . . . . . . . . . . . . . . . . )
    9:  6: . . . . . . . . . . . . . . . . )
    9:  6: . . . . . . . . . . . . . . . )
    9:  6: . . . . . . . . . . . . . . )
    9:  6: . . . . . . . . . . . . . )
    9:  6: . . . . . . . . . . . . . "..."
 /app/parser/parser.go:2160: ast.CallExpr{Fun: x, Ellipsis: true, isCmd: true}
    9:  9: . . . . . . . . . . . . )
    9:  9: . . . . . . . . . . . )
    9:  9: . . . . . . . . . . )
    9:  9: . . . . . . . . . )
    9:  9: . . . . . . . . )
    9:  9: . . . . . . . )
    9:  9: . . . . . . )
    9:  9: . . . . . . ";"
   10:  1: . . . . . )
   10:  1: . . . . )
   10:  1: . . . . "}"
   10:  2: . . . )
   10:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: main, ...}
   10:  3: . . )
   10:  3: . )
   10:  3: )
=== RUN   TestFromNofmt/cmdlinestyle2
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_nofmt/cmdlinestyle2
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT add
 /app/parser/parser.go:713: ast.Ident{Name: add}
    1:  4: . . . . . . . . . . )
    1:  4: . . . . . . . . . . CallOrConversion (
    1:  4: . . . . . . . . . . . "("
    1:  5: . . . . . . . . . . . Expression (
    1:  5: . . . . . . . . . . . . BinaryExpr (
    1:  5: . . . . . . . . . . . . . UnaryExpr (
    1:  5: . . . . . . . . . . . . . . PrimaryExpr (
    1:  5: . . . . . . . . . . . . . . . Operand (
    1:  5: . . . . . . . . . . . . . . . . INT 100
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
    1:  8: . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . ","
    1: 10: . . . . . . . . . . . Expression (
    1: 10: . . . . . . . . . . . . BinaryExpr (
    1: 10: . . . . . . . . . . . . . UnaryExpr (
    1: 10: . . . . . . . . . . . . . . PrimaryExpr (
    1: 10: . . . . . . . . . . . . . . . Operand (
    1: 10: . . . . . . . . . . . . . . . . INT 200
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 200}
    1: 13: . . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . )
    1: 13: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: add, Ellipsis: false, isCmd: false}
    1: 15: . . . . . . . . . . )
    1: 15: . . . . . . . . . . CallOrConversion (
    1: 15: . . . . . . . . . . . "("
    1: 16: . . . . . . . . . . . Expression (
    1: 16: . . . . . . . . . . . . BinaryExpr (
    1: 16: . . . . . . . . . . . . . UnaryExpr (
    1: 16: . . . . . . . . . . . . . . PrimaryExpr (
    1: 16: . . . . . . . . . . . . . . . Operand (
    1: 16: . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    1: 17: . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{add 4 [0xc00052b590 0xc00052b5c0] 0 [] 13 0}, Ellipsis: false, isCmd: false}
    1: 18: . . . . . . . . . . )
    1: 18: . . . . . . . . . . "."
    1: 19: . . . . . . . . . . Selector (
    1: 19: . . . . . . . . . . . IDENT Test
 /app/parser/parser.go:713: ast.Ident{Name: Test}
    1: 23: . . . . . . . . . . )
    1: 23: . . . . . . . . . . CallOrConversion (
    1: 23: . . . . . . . . . . . "("
    1: 24: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: &{0xc00044cd20 Test}, Ellipsis: false, isCmd: false}
    1: 25: . . . . . . . . . . )
    1: 25: . . . . . . . . . )
    1: 25: . . . . . . . . )
    1: 25: . . . . . . . )
    1: 25: . . . . . . )
    1: 25: . . . . . )
    1: 25: . . . . )
    1: 25: . . . . ";"
    1: 26: . . . )
    1: 26: . . )
    1: 26: . )
    1: 26: )
=== RUN   TestFromNofmt/cmdlinestyle3
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_nofmt/cmdlinestyle3
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    1:  9: . . . . . . . . . . )
    1:  9: . . . . . . . . . . CallOrConversion (
    1:  9: . . . . . . . . . . . Expression (
    1:  9: . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . . . . . . . "("
    1: 10: . . . . . . . . . . . . . . . . Expression (
    1: 10: . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 10: . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 10: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 10: . . . . . . . . . . . . . . . . . . . . Operand (
    1: 10: . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1: 11: . . . . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . . . "+"
    1: 12: . . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 12: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 12: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 12: . . . . . . . . . . . . . . . . . . . . . Operand (
    1: 12: . . . . . . . . . . . . . . . . . . . . . . IMAG 2i
 /app/parser/parser.go:1862: ast.BasicLit{Kind: IMAG, Value: 2i}
    1: 14: . . . . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . . ","
    1: 16: . . . . . . . . . . . . . . . . Expression (
    1: 16: . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 16: . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 16: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 16: . . . . . . . . . . . . . . . . . . . . Operand (
    1: 16: . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    1: 17: . . . . . . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . . ")"
    1: 18: . . . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . . )
    1: 18: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: true}
    1: 18: . . . . . . . . . . )
    1: 18: . . . . . . . . . )
    1: 18: . . . . . . . . )
    1: 18: . . . . . . . )
    1: 18: . . . . . . )
    1: 18: . . . . . )
    1: 18: . . . . )
    1: 18: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  9: . . . . . . . . . . )
    2:  9: . . . . . . . . . . CallOrConversion (
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . "("
    2: 10: . . . . . . . . . . . . . . . . Expression (
    2: 10: . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 10: . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 10: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 10: . . . . . . . . . . . . . . . . . . . . Operand (
    2: 10: . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2: 11: . . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . )
    2: 11: . . . . . . . . . . . . . . . . ","
    2: 13: . . . . . . . . . . . . . . . . Expression (
    2: 13: . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 13: . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 13: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 13: . . . . . . . . . . . . . . . . . . . . Operand (
    2: 13: . . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2: 14: . . . . . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . )
    2: 14: . . . . . . . . . . . . . . . . "..."
    2: 17: . . . . . . . . . . . . . . . . ")"
    2: 18: . . . . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . . )
    2: 18: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: true, isCmd: true}
    2: 18: . . . . . . . . . . )
    2: 18: . . . . . . . . . )
    2: 18: . . . . . . . . )
    2: 18: . . . . . . . )
    2: 18: . . . . . . )
    2: 18: . . . . . )
    2: 18: . . . . )
    2: 18: . . . . ";"
    3:  1: . . . )
    3:  1: . . . Statement (
    3:  1: . . . . SimpleStmt (
    3:  1: . . . . . ExpressionList (
    3:  1: . . . . . . Expression (
    3:  1: . . . . . . . BinaryExpr (
    3:  1: . . . . . . . . UnaryExpr (
    3:  1: . . . . . . . . . PrimaryExpr (
    3:  1: . . . . . . . . . . Operand (
    3:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    3:  9: . . . . . . . . . . )
    3:  9: . . . . . . . . . . CallOrConversion (
    3:  9: . . . . . . . . . . . Expression (
    3:  9: . . . . . . . . . . . . BinaryExpr (
    3:  9: . . . . . . . . . . . . . UnaryExpr (
    3:  9: . . . . . . . . . . . . . . PrimaryExpr (
    3:  9: . . . . . . . . . . . . . . . Operand (
    3:  9: . . . . . . . . . . . . . . . . "("
    3: 10: . . . . . . . . . . . . . . . . Expression (
    3: 10: . . . . . . . . . . . . . . . . . BinaryExpr (
    3: 10: . . . . . . . . . . . . . . . . . . UnaryExpr (
    3: 10: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3: 10: . . . . . . . . . . . . . . . . . . . . Operand (
    3: 10: . . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    3: 11: . . . . . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . . "..."
    3: 14: . . . . . . . . . . . . . . . . ")"
    3: 15: . . . . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . . )
    3: 15: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: true, isCmd: true}
    3: 15: . . . . . . . . . . )
    3: 15: . . . . . . . . . )
    3: 15: . . . . . . . . )
    3: 15: . . . . . . . )
    3: 15: . . . . . . )
    3: 15: . . . . . )
    3: 15: . . . . )
    3: 15: . . . . ";"
    3: 16: . . . )
    3: 16: . . )
    3: 16: . )
    3: 16: )
=== RUN   TestFromNofmt/exists
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_nofmt/exists
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . ArrayType (
    1:  6: . . . . . . . . . . . . "["
    1:  7: . . . . . . . . . . . . Expression (
    1:  7: . . . . . . . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  8: . . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . ","
    1: 10: . . . . . . . . . . . . Expression (
    1: 10: . . . . . . . . . . . . . BinaryExpr (
    1: 10: . . . . . . . . . . . . . . UnaryExpr (
    1: 10: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 10: . . . . . . . . . . . . . . . . Operand (
    1: 10: . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    1: 11: . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . ","
    1: 13: . . . . . . . . . . . . Expression (
    1: 13: . . . . . . . . . . . . . BinaryExpr (
    1: 13: . . . . . . . . . . . . . . UnaryExpr (
    1: 13: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 13: . . . . . . . . . . . . . . . . Operand (
    1: 13: . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    1: 14: . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . ","
    1: 16: . . . . . . . . . . . . Expression (
    1: 16: . . . . . . . . . . . . . BinaryExpr (
    1: 16: . . . . . . . . . . . . . . UnaryExpr (
    1: 16: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 16: . . . . . . . . . . . . . . . . Operand (
    1: 16: . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    1: 17: . . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . ","
    1: 19: . . . . . . . . . . . . Expression (
    1: 19: . . . . . . . . . . . . . BinaryExpr (
    1: 19: . . . . . . . . . . . . . . UnaryExpr (
    1: 19: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 19: . . . . . . . . . . . . . . . . Operand (
    1: 19: . . . . . . . . . . . . . . . . . INT 8
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 8}
    1: 20: . . . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . ","
    1: 22: . . . . . . . . . . . . Expression (
    1: 22: . . . . . . . . . . . . . BinaryExpr (
    1: 22: . . . . . . . . . . . . . . UnaryExpr (
    1: 22: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 22: . . . . . . . . . . . . . . . . Operand (
    1: 22: . . . . . . . . . . . . . . . . . INT 19
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 19}
    1: 24: . . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . "]"
    1: 25: . . . . . . . . . . . )
    1: 25: . . . . . . . . . . )
    1: 25: . . . . . . . . . )
    1: 25: . . . . . . . . )
    1: 25: . . . . . . . )
    1: 25: . . . . . . )
    1: 25: . . . . . )
    1: 25: . . . . )
    1: 25: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT hasEven
 /app/parser/parser.go:713: ast.Ident{Name: hasEven}
    2:  9: . . . . . . . . . . )
    2:  9: . . . . . . . . . )
    2:  9: . . . . . . . . )
    2:  9: . . . . . . . )
    2:  9: . . . . . . )
    2:  9: . . . . . )
    2:  9: . . . . . ":="
    2: 12: . . . . . ExpressionList (
    2: 12: . . . . . . Expression (
    2: 12: . . . . . . . BinaryExpr (
    2: 12: . . . . . . . . UnaryExpr (
    2: 12: . . . . . . . . . PrimaryExpr (
    2: 12: . . . . . . . . . . Operand (
    2: 12: . . . . . . . . . . . LiteralValue (
    2: 12: . . . . . . . . . . . . "{"
    2: 13: . . . . . . . . . . . . ElementList (
    2: 13: . . . . . . . . . . . . . ForPhrase (
    2: 13: . . . . . . . . . . . . . . "for"
    2: 17: . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 19: . . . . . . . . . . . . . . "<-"
    2: 22: . . . . . . . . . . . . . . Expression (
    2: 22: . . . . . . . . . . . . . . . RangeExpr (
    2: 22: . . . . . . . . . . . . . . . . BinaryExpr (
    2: 22: . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 22: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 22: . . . . . . . . . . . . . . . . . . . Operand (
    2: 22: . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2: 24: . . . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . "if"
    2: 27: . . . . . . . . . . . . . . SimpleStmt (
    2: 27: . . . . . . . . . . . . . . . ExpressionList (
    2: 27: . . . . . . . . . . . . . . . . Expression (
    2: 27: . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 27: . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 27: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 27: . . . . . . . . . . . . . . . . . . . . Operand (
    2: 27: . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 28: . . . . . . . . . . . . . . . . . . . . )
    2: 28: . . . . . . . . . . . . . . . . . . . )
    2: 28: . . . . . . . . . . . . . . . . . . )
    2: 28: . . . . . . . . . . . . . . . . . . "%"
    2: 29: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 29: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 29: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 29: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 29: . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    2: 31: . . . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . "=="
    2: 34: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 34: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 34: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 34: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 34: . . . . . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    2: 35: . . . . . . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . )
    2: 35: . . . . . . . . . . . . "}"
    2: 36: . . . . . . . . . . . )
    2: 36: . . . . . . . . . . )
    2: 36: . . . . . . . . . )
    2: 36: . . . . . . . . )
    2: 36: . . . . . . . )
    2: 36: . . . . . . )
    2: 36: . . . . . )
    2: 36: . . . . )
    2: 36: . . . . ";"
    2: 37: . . . )
    2: 37: . . )
    2: 37: . )
    2: 37: )
=== RUN   TestFromNofmt/forloop
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_nofmt/forloop
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT n
 /app/parser/parser.go:713: ast.Ident{Name: n}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    1:  7: . . . . . . . . . . )
    1:  7: . . . . . . . . . )
    1:  7: . . . . . . . . )
    1:  7: . . . . . . . )
    1:  7: . . . . . . )
    1:  7: . . . . . )
    1:  7: . . . . )
    1:  7: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . ForStmt (
    2:  1: . . . . . "for"
    2:  5: . . . . . "range"
    2: 11: . . . . . Expression (
    2: 11: . . . . . . RangeExpr (
    2: 11: . . . . . . . BinaryExpr (
    2: 11: . . . . . . . . UnaryExpr (
    2: 11: . . . . . . . . . PrimaryExpr (
    2: 11: . . . . . . . . . . Operand (
    2: 11: . . . . . . . . . . . ArrayType (
    2: 11: . . . . . . . . . . . . "["
    2: 12: . . . . . . . . . . . . Expression (
    2: 12: . . . . . . . . . . . . . BinaryExpr (
    2: 12: . . . . . . . . . . . . . . UnaryExpr (
    2: 12: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 12: . . . . . . . . . . . . . . . . Operand (
    2: 12: . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2: 13: . . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . )
    2: 13: . . . . . . . . . . . . ","
    2: 15: . . . . . . . . . . . . Expression (
    2: 15: . . . . . . . . . . . . . BinaryExpr (
    2: 15: . . . . . . . . . . . . . . UnaryExpr (
    2: 15: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 15: . . . . . . . . . . . . . . . . Operand (
    2: 15: . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    2: 16: . . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . )
    2: 16: . . . . . . . . . . . . ","
    2: 18: . . . . . . . . . . . . Expression (
    2: 18: . . . . . . . . . . . . . BinaryExpr (
    2: 18: . . . . . . . . . . . . . . UnaryExpr (
    2: 18: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 18: . . . . . . . . . . . . . . . . Operand (
    2: 18: . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    2: 19: . . . . . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . )
    2: 19: . . . . . . . . . . . . ","
    2: 21: . . . . . . . . . . . . Expression (
    2: 21: . . . . . . . . . . . . . BinaryExpr (
    2: 21: . . . . . . . . . . . . . . UnaryExpr (
    2: 21: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 21: . . . . . . . . . . . . . . . . Operand (
    2: 21: . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    2: 22: . . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . )
    2: 22: . . . . . . . . . . . . ","
    2: 24: . . . . . . . . . . . . Expression (
    2: 24: . . . . . . . . . . . . . BinaryExpr (
    2: 24: . . . . . . . . . . . . . . UnaryExpr (
    2: 24: . . . . . . . . . . . . . . . PrimaryExpr (
    2: 24: . . . . . . . . . . . . . . . . Operand (
    2: 24: . . . . . . . . . . . . . . . . . INT 11
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 11}
    2: 26: . . . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . )
    2: 26: . . . . . . . . . . . . "]"
    2: 28: . . . . . . . . . . . )
    2: 28: . . . . . . . . . . )
    2: 28: . . . . . . . . . )
    2: 28: . . . . . . . . )
    2: 28: . . . . . . . )
    2: 28: . . . . . . )
    2: 28: . . . . . )
    2: 28: . . . . . BlockStmt (
    2: 28: . . . . . . "{"
    3:  2: . . . . . . StatementList (
    3:  2: . . . . . . . Statement (
    3:  2: . . . . . . . . SimpleStmt (
    3:  2: . . . . . . . . . ExpressionList (
    3:  2: . . . . . . . . . . Expression (
    3:  2: . . . . . . . . . . . BinaryExpr (
    3:  2: . . . . . . . . . . . . UnaryExpr (
    3:  2: . . . . . . . . . . . . . PrimaryExpr (
    3:  2: . . . . . . . . . . . . . . Operand (
    3:  2: . . . . . . . . . . . . . . . IDENT n
 /app/parser/parser.go:713: ast.Ident{Name: n}
    3:  3: . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . )
    3:  3: . . . . . . . . . . )
    3:  3: . . . . . . . . . )
    3:  3: . . . . . . . . . "++"
    3:  5: . . . . . . . . )
    3:  5: . . . . . . . . ";"
    4:  1: . . . . . . . )
    4:  1: . . . . . . )
    4:  1: . . . . . . "}"
    4:  2: . . . . . )
    4:  2: . . . . . ";"
    5:  1: . . . . )
    5:  1: . . . )
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5:  8: . . . . . . . . . . )
    5:  8: . . . . . . . . . . CallOrConversion (
    5:  8: . . . . . . . . . . . "("
    5:  9: . . . . . . . . . . . Expression (
    5:  9: . . . . . . . . . . . . BinaryExpr (
    5:  9: . . . . . . . . . . . . . UnaryExpr (
    5:  9: . . . . . . . . . . . . . . PrimaryExpr (
    5:  9: . . . . . . . . . . . . . . . Operand (
    5:  9: . . . . . . . . . . . . . . . . STRING "n:"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "n:"}
    5: 13: . . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . ","
    5: 15: . . . . . . . . . . . Expression (
    5: 15: . . . . . . . . . . . . BinaryExpr (
    5: 15: . . . . . . . . . . . . . UnaryExpr (
    5: 15: . . . . . . . . . . . . . . PrimaryExpr (
    5: 15: . . . . . . . . . . . . . . . Operand (
    5: 15: . . . . . . . . . . . . . . . . IDENT n
 /app/parser/parser.go:713: ast.Ident{Name: n}
    5: 16: . . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . )
    5: 16: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    5: 17: . . . . . . . . . . )
    5: 17: . . . . . . . . . )
    5: 17: . . . . . . . . )
    5: 17: . . . . . . . )
    5: 17: . . . . . . )
    5: 17: . . . . . )
    5: 17: . . . . )
    5: 17: . . . . ";"
    7:  1: . . . )
    7:  1: . . . Statement (
    7:  1: . . . . ForStmt (
    7:  1: . . . . . "for"
    7:  5: . . . . . SimpleStmt (
    7:  5: . . . . . . ExpressionList (
    7:  5: . . . . . . . Expression (
    7:  5: . . . . . . . . BinaryExpr (
    7:  5: . . . . . . . . . UnaryExpr (
    7:  5: . . . . . . . . . . PrimaryExpr (
    7:  5: . . . . . . . . . . . Operand (
    7:  5: . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    7:  7: . . . . . . . . . . . )
    7:  7: . . . . . . . . . . )
    7:  7: . . . . . . . . . )
    7:  7: . . . . . . . . )
    7:  7: . . . . . . . )
    7:  7: . . . . . . )
    7:  7: . . . . . . ":="
    7: 10: . . . . . . "range"
    7: 16: . . . . . . Expression (
    7: 16: . . . . . . . RangeExpr (
    7: 16: . . . . . . . . BinaryExpr (
    7: 16: . . . . . . . . . UnaryExpr (
    7: 16: . . . . . . . . . . PrimaryExpr (
    7: 16: . . . . . . . . . . . Operand (
    7: 16: . . . . . . . . . . . . ArrayType (
    7: 16: . . . . . . . . . . . . . "["
    7: 17: . . . . . . . . . . . . . Expression (
    7: 17: . . . . . . . . . . . . . . BinaryExpr (
    7: 17: . . . . . . . . . . . . . . . UnaryExpr (
    7: 17: . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 17: . . . . . . . . . . . . . . . . . Operand (
    7: 17: . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    7: 18: . . . . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . )
    7: 18: . . . . . . . . . . . . . "]"
 /app/parser/parser.go:902: ast.SliceLit{Elts: [0xc00012ced0]}
    7: 20: . . . . . . . . . . . . )
    7: 20: . . . . . . . . . . . )
    7: 20: . . . . . . . . . . )
    7: 20: . . . . . . . . . )
    7: 20: . . . . . . . . )
    7: 20: . . . . . . . )
    7: 20: . . . . . . )
    7: 20: . . . . . )
    7: 20: . . . . . BlockStmt (
    7: 20: . . . . . . "{"
    8:  1: . . . . . . StatementList (
    8:  1: . . . . . . )
    8:  1: . . . . . . "}"
    8:  2: . . . . . )
    8:  2: . . . . . ";"
   10:  1: . . . . )
   10:  1: . . . )
   10:  1: . . . Statement (
   10:  1: . . . . SimpleStmt (
   10:  1: . . . . . ExpressionList (
   10:  1: . . . . . . Expression (
   10:  1: . . . . . . . BinaryExpr (
   10:  1: . . . . . . . . UnaryExpr (
   10:  1: . . . . . . . . . PrimaryExpr (
   10:  1: . . . . . . . . . . Operand (
   10:  1: . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   10:  5: . . . . . . . . . . )
   10:  5: . . . . . . . . . )
   10:  5: . . . . . . . . )
   10:  5: . . . . . . . )
   10:  5: . . . . . . )
   10:  5: . . . . . )
   10:  5: . . . . . ":="
   10:  8: . . . . . ExpressionList (
   10:  8: . . . . . . Expression (
   10:  8: . . . . . . . BinaryExpr (
   10:  8: . . . . . . . . UnaryExpr (
   10:  8: . . . . . . . . . PrimaryExpr (
   10:  8: . . . . . . . . . . Operand (
   10:  8: . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   10:  9: . . . . . . . . . . )
   10:  9: . . . . . . . . . )
   10:  9: . . . . . . . . )
   10:  9: . . . . . . . )
   10:  9: . . . . . . )
   10:  9: . . . . . )
   10:  9: . . . . )
   10:  9: . . . . ";"
   11:  1: . . . )
   11:  1: . . . Statement (
   11:  1: . . . . ForStmt (
   11:  1: . . . . . "for"
   11:  5: . . . . . SimpleStmt (
   11:  5: . . . . . . ExpressionList (
   11:  5: . . . . . . . Expression (
   11:  5: . . . . . . . . BinaryExpr (
   11:  5: . . . . . . . . . UnaryExpr (
   11:  5: . . . . . . . . . . PrimaryExpr (
   11:  5: . . . . . . . . . . . Operand (
   11:  5: . . . . . . . . . . . . IDENT _
 /app/parser/parser.go:713: ast.Ident{Name: _}
   11:  6: . . . . . . . . . . . )
   11:  6: . . . . . . . . . . )
   11:  6: . . . . . . . . . )
   11:  6: . . . . . . . . )
   11:  6: . . . . . . . )
   11:  6: . . . . . . . ","
   11:  8: . . . . . . . Expression (
   11:  8: . . . . . . . . BinaryExpr (
   11:  8: . . . . . . . . . UnaryExpr (
   11:  8: . . . . . . . . . . PrimaryExpr (
   11:  8: . . . . . . . . . . . Operand (
   11:  8: . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   11: 10: . . . . . . . . . . . )
   11: 10: . . . . . . . . . . )
   11: 10: . . . . . . . . . )
   11: 10: . . . . . . . . )
   11: 10: . . . . . . . )
   11: 10: . . . . . . )
   11: 10: . . . . . . ":="
   11: 13: . . . . . . "range"
   11: 19: . . . . . . Expression (
   11: 19: . . . . . . . RangeExpr (
   11: 19: . . . . . . . . BinaryExpr (
   11: 19: . . . . . . . . . UnaryExpr (
   11: 19: . . . . . . . . . . PrimaryExpr (
   11: 19: . . . . . . . . . . . Operand (
   11: 19: . . . . . . . . . . . . ArrayType (
   11: 19: . . . . . . . . . . . . . "["
   11: 20: . . . . . . . . . . . . . Expression (
   11: 20: . . . . . . . . . . . . . . BinaryExpr (
   11: 20: . . . . . . . . . . . . . . . UnaryExpr (
   11: 20: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 20: . . . . . . . . . . . . . . . . . Operand (
   11: 20: . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   11: 21: . . . . . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . )
   11: 21: . . . . . . . . . . . . . ","
   11: 23: . . . . . . . . . . . . . Expression (
   11: 23: . . . . . . . . . . . . . . BinaryExpr (
   11: 23: . . . . . . . . . . . . . . . UnaryExpr (
   11: 23: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 23: . . . . . . . . . . . . . . . . . Operand (
   11: 23: . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
   11: 24: . . . . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . )
   11: 24: . . . . . . . . . . . . . ","
   11: 26: . . . . . . . . . . . . . Expression (
   11: 26: . . . . . . . . . . . . . . BinaryExpr (
   11: 26: . . . . . . . . . . . . . . . UnaryExpr (
   11: 26: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 26: . . . . . . . . . . . . . . . . . Operand (
   11: 26: . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
   11: 27: . . . . . . . . . . . . . . . . . )
   11: 27: . . . . . . . . . . . . . . . . )
   11: 27: . . . . . . . . . . . . . . . )
   11: 27: . . . . . . . . . . . . . . )
   11: 27: . . . . . . . . . . . . . )
   11: 27: . . . . . . . . . . . . . ","
   11: 29: . . . . . . . . . . . . . Expression (
   11: 29: . . . . . . . . . . . . . . BinaryExpr (
   11: 29: . . . . . . . . . . . . . . . UnaryExpr (
   11: 29: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 29: . . . . . . . . . . . . . . . . . Operand (
   11: 29: . . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
   11: 30: . . . . . . . . . . . . . . . . . )
   11: 30: . . . . . . . . . . . . . . . . )
   11: 30: . . . . . . . . . . . . . . . )
   11: 30: . . . . . . . . . . . . . . )
   11: 30: . . . . . . . . . . . . . )
   11: 30: . . . . . . . . . . . . . ","
   11: 32: . . . . . . . . . . . . . Expression (
   11: 32: . . . . . . . . . . . . . . BinaryExpr (
   11: 32: . . . . . . . . . . . . . . . UnaryExpr (
   11: 32: . . . . . . . . . . . . . . . . PrimaryExpr (
   11: 32: . . . . . . . . . . . . . . . . . Operand (
   11: 32: . . . . . . . . . . . . . . . . . . INT 11
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 11}
   11: 34: . . . . . . . . . . . . . . . . . )
   11: 34: . . . . . . . . . . . . . . . . )
   11: 34: . . . . . . . . . . . . . . . )
   11: 34: . . . . . . . . . . . . . . )
   11: 34: . . . . . . . . . . . . . )
   11: 34: . . . . . . . . . . . . . "]"
   11: 36: . . . . . . . . . . . . )
   11: 36: . . . . . . . . . . . )
   11: 36: . . . . . . . . . . )
   11: 36: . . . . . . . . . )
   11: 36: . . . . . . . . )
   11: 36: . . . . . . . )
   11: 36: . . . . . . )
   11: 36: . . . . . )
   11: 36: . . . . . BlockStmt (
   11: 36: . . . . . . "{"
   12:  2: . . . . . . StatementList (
   12:  2: . . . . . . . Statement (
   12:  2: . . . . . . . . IfStmt (
   12:  2: . . . . . . . . . "if"
   12:  5: . . . . . . . . . SimpleStmt (
   12:  5: . . . . . . . . . . ExpressionList (
   12:  5: . . . . . . . . . . . Expression (
   12:  5: . . . . . . . . . . . . BinaryExpr (
   12:  5: . . . . . . . . . . . . . UnaryExpr (
   12:  5: . . . . . . . . . . . . . . PrimaryExpr (
   12:  5: . . . . . . . . . . . . . . . Operand (
   12:  5: . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   12:  7: . . . . . . . . . . . . . . . )
   12:  7: . . . . . . . . . . . . . . )
   12:  7: . . . . . . . . . . . . . )
   12:  7: . . . . . . . . . . . . . ">"
   12:  9: . . . . . . . . . . . . . BinaryExpr (
   12:  9: . . . . . . . . . . . . . . UnaryExpr (
   12:  9: . . . . . . . . . . . . . . . PrimaryExpr (
   12:  9: . . . . . . . . . . . . . . . . Operand (
   12:  9: . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
   12: 11: . . . . . . . . . . . . . . . . )
   12: 11: . . . . . . . . . . . . . . . )
   12: 11: . . . . . . . . . . . . . . )
   12: 11: . . . . . . . . . . . . . )
   12: 11: . . . . . . . . . . . . )
   12: 11: . . . . . . . . . . . )
   12: 11: . . . . . . . . . . )
   12: 11: . . . . . . . . . )
   12: 11: . . . . . . . . . BlockStmt (
   12: 11: . . . . . . . . . . "{"
   13:  3: . . . . . . . . . . StatementList (
   13:  3: . . . . . . . . . . . Statement (
   13:  3: . . . . . . . . . . . . SimpleStmt (
   13:  3: . . . . . . . . . . . . . ExpressionList (
   13:  3: . . . . . . . . . . . . . . Expression (
   13:  3: . . . . . . . . . . . . . . . BinaryExpr (
   13:  3: . . . . . . . . . . . . . . . . UnaryExpr (
   13:  3: . . . . . . . . . . . . . . . . . PrimaryExpr (
   13:  3: . . . . . . . . . . . . . . . . . . Operand (
   13:  3: . . . . . . . . . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   13:  7: . . . . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . )
   13:  7: . . . . . . . . . . . . . "+="
   13: 10: . . . . . . . . . . . . . ExpressionList (
   13: 10: . . . . . . . . . . . . . . Expression (
   13: 10: . . . . . . . . . . . . . . . BinaryExpr (
   13: 10: . . . . . . . . . . . . . . . . UnaryExpr (
   13: 10: . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 10: . . . . . . . . . . . . . . . . . . Operand (
   13: 10: . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   13: 11: . . . . . . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . )
   13: 11: . . . . . . . . . . . . ";"
   14:  2: . . . . . . . . . . . )
   14:  2: . . . . . . . . . . )
   14:  2: . . . . . . . . . . "}"
   14:  3: . . . . . . . . . )
   14:  3: . . . . . . . . . ";"
   15:  1: . . . . . . . . )
   15:  1: . . . . . . . )
   15:  1: . . . . . . )
   15:  1: . . . . . . "}"
   15:  2: . . . . . )
   15:  2: . . . . . ";"
   16:  1: . . . . )
   16:  1: . . . )
   16:  1: . . . Statement (
   16:  1: . . . . SimpleStmt (
   16:  1: . . . . . ExpressionList (
   16:  1: . . . . . . Expression (
   16:  1: . . . . . . . BinaryExpr (
   16:  1: . . . . . . . . UnaryExpr (
   16:  1: . . . . . . . . . PrimaryExpr (
   16:  1: . . . . . . . . . . Operand (
   16:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   16:  8: . . . . . . . . . . )
   16:  8: . . . . . . . . . . CallOrConversion (
   16:  8: . . . . . . . . . . . "("
   16:  9: . . . . . . . . . . . Expression (
   16:  9: . . . . . . . . . . . . BinaryExpr (
   16:  9: . . . . . . . . . . . . . UnaryExpr (
   16:  9: . . . . . . . . . . . . . . PrimaryExpr (
   16:  9: . . . . . . . . . . . . . . . Operand (
   16:  9: . . . . . . . . . . . . . . . . STRING "sum(1,3,5,7,11):"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "sum(1,3,5,7,11):"}
   16: 27: . . . . . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . )
   16: 27: . . . . . . . . . . . ","
   16: 29: . . . . . . . . . . . Expression (
   16: 29: . . . . . . . . . . . . BinaryExpr (
   16: 29: . . . . . . . . . . . . . UnaryExpr (
   16: 29: . . . . . . . . . . . . . . PrimaryExpr (
   16: 29: . . . . . . . . . . . . . . . Operand (
   16: 29: . . . . . . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   16: 32: . . . . . . . . . . . . . . . )
   16: 32: . . . . . . . . . . . . . . )
   16: 32: . . . . . . . . . . . . . )
   16: 32: . . . . . . . . . . . . )
   16: 32: . . . . . . . . . . . )
   16: 32: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   16: 33: . . . . . . . . . . )
   16: 33: . . . . . . . . . )
   16: 33: . . . . . . . . )
   16: 33: . . . . . . . )
   16: 33: . . . . . . )
   16: 33: . . . . . )
   16: 33: . . . . )
   16: 33: . . . . ";"
   18:  1: . . . )
   18:  1: . . . Statement (
   18:  1: . . . . SimpleStmt (
   18:  1: . . . . . ExpressionList (
   18:  1: . . . . . . Expression (
   18:  1: . . . . . . . BinaryExpr (
   18:  1: . . . . . . . . UnaryExpr (
   18:  1: . . . . . . . . . PrimaryExpr (
   18:  1: . . . . . . . . . . Operand (
   18:  1: . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   18:  5: . . . . . . . . . . )
   18:  5: . . . . . . . . . )
   18:  5: . . . . . . . . )
   18:  5: . . . . . . . )
   18:  5: . . . . . . )
   18:  5: . . . . . )
   18:  5: . . . . . "="
   18:  7: . . . . . ExpressionList (
   18:  7: . . . . . . Expression (
   18:  7: . . . . . . . BinaryExpr (
   18:  7: . . . . . . . . UnaryExpr (
   18:  7: . . . . . . . . . PrimaryExpr (
   18:  7: . . . . . . . . . . Operand (
   18:  7: . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   18:  8: . . . . . . . . . . )
   18:  8: . . . . . . . . . )
   18:  8: . . . . . . . . )
   18:  8: . . . . . . . )
   18:  8: . . . . . . )
   18:  8: . . . . . )
   18:  8: . . . . )
   18:  8: . . . . ";"
   19:  1: . . . )
   19:  1: . . . Statement (
   19:  1: . . . . ForStmt (
   19:  1: . . . . . "for"
   19:  5: . . . . . SimpleStmt (
   19:  5: . . . . . . ExpressionList (
   19:  5: . . . . . . . Expression (
   19:  5: . . . . . . . . BinaryExpr (
   19:  5: . . . . . . . . . UnaryExpr (
   19:  5: . . . . . . . . . . PrimaryExpr (
   19:  5: . . . . . . . . . . . Operand (
   19:  5: . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   19:  7: . . . . . . . . . . . )
   19:  7: . . . . . . . . . . )
   19:  7: . . . . . . . . . )
   19:  7: . . . . . . . . )
   19:  7: . . . . . . . )
   19:  7: . . . . . . )
   19:  7: . . . . . . ":="
   19: 10: . . . . . . ExpressionList (
   19: 10: . . . . . . . Expression (
   19: 10: . . . . . . . . BinaryExpr (
   19: 10: . . . . . . . . . UnaryExpr (
   19: 10: . . . . . . . . . . PrimaryExpr (
   19: 10: . . . . . . . . . . . Operand (
   19: 10: . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   19: 11: . . . . . . . . . . . )
   19: 11: . . . . . . . . . . )
   19: 11: . . . . . . . . . )
   19: 11: . . . . . . . . )
   19: 11: . . . . . . . )
   19: 11: . . . . . . )
   19: 11: . . . . . )
   19: 11: . . . . . ";"
   19: 13: . . . . . SimpleStmt (
   19: 13: . . . . . . ExpressionList (
   19: 13: . . . . . . . Expression (
   19: 13: . . . . . . . . BinaryExpr (
   19: 13: . . . . . . . . . UnaryExpr (
   19: 13: . . . . . . . . . . PrimaryExpr (
   19: 13: . . . . . . . . . . . Operand (
   19: 13: . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   19: 15: . . . . . . . . . . . )
   19: 15: . . . . . . . . . . )
   19: 15: . . . . . . . . . )
   19: 15: . . . . . . . . . "<"
   19: 17: . . . . . . . . . BinaryExpr (
   19: 17: . . . . . . . . . . UnaryExpr (
   19: 17: . . . . . . . . . . . PrimaryExpr (
   19: 17: . . . . . . . . . . . . Operand (
   19: 17: . . . . . . . . . . . . . INT 100
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 100}
   19: 20: . . . . . . . . . . . . )
   19: 20: . . . . . . . . . . . )
   19: 20: . . . . . . . . . . )
   19: 20: . . . . . . . . . )
   19: 20: . . . . . . . . )
   19: 20: . . . . . . . )
   19: 20: . . . . . . )
   19: 20: . . . . . )
   19: 20: . . . . . ";"
   19: 22: . . . . . SimpleStmt (
   19: 22: . . . . . . ExpressionList (
   19: 22: . . . . . . . Expression (
   19: 22: . . . . . . . . BinaryExpr (
   19: 22: . . . . . . . . . UnaryExpr (
   19: 22: . . . . . . . . . . PrimaryExpr (
   19: 22: . . . . . . . . . . . Operand (
   19: 22: . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   19: 23: . . . . . . . . . . . )
   19: 23: . . . . . . . . . . )
   19: 23: . . . . . . . . . )
   19: 23: . . . . . . . . )
   19: 23: . . . . . . . )
   19: 23: . . . . . . )
   19: 23: . . . . . . "++"
   19: 26: . . . . . )
   19: 26: . . . . . BlockStmt (
   19: 26: . . . . . . "{"
   20:  2: . . . . . . StatementList (
   20:  2: . . . . . . . Statement (
   20:  2: . . . . . . . . SimpleStmt (
   20:  2: . . . . . . . . . ExpressionList (
   20:  2: . . . . . . . . . . Expression (
   20:  2: . . . . . . . . . . . BinaryExpr (
   20:  2: . . . . . . . . . . . . UnaryExpr (
   20:  2: . . . . . . . . . . . . . PrimaryExpr (
   20:  2: . . . . . . . . . . . . . . Operand (
   20:  2: . . . . . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   20:  6: . . . . . . . . . . . . . . )
   20:  6: . . . . . . . . . . . . . )
   20:  6: . . . . . . . . . . . . )
   20:  6: . . . . . . . . . . . )
   20:  6: . . . . . . . . . . )
   20:  6: . . . . . . . . . )
   20:  6: . . . . . . . . . "+="
   20:  9: . . . . . . . . . ExpressionList (
   20:  9: . . . . . . . . . . Expression (
   20:  9: . . . . . . . . . . . BinaryExpr (
   20:  9: . . . . . . . . . . . . UnaryExpr (
   20:  9: . . . . . . . . . . . . . PrimaryExpr (
   20:  9: . . . . . . . . . . . . . . Operand (
   20:  9: . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   20: 10: . . . . . . . . . . . . . . )
   20: 10: . . . . . . . . . . . . . )
   20: 10: . . . . . . . . . . . . )
   20: 10: . . . . . . . . . . . )
   20: 10: . . . . . . . . . . )
   20: 10: . . . . . . . . . )
   20: 10: . . . . . . . . )
   20: 10: . . . . . . . . ";"
   21:  1: . . . . . . . )
   21:  1: . . . . . . )
   21:  1: . . . . . . "}"
   21:  2: . . . . . )
   21:  2: . . . . . ";"
   22:  1: . . . . )
   22:  1: . . . )
   22:  1: . . . Statement (
   22:  1: . . . . SimpleStmt (
   22:  1: . . . . . ExpressionList (
   22:  1: . . . . . . Expression (
   22:  1: . . . . . . . BinaryExpr (
   22:  1: . . . . . . . . UnaryExpr (
   22:  1: . . . . . . . . . PrimaryExpr (
   22:  1: . . . . . . . . . . Operand (
   22:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   22:  8: . . . . . . . . . . )
   22:  8: . . . . . . . . . . CallOrConversion (
   22:  8: . . . . . . . . . . . "("
   22:  9: . . . . . . . . . . . Expression (
   22:  9: . . . . . . . . . . . . BinaryExpr (
   22:  9: . . . . . . . . . . . . . UnaryExpr (
   22:  9: . . . . . . . . . . . . . . PrimaryExpr (
   22:  9: . . . . . . . . . . . . . . . Operand (
   22:  9: . . . . . . . . . . . . . . . . STRING "sum(1-100):"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "sum(1-100):"}
   22: 22: . . . . . . . . . . . . . . . )
   22: 22: . . . . . . . . . . . . . . )
   22: 22: . . . . . . . . . . . . . )
   22: 22: . . . . . . . . . . . . )
   22: 22: . . . . . . . . . . . )
   22: 22: . . . . . . . . . . . ","
   22: 24: . . . . . . . . . . . Expression (
   22: 24: . . . . . . . . . . . . BinaryExpr (
   22: 24: . . . . . . . . . . . . . UnaryExpr (
   22: 24: . . . . . . . . . . . . . . PrimaryExpr (
   22: 24: . . . . . . . . . . . . . . . Operand (
   22: 24: . . . . . . . . . . . . . . . . IDENT sum
 /app/parser/parser.go:713: ast.Ident{Name: sum}
   22: 27: . . . . . . . . . . . . . . . )
   22: 27: . . . . . . . . . . . . . . )
   22: 27: . . . . . . . . . . . . . )
   22: 27: . . . . . . . . . . . . )
   22: 27: . . . . . . . . . . . )
   22: 27: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   22: 28: . . . . . . . . . . )
   22: 28: . . . . . . . . . )
   22: 28: . . . . . . . . )
   22: 28: . . . . . . . )
   22: 28: . . . . . . )
   22: 28: . . . . . )
   22: 28: . . . . )
   22: 28: . . . . ";"
   24:  1: . . . )
   24:  1: . . . Statement (
   24:  1: . . . . ForStmt (
   24:  1: . . . . . "for"
   24:  5: . . . . . SimpleStmt (
   24:  5: . . . . . . ExpressionList (
   24:  5: . . . . . . . Expression (
   24:  5: . . . . . . . . BinaryExpr (
   24:  5: . . . . . . . . . UnaryExpr (
   24:  5: . . . . . . . . . . PrimaryExpr (
   24:  5: . . . . . . . . . . . Operand (
   24:  5: . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   24:  7: . . . . . . . . . . . )
   24:  7: . . . . . . . . . . )
   24:  7: . . . . . . . . . )
   24:  7: . . . . . . . . )
   24:  7: . . . . . . . )
   24:  7: . . . . . . )
   24:  7: . . . . . . "<-"
   24: 10: . . . . . . Expression (
   24: 10: . . . . . . . RangeExpr (
   24: 10: . . . . . . . . BinaryExpr (
   24: 10: . . . . . . . . . UnaryExpr (
   24: 10: . . . . . . . . . . PrimaryExpr (
   24: 10: . . . . . . . . . . . Operand (
   24: 10: . . . . . . . . . . . . ArrayType (
   24: 10: . . . . . . . . . . . . . "["
   24: 11: . . . . . . . . . . . . . Expression (
   24: 11: . . . . . . . . . . . . . . BinaryExpr (
   24: 11: . . . . . . . . . . . . . . . UnaryExpr (
   24: 11: . . . . . . . . . . . . . . . . PrimaryExpr (
   24: 11: . . . . . . . . . . . . . . . . . Operand (
   24: 11: . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   24: 12: . . . . . . . . . . . . . . . . . )
   24: 12: . . . . . . . . . . . . . . . . )
   24: 12: . . . . . . . . . . . . . . . )
   24: 12: . . . . . . . . . . . . . . )
   24: 12: . . . . . . . . . . . . . )
   24: 12: . . . . . . . . . . . . . "]"
 /app/parser/parser.go:902: ast.SliceLit{Elts: [0xc00012d440]}
   24: 14: . . . . . . . . . . . . )
   24: 14: . . . . . . . . . . . )
   24: 14: . . . . . . . . . . )
   24: 14: . . . . . . . . . )
   24: 14: . . . . . . . . )
   24: 14: . . . . . . . )
   24: 14: . . . . . . )
   24: 14: . . . . . )
   24: 14: . . . . . BlockStmt (
   24: 14: . . . . . . "{"
   25:  2: . . . . . . StatementList (
   25:  2: . . . . . . . Statement (
   25:  2: . . . . . . . . SimpleStmt (
   25:  2: . . . . . . . . . ExpressionList (
   25:  2: . . . . . . . . . . Expression (
   25:  2: . . . . . . . . . . . BinaryExpr (
   25:  2: . . . . . . . . . . . . UnaryExpr (
   25:  2: . . . . . . . . . . . . . PrimaryExpr (
   25:  2: . . . . . . . . . . . . . . Operand (
   25:  2: . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   25:  9: . . . . . . . . . . . . . . )
   25:  9: . . . . . . . . . . . . . . CallOrConversion (
   25:  9: . . . . . . . . . . . . . . . "("
   25: 10: . . . . . . . . . . . . . . . Expression (
   25: 10: . . . . . . . . . . . . . . . . BinaryExpr (
   25: 10: . . . . . . . . . . . . . . . . . UnaryExpr (
   25: 10: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   25: 10: . . . . . . . . . . . . . . . . . . . Operand (
   25: 10: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   25: 11: . . . . . . . . . . . . . . . . . . . )
   25: 11: . . . . . . . . . . . . . . . . . . )
   25: 11: . . . . . . . . . . . . . . . . . )
   25: 11: . . . . . . . . . . . . . . . . )
   25: 11: . . . . . . . . . . . . . . . )
   25: 11: . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   25: 12: . . . . . . . . . . . . . . )
   25: 12: . . . . . . . . . . . . . )
   25: 12: . . . . . . . . . . . . )
   25: 12: . . . . . . . . . . . )
   25: 12: . . . . . . . . . . )
   25: 12: . . . . . . . . . )
   25: 12: . . . . . . . . )
   25: 12: . . . . . . . . ";"
   26:  1: . . . . . . . )
   26:  1: . . . . . . )
   26:  1: . . . . . . "}"
   26:  2: . . . . . )
   26:  2: . . . . . ";"
   28:  1: . . . . )
   28:  1: . . . )
   28:  1: . . . Statement (
   28:  1: . . . . ForStmt (
   28:  1: . . . . . "for"
   28:  5: . . . . . SimpleStmt (
   28:  5: . . . . . . ExpressionList (
   28:  5: . . . . . . . Expression (
   28:  5: . . . . . . . . BinaryExpr (
   28:  5: . . . . . . . . . UnaryExpr (
   28:  5: . . . . . . . . . . PrimaryExpr (
   28:  5: . . . . . . . . . . . Operand (
   28:  5: . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   28:  6: . . . . . . . . . . . )
   28:  6: . . . . . . . . . . )
   28:  6: . . . . . . . . . )
   28:  6: . . . . . . . . )
   28:  6: . . . . . . . )
   28:  6: . . . . . . . ","
   28:  8: . . . . . . . Expression (
   28:  8: . . . . . . . . BinaryExpr (
   28:  8: . . . . . . . . . UnaryExpr (
   28:  8: . . . . . . . . . . PrimaryExpr (
   28:  8: . . . . . . . . . . . Operand (
   28:  8: . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   28: 10: . . . . . . . . . . . )
   28: 10: . . . . . . . . . . )
   28: 10: . . . . . . . . . )
   28: 10: . . . . . . . . )
   28: 10: . . . . . . . )
   28: 10: . . . . . . )
   28: 10: . . . . . . "<-"
   28: 13: . . . . . . Expression (
   28: 13: . . . . . . . RangeExpr (
   28: 13: . . . . . . . . BinaryExpr (
   28: 13: . . . . . . . . . UnaryExpr (
   28: 13: . . . . . . . . . . PrimaryExpr (
   28: 13: . . . . . . . . . . . Operand (
   28: 13: . . . . . . . . . . . . ArrayType (
   28: 13: . . . . . . . . . . . . . "["
   28: 14: . . . . . . . . . . . . . Expression (
   28: 14: . . . . . . . . . . . . . . BinaryExpr (
   28: 14: . . . . . . . . . . . . . . . UnaryExpr (
   28: 14: . . . . . . . . . . . . . . . . PrimaryExpr (
   28: 14: . . . . . . . . . . . . . . . . . Operand (
   28: 14: . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   28: 15: . . . . . . . . . . . . . . . . . )
   28: 15: . . . . . . . . . . . . . . . . )
   28: 15: . . . . . . . . . . . . . . . )
   28: 15: . . . . . . . . . . . . . . )
   28: 15: . . . . . . . . . . . . . )
   28: 15: . . . . . . . . . . . . . "]"
 /app/parser/parser.go:902: ast.SliceLit{Elts: [0xc00012d530]}
   28: 17: . . . . . . . . . . . . )
   28: 17: . . . . . . . . . . . )
   28: 17: . . . . . . . . . . )
   28: 17: . . . . . . . . . )
   28: 17: . . . . . . . . )
   28: 17: . . . . . . . )
   28: 17: . . . . . . )
   28: 17: . . . . . . "if"
   28: 20: . . . . . . Expression (
   28: 20: . . . . . . . BinaryExpr (
   28: 20: . . . . . . . . UnaryExpr (
   28: 20: . . . . . . . . . PrimaryExpr (
   28: 20: . . . . . . . . . . Operand (
   28: 20: . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   28: 21: . . . . . . . . . . )
   28: 21: . . . . . . . . . )
   28: 21: . . . . . . . . )
   28: 21: . . . . . . . . "%"
   28: 22: . . . . . . . . BinaryExpr (
   28: 22: . . . . . . . . . UnaryExpr (
   28: 22: . . . . . . . . . . PrimaryExpr (
   28: 22: . . . . . . . . . . . Operand (
   28: 22: . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   28: 24: . . . . . . . . . . . )
   28: 24: . . . . . . . . . . )
   28: 24: . . . . . . . . . )
   28: 24: . . . . . . . . )
   28: 24: . . . . . . . . "=="
   28: 27: . . . . . . . . BinaryExpr (
   28: 27: . . . . . . . . . UnaryExpr (
   28: 27: . . . . . . . . . . PrimaryExpr (
   28: 27: . . . . . . . . . . . Operand (
   28: 27: . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
   28: 29: . . . . . . . . . . . )
   28: 29: . . . . . . . . . . )
   28: 29: . . . . . . . . . )
   28: 29: . . . . . . . . )
   28: 29: . . . . . . . )
   28: 29: . . . . . . )
   28: 29: . . . . . )
   28: 29: . . . . . BlockStmt (
   28: 29: . . . . . . "{"
   29:  2: . . . . . . StatementList (
   29:  2: . . . . . . . Statement (
   29:  2: . . . . . . . . SimpleStmt (
   29:  2: . . . . . . . . . ExpressionList (
   29:  2: . . . . . . . . . . Expression (
   29:  2: . . . . . . . . . . . BinaryExpr (
   29:  2: . . . . . . . . . . . . UnaryExpr (
   29:  2: . . . . . . . . . . . . . PrimaryExpr (
   29:  2: . . . . . . . . . . . . . . Operand (
   29:  2: . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   29:  9: . . . . . . . . . . . . . . )
   29:  9: . . . . . . . . . . . . . . CallOrConversion (
   29:  9: . . . . . . . . . . . . . . . "("
   29: 10: . . . . . . . . . . . . . . . Expression (
   29: 10: . . . . . . . . . . . . . . . . BinaryExpr (
   29: 10: . . . . . . . . . . . . . . . . . UnaryExpr (
   29: 10: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   29: 10: . . . . . . . . . . . . . . . . . . . Operand (
   29: 10: . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   29: 11: . . . . . . . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . . . . )
   29: 11: . . . . . . . . . . . . . . . ","
   29: 13: . . . . . . . . . . . . . . . Expression (
   29: 13: . . . . . . . . . . . . . . . . BinaryExpr (
   29: 13: . . . . . . . . . . . . . . . . . UnaryExpr (
   29: 13: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   29: 13: . . . . . . . . . . . . . . . . . . . Operand (
   29: 13: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   29: 14: . . . . . . . . . . . . . . . . . . . )
   29: 14: . . . . . . . . . . . . . . . . . . )
   29: 14: . . . . . . . . . . . . . . . . . )
   29: 14: . . . . . . . . . . . . . . . . )
   29: 14: . . . . . . . . . . . . . . . )
   29: 14: . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   29: 15: . . . . . . . . . . . . . . )
   29: 15: . . . . . . . . . . . . . )
   29: 15: . . . . . . . . . . . . )
   29: 15: . . . . . . . . . . . )
   29: 15: . . . . . . . . . . )
   29: 15: . . . . . . . . . )
   29: 15: . . . . . . . . )
   29: 15: . . . . . . . . ";"
   30:  1: . . . . . . . )
   30:  1: . . . . . . )
   30:  1: . . . . . . "}"
   30:  2: . . . . . )
   30:  2: . . . . . ";"
   30:  3: . . . . )
   30:  3: . . . )
   30:  3: . . )
   30:  3: . )
   30:  3: )
=== RUN   TestFromNofmt/listcompr
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_nofmt/listcompr
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . ArrayType (
    1:  6: . . . . . . . . . . . . "["
    1:  7: . . . . . . . . . . . . Expression (
    1:  7: . . . . . . . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1:  8: . . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . "*"
    1:  9: . . . . . . . . . . . . . . BinaryExpr (
    1:  9: . . . . . . . . . . . . . . . UnaryExpr (
    1:  9: . . . . . . . . . . . . . . . . PrimaryExpr (
    1:  9: . . . . . . . . . . . . . . . . . Operand (
    1:  9: . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1: 11: . . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . ForPhrase (
    1: 11: . . . . . . . . . . . . . "for"
    1: 15: . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    1: 17: . . . . . . . . . . . . . "<-"
    1: 20: . . . . . . . . . . . . . Expression (
    1: 20: . . . . . . . . . . . . . . RangeExpr (
    1: 20: . . . . . . . . . . . . . . . BinaryExpr (
    1: 20: . . . . . . . . . . . . . . . . UnaryExpr (
    1: 20: . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 20: . . . . . . . . . . . . . . . . . . Operand (
    1: 20: . . . . . . . . . . . . . . . . . . . ArrayType (
    1: 20: . . . . . . . . . . . . . . . . . . . . "["
    1: 21: . . . . . . . . . . . . . . . . . . . . Expression (
    1: 21: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    1: 21: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    1: 21: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    1: 21: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    1: 21: . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1: 22: . . . . . . . . . . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . . . . . . )
    1: 22: . . . . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:902: ast.SliceLit{Elts: [0xc00012d980]}
    1: 23: . . . . . . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . )
    1: 23: . . . . . . . . . . . . "]"
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{x 8 * x}, Fors: [0xc00044daa0]}
    1: 24: . . . . . . . . . . . )
    1: 24: . . . . . . . . . . )
    1: 24: . . . . . . . . . )
    1: 24: . . . . . . . . )
    1: 24: . . . . . . . )
    1: 24: . . . . . . )
    1: 24: . . . . . )
    1: 24: . . . . )
    1: 24: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    2:  8: . . . . . . . . . . )
    2:  8: . . . . . . . . . . CallOrConversion (
    2:  8: . . . . . . . . . . . "("
    2:  9: . . . . . . . . . . . Expression (
    2:  9: . . . . . . . . . . . . BinaryExpr (
    2:  9: . . . . . . . . . . . . . UnaryExpr (
    2:  9: . . . . . . . . . . . . . . PrimaryExpr (
    2:  9: . . . . . . . . . . . . . . . Operand (
    2:  9: . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    2: 10: . . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . )
    2: 10: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    2: 11: . . . . . . . . . . )
    2: 11: . . . . . . . . . )
    2: 11: . . . . . . . . )
    2: 11: . . . . . . . )
    2: 11: . . . . . . )
    2: 11: . . . . . )
    2: 11: . . . . )
    2: 11: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    4:  3: . . . . . . . . . . )
    4:  3: . . . . . . . . . )
    4:  3: . . . . . . . . )
    4:  3: . . . . . . . )
    4:  3: . . . . . . )
    4:  3: . . . . . )
    4:  3: . . . . . "="
    4:  5: . . . . . ExpressionList (
    4:  5: . . . . . . Expression (
    4:  5: . . . . . . . BinaryExpr (
    4:  5: . . . . . . . . UnaryExpr (
    4:  5: . . . . . . . . . PrimaryExpr (
    4:  5: . . . . . . . . . . Operand (
    4:  5: . . . . . . . . . . . ArrayType (
    4:  5: . . . . . . . . . . . . "["
    4:  6: . . . . . . . . . . . . Expression (
    4:  6: . . . . . . . . . . . . . BinaryExpr (
    4:  6: . . . . . . . . . . . . . . UnaryExpr (
    4:  6: . . . . . . . . . . . . . . . PrimaryExpr (
    4:  6: . . . . . . . . . . . . . . . . Operand (
    4:  6: . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4:  7: . . . . . . . . . . . . . . . . )
    4:  7: . . . . . . . . . . . . . . . )
    4:  7: . . . . . . . . . . . . . . )
    4:  7: . . . . . . . . . . . . . . "*"
    4:  8: . . . . . . . . . . . . . . BinaryExpr (
    4:  8: . . . . . . . . . . . . . . . UnaryExpr (
    4:  8: . . . . . . . . . . . . . . . . PrimaryExpr (
    4:  8: . . . . . . . . . . . . . . . . . Operand (
    4:  8: . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4: 10: . . . . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . )
    4: 10: . . . . . . . . . . . . ForPhrase (
    4: 10: . . . . . . . . . . . . . "for"
    4: 14: . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4: 16: . . . . . . . . . . . . . "<-"
    4: 19: . . . . . . . . . . . . . Expression (
    4: 19: . . . . . . . . . . . . . . RangeExpr (
    4: 19: . . . . . . . . . . . . . . . BinaryExpr (
    4: 19: . . . . . . . . . . . . . . . . UnaryExpr (
    4: 19: . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 19: . . . . . . . . . . . . . . . . . . Operand (
    4: 19: . . . . . . . . . . . . . . . . . . . ArrayType (
    4: 19: . . . . . . . . . . . . . . . . . . . . "["
    4: 20: . . . . . . . . . . . . . . . . . . . . Expression (
    4: 20: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 20: . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    4: 21: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . . . . . . . . . ","
    4: 23: . . . . . . . . . . . . . . . . . . . . Expression (
    4: 23: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 23: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 23: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 23: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 23: . . . . . . . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    4: 24: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 24: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 24: . . . . . . . . . . . . . . . . . . . . . . )
    4: 24: . . . . . . . . . . . . . . . . . . . . . )
    4: 24: . . . . . . . . . . . . . . . . . . . . )
    4: 24: . . . . . . . . . . . . . . . . . . . . ","
    4: 26: . . . . . . . . . . . . . . . . . . . . Expression (
    4: 26: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 26: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 26: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 26: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 26: . . . . . . . . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    4: 27: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 27: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 27: . . . . . . . . . . . . . . . . . . . . . . )
    4: 27: . . . . . . . . . . . . . . . . . . . . . )
    4: 27: . . . . . . . . . . . . . . . . . . . . )
    4: 27: . . . . . . . . . . . . . . . . . . . . ","
    4: 29: . . . . . . . . . . . . . . . . . . . . Expression (
    4: 29: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 29: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 29: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 29: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 29: . . . . . . . . . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . )
    4: 30: . . . . . . . . . . . . . . . . . . . . ","
    4: 32: . . . . . . . . . . . . . . . . . . . . Expression (
    4: 32: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 32: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 32: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 32: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    4: 32: . . . . . . . . . . . . . . . . . . . . . . . . . INT 11
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 11}
    4: 34: . . . . . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . . )
    4: 34: . . . . . . . . . . . . . . . . . . . . "]"
    4: 36: . . . . . . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . )
    4: 36: . . . . . . . . . . . . . "if"
    4: 39: . . . . . . . . . . . . . SimpleStmt (
    4: 39: . . . . . . . . . . . . . . ExpressionList (
    4: 39: . . . . . . . . . . . . . . . Expression (
    4: 39: . . . . . . . . . . . . . . . . BinaryExpr (
    4: 39: . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 39: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 39: . . . . . . . . . . . . . . . . . . . Operand (
    4: 39: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    4: 41: . . . . . . . . . . . . . . . . . . . )
    4: 41: . . . . . . . . . . . . . . . . . . )
    4: 41: . . . . . . . . . . . . . . . . . )
    4: 41: . . . . . . . . . . . . . . . . . ">"
    4: 43: . . . . . . . . . . . . . . . . . BinaryExpr (
    4: 43: . . . . . . . . . . . . . . . . . . UnaryExpr (
    4: 43: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    4: 43: . . . . . . . . . . . . . . . . . . . . Operand (
    4: 43: . . . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    4: 44: . . . . . . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . )
    4: 44: . . . . . . . . . . . . "]"
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{x 43 * x}, Fors: [0xc00044db60]}
    4: 45: . . . . . . . . . . . )
    4: 45: . . . . . . . . . . )
    4: 45: . . . . . . . . . )
    4: 45: . . . . . . . . )
    4: 45: . . . . . . . )
    4: 45: . . . . . . )
    4: 45: . . . . . )
    4: 45: . . . . )
    4: 45: . . . . ";"
    5:  1: . . . )
    5:  1: . . . Statement (
    5:  1: . . . . SimpleStmt (
    5:  1: . . . . . ExpressionList (
    5:  1: . . . . . . Expression (
    5:  1: . . . . . . . BinaryExpr (
    5:  1: . . . . . . . . UnaryExpr (
    5:  1: . . . . . . . . . PrimaryExpr (
    5:  1: . . . . . . . . . . Operand (
    5:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5:  8: . . . . . . . . . . )
    5:  8: . . . . . . . . . . CallOrConversion (
    5:  8: . . . . . . . . . . . "("
    5:  9: . . . . . . . . . . . Expression (
    5:  9: . . . . . . . . . . . . BinaryExpr (
    5:  9: . . . . . . . . . . . . . UnaryExpr (
    5:  9: . . . . . . . . . . . . . . PrimaryExpr (
    5:  9: . . . . . . . . . . . . . . . Operand (
    5:  9: . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    5: 10: . . . . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    5: 11: . . . . . . . . . . )
    5: 11: . . . . . . . . . )
    5: 11: . . . . . . . . )
    5: 11: . . . . . . . )
    5: 11: . . . . . . )
    5: 11: . . . . . )
    5: 11: . . . . )
    5: 11: . . . . ";"
    7:  1: . . . )
    7:  1: . . . Statement (
    7:  1: . . . . SimpleStmt (
    7:  1: . . . . . ExpressionList (
    7:  1: . . . . . . Expression (
    7:  1: . . . . . . . BinaryExpr (
    7:  1: . . . . . . . . UnaryExpr (
    7:  1: . . . . . . . . . PrimaryExpr (
    7:  1: . . . . . . . . . . Operand (
    7:  1: . . . . . . . . . . . IDENT z
 /app/parser/parser.go:713: ast.Ident{Name: z}
    7:  3: . . . . . . . . . . )
    7:  3: . . . . . . . . . )
    7:  3: . . . . . . . . )
    7:  3: . . . . . . . )
    7:  3: . . . . . . )
    7:  3: . . . . . )
    7:  3: . . . . . ":="
    7:  6: . . . . . ExpressionList (
    7:  6: . . . . . . Expression (
    7:  6: . . . . . . . BinaryExpr (
    7:  6: . . . . . . . . UnaryExpr (
    7:  6: . . . . . . . . . PrimaryExpr (
    7:  6: . . . . . . . . . . Operand (
    7:  6: . . . . . . . . . . . ArrayType (
    7:  6: . . . . . . . . . . . . "["
    7:  7: . . . . . . . . . . . . Expression (
    7:  7: . . . . . . . . . . . . . BinaryExpr (
    7:  7: . . . . . . . . . . . . . . UnaryExpr (
    7:  7: . . . . . . . . . . . . . . . PrimaryExpr (
    7:  7: . . . . . . . . . . . . . . . . Operand (
    7:  7: . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    7:  8: . . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . )
    7:  8: . . . . . . . . . . . . . . "+"
    7:  9: . . . . . . . . . . . . . . BinaryExpr (
    7:  9: . . . . . . . . . . . . . . . UnaryExpr (
    7:  9: . . . . . . . . . . . . . . . . PrimaryExpr (
    7:  9: . . . . . . . . . . . . . . . . . Operand (
    7:  9: . . . . . . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
    7: 11: . . . . . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . )
    7: 11: . . . . . . . . . . . . ForPhrase (
    7: 11: . . . . . . . . . . . . . "for"
    7: 15: . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    7: 16: . . . . . . . . . . . . . ","
    7: 18: . . . . . . . . . . . . . IDENT v
 /app/parser/parser.go:713: ast.Ident{Name: v}
    7: 20: . . . . . . . . . . . . . "<-"
    7: 23: . . . . . . . . . . . . . Expression (
    7: 23: . . . . . . . . . . . . . . RangeExpr (
    7: 23: . . . . . . . . . . . . . . . BinaryExpr (
    7: 23: . . . . . . . . . . . . . . . . UnaryExpr (
    7: 23: . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 23: . . . . . . . . . . . . . . . . . . Operand (
    7: 23: . . . . . . . . . . . . . . . . . . . ArrayType (
    7: 23: . . . . . . . . . . . . . . . . . . . . "["
    7: 24: . . . . . . . . . . . . . . . . . . . . Expression (
    7: 24: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 24: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 24: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 24: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    7: 24: . . . . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    7: 25: . . . . . . . . . . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . . . . . . . )
    7: 25: . . . . . . . . . . . . . . . . . . . . ","
    7: 27: . . . . . . . . . . . . . . . . . . . . Expression (
    7: 27: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 27: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 27: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 27: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    7: 27: . . . . . . . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    7: 28: . . . . . . . . . . . . . . . . . . . . . . . . )
    7: 28: . . . . . . . . . . . . . . . . . . . . . . . )
    7: 28: . . . . . . . . . . . . . . . . . . . . . . )
    7: 28: . . . . . . . . . . . . . . . . . . . . . )
    7: 28: . . . . . . . . . . . . . . . . . . . . )
    7: 28: . . . . . . . . . . . . . . . . . . . . ","
    7: 30: . . . . . . . . . . . . . . . . . . . . Expression (
    7: 30: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 30: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 30: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 30: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    7: 30: . . . . . . . . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    7: 31: . . . . . . . . . . . . . . . . . . . . . . . . )
    7: 31: . . . . . . . . . . . . . . . . . . . . . . . )
    7: 31: . . . . . . . . . . . . . . . . . . . . . . )
    7: 31: . . . . . . . . . . . . . . . . . . . . . )
    7: 31: . . . . . . . . . . . . . . . . . . . . )
    7: 31: . . . . . . . . . . . . . . . . . . . . ","
    7: 33: . . . . . . . . . . . . . . . . . . . . Expression (
    7: 33: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 33: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 33: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 33: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    7: 33: . . . . . . . . . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    7: 34: . . . . . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . )
    7: 34: . . . . . . . . . . . . . . . . . . . . ","
    7: 36: . . . . . . . . . . . . . . . . . . . . Expression (
    7: 36: . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 36: . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 36: . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 36: . . . . . . . . . . . . . . . . . . . . . . . . Operand (
    7: 36: . . . . . . . . . . . . . . . . . . . . . . . . . INT 11
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 11}
    7: 38: . . . . . . . . . . . . . . . . . . . . . . . . )
    7: 38: . . . . . . . . . . . . . . . . . . . . . . . )
    7: 38: . . . . . . . . . . . . . . . . . . . . . . )
    7: 38: . . . . . . . . . . . . . . . . . . . . . )
    7: 38: . . . . . . . . . . . . . . . . . . . . )
    7: 38: . . . . . . . . . . . . . . . . . . . . "]"
    7: 40: . . . . . . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . )
    7: 40: . . . . . . . . . . . . . "if"
    7: 43: . . . . . . . . . . . . . SimpleStmt (
    7: 43: . . . . . . . . . . . . . . ExpressionList (
    7: 43: . . . . . . . . . . . . . . . Expression (
    7: 43: . . . . . . . . . . . . . . . . BinaryExpr (
    7: 43: . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 43: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 43: . . . . . . . . . . . . . . . . . . . Operand (
    7: 43: . . . . . . . . . . . . . . . . . . . . IDENT t
 /app/parser/parser.go:713: ast.Ident{Name: t}
    7: 45: . . . . . . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . )
    7: 45: . . . . . . . . . . . . . . ":="
    7: 48: . . . . . . . . . . . . . . ExpressionList (
    7: 48: . . . . . . . . . . . . . . . Expression (
    7: 48: . . . . . . . . . . . . . . . . BinaryExpr (
    7: 48: . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 48: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 48: . . . . . . . . . . . . . . . . . . . Operand (
    7: 48: . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    7: 50: . . . . . . . . . . . . . . . . . . . )
    7: 50: . . . . . . . . . . . . . . . . . . )
    7: 50: . . . . . . . . . . . . . . . . . )
    7: 50: . . . . . . . . . . . . . . . . . "%"
    7: 52: . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 52: . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 52: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 52: . . . . . . . . . . . . . . . . . . . . Operand (
    7: 52: . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    7: 53: . . . . . . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . )
    7: 53: . . . . . . . . . . . . . ";"
    7: 55: . . . . . . . . . . . . . SimpleStmt (
    7: 55: . . . . . . . . . . . . . . ExpressionList (
    7: 55: . . . . . . . . . . . . . . . Expression (
    7: 55: . . . . . . . . . . . . . . . . BinaryExpr (
    7: 55: . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 55: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 55: . . . . . . . . . . . . . . . . . . . Operand (
    7: 55: . . . . . . . . . . . . . . . . . . . . IDENT t
 /app/parser/parser.go:713: ast.Ident{Name: t}
    7: 57: . . . . . . . . . . . . . . . . . . . )
    7: 57: . . . . . . . . . . . . . . . . . . )
    7: 57: . . . . . . . . . . . . . . . . . )
    7: 57: . . . . . . . . . . . . . . . . . "=="
    7: 60: . . . . . . . . . . . . . . . . . BinaryExpr (
    7: 60: . . . . . . . . . . . . . . . . . . UnaryExpr (
    7: 60: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    7: 60: . . . . . . . . . . . . . . . . . . . . Operand (
    7: 60: . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    7: 61: . . . . . . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . )
    7: 61: . . . . . . . . . . . . "]"
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{i 101 + v}, Fors: [0xc00044dc20]}
    7: 62: . . . . . . . . . . . )
    7: 62: . . . . . . . . . . )
    7: 62: . . . . . . . . . )
    7: 62: . . . . . . . . )
    7: 62: . . . . . . . )
    7: 62: . . . . . . )
    7: 62: . . . . . )
    7: 62: . . . . )
    7: 62: . . . . ";"
    8:  1: . . . )
    8:  1: . . . Statement (
    8:  1: . . . . SimpleStmt (
    8:  1: . . . . . ExpressionList (
    8:  1: . . . . . . Expression (
    8:  1: . . . . . . . BinaryExpr (
    8:  1: . . . . . . . . UnaryExpr (
    8:  1: . . . . . . . . . PrimaryExpr (
    8:  1: . . . . . . . . . . Operand (
    8:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    8:  8: . . . . . . . . . . )
    8:  8: . . . . . . . . . . CallOrConversion (
    8:  8: . . . . . . . . . . . "("
    8:  9: . . . . . . . . . . . Expression (
    8:  9: . . . . . . . . . . . . BinaryExpr (
    8:  9: . . . . . . . . . . . . . UnaryExpr (
    8:  9: . . . . . . . . . . . . . . PrimaryExpr (
    8:  9: . . . . . . . . . . . . . . . Operand (
    8:  9: . . . . . . . . . . . . . . . . IDENT z
 /app/parser/parser.go:713: ast.Ident{Name: z}
    8: 10: . . . . . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . )
    8: 10: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    8: 11: . . . . . . . . . . )
    8: 11: . . . . . . . . . )
    8: 11: . . . . . . . . )
    8: 11: . . . . . . . )
    8: 11: . . . . . . )
    8: 11: . . . . . )
    8: 11: . . . . )
    8: 11: . . . . ";"
   10:  1: . . . )
   10:  1: . . . Statement (
   10:  1: . . . . SimpleStmt (
   10:  1: . . . . . ExpressionList (
   10:  1: . . . . . . Expression (
   10:  1: . . . . . . . BinaryExpr (
   10:  1: . . . . . . . . UnaryExpr (
   10:  1: . . . . . . . . . PrimaryExpr (
   10:  1: . . . . . . . . . . Operand (
   10:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   10:  8: . . . . . . . . . . )
   10:  8: . . . . . . . . . . CallOrConversion (
   10:  8: . . . . . . . . . . . "("
   10:  9: . . . . . . . . . . . Expression (
   10:  9: . . . . . . . . . . . . BinaryExpr (
   10:  9: . . . . . . . . . . . . . UnaryExpr (
   10:  9: . . . . . . . . . . . . . . PrimaryExpr (
   10:  9: . . . . . . . . . . . . . . . Operand (
   10:  9: . . . . . . . . . . . . . . . . ArrayType (
   10:  9: . . . . . . . . . . . . . . . . . "["
   10: 10: . . . . . . . . . . . . . . . . . Expression (
   10: 10: . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 10: . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 10: . . . . . . . . . . . . . . . . . . . . . . IDENT k
 /app/parser/parser.go:713: ast.Ident{Name: k}
   10: 11: . . . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . . )
   10: 11: . . . . . . . . . . . . . . . . . . . "+"
   10: 12: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 12: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 12: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 12: . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 12: . . . . . . . . . . . . . . . . . . . . . . . STRING ","
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: ","}
   10: 15: . . . . . . . . . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . . . . . . . )
   10: 15: . . . . . . . . . . . . . . . . . . . "+"
   10: 16: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 16: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 16: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 16: . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 16: . . . . . . . . . . . . . . . . . . . . . . . IDENT s
 /app/parser/parser.go:713: ast.Ident{Name: s}
   10: 18: . . . . . . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . )
   10: 18: . . . . . . . . . . . . . . . . . ForPhrase (
   10: 18: . . . . . . . . . . . . . . . . . . "for"
   10: 22: . . . . . . . . . . . . . . . . . . IDENT k
 /app/parser/parser.go:713: ast.Ident{Name: k}
   10: 23: . . . . . . . . . . . . . . . . . . ","
   10: 25: . . . . . . . . . . . . . . . . . . IDENT s
 /app/parser/parser.go:713: ast.Ident{Name: s}
   10: 27: . . . . . . . . . . . . . . . . . . "<-"
   10: 30: . . . . . . . . . . . . . . . . . . Expression (
   10: 30: . . . . . . . . . . . . . . . . . . . RangeExpr (
   10: 30: . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 30: . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 30: . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 30: . . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 30: . . . . . . . . . . . . . . . . . . . . . . . . LiteralValue (
   10: 30: . . . . . . . . . . . . . . . . . . . . . . . . . "{"
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . ElementList (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 31: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "Hello"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hello"}
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 38: . . . . . . . . . . . . . . . . . . . . . . . . . . . ":"
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 40: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "xsw"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "xsw"}
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 45: . . . . . . . . . . . . . . . . . . . . . . . . . . ","
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 47: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "Hi"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Hi"}
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 51: . . . . . . . . . . . . . . . . . . . . . . . . . . . ":"
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . Element (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . Expression (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . BinaryExpr (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . Operand (
   10: 53: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . STRING "XGo"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "XGo"}
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 58: . . . . . . . . . . . . . . . . . . . . . . . . . "}"
   10: 59: . . . . . . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . )
   10: 59: . . . . . . . . . . . . . . . . . "]"
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{0xc00012dec0 182 + s}, Fors: [0xc00044dce0]}
   10: 60: . . . . . . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . )
   10: 60: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   10: 61: . . . . . . . . . . )
   10: 61: . . . . . . . . . )
   10: 61: . . . . . . . . )
   10: 61: . . . . . . . )
   10: 61: . . . . . . )
   10: 61: . . . . . )
   10: 61: . . . . )
   10: 61: . . . . ";"
   12:  1: . . . )
   12:  1: . . . Statement (
   12:  1: . . . . SimpleStmt (
   12:  1: . . . . . ExpressionList (
   12:  1: . . . . . . Expression (
   12:  1: . . . . . . . BinaryExpr (
   12:  1: . . . . . . . . UnaryExpr (
   12:  1: . . . . . . . . . PrimaryExpr (
   12:  1: . . . . . . . . . . Operand (
   12:  1: . . . . . . . . . . . IDENT arr
 /app/parser/parser.go:713: ast.Ident{Name: arr}
   12:  5: . . . . . . . . . . )
   12:  5: . . . . . . . . . )
   12:  5: . . . . . . . . )
   12:  5: . . . . . . . )
   12:  5: . . . . . . )
   12:  5: . . . . . )
   12:  5: . . . . . ":="
   12:  8: . . . . . ExpressionList (
   12:  8: . . . . . . Expression (
   12:  8: . . . . . . . BinaryExpr (
   12:  8: . . . . . . . . UnaryExpr (
   12:  8: . . . . . . . . . PrimaryExpr (
   12:  8: . . . . . . . . . . Operand (
   12:  8: . . . . . . . . . . . ArrayType (
   12:  8: . . . . . . . . . . . . "["
   12:  9: . . . . . . . . . . . . Expression (
   12:  9: . . . . . . . . . . . . . BinaryExpr (
   12:  9: . . . . . . . . . . . . . . UnaryExpr (
   12:  9: . . . . . . . . . . . . . . . PrimaryExpr (
   12:  9: . . . . . . . . . . . . . . . . Operand (
   12:  9: . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
   12: 10: . . . . . . . . . . . . . . . . )
   12: 10: . . . . . . . . . . . . . . . )
   12: 10: . . . . . . . . . . . . . . )
   12: 10: . . . . . . . . . . . . . )
   12: 10: . . . . . . . . . . . . )
   12: 10: . . . . . . . . . . . . ","
   12: 12: . . . . . . . . . . . . Expression (
   12: 12: . . . . . . . . . . . . . BinaryExpr (
   12: 12: . . . . . . . . . . . . . . UnaryExpr (
   12: 12: . . . . . . . . . . . . . . . PrimaryExpr (
   12: 12: . . . . . . . . . . . . . . . . Operand (
   12: 12: . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   12: 13: . . . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . )
   12: 13: . . . . . . . . . . . . ","
   12: 15: . . . . . . . . . . . . Expression (
   12: 15: . . . . . . . . . . . . . BinaryExpr (
   12: 15: . . . . . . . . . . . . . . UnaryExpr (
   12: 15: . . . . . . . . . . . . . . . PrimaryExpr (
   12: 15: . . . . . . . . . . . . . . . . Operand (
   12: 15: . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
   12: 16: . . . . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . )
   12: 16: . . . . . . . . . . . . ","
   12: 18: . . . . . . . . . . . . Expression (
   12: 18: . . . . . . . . . . . . . BinaryExpr (
   12: 18: . . . . . . . . . . . . . . UnaryExpr (
   12: 18: . . . . . . . . . . . . . . . PrimaryExpr (
   12: 18: . . . . . . . . . . . . . . . . Operand (
   12: 18: . . . . . . . . . . . . . . . . . INT 4
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 4}
   12: 19: . . . . . . . . . . . . . . . . )
   12: 19: . . . . . . . . . . . . . . . )
   12: 19: . . . . . . . . . . . . . . )
   12: 19: . . . . . . . . . . . . . )
   12: 19: . . . . . . . . . . . . )
   12: 19: . . . . . . . . . . . . ","
   12: 21: . . . . . . . . . . . . Expression (
   12: 21: . . . . . . . . . . . . . BinaryExpr (
   12: 21: . . . . . . . . . . . . . . UnaryExpr (
   12: 21: . . . . . . . . . . . . . . . PrimaryExpr (
   12: 21: . . . . . . . . . . . . . . . . Operand (
   12: 21: . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
   12: 22: . . . . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . )
   12: 22: . . . . . . . . . . . . ","
   12: 24: . . . . . . . . . . . . Expression (
   12: 24: . . . . . . . . . . . . . BinaryExpr (
   12: 24: . . . . . . . . . . . . . . UnaryExpr (
   12: 24: . . . . . . . . . . . . . . . PrimaryExpr (
   12: 24: . . . . . . . . . . . . . . . . Operand (
   12: 24: . . . . . . . . . . . . . . . . . INT 6
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 6}
   12: 25: . . . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . )
   12: 25: . . . . . . . . . . . . "]"
   12: 26: . . . . . . . . . . . )
   12: 26: . . . . . . . . . . )
   12: 26: . . . . . . . . . )
   12: 26: . . . . . . . . )
   12: 26: . . . . . . . )
   12: 26: . . . . . . )
   12: 26: . . . . . )
   12: 26: . . . . )
   12: 26: . . . . ";"
   13:  1: . . . )
   13:  1: . . . Statement (
   13:  1: . . . . SimpleStmt (
   13:  1: . . . . . ExpressionList (
   13:  1: . . . . . . Expression (
   13:  1: . . . . . . . BinaryExpr (
   13:  1: . . . . . . . . UnaryExpr (
   13:  1: . . . . . . . . . PrimaryExpr (
   13:  1: . . . . . . . . . . Operand (
   13:  1: . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   13:  3: . . . . . . . . . . )
   13:  3: . . . . . . . . . )
   13:  3: . . . . . . . . )
   13:  3: . . . . . . . )
   13:  3: . . . . . . )
   13:  3: . . . . . )
   13:  3: . . . . . ":="
   13:  6: . . . . . ExpressionList (
   13:  6: . . . . . . Expression (
   13:  6: . . . . . . . BinaryExpr (
   13:  6: . . . . . . . . UnaryExpr (
   13:  6: . . . . . . . . . PrimaryExpr (
   13:  6: . . . . . . . . . . Operand (
   13:  6: . . . . . . . . . . . ArrayType (
   13:  6: . . . . . . . . . . . . "["
   13:  7: . . . . . . . . . . . . Expression (
   13:  7: . . . . . . . . . . . . . BinaryExpr (
   13:  7: . . . . . . . . . . . . . . UnaryExpr (
   13:  7: . . . . . . . . . . . . . . . PrimaryExpr (
   13:  7: . . . . . . . . . . . . . . . . Operand (
   13:  7: . . . . . . . . . . . . . . . . . ArrayType (
   13:  7: . . . . . . . . . . . . . . . . . . "["
   13:  8: . . . . . . . . . . . . . . . . . . Expression (
   13:  8: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   13:  8: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   13:  8: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13:  8: . . . . . . . . . . . . . . . . . . . . . . Operand (
   13:  8: . . . . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   13:  9: . . . . . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . )
   13:  9: . . . . . . . . . . . . . . . . . . ","
   13: 11: . . . . . . . . . . . . . . . . . . Expression (
   13: 11: . . . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . . . Operand (
   13: 11: . . . . . . . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   13: 12: . . . . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . "]"
   13: 14: . . . . . . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . )
   13: 14: . . . . . . . . . . . . ForPhrase (
   13: 14: . . . . . . . . . . . . . "for"
   13: 18: . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   13: 20: . . . . . . . . . . . . . "<-"
   13: 23: . . . . . . . . . . . . . Expression (
   13: 23: . . . . . . . . . . . . . . RangeExpr (
   13: 23: . . . . . . . . . . . . . . . BinaryExpr (
   13: 23: . . . . . . . . . . . . . . . . UnaryExpr (
   13: 23: . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 23: . . . . . . . . . . . . . . . . . . Operand (
   13: 23: . . . . . . . . . . . . . . . . . . . IDENT arr
 /app/parser/parser.go:713: ast.Ident{Name: arr}
   13: 27: . . . . . . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . )
   13: 27: . . . . . . . . . . . . . "if"
   13: 30: . . . . . . . . . . . . . SimpleStmt (
   13: 30: . . . . . . . . . . . . . . ExpressionList (
   13: 30: . . . . . . . . . . . . . . . Expression (
   13: 30: . . . . . . . . . . . . . . . . BinaryExpr (
   13: 30: . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 30: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 30: . . . . . . . . . . . . . . . . . . . Operand (
   13: 30: . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
   13: 32: . . . . . . . . . . . . . . . . . . . )
   13: 32: . . . . . . . . . . . . . . . . . . )
   13: 32: . . . . . . . . . . . . . . . . . )
   13: 32: . . . . . . . . . . . . . . . . . "<"
   13: 34: . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 34: . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 34: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 34: . . . . . . . . . . . . . . . . . . . . Operand (
   13: 34: . . . . . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   13: 36: . . . . . . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . )
   13: 36: . . . . . . . . . . . . ForPhrase (
   13: 36: . . . . . . . . . . . . . "for"
   13: 40: . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   13: 42: . . . . . . . . . . . . . "<-"
   13: 45: . . . . . . . . . . . . . Expression (
   13: 45: . . . . . . . . . . . . . . RangeExpr (
   13: 45: . . . . . . . . . . . . . . . BinaryExpr (
   13: 45: . . . . . . . . . . . . . . . . UnaryExpr (
   13: 45: . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 45: . . . . . . . . . . . . . . . . . . Operand (
   13: 45: . . . . . . . . . . . . . . . . . . . IDENT arr
 /app/parser/parser.go:713: ast.Ident{Name: arr}
   13: 49: . . . . . . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . )
   13: 49: . . . . . . . . . . . . . "if"
   13: 52: . . . . . . . . . . . . . SimpleStmt (
   13: 52: . . . . . . . . . . . . . . ExpressionList (
   13: 52: . . . . . . . . . . . . . . . Expression (
   13: 52: . . . . . . . . . . . . . . . . BinaryExpr (
   13: 52: . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 52: . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 52: . . . . . . . . . . . . . . . . . . . Operand (
   13: 52: . . . . . . . . . . . . . . . . . . . . IDENT b
 /app/parser/parser.go:713: ast.Ident{Name: b}
   13: 54: . . . . . . . . . . . . . . . . . . . )
   13: 54: . . . . . . . . . . . . . . . . . . )
   13: 54: . . . . . . . . . . . . . . . . . )
   13: 54: . . . . . . . . . . . . . . . . . ">"
   13: 56: . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 56: . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 56: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 56: . . . . . . . . . . . . . . . . . . . . Operand (
   13: 56: . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   13: 57: . . . . . . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . )
   13: 57: . . . . . . . . . . . . "]"
 /app/parser/parser.go:875: ast.ComprehensionExpr{Tok: [, Elt: &{262 [a b] 267 false}, Fors: [0xc00044dda0 0xc00044de00]}
   13: 58: . . . . . . . . . . . )
   13: 58: . . . . . . . . . . )
   13: 58: . . . . . . . . . )
   13: 58: . . . . . . . . )
   13: 58: . . . . . . . )
   13: 58: . . . . . . )
   13: 58: . . . . . )
   13: 58: . . . . )
   13: 58: . . . . ";"
   14:  1: . . . )
   14:  1: . . . Statement (
   14:  1: . . . . SimpleStmt (
   14:  1: . . . . . ExpressionList (
   14:  1: . . . . . . Expression (
   14:  1: . . . . . . . BinaryExpr (
   14:  1: . . . . . . . . UnaryExpr (
   14:  1: . . . . . . . . . PrimaryExpr (
   14:  1: . . . . . . . . . . Operand (
   14:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   14:  8: . . . . . . . . . . )
   14:  8: . . . . . . . . . . CallOrConversion (
   14:  8: . . . . . . . . . . . "("
   14:  9: . . . . . . . . . . . Expression (
   14:  9: . . . . . . . . . . . . BinaryExpr (
   14:  9: . . . . . . . . . . . . . UnaryExpr (
   14:  9: . . . . . . . . . . . . . . PrimaryExpr (
   14:  9: . . . . . . . . . . . . . . . Operand (
   14:  9: . . . . . . . . . . . . . . . . STRING "x:"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "x:"}
   14: 13: . . . . . . . . . . . . . . . )
   14: 13: . . . . . . . . . . . . . . )
   14: 13: . . . . . . . . . . . . . )
   14: 13: . . . . . . . . . . . . )
   14: 13: . . . . . . . . . . . )
   14: 13: . . . . . . . . . . . ","
   14: 15: . . . . . . . . . . . Expression (
   14: 15: . . . . . . . . . . . . BinaryExpr (
   14: 15: . . . . . . . . . . . . . UnaryExpr (
   14: 15: . . . . . . . . . . . . . . PrimaryExpr (
   14: 15: . . . . . . . . . . . . . . . Operand (
   14: 15: . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
   14: 16: . . . . . . . . . . . . . . . )
   14: 16: . . . . . . . . . . . . . . )
   14: 16: . . . . . . . . . . . . . )
   14: 16: . . . . . . . . . . . . )
   14: 16: . . . . . . . . . . . )
   14: 16: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   14: 17: . . . . . . . . . . )
   14: 17: . . . . . . . . . )
   14: 17: . . . . . . . . )
   14: 17: . . . . . . . )
   14: 17: . . . . . . )
   14: 17: . . . . . )
   14: 17: . . . . )
   14: 17: . . . . ";"
   14: 18: . . . )
   14: 18: . . )
   14: 18: . )
   14: 18: )
=== RUN   TestFromNofmt/matrix1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_nofmt/matrix1
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT echo
 /app/parser/parser.go:713: ast.Ident{Name: echo}
    1:  6: . . . . . . . . . . )
    1:  6: . . . . . . . . . . CallOrConversion (
    1:  6: . . . . . . . . . . . Expression (
    1:  6: . . . . . . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . . . . . . ArrayType (
    1:  6: . . . . . . . . . . . . . . . . . "["
    2:  2: . . . . . . . . . . . . . . . . . Expression (
    2:  2: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  2: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  2: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  2: . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  2: . . . . . . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    2:  3: . . . . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . . . . ","
    2:  5: . . . . . . . . . . . . . . . . . Expression (
    2:  5: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  5: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  5: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  5: . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  5: . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    2:  6: . . . . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . )
    2:  6: . . . . . . . . . . . . . . . . . ","
    2:  8: . . . . . . . . . . . . . . . . . Expression (
    2:  8: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2:  8: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  8: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  8: . . . . . . . . . . . . . . . . . . . . . Operand (
    2:  8: . . . . . . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    2:  9: . . . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . ";"
    3:  2: . . . . . . . . . . . . . . . . . Expression (
    3:  2: . . . . . . . . . . . . . . . . . . BinaryExpr (
    3:  2: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3:  2: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3:  2: . . . . . . . . . . . . . . . . . . . . . Operand (
    3:  2: . . . . . . . . . . . . . . . . . . . . . . INT 4
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 4}
    3:  3: . . . . . . . . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . . . . . )
    3:  3: . . . . . . . . . . . . . . . . . ","
    3:  5: . . . . . . . . . . . . . . . . . Expression (
    3:  5: . . . . . . . . . . . . . . . . . . BinaryExpr (
    3:  5: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3:  5: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3:  5: . . . . . . . . . . . . . . . . . . . . . Operand (
    3:  5: . . . . . . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    3:  6: . . . . . . . . . . . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . . . . . . . )
    3:  6: . . . . . . . . . . . . . . . . . ","
    3:  8: . . . . . . . . . . . . . . . . . Expression (
    3:  8: . . . . . . . . . . . . . . . . . . BinaryExpr (
    3:  8: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    3:  8: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    3:  8: . . . . . . . . . . . . . . . . . . . . . Operand (
    3:  8: . . . . . . . . . . . . . . . . . . . . . . INT 6
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 6}
    3: 10: . . . . . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . )
    3: 10: . . . . . . . . . . . . . . . . . "]"
    3: 11: . . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . . )
    3: 11: . . . . . . . . . . . )
 /app/parser/parser.go:2160: ast.CallExpr{Fun: echo, Ellipsis: false, isCmd: true}
    3: 11: . . . . . . . . . . )
    3: 11: . . . . . . . . . )
    3: 11: . . . . . . . . )
    3: 11: . . . . . . . )
    3: 11: . . . . . . )
    3: 11: . . . . . )
    3: 11: . . . . )
    3: 11: . . . . ";"
    3: 12: . . . )
    3: 12: . . )
    3: 12: . )
    3: 12: )
=== RUN   TestFromNofmt/printvariadic
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_nofmt/printvariadic
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    1:  8: . . . . . . . . . . )
    1:  8: . . . . . . . . . . CallOrConversion (
    1:  8: . . . . . . . . . . . "("
    2:  2: . . . . . . . . . . . Expression (
    2:  2: . . . . . . . . . . . . BinaryExpr (
    2:  2: . . . . . . . . . . . . . UnaryExpr (
    2:  2: . . . . . . . . . . . . . . PrimaryExpr (
    2:  2: . . . . . . . . . . . . . . . Operand (
    2:  2: . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2:  3: . . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . )
    2:  3: . . . . . . . . . . . "..."
    3:  1: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: true, isCmd: false}
    3:  2: . . . . . . . . . . )
    3:  2: . . . . . . . . . )
    3:  2: . . . . . . . . )
    3:  2: . . . . . . . )
    3:  2: . . . . . . )
    3:  2: . . . . . )
    3:  2: . . . . )
    3:  2: . . . . ";"
    4:  1: . . . )
    4:  1: . . . Statement (
    4:  1: . . . . SimpleStmt (
    4:  1: . . . . . ExpressionList (
    4:  1: . . . . . . Expression (
    4:  1: . . . . . . . BinaryExpr (
    4:  1: . . . . . . . . UnaryExpr (
    4:  1: . . . . . . . . . PrimaryExpr (
    4:  1: . . . . . . . . . . Operand (
    4:  1: . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    4:  8: . . . . . . . . . . )
    4:  8: . . . . . . . . . . CallOrConversion (
    4:  8: . . . . . . . . . . . "("
    5:  2: . . . . . . . . . . . Expression (
    5:  2: . . . . . . . . . . . . BinaryExpr (
    5:  2: . . . . . . . . . . . . . UnaryExpr (
    5:  2: . . . . . . . . . . . . . . PrimaryExpr (
    5:  2: . . . . . . . . . . . . . . . Operand (
    5:  2: . . . . . . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    5:  3: . . . . . . . . . . . . . . . )
    5:  3: . . . . . . . . . . . . . . )
    5:  3: . . . . . . . . . . . . . )
    5:  3: . . . . . . . . . . . . )
    5:  3: . . . . . . . . . . . )
    5:  3: . . . . . . . . . . . "..."
    5:  6: . . . . . . . . . . . ","
    6:  1: . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: true, isCmd: false}
    6:  2: . . . . . . . . . . )
    6:  2: . . . . . . . . . )
    6:  2: . . . . . . . . )
    6:  2: . . . . . . . )
    6:  2: . . . . . . )
    6:  2: . . . . . )
    6:  2: . . . . )
    6:  2: . . . . ";"
    6:  3: . . . )
    6:  3: . . )
    6:  3: . )
    6:  3: )
=== RUN   TestFromNofmt/rangeexpr1
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_nofmt/rangeexpr1
    1:  1: File (
    1:  1: . "package"
    1:  9: . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    1: 13: . ";"
    3:  1: . Declaration (
    3:  1: . . FunctionDeclOrCall (
    3:  1: . . . "func"
    3:  6: . . . IDENT main
 /app/parser/parser.go:713: ast.Ident{Name: main}
    3: 10: . . . Signature (
    3: 10: . . . . Parameters (
    3: 10: . . . . . "("
    3: 11: . . . . . ")"
    3: 13: . . . . )
    3: 13: . . . . Result (
    3: 13: . . . . )
    3: 13: . . . )
    3: 13: . . . Body (
    3: 13: . . . . "{"
    4:  2: . . . . StatementList (
    4:  2: . . . . . Statement (
    4:  2: . . . . . . ForStmt (
    4:  2: . . . . . . . "for"
    4:  6: . . . . . . . SimpleStmt (
    4:  6: . . . . . . . . ExpressionList (
    4:  6: . . . . . . . . . Expression (
    4:  6: . . . . . . . . . . BinaryExpr (
    4:  6: . . . . . . . . . . . UnaryExpr (
    4:  6: . . . . . . . . . . . . PrimaryExpr (
    4:  6: . . . . . . . . . . . . . Operand (
    4:  6: . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    4:  8: . . . . . . . . . . . . . )
    4:  8: . . . . . . . . . . . . )
    4:  8: . . . . . . . . . . . )
    4:  8: . . . . . . . . . . )
    4:  8: . . . . . . . . . )
    4:  8: . . . . . . . . )
    4:  8: . . . . . . . . ":="
    4: 11: . . . . . . . . "range"
    4: 17: . . . . . . . . Expression (
    4: 17: . . . . . . . . . RangeExpr (
    4: 17: . . . . . . . . . . ":"
    4: 18: . . . . . . . . . . BinaryExpr (
    4: 18: . . . . . . . . . . . UnaryExpr (
    4: 18: . . . . . . . . . . . . PrimaryExpr (
    4: 18: . . . . . . . . . . . . . Operand (
    4: 18: . . . . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
    4: 21: . . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . . )
    4: 21: . . . . . . . . . . . )
    4: 21: . . . . . . . . . . )
 /app/parser/parser.go:2669: ast.RangeExpr{First: <nil>, Last: &{46 INT 10 <nil>}, Expr3: <nil>}
    4: 21: . . . . . . . . . )
    4: 21: . . . . . . . . )
    4: 21: . . . . . . . )
    4: 21: . . . . . . . BlockStmt (
    4: 21: . . . . . . . . "{"
    5:  3: . . . . . . . . StatementList (
    5:  3: . . . . . . . . . Statement (
    5:  3: . . . . . . . . . . SimpleStmt (
    5:  3: . . . . . . . . . . . ExpressionList (
    5:  3: . . . . . . . . . . . . Expression (
    5:  3: . . . . . . . . . . . . . BinaryExpr (
    5:  3: . . . . . . . . . . . . . . UnaryExpr (
    5:  3: . . . . . . . . . . . . . . . PrimaryExpr (
    5:  3: . . . . . . . . . . . . . . . . Operand (
    5:  3: . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    5: 10: . . . . . . . . . . . . . . . . )
    5: 10: . . . . . . . . . . . . . . . . CallOrConversion (
    5: 10: . . . . . . . . . . . . . . . . . "("
    5: 11: . . . . . . . . . . . . . . . . . Expression (
    5: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    5: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
    5: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    5: 12: . . . . . . . . . . . . . . . . . . . . . )
    5: 12: . . . . . . . . . . . . . . . . . . . . )
    5: 12: . . . . . . . . . . . . . . . . . . . )
    5: 12: . . . . . . . . . . . . . . . . . . )
    5: 12: . . . . . . . . . . . . . . . . . )
    5: 12: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    5: 13: . . . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . . )
    5: 13: . . . . . . . . . . . )
    5: 13: . . . . . . . . . . )
    5: 13: . . . . . . . . . . ";"
    6:  2: . . . . . . . . . )
    6:  2: . . . . . . . . )
    6:  2: . . . . . . . . "}"
    6:  3: . . . . . . . )
    6:  3: . . . . . . . ";"
    8:  2: . . . . . . )
    8:  2: . . . . . )
    8:  2: . . . . . Statement (
    8:  2: . . . . . . ForStmt (
    8:  2: . . . . . . . "for"
    8:  6: . . . . . . . SimpleStmt (
    8:  6: . . . . . . . . ExpressionList (
    8:  6: . . . . . . . . . Expression (
    8:  6: . . . . . . . . . . BinaryExpr (
    8:  6: . . . . . . . . . . . UnaryExpr (
    8:  6: . . . . . . . . . . . . PrimaryExpr (
    8:  6: . . . . . . . . . . . . . Operand (
    8:  6: . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    8:  8: . . . . . . . . . . . . . )
    8:  8: . . . . . . . . . . . . )
    8:  8: . . . . . . . . . . . )
    8:  8: . . . . . . . . . . )
    8:  8: . . . . . . . . . )
    8:  8: . . . . . . . . )
    8:  8: . . . . . . . . "<-"
    8: 11: . . . . . . . . Expression (
    8: 11: . . . . . . . . . RangeExpr (
    8: 11: . . . . . . . . . . BinaryExpr (
    8: 11: . . . . . . . . . . . UnaryExpr (
    8: 11: . . . . . . . . . . . . PrimaryExpr (
    8: 11: . . . . . . . . . . . . . Operand (
    8: 11: . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    8: 12: . . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . . )
    8: 12: . . . . . . . . . . . )
    8: 12: . . . . . . . . . . )
    8: 12: . . . . . . . . . . ":"
    8: 13: . . . . . . . . . . BinaryExpr (
    8: 13: . . . . . . . . . . . UnaryExpr (
    8: 13: . . . . . . . . . . . . PrimaryExpr (
    8: 13: . . . . . . . . . . . . . Operand (
    8: 13: . . . . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
    8: 16: . . . . . . . . . . . . . )
    8: 16: . . . . . . . . . . . . )
    8: 16: . . . . . . . . . . . )
    8: 16: . . . . . . . . . . )
 /app/parser/parser.go:2669: ast.RangeExpr{First: &{78 INT 1 <nil>}, Last: &{80 INT 10 <nil>}, Expr3: <nil>}
    8: 16: . . . . . . . . . )
    8: 16: . . . . . . . . )
    8: 16: . . . . . . . )
    8: 16: . . . . . . . BlockStmt (
    8: 16: . . . . . . . . "{"
    9:  3: . . . . . . . . StatementList (
    9:  3: . . . . . . . . . Statement (
    9:  3: . . . . . . . . . . SimpleStmt (
    9:  3: . . . . . . . . . . . ExpressionList (
    9:  3: . . . . . . . . . . . . Expression (
    9:  3: . . . . . . . . . . . . . BinaryExpr (
    9:  3: . . . . . . . . . . . . . . UnaryExpr (
    9:  3: . . . . . . . . . . . . . . . PrimaryExpr (
    9:  3: . . . . . . . . . . . . . . . . Operand (
    9:  3: . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
    9: 10: . . . . . . . . . . . . . . . . )
    9: 10: . . . . . . . . . . . . . . . . CallOrConversion (
    9: 10: . . . . . . . . . . . . . . . . . "("
    9: 11: . . . . . . . . . . . . . . . . . Expression (
    9: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
    9: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    9: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    9: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
    9: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
    9: 12: . . . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . )
    9: 12: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
    9: 13: . . . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . . )
    9: 13: . . . . . . . . . . . )
    9: 13: . . . . . . . . . . )
    9: 13: . . . . . . . . . . ";"
   10:  2: . . . . . . . . . )
   10:  2: . . . . . . . . )
   10:  2: . . . . . . . . "}"
   10:  3: . . . . . . . )
   10:  3: . . . . . . . ";"
   12:  2: . . . . . . )
   12:  2: . . . . . )
   12:  2: . . . . . Statement (
   12:  2: . . . . . . ForStmt (
   12:  2: . . . . . . . "for"
   12:  6: . . . . . . . SimpleStmt (
   12:  6: . . . . . . . . ExpressionList (
   12:  6: . . . . . . . . . Expression (
   12:  6: . . . . . . . . . . BinaryExpr (
   12:  6: . . . . . . . . . . . UnaryExpr (
   12:  6: . . . . . . . . . . . . PrimaryExpr (
   12:  6: . . . . . . . . . . . . . Operand (
   12:  6: . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   12:  8: . . . . . . . . . . . . . )
   12:  8: . . . . . . . . . . . . )
   12:  8: . . . . . . . . . . . )
   12:  8: . . . . . . . . . . )
   12:  8: . . . . . . . . . )
   12:  8: . . . . . . . . )
   12:  8: . . . . . . . . ":="
   12: 11: . . . . . . . . "range"
   12: 17: . . . . . . . . Expression (
   12: 17: . . . . . . . . . RangeExpr (
   12: 17: . . . . . . . . . . ":"
   12: 18: . . . . . . . . . . BinaryExpr (
   12: 18: . . . . . . . . . . . UnaryExpr (
   12: 18: . . . . . . . . . . . . PrimaryExpr (
   12: 18: . . . . . . . . . . . . . Operand (
   12: 18: . . . . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
   12: 20: . . . . . . . . . . . . . )
   12: 20: . . . . . . . . . . . . )
   12: 20: . . . . . . . . . . . )
   12: 20: . . . . . . . . . . )
   12: 20: . . . . . . . . . . ":"
   12: 21: . . . . . . . . . . BinaryExpr (
   12: 21: . . . . . . . . . . . UnaryExpr (
   12: 21: . . . . . . . . . . . . PrimaryExpr (
   12: 21: . . . . . . . . . . . . . Operand (
   12: 21: . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
   12: 23: . . . . . . . . . . . . . )
   12: 23: . . . . . . . . . . . . )
   12: 23: . . . . . . . . . . . )
   12: 23: . . . . . . . . . . )
 /app/parser/parser.go:2669: ast.RangeExpr{First: <nil>, Last: &{119 INT 10 <nil>}, Expr3: &{122 INT 2 <nil>}}
   12: 23: . . . . . . . . . )
   12: 23: . . . . . . . . )
   12: 23: . . . . . . . )
   12: 23: . . . . . . . BlockStmt (
   12: 23: . . . . . . . . "{"
   13:  3: . . . . . . . . StatementList (
   13:  3: . . . . . . . . . Statement (
   13:  3: . . . . . . . . . . SimpleStmt (
   13:  3: . . . . . . . . . . . ExpressionList (
   13:  3: . . . . . . . . . . . . Expression (
   13:  3: . . . . . . . . . . . . . BinaryExpr (
   13:  3: . . . . . . . . . . . . . . UnaryExpr (
   13:  3: . . . . . . . . . . . . . . . PrimaryExpr (
   13:  3: . . . . . . . . . . . . . . . . Operand (
   13:  3: . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   13: 10: . . . . . . . . . . . . . . . . )
   13: 10: . . . . . . . . . . . . . . . . CallOrConversion (
   13: 10: . . . . . . . . . . . . . . . . . "("
   13: 11: . . . . . . . . . . . . . . . . . Expression (
   13: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   13: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
   13: 11: . . . . . . . . . . . . . . . . . . . . . . IDENT i
 /app/parser/parser.go:713: ast.Ident{Name: i}
   13: 12: . . . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . )
   13: 12: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   13: 13: . . . . . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . . )
   13: 13: . . . . . . . . . . . )
   13: 13: . . . . . . . . . . )
   13: 13: . . . . . . . . . . ";"
   14:  2: . . . . . . . . . )
   14:  2: . . . . . . . . )
   14:  2: . . . . . . . . "}"
   14:  3: . . . . . . . )
   14:  3: . . . . . . . ";"
   16:  2: . . . . . . )
   16:  2: . . . . . )
   16:  2: . . . . . Statement (
   16:  2: . . . . . . ForStmt (
   16:  2: . . . . . . . "for"
   16:  6: . . . . . . . "range"
   16: 12: . . . . . . . Expression (
   16: 12: . . . . . . . . RangeExpr (
   16: 12: . . . . . . . . . ":"
   16: 13: . . . . . . . . . BinaryExpr (
   16: 13: . . . . . . . . . . UnaryExpr (
   16: 13: . . . . . . . . . . . PrimaryExpr (
   16: 13: . . . . . . . . . . . . Operand (
   16: 13: . . . . . . . . . . . . . INT 10
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 10}
   16: 16: . . . . . . . . . . . . )
   16: 16: . . . . . . . . . . . )
   16: 16: . . . . . . . . . . )
   16: 16: . . . . . . . . . )
 /app/parser/parser.go:2669: ast.RangeExpr{First: <nil>, Last: &{155 INT 10 <nil>}, Expr3: <nil>}
   16: 16: . . . . . . . . )
   16: 16: . . . . . . . )
   16: 16: . . . . . . . BlockStmt (
   16: 16: . . . . . . . . "{"
   17:  3: . . . . . . . . StatementList (
   17:  3: . . . . . . . . . Statement (
   17:  3: . . . . . . . . . . SimpleStmt (
   17:  3: . . . . . . . . . . . ExpressionList (
   17:  3: . . . . . . . . . . . . Expression (
   17:  3: . . . . . . . . . . . . . BinaryExpr (
   17:  3: . . . . . . . . . . . . . . UnaryExpr (
   17:  3: . . . . . . . . . . . . . . . PrimaryExpr (
   17:  3: . . . . . . . . . . . . . . . . Operand (
   17:  3: . . . . . . . . . . . . . . . . . IDENT println
 /app/parser/parser.go:713: ast.Ident{Name: println}
   17: 10: . . . . . . . . . . . . . . . . )
   17: 10: . . . . . . . . . . . . . . . . CallOrConversion (
   17: 10: . . . . . . . . . . . . . . . . . "("
   17: 11: . . . . . . . . . . . . . . . . . Expression (
   17: 11: . . . . . . . . . . . . . . . . . . BinaryExpr (
   17: 11: . . . . . . . . . . . . . . . . . . . UnaryExpr (
   17: 11: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
   17: 11: . . . . . . . . . . . . . . . . . . . . . Operand (
   17: 11: . . . . . . . . . . . . . . . . . . . . . . STRING "Range expression"
 /app/parser/parser.go:1862: ast.BasicLit{Kind: STRING, Value: "Range expression"}
   17: 29: . . . . . . . . . . . . . . . . . . . . . )
   17: 29: . . . . . . . . . . . . . . . . . . . . )
   17: 29: . . . . . . . . . . . . . . . . . . . )
   17: 29: . . . . . . . . . . . . . . . . . . )
   17: 29: . . . . . . . . . . . . . . . . . )
   17: 29: . . . . . . . . . . . . . . . . . ")"
 /app/parser/parser.go:2160: ast.CallExpr{Fun: println, Ellipsis: false, isCmd: false}
   17: 30: . . . . . . . . . . . . . . . . )
   17: 30: . . . . . . . . . . . . . . . )
   17: 30: . . . . . . . . . . . . . . )
   17: 30: . . . . . . . . . . . . . )
   17: 30: . . . . . . . . . . . . )
   17: 30: . . . . . . . . . . . )
   17: 30: . . . . . . . . . . )
   17: 30: . . . . . . . . . . ";"
   18:  2: . . . . . . . . . )
   18:  2: . . . . . . . . )
   18:  2: . . . . . . . . "}"
   18:  3: . . . . . . . )
   18:  3: . . . . . . . ";"
   19:  1: . . . . . . )
   19:  1: . . . . . )
   19:  1: . . . . )
   19:  1: . . . . "}"
   19:  2: . . . )
   19:  2: . . . ";"
 /app/parser/parser.go:4088: ast.FuncDecl{Name: main, ...}
   19:  3: . . )
   19:  3: . )
   19:  3: )
=== RUN   TestFromNofmt/selectdata
 /app/parser/parserdir_test.go:107: Parsing /app/parser/_nofmt/selectdata
    1:  1: File (
    1:  1: . Declaration (
    1:  1: . . StatementList (
    1:  1: . . . Statement (
    1:  1: . . . . SimpleStmt (
    1:  1: . . . . . ExpressionList (
    1:  1: . . . . . . Expression (
    1:  1: . . . . . . . BinaryExpr (
    1:  1: . . . . . . . . UnaryExpr (
    1:  1: . . . . . . . . . PrimaryExpr (
    1:  1: . . . . . . . . . . Operand (
    1:  1: . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    1:  3: . . . . . . . . . . )
    1:  3: . . . . . . . . . )
    1:  3: . . . . . . . . )
    1:  3: . . . . . . . )
    1:  3: . . . . . . )
    1:  3: . . . . . )
    1:  3: . . . . . ":="
    1:  6: . . . . . ExpressionList (
    1:  6: . . . . . . Expression (
    1:  6: . . . . . . . BinaryExpr (
    1:  6: . . . . . . . . UnaryExpr (
    1:  6: . . . . . . . . . PrimaryExpr (
    1:  6: . . . . . . . . . . Operand (
    1:  6: . . . . . . . . . . . ArrayType (
    1:  6: . . . . . . . . . . . . "["
    1:  7: . . . . . . . . . . . . Expression (
    1:  7: . . . . . . . . . . . . . BinaryExpr (
    1:  7: . . . . . . . . . . . . . . UnaryExpr (
    1:  7: . . . . . . . . . . . . . . . PrimaryExpr (
    1:  7: . . . . . . . . . . . . . . . . Operand (
    1:  7: . . . . . . . . . . . . . . . . . INT 1
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 1}
    1:  8: . . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . )
    1:  8: . . . . . . . . . . . . ","
    1: 10: . . . . . . . . . . . . Expression (
    1: 10: . . . . . . . . . . . . . BinaryExpr (
    1: 10: . . . . . . . . . . . . . . UnaryExpr (
    1: 10: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 10: . . . . . . . . . . . . . . . . Operand (
    1: 10: . . . . . . . . . . . . . . . . . INT 3
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 3}
    1: 11: . . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . )
    1: 11: . . . . . . . . . . . . ","
    1: 13: . . . . . . . . . . . . Expression (
    1: 13: . . . . . . . . . . . . . BinaryExpr (
    1: 13: . . . . . . . . . . . . . . UnaryExpr (
    1: 13: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 13: . . . . . . . . . . . . . . . . Operand (
    1: 13: . . . . . . . . . . . . . . . . . INT 5
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 5}
    1: 14: . . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . )
    1: 14: . . . . . . . . . . . . ","
    1: 16: . . . . . . . . . . . . Expression (
    1: 16: . . . . . . . . . . . . . BinaryExpr (
    1: 16: . . . . . . . . . . . . . . UnaryExpr (
    1: 16: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 16: . . . . . . . . . . . . . . . . Operand (
    1: 16: . . . . . . . . . . . . . . . . . INT 7
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 7}
    1: 17: . . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . )
    1: 17: . . . . . . . . . . . . ","
    1: 19: . . . . . . . . . . . . Expression (
    1: 19: . . . . . . . . . . . . . BinaryExpr (
    1: 19: . . . . . . . . . . . . . . UnaryExpr (
    1: 19: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 19: . . . . . . . . . . . . . . . . Operand (
    1: 19: . . . . . . . . . . . . . . . . . INT 8
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 8}
    1: 20: . . . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . )
    1: 20: . . . . . . . . . . . . ","
    1: 22: . . . . . . . . . . . . Expression (
    1: 22: . . . . . . . . . . . . . BinaryExpr (
    1: 22: . . . . . . . . . . . . . . UnaryExpr (
    1: 22: . . . . . . . . . . . . . . . PrimaryExpr (
    1: 22: . . . . . . . . . . . . . . . . Operand (
    1: 22: . . . . . . . . . . . . . . . . . INT 19
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 19}
    1: 24: . . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . )
    1: 24: . . . . . . . . . . . . "]"
    1: 25: . . . . . . . . . . . )
    1: 25: . . . . . . . . . . )
    1: 25: . . . . . . . . . )
    1: 25: . . . . . . . . )
    1: 25: . . . . . . . )
    1: 25: . . . . . . )
    1: 25: . . . . . )
    1: 25: . . . . )
    1: 25: . . . . ";"
    2:  1: . . . )
    2:  1: . . . Statement (
    2:  1: . . . . SimpleStmt (
    2:  1: . . . . . ExpressionList (
    2:  1: . . . . . . Expression (
    2:  1: . . . . . . . BinaryExpr (
    2:  1: . . . . . . . . UnaryExpr (
    2:  1: . . . . . . . . . PrimaryExpr (
    2:  1: . . . . . . . . . . Operand (
    2:  1: . . . . . . . . . . . IDENT y
 /app/parser/parser.go:713: ast.Ident{Name: y}
    2:  3: . . . . . . . . . . )
    2:  3: . . . . . . . . . )
    2:  3: . . . . . . . . )
    2:  3: . . . . . . . )
    2:  3: . . . . . . )
    2:  3: . . . . . )
    2:  3: . . . . . ":="
    2:  6: . . . . . ExpressionList (
    2:  6: . . . . . . Expression (
    2:  6: . . . . . . . BinaryExpr (
    2:  6: . . . . . . . . UnaryExpr (
    2:  6: . . . . . . . . . PrimaryExpr (
    2:  6: . . . . . . . . . . Operand (
    2:  6: . . . . . . . . . . . LiteralValue (
    2:  6: . . . . . . . . . . . . "{"
    2:  7: . . . . . . . . . . . . ElementList (
    2:  7: . . . . . . . . . . . . . Element (
    2:  7: . . . . . . . . . . . . . . Element (
    2:  7: . . . . . . . . . . . . . . . Expression (
    2:  7: . . . . . . . . . . . . . . . . BinaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . UnaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2:  7: . . . . . . . . . . . . . . . . . . . Operand (
    2:  7: . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2:  9: . . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . )
    2:  9: . . . . . . . . . . . . . ForPhrase (
    2:  9: . . . . . . . . . . . . . . "for"
    2: 13: . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 15: . . . . . . . . . . . . . . "<-"
    2: 18: . . . . . . . . . . . . . . Expression (
    2: 18: . . . . . . . . . . . . . . . RangeExpr (
    2: 18: . . . . . . . . . . . . . . . . BinaryExpr (
    2: 18: . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 18: . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 18: . . . . . . . . . . . . . . . . . . . Operand (
    2: 18: . . . . . . . . . . . . . . . . . . . . IDENT a
 /app/parser/parser.go:713: ast.Ident{Name: a}
    2: 20: . . . . . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . )
    2: 20: . . . . . . . . . . . . . . "if"
    2: 23: . . . . . . . . . . . . . . SimpleStmt (
    2: 23: . . . . . . . . . . . . . . . ExpressionList (
    2: 23: . . . . . . . . . . . . . . . . Expression (
    2: 23: . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 23: . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 23: . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 23: . . . . . . . . . . . . . . . . . . . . Operand (
    2: 23: . . . . . . . . . . . . . . . . . . . . . IDENT x
 /app/parser/parser.go:713: ast.Ident{Name: x}
    2: 24: . . . . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . . . )
    2: 24: . . . . . . . . . . . . . . . . . . "%"
    2: 25: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 25: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 25: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 25: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 25: . . . . . . . . . . . . . . . . . . . . . . INT 2
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 2}
    2: 27: . . . . . . . . . . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . . . . . . . . )
    2: 27: . . . . . . . . . . . . . . . . . . "=="
    2: 30: . . . . . . . . . . . . . . . . . . BinaryExpr (
    2: 30: . . . . . . . . . . . . . . . . . . . UnaryExpr (
    2: 30: . . . . . . . . . . . . . . . . . . . . PrimaryExpr (
    2: 30: . . . . . . . . . . . . . . . . . . . . . Operand (
    2: 30: . . . . . . . . . . . . . . . . . . . . . . INT 0
 /app/parser/parser.go:1862: ast.BasicLit{Kind: INT, Value: 0}
    2: 31: . . . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . )
    2: 31: . . . . . . . . . . . . "}"
    2: 32: . . . . . . . . . . . )
    2: 32: . . . . . . . . . . )
    2: 32: . . . . . . . . . )
    2: 32: . . . . . . . . )
    2: 32: . . . . . . . )
    2: 32: . . . . . . )
    2: 32: . . . . . )
    2: 32: . . . . )
    2: 32: . . . . ";"
    2: 33: . . . )
    2: 33: . . )
    2: 33: . )
    2: 33: )
--- PASS: TestFromNofmt (0.02s)
    --- PASS: TestFromNofmt/cmdlinestyle1 (0.00s)
    --- PASS: TestFromNofmt/cmdlinestyle2 (0.00s)
    --- PASS: TestFromNofmt/cmdlinestyle3 (0.00s)
    --- PASS: TestFromNofmt/exists (0.00s)
    --- PASS: TestFromNofmt/forloop (0.01s)
    --- PASS: TestFromNofmt/listcompr (0.01s)
    --- PASS: TestFromNofmt/matrix1 (0.00s)
    --- PASS: TestFromNofmt/printvariadic (0.00s)
    --- PASS: TestFromNofmt/rangeexpr1 (0.00s)
    --- PASS: TestFromNofmt/selectdata (0.00s)
PASS
coverage: 65.0% of statements
ok  	github.com/goplus/xgo/parser	0.226s	coverage: 65.0% of statements
=== RUN   TestLineComments
--- PASS: TestLineComments (0.00s)
=== RUN   TestBadComments
=== PAUSE TestBadComments
=== RUN   TestSourcePos
2025/12/19 11:09:23 ==> Format Func foo
--- PASS: TestSourcePos (0.00s)
=== RUN   TestIssue5945
2025/12/19 11:09:23 ==> Format Func f
2025/12/19 11:09:23 ==> Format Func g
--- PASS: TestIssue5945 (0.00s)
=== RUN   TestDeclLists
2025/12/19 11:09:23 ==> Format Func sum
--- PASS: TestDeclLists (0.00s)
=== RUN   TestStmtLists
2025/12/19 11:09:23 ==> AssignStmt [i]
--- PASS: TestStmtLists (0.00s)
=== RUN   TestBaseIndent
=== PAUSE TestBaseIndent
=== RUN   TestFuncType
2025/12/19 11:09:23 ==> Format Func f
--- PASS: TestFuncType (0.00s)
=== RUN   TestWriteErrors
=== PAUSE TestWriteErrors
=== RUN   TestX
2025/12/19 11:09:23 ==> Format Func _
--- PASS: TestX (0.00s)
=== RUN   TestCommentedNode
2025/12/19 11:09:23 ==> Format Func foo
--- PASS: TestCommentedNode (0.00s)
=== RUN   TestIssue11151
--- PASS: TestIssue11151 (0.00s)
=== RUN   TestParenthesizedDecl
--- PASS: TestParenthesizedDecl (0.00s)
=== RUN   TestIssue32854
--- PASS: TestIssue32854 (0.00s)
=== RUN   TestStripParens
--- PASS: TestStripParens (0.00s)
=== RUN   TestGoFormat
--- PASS: TestGoFormat (0.00s)
=== RUN   TestGopFormat
--- PASS: TestGopFormat (0.00s)
=== RUN   TestNoPkgDecl
--- PASS: TestNoPkgDecl (0.00s)
=== RUN   TestFuncs
2025/12/19 11:09:23 ==> Format Func foo
2025/12/19 11:09:23 ==> Format Func bar
--- PASS: TestFuncs (0.00s)
=== RUN   TestFromGopPrinter
=== RUN   TestFromGopPrinter/format.Source_nodes.go
2025/12/19 11:09:23 ==> Format Func SetDebug
2025/12/19 11:09:23 ==> AssignStmt [debugFormat]
2025/12/19 11:09:23 ==> Format Func linebreak
2025/12/19 11:09:23 ==> AssignStmt [n]
2025/12/19 11:09:23 ==> AssignStmt [n]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [nbreaks]
2025/12/19 11:09:23 ==> AssignStmt [nbreaks]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> Format Func setComment
2025/12/19 11:09:23 ==> AssignStmt [0xc000010e40]
2025/12/19 11:09:23 ==> ExprStmt &{p flush}
2025/12/19 11:09:23 ==> AssignStmt [0xc000010f90]
2025/12/19 11:09:23 ==> ExprStmt &{p internalError}
2025/12/19 11:09:23 ==> AssignStmt [0xc000223cb0]
2025/12/19 11:09:23 ==> AssignStmt [0xc000011020]
2025/12/19 11:09:23 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:23 ==> Format Func identList
2025/12/19 11:09:23 ==> AssignStmt [xlist]
2025/12/19 11:09:23 ==> AssignStmt [0xc00024e0c0]
2025/12/19 11:09:23 ==> AssignStmt [mode]
2025/12/19 11:09:23 ==> ExprStmt &{p exprList}
2025/12/19 11:09:23 ==> Format Func exprList
2025/12/19 11:09:23 ==> AssignStmt [prev]
2025/12/19 11:09:23 ==> AssignStmt [next]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [prev]
2025/12/19 11:09:23 ==> AssignStmt [next]
2025/12/19 11:09:23 ==> AssignStmt [line]
2025/12/19 11:09:23 ==> AssignStmt [endLine]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr0}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [ws]
2025/12/19 11:09:23 ==> AssignStmt [ws]
2025/12/19 11:09:23 ==> AssignStmt [prevBreak]
2025/12/19 11:09:23 ==> AssignStmt [ws]
2025/12/19 11:09:23 ==> AssignStmt [prevBreak]
2025/12/19 11:09:23 ==> AssignStmt [size]
2025/12/19 11:09:23 ==> AssignStmt [lnsum]
2025/12/19 11:09:23 ==> AssignStmt [count]
2025/12/19 11:09:23 ==> AssignStmt [prevLine]
2025/12/19 11:09:23 ==> AssignStmt [line]
2025/12/19 11:09:23 ==> AssignStmt [useFF]
2025/12/19 11:09:23 ==> AssignStmt [prevSize]
2025/12/19 11:09:23 ==> AssignStmt [size]
2025/12/19 11:09:23 ==> AssignStmt [pair isPair]
2025/12/19 11:09:23 ==> AssignStmt [size]
2025/12/19 11:09:23 ==> AssignStmt [size]
2025/12/19 11:09:23 ==> AssignStmt [useFF]
2025/12/19 11:09:23 ==> AssignStmt [geomean]
2025/12/19 11:09:23 ==> AssignStmt [ratio]
2025/12/19 11:09:23 ==> AssignStmt [useFF]
2025/12/19 11:09:23 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [needsBlank]
2025/12/19 11:09:23 ==> AssignStmt [nbreaks]
2025/12/19 11:09:23 ==> AssignStmt [ws]
2025/12/19 11:09:23 ==> AssignStmt [prevBreak]
2025/12/19 11:09:23 ==> AssignStmt [needsBlank]
2025/12/19 11:09:23 ==> AssignStmt [lnsum]
2025/12/19 11:09:23 ==> AssignStmt [count]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p expr0}
2025/12/19 11:09:23 ==> AssignStmt [lnsum]
2025/12/19 11:09:23 ==> AssignStmt [prevLine]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> Format Func parameters
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [prevLine]
2025/12/19 11:09:23 ==> AssignStmt [ws]
2025/12/19 11:09:23 ==> AssignStmt [parLineBeg]
2025/12/19 11:09:23 ==> AssignStmt [parLineBeg]
2025/12/19 11:09:23 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [ws]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p identList}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [prevLine]
2025/12/19 11:09:23 ==> AssignStmt [closing]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> Format Func signature
2025/12/19 11:09:23 ==> ExprStmt &{p parameters}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [n]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p parameters}
2025/12/19 11:09:23 ==> Format Func identListSize
2025/12/19 11:09:23 ==> AssignStmt [size]
2025/12/19 11:09:23 ==> AssignStmt [size]
2025/12/19 11:09:23 ==> Format Func isOneLineFieldList
2025/12/19 11:09:23 ==> AssignStmt [f]
2025/12/19 11:09:23 ==> AssignStmt [namesSize]
2025/12/19 11:09:23 ==> AssignStmt [namesSize]
2025/12/19 11:09:23 ==> AssignStmt [typeSize]
2025/12/19 11:09:23 ==> Format Func setLineComment
2025/12/19 11:09:23 ==> ExprStmt &{p setComment}
2025/12/19 11:09:23 ==> Format Func fieldList
2025/12/19 11:09:23 ==> AssignStmt [lbrace]
2025/12/19 11:09:23 ==> AssignStmt [list]
2025/12/19 11:09:23 ==> AssignStmt [rbrace]
2025/12/19 11:09:23 ==> AssignStmt [hasComments]
2025/12/19 11:09:23 ==> AssignStmt [srcIsOneLine]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [f]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> AssignStmt [ftyp isFtyp]
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p signature}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [sep]
2025/12/19 11:09:23 ==> AssignStmt [sep]
2025/12/19 11:09:23 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:23 ==> AssignStmt [extraTabs]
2025/12/19 11:09:23 ==> ExprStmt &{p setComment}
2025/12/19 11:09:23 ==> ExprStmt &{p recordLine}
2025/12/19 11:09:23 ==> ExprStmt &{p identList}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> AssignStmt [extraTabs]
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> AssignStmt [extraTabs]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> AssignStmt [extraTabs]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p setComment}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p flush}
2025/12/19 11:09:23 ==> ExprStmt &{p setLineComment}
2025/12/19 11:09:23 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:23 ==> ExprStmt &{p setComment}
2025/12/19 11:09:23 ==> ExprStmt &{p recordLine}
2025/12/19 11:09:23 ==> AssignStmt [ftyp isFtyp]
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p signature}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p setComment}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p flush}
2025/12/19 11:09:23 ==> ExprStmt &{p setLineComment}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> Format Func walkBinary
2025/12/19 11:09:23 ==> AssignStmt [has4]
2025/12/19 11:09:23 ==> AssignStmt [has5]
2025/12/19 11:09:23 ==> AssignStmt [l]
2025/12/19 11:09:23 ==> AssignStmt [h4 h5 mp]
2025/12/19 11:09:23 ==> AssignStmt [has4]
2025/12/19 11:09:23 ==> AssignStmt [has5]
2025/12/19 11:09:23 ==> AssignStmt [maxProblem]
2025/12/19 11:09:23 ==> AssignStmt [r]
2025/12/19 11:09:23 ==> AssignStmt [h4 h5 mp]
2025/12/19 11:09:23 ==> AssignStmt [has4]
2025/12/19 11:09:23 ==> AssignStmt [has5]
2025/12/19 11:09:23 ==> AssignStmt [maxProblem]
2025/12/19 11:09:23 ==> AssignStmt [maxProblem]
2025/12/19 11:09:23 ==> AssignStmt [maxProblem]
2025/12/19 11:09:23 ==> AssignStmt [maxProblem]
2025/12/19 11:09:23 ==> Format Func cutoff
2025/12/19 11:09:23 ==> AssignStmt [has4 has5 maxProblem]
2025/12/19 11:09:23 ==> Format Func diffPrec
2025/12/19 11:09:23 ==> AssignStmt [x ok]
2025/12/19 11:09:23 ==> Format Func reduceDepth
2025/12/19 11:09:23 ==> AssignStmt [depth]
2025/12/19 11:09:23 ==> Format Func binaryExpr
2025/12/19 11:09:23 ==> AssignStmt [prec]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr0}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [printBlank]
2025/12/19 11:09:23 ==> AssignStmt [ws]
2025/12/19 11:09:23 ==> ExprStmt &{p expr1}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [xline]
2025/12/19 11:09:23 ==> AssignStmt [yline]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [ws]
2025/12/19 11:09:23 ==> AssignStmt [printBlank]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr1}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> Format Func isBinary
2025/12/19 11:09:23 ==> AssignStmt [_ ok]
2025/12/19 11:09:23 ==> Format Func expr1
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [x]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p internalError}
2025/12/19 11:09:23 ==> AssignStmt [depth]
2025/12/19 11:09:23 ==> AssignStmt [v ok]
2025/12/19 11:09:23 ==> ExprStmt &{p binaryExpr}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr1}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [startCol]
2025/12/19 11:09:23 ==> ExprStmt &{p signature}
2025/12/19 11:09:23 ==> ExprStmt &{p funcBody}
2025/12/19 11:09:23 ==> AssignStmt [_ hasParens]
2025/12/19 11:09:23 ==> ExprStmt &{p expr0}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr0}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p selectorExpr}
2025/12/19 11:09:23 ==> ExprStmt &{p expr1}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr1}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr0}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr1}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p exprList}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr1}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [indices]
2025/12/19 11:09:23 ==> AssignStmt [indices]
2025/12/19 11:09:23 ==> AssignStmt [hasBinaries]
2025/12/19 11:09:23 ==> AssignStmt [needsBlanks]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr0}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [_ ok]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [wasIndented]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [wasIndented]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p exprList}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p exprList}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr0}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr1}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p exprList}
2025/12/19 11:09:23 ==> AssignStmt [mode]
2025/12/19 11:09:23 ==> AssignStmt [mode]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [incomplete]
2025/12/19 11:09:23 ==> ExprStmt &{p exprList}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [mode]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p fieldList}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p signature}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p fieldList}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p exprList}
2025/12/19 11:09:23 ==> AssignStmt [mode]
2025/12/19 11:09:23 ==> AssignStmt [mode]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr0}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p listForPhrase}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [elt ok]
2025/12/19 11:09:23 ==> ExprStmt &{p expr0}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr0}
2025/12/19 11:09:23 ==> ExprStmt &{p expr0}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p listForPhrase}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p identList}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p exprList}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p identList}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p block}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{log Fatalf}
2025/12/19 11:09:23 ==> Format Func listForPhrase
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p stmt}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> Format Func possibleSelectorExpr
2025/12/19 11:09:23 ==> AssignStmt [x ok]
2025/12/19 11:09:23 ==> ExprStmt &{p expr1}
2025/12/19 11:09:23 ==> Format Func selectorExpr
2025/12/19 11:09:23 ==> ExprStmt &{p expr1}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [line]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> Format Func expr0
2025/12/19 11:09:23 ==> ExprStmt &{p expr1}
2025/12/19 11:09:23 ==> Format Func expr
2025/12/19 11:09:23 ==> ExprStmt &{p expr1}
2025/12/19 11:09:23 ==> Format Func stmtList
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [i]
2025/12/19 11:09:23 ==> AssignStmt [_ isEmpty]
2025/12/19 11:09:23 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:23 ==> ExprStmt &{p recordLine}
2025/12/19 11:09:23 ==> ExprStmt &{p stmt}
2025/12/19 11:09:23 ==> AssignStmt [t]
2025/12/19 11:09:23 ==> AssignStmt [lt _]
2025/12/19 11:09:23 ==> AssignStmt [t]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> Format Func block
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:23 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> Format Func isTypeName
2025/12/19 11:09:23 ==> AssignStmt [t]
2025/12/19 11:09:23 ==> Format Func stripParens
2025/12/19 11:09:23 ==> AssignStmt [px strip]
2025/12/19 11:09:23 ==> ExprStmt &{ast Inspect}
2025/12/19 11:09:23 ==> AssignStmt [x]
2025/12/19 11:09:23 ==> AssignStmt [strip]
2025/12/19 11:09:23 ==> AssignStmt [x]
2025/12/19 11:09:23 ==> AssignStmt [strip]
2025/12/19 11:09:23 ==> Format Func stripParensAlways
2025/12/19 11:09:23 ==> AssignStmt [x ok]
2025/12/19 11:09:23 ==> Format Func controlClause
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [needsBlank]
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> AssignStmt [needsBlank]
2025/12/19 11:09:23 ==> ExprStmt &{p stmt}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> AssignStmt [needsBlank]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [needsBlank]
2025/12/19 11:09:23 ==> ExprStmt &{p stmt}
2025/12/19 11:09:23 ==> AssignStmt [needsBlank]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> Format Func indentList
2025/12/19 11:09:23 ==> AssignStmt [n]
2025/12/19 11:09:23 ==> AssignStmt [line]
2025/12/19 11:09:23 ==> AssignStmt [xb]
2025/12/19 11:09:23 ==> AssignStmt [xe]
2025/12/19 11:09:23 ==> AssignStmt [line]
2025/12/19 11:09:23 ==> Format Func stmt
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [s]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p decl}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [e isEmpty]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:23 ==> ExprStmt &{p stmt}
2025/12/19 11:09:23 ==> AssignStmt [e ok]
2025/12/19 11:09:23 ==> ExprStmt &{log Println}
2025/12/19 11:09:23 ==> ExprStmt &{p expr0}
2025/12/19 11:09:23 ==> ExprStmt &{p expr0}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr0}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr0}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{log Println}
2025/12/19 11:09:23 ==> ExprStmt &{p exprList}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p exprList}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p exprList}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p exprList}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p block}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p controlClause}
2025/12/19 11:09:23 ==> ExprStmt &{p block}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p stmt}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p stmt}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p exprList}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p controlClause}
2025/12/19 11:09:23 ==> ExprStmt &{p block}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p stmt}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p stmt}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p block}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p stmt}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [body]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p block}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p controlClause}
2025/12/19 11:09:23 ==> ExprStmt &{p block}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p block}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p block}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{log Printf}
2025/12/19 11:09:23 ==> Format Func keepTypeColumn
2025/12/19 11:09:23 ==> AssignStmt [m]
2025/12/19 11:09:23 ==> AssignStmt [populate]
2025/12/19 11:09:23 ==> AssignStmt [0xc000307d40]
2025/12/19 11:09:23 ==> AssignStmt [0xc000307d40]
2025/12/19 11:09:23 ==> AssignStmt [i0]
2025/12/19 11:09:23 ==> AssignStmt [t]
2025/12/19 11:09:23 ==> AssignStmt [i0]
2025/12/19 11:09:23 ==> AssignStmt [keepType]
2025/12/19 11:09:23 ==> ExprStmt populate
2025/12/19 11:09:23 ==> AssignStmt [i0]
2025/12/19 11:09:23 ==> AssignStmt [keepType]
2025/12/19 11:09:23 ==> ExprStmt populate
2025/12/19 11:09:23 ==> Format Func valueSpec
2025/12/19 11:09:23 ==> ExprStmt &{p setComment}
2025/12/19 11:09:23 ==> ExprStmt &{p identList}
2025/12/19 11:09:23 ==> AssignStmt [extraTabs]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p exprList}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p setComment}
2025/12/19 11:09:23 ==> Format Func sanitizeImportPath
2025/12/19 11:09:23 ==> AssignStmt [s err]
2025/12/19 11:09:23 ==> AssignStmt [s]
2025/12/19 11:09:23 ==> Format Func spec
2025/12/19 11:09:23 ==> AssignStmt [s]
2025/12/19 11:09:23 ==> ExprStmt &{p setComment}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p setComment}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p internalError}
2025/12/19 11:09:23 ==> ExprStmt &{p setComment}
2025/12/19 11:09:23 ==> ExprStmt &{p identList}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p exprList}
2025/12/19 11:09:23 ==> ExprStmt &{p setComment}
2025/12/19 11:09:23 ==> ExprStmt &{p setComment}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p setComment}
2025/12/19 11:09:23 ==> ExprStmt panic
2025/12/19 11:09:23 ==> Format Func genDecl
2025/12/19 11:09:23 ==> ExprStmt &{p setComment}
2025/12/19 11:09:23 ==> ExprStmt &{p setPos}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p setPos}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [n]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [keepType]
2025/12/19 11:09:23 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:23 ==> ExprStmt &{p recordLine}
2025/12/19 11:09:23 ==> ExprStmt &{p valueSpec}
2025/12/19 11:09:23 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:23 ==> ExprStmt &{p recordLine}
2025/12/19 11:09:23 ==> ExprStmt &{p spec}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p setPos}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p spec}
2025/12/19 11:09:23 ==> Format Func nodeSize
2025/12/19 11:09:23 ==> AssignStmt [size found]
2025/12/19 11:09:23 ==> AssignStmt [size]
2025/12/19 11:09:23 ==> AssignStmt [0xc000346b40]
2025/12/19 11:09:23 ==> AssignStmt [cfg]
2025/12/19 11:09:23 ==> AssignStmt [err]
2025/12/19 11:09:23 ==> AssignStmt [size]
2025/12/19 11:09:23 ==> AssignStmt [0xc000346e70]
2025/12/19 11:09:23 ==> Format Func numLines
2025/12/19 11:09:23 ==> AssignStmt [from]
2025/12/19 11:09:23 ==> AssignStmt [to]
2025/12/19 11:09:23 ==> Format Func bodySize
2025/12/19 11:09:23 ==> AssignStmt [pos1]
2025/12/19 11:09:23 ==> AssignStmt [pos2]
2025/12/19 11:09:23 ==> AssignStmt [bodySize]
2025/12/19 11:09:23 ==> AssignStmt [bodySize]
2025/12/19 11:09:23 ==> AssignStmt [bodySize]
2025/12/19 11:09:23 ==> Format Func funcBody
2025/12/19 11:09:23 ==> AssignStmt [0xc0003335a8]
2025/12/19 11:09:23 ==> AssignStmt [0xc0003335d8]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p stmt}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p block}
2025/12/19 11:09:23 ==> Format Func funcBodyUnnamed
2025/12/19 11:09:23 ==> AssignStmt [_ _]
2025/12/19 11:09:23 ==> AssignStmt [0xc0003338c0]
2025/12/19 11:09:23 ==> AssignStmt [0xc0003338f0]
2025/12/19 11:09:23 ==> AssignStmt [i]
2025/12/19 11:09:23 ==> AssignStmt [_ isEmpty]
2025/12/19 11:09:23 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:23 ==> ExprStmt &{p recordLine}
2025/12/19 11:09:23 ==> ExprStmt &{p stmt}
2025/12/19 11:09:23 ==> AssignStmt [t]
2025/12/19 11:09:23 ==> AssignStmt [lt _]
2025/12/19 11:09:23 ==> AssignStmt [t]
2025/12/19 11:09:23 ==> Format Func distanceFrom
2025/12/19 11:09:23 ==> Format Func funcDecl
2025/12/19 11:09:23 ==> ExprStmt &{log Println}
2025/12/19 11:09:23 ==> ExprStmt &{p setComment}
2025/12/19 11:09:23 ==> ExprStmt &{p funcBodyUnnamed}
2025/12/19 11:09:23 ==> AssignStmt [pos]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> AssignStmt [startCol]
2025/12/19 11:09:23 ==> AssignStmt [list]
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p parameters}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p signature}
2025/12/19 11:09:23 ==> ExprStmt &{p funcBody}
2025/12/19 11:09:23 ==> Format Func overloadFuncDecl
2025/12/19 11:09:23 ==> ExprStmt &{log Println}
2025/12/19 11:09:23 ==> ExprStmt &{p setComment}
2025/12/19 11:09:23 ==> AssignStmt [pos]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p parameters}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr1}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> Format Func decl
2025/12/19 11:09:23 ==> AssignStmt [d]
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p genDecl}
2025/12/19 11:09:23 ==> ExprStmt &{p funcDecl}
2025/12/19 11:09:23 ==> ExprStmt &{p overloadFuncDecl}
2025/12/19 11:09:23 ==> ExprStmt panic
2025/12/19 11:09:23 ==> Format Func declToken
2025/12/19 11:09:23 ==> AssignStmt [tok]
2025/12/19 11:09:23 ==> AssignStmt [d]
2025/12/19 11:09:23 ==> AssignStmt [tok]
2025/12/19 11:09:23 ==> AssignStmt [tok]
2025/12/19 11:09:23 ==> Format Func declList
2025/12/19 11:09:23 ==> AssignStmt [tok]
2025/12/19 11:09:23 ==> AssignStmt [decl ok]
2025/12/19 11:09:23 ==> AssignStmt [prev]
2025/12/19 11:09:23 ==> AssignStmt [tok]
2025/12/19 11:09:23 ==> AssignStmt [min]
2025/12/19 11:09:23 ==> AssignStmt [min]
2025/12/19 11:09:23 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:23 ==> ExprStmt &{p decl}
2025/12/19 11:09:23 ==> Format Func file
2025/12/19 11:09:23 ==> AssignStmt [0xc00035aca8]
2025/12/19 11:09:23 ==> ExprStmt &{p setComment}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
2025/12/19 11:09:23 ==> ExprStmt &{p expr}
2025/12/19 11:09:23 ==> ExprStmt &{p declList}
2025/12/19 11:09:23 ==> ExprStmt &{p print}
=== RUN   TestFromGopPrinter/format.Node_nodes.go
2025/12/19 11:09:24 ==> Format Func SetDebug
2025/12/19 11:09:24 ==> AssignStmt [debugFormat]
2025/12/19 11:09:24 ==> Format Func linebreak
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [nbreaks]
2025/12/19 11:09:24 ==> AssignStmt [nbreaks]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> Format Func setComment
2025/12/19 11:09:24 ==> AssignStmt [0xc0002fc870]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [0xc0002fc9c0]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc000448480]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002fca50]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func identList
2025/12/19 11:09:24 ==> AssignStmt [xlist]
2025/12/19 11:09:24 ==> AssignStmt [0xc000448810]
2025/12/19 11:09:24 ==> AssignStmt [mode]
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> Format Func exprList
2025/12/19 11:09:24 ==> AssignStmt [prev]
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [prev]
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [endLine]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [ws]
2025/12/19 11:09:24 ==> AssignStmt [ws]
2025/12/19 11:09:24 ==> AssignStmt [prevBreak]
2025/12/19 11:09:24 ==> AssignStmt [ws]
2025/12/19 11:09:24 ==> AssignStmt [prevBreak]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [lnsum]
2025/12/19 11:09:24 ==> AssignStmt [count]
2025/12/19 11:09:24 ==> AssignStmt [prevLine]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [useFF]
2025/12/19 11:09:24 ==> AssignStmt [prevSize]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [pair isPair]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [useFF]
2025/12/19 11:09:24 ==> AssignStmt [geomean]
2025/12/19 11:09:24 ==> AssignStmt [ratio]
2025/12/19 11:09:24 ==> AssignStmt [useFF]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [needsBlank]
2025/12/19 11:09:24 ==> AssignStmt [nbreaks]
2025/12/19 11:09:24 ==> AssignStmt [ws]
2025/12/19 11:09:24 ==> AssignStmt [prevBreak]
2025/12/19 11:09:24 ==> AssignStmt [needsBlank]
2025/12/19 11:09:24 ==> AssignStmt [lnsum]
2025/12/19 11:09:24 ==> AssignStmt [count]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> AssignStmt [lnsum]
2025/12/19 11:09:24 ==> AssignStmt [prevLine]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> Format Func parameters
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [prevLine]
2025/12/19 11:09:24 ==> AssignStmt [ws]
2025/12/19 11:09:24 ==> AssignStmt [parLineBeg]
2025/12/19 11:09:24 ==> AssignStmt [parLineBeg]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [ws]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p identList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [prevLine]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> Format Func signature
2025/12/19 11:09:24 ==> ExprStmt &{p parameters}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p parameters}
2025/12/19 11:09:24 ==> Format Func identListSize
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> Format Func isOneLineFieldList
2025/12/19 11:09:24 ==> AssignStmt [f]
2025/12/19 11:09:24 ==> AssignStmt [namesSize]
2025/12/19 11:09:24 ==> AssignStmt [namesSize]
2025/12/19 11:09:24 ==> AssignStmt [typeSize]
2025/12/19 11:09:24 ==> Format Func setLineComment
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> Format Func fieldList
2025/12/19 11:09:24 ==> AssignStmt [lbrace]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [rbrace]
2025/12/19 11:09:24 ==> AssignStmt [hasComments]
2025/12/19 11:09:24 ==> AssignStmt [srcIsOneLine]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [f]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [ftyp isFtyp]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p signature}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:24 ==> AssignStmt [extraTabs]
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p recordLine}
2025/12/19 11:09:24 ==> ExprStmt &{p identList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [extraTabs]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [extraTabs]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [extraTabs]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> ExprStmt &{p setLineComment}
2025/12/19 11:09:24 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p recordLine}
2025/12/19 11:09:24 ==> AssignStmt [ftyp isFtyp]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p signature}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> ExprStmt &{p setLineComment}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> Format Func walkBinary
2025/12/19 11:09:24 ==> AssignStmt [has4]
2025/12/19 11:09:24 ==> AssignStmt [has5]
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [h4 h5 mp]
2025/12/19 11:09:24 ==> AssignStmt [has4]
2025/12/19 11:09:24 ==> AssignStmt [has5]
2025/12/19 11:09:24 ==> AssignStmt [maxProblem]
2025/12/19 11:09:24 ==> AssignStmt [r]
2025/12/19 11:09:24 ==> AssignStmt [h4 h5 mp]
2025/12/19 11:09:24 ==> AssignStmt [has4]
2025/12/19 11:09:24 ==> AssignStmt [has5]
2025/12/19 11:09:24 ==> AssignStmt [maxProblem]
2025/12/19 11:09:24 ==> AssignStmt [maxProblem]
2025/12/19 11:09:24 ==> AssignStmt [maxProblem]
2025/12/19 11:09:24 ==> AssignStmt [maxProblem]
2025/12/19 11:09:24 ==> Format Func cutoff
2025/12/19 11:09:24 ==> AssignStmt [has4 has5 maxProblem]
2025/12/19 11:09:24 ==> Format Func diffPrec
2025/12/19 11:09:24 ==> AssignStmt [x ok]
2025/12/19 11:09:24 ==> Format Func reduceDepth
2025/12/19 11:09:24 ==> AssignStmt [depth]
2025/12/19 11:09:24 ==> Format Func binaryExpr
2025/12/19 11:09:24 ==> AssignStmt [prec]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [printBlank]
2025/12/19 11:09:24 ==> AssignStmt [ws]
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [xline]
2025/12/19 11:09:24 ==> AssignStmt [yline]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [ws]
2025/12/19 11:09:24 ==> AssignStmt [printBlank]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> Format Func isBinary
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> Format Func expr1
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [depth]
2025/12/19 11:09:24 ==> AssignStmt [v ok]
2025/12/19 11:09:24 ==> ExprStmt &{p binaryExpr}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [startCol]
2025/12/19 11:09:24 ==> ExprStmt &{p signature}
2025/12/19 11:09:24 ==> ExprStmt &{p funcBody}
2025/12/19 11:09:24 ==> AssignStmt [_ hasParens]
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p selectorExpr}
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [indices]
2025/12/19 11:09:24 ==> AssignStmt [indices]
2025/12/19 11:09:24 ==> AssignStmt [hasBinaries]
2025/12/19 11:09:24 ==> AssignStmt [needsBlanks]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [wasIndented]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [wasIndented]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> AssignStmt [mode]
2025/12/19 11:09:24 ==> AssignStmt [mode]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [incomplete]
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [mode]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p fieldList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p signature}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p fieldList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> AssignStmt [mode]
2025/12/19 11:09:24 ==> AssignStmt [mode]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p listForPhrase}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [elt ok]
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p listForPhrase}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p identList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p identList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p block}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{log Fatalf}
2025/12/19 11:09:24 ==> Format Func listForPhrase
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> Format Func possibleSelectorExpr
2025/12/19 11:09:24 ==> AssignStmt [x ok]
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> Format Func selectorExpr
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> Format Func expr0
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> Format Func expr
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> Format Func stmtList
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [_ isEmpty]
2025/12/19 11:09:24 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:24 ==> ExprStmt &{p recordLine}
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [lt _]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> Format Func block
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> Format Func isTypeName
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> Format Func stripParens
2025/12/19 11:09:24 ==> AssignStmt [px strip]
2025/12/19 11:09:24 ==> ExprStmt &{ast Inspect}
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [strip]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [strip]
2025/12/19 11:09:24 ==> Format Func stripParensAlways
2025/12/19 11:09:24 ==> AssignStmt [x ok]
2025/12/19 11:09:24 ==> Format Func controlClause
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [needsBlank]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [needsBlank]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [needsBlank]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [needsBlank]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> AssignStmt [needsBlank]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> Format Func indentList
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [xb]
2025/12/19 11:09:24 ==> AssignStmt [xe]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> Format Func stmt
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [e isEmpty]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> AssignStmt [e ok]
2025/12/19 11:09:24 ==> ExprStmt &{log Println}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{log Println}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p block}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p controlClause}
2025/12/19 11:09:24 ==> ExprStmt &{p block}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p controlClause}
2025/12/19 11:09:24 ==> ExprStmt &{p block}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p block}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [body]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p block}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p controlClause}
2025/12/19 11:09:24 ==> ExprStmt &{p block}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p block}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p block}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{log Printf}
2025/12/19 11:09:24 ==> Format Func keepTypeColumn
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [populate]
2025/12/19 11:09:24 ==> AssignStmt [0xc000222360]
2025/12/19 11:09:24 ==> AssignStmt [0xc000222360]
2025/12/19 11:09:24 ==> AssignStmt [i0]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [i0]
2025/12/19 11:09:24 ==> AssignStmt [keepType]
2025/12/19 11:09:24 ==> ExprStmt populate
2025/12/19 11:09:24 ==> AssignStmt [i0]
2025/12/19 11:09:24 ==> AssignStmt [keepType]
2025/12/19 11:09:24 ==> ExprStmt populate
2025/12/19 11:09:24 ==> Format Func valueSpec
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p identList}
2025/12/19 11:09:24 ==> AssignStmt [extraTabs]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> Format Func sanitizeImportPath
2025/12/19 11:09:24 ==> AssignStmt [s err]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> Format Func spec
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p identList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func genDecl
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p setPos}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p setPos}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [keepType]
2025/12/19 11:09:24 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:24 ==> ExprStmt &{p recordLine}
2025/12/19 11:09:24 ==> ExprStmt &{p valueSpec}
2025/12/19 11:09:24 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:24 ==> ExprStmt &{p recordLine}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p setPos}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> Format Func nodeSize
2025/12/19 11:09:24 ==> AssignStmt [size found]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002e5170]
2025/12/19 11:09:24 ==> AssignStmt [cfg]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002e58c0]
2025/12/19 11:09:24 ==> Format Func numLines
2025/12/19 11:09:24 ==> AssignStmt [from]
2025/12/19 11:09:24 ==> AssignStmt [to]
2025/12/19 11:09:24 ==> Format Func bodySize
2025/12/19 11:09:24 ==> AssignStmt [pos1]
2025/12/19 11:09:24 ==> AssignStmt [pos2]
2025/12/19 11:09:24 ==> AssignStmt [bodySize]
2025/12/19 11:09:24 ==> AssignStmt [bodySize]
2025/12/19 11:09:24 ==> AssignStmt [bodySize]
2025/12/19 11:09:24 ==> Format Func funcBody
2025/12/19 11:09:24 ==> AssignStmt [0xc00035a1e0]
2025/12/19 11:09:24 ==> AssignStmt [0xc00035a210]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p block}
2025/12/19 11:09:24 ==> Format Func funcBodyUnnamed
2025/12/19 11:09:24 ==> AssignStmt [_ _]
2025/12/19 11:09:24 ==> AssignStmt [0xc00035a4f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc00035a528]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [_ isEmpty]
2025/12/19 11:09:24 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:24 ==> ExprStmt &{p recordLine}
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [lt _]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> Format Func distanceFrom
2025/12/19 11:09:24 ==> Format Func funcDecl
2025/12/19 11:09:24 ==> ExprStmt &{log Println}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p funcBodyUnnamed}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [startCol]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p parameters}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p signature}
2025/12/19 11:09:24 ==> ExprStmt &{p funcBody}
2025/12/19 11:09:24 ==> Format Func overloadFuncDecl
2025/12/19 11:09:24 ==> ExprStmt &{log Println}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p parameters}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> Format Func decl
2025/12/19 11:09:24 ==> AssignStmt [d]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p genDecl}
2025/12/19 11:09:24 ==> ExprStmt &{p funcDecl}
2025/12/19 11:09:24 ==> ExprStmt &{p overloadFuncDecl}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func declToken
2025/12/19 11:09:24 ==> AssignStmt [tok]
2025/12/19 11:09:24 ==> AssignStmt [d]
2025/12/19 11:09:24 ==> AssignStmt [tok]
2025/12/19 11:09:24 ==> AssignStmt [tok]
2025/12/19 11:09:24 ==> Format Func declList
2025/12/19 11:09:24 ==> AssignStmt [tok]
2025/12/19 11:09:24 ==> AssignStmt [decl ok]
2025/12/19 11:09:24 ==> AssignStmt [prev]
2025/12/19 11:09:24 ==> AssignStmt [tok]
2025/12/19 11:09:24 ==> AssignStmt [min]
2025/12/19 11:09:24 ==> AssignStmt [min]
2025/12/19 11:09:24 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> Format Func file
2025/12/19 11:09:24 ==> AssignStmt [0xc00035b878]
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> Format Func SetDebug
2025/12/19 11:09:24 ==> AssignStmt [debugFormat]
2025/12/19 11:09:24 ==> Format Func linebreak
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [nbreaks]
2025/12/19 11:09:24 ==> AssignStmt [nbreaks]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> Format Func setComment
2025/12/19 11:09:24 ==> AssignStmt [0xc0001cbad0]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001cbc20]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001f3050]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001cbcb0]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func identList
2025/12/19 11:09:24 ==> AssignStmt [xlist]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001f33e0]
2025/12/19 11:09:24 ==> AssignStmt [mode]
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> Format Func exprList
2025/12/19 11:09:24 ==> AssignStmt [prev]
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [prev]
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [endLine]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [ws]
2025/12/19 11:09:24 ==> AssignStmt [ws]
2025/12/19 11:09:24 ==> AssignStmt [prevBreak]
2025/12/19 11:09:24 ==> AssignStmt [ws]
2025/12/19 11:09:24 ==> AssignStmt [prevBreak]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [lnsum]
2025/12/19 11:09:24 ==> AssignStmt [count]
2025/12/19 11:09:24 ==> AssignStmt [prevLine]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [useFF]
2025/12/19 11:09:24 ==> AssignStmt [prevSize]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [pair isPair]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [useFF]
2025/12/19 11:09:24 ==> AssignStmt [geomean]
2025/12/19 11:09:24 ==> AssignStmt [ratio]
2025/12/19 11:09:24 ==> AssignStmt [useFF]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [needsBlank]
2025/12/19 11:09:24 ==> AssignStmt [nbreaks]
2025/12/19 11:09:24 ==> AssignStmt [ws]
2025/12/19 11:09:24 ==> AssignStmt [prevBreak]
2025/12/19 11:09:24 ==> AssignStmt [needsBlank]
2025/12/19 11:09:24 ==> AssignStmt [lnsum]
2025/12/19 11:09:24 ==> AssignStmt [count]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> AssignStmt [lnsum]
2025/12/19 11:09:24 ==> AssignStmt [prevLine]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> Format Func parameters
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [prevLine]
2025/12/19 11:09:24 ==> AssignStmt [ws]
2025/12/19 11:09:24 ==> AssignStmt [parLineBeg]
2025/12/19 11:09:24 ==> AssignStmt [parLineBeg]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [ws]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p identList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [prevLine]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> Format Func signature
2025/12/19 11:09:24 ==> ExprStmt &{p parameters}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p parameters}
2025/12/19 11:09:24 ==> Format Func identListSize
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> Format Func isOneLineFieldList
2025/12/19 11:09:24 ==> AssignStmt [f]
2025/12/19 11:09:24 ==> AssignStmt [namesSize]
2025/12/19 11:09:24 ==> AssignStmt [namesSize]
2025/12/19 11:09:24 ==> AssignStmt [typeSize]
2025/12/19 11:09:24 ==> Format Func setLineComment
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> Format Func fieldList
2025/12/19 11:09:24 ==> AssignStmt [lbrace]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [rbrace]
2025/12/19 11:09:24 ==> AssignStmt [hasComments]
2025/12/19 11:09:24 ==> AssignStmt [srcIsOneLine]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [f]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [ftyp isFtyp]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p signature}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:24 ==> AssignStmt [extraTabs]
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p recordLine}
2025/12/19 11:09:24 ==> ExprStmt &{p identList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [extraTabs]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [extraTabs]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [extraTabs]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> ExprStmt &{p setLineComment}
2025/12/19 11:09:24 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p recordLine}
2025/12/19 11:09:24 ==> AssignStmt [ftyp isFtyp]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p signature}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> ExprStmt &{p setLineComment}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> Format Func walkBinary
2025/12/19 11:09:24 ==> AssignStmt [has4]
2025/12/19 11:09:24 ==> AssignStmt [has5]
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [h4 h5 mp]
2025/12/19 11:09:24 ==> AssignStmt [has4]
2025/12/19 11:09:24 ==> AssignStmt [has5]
2025/12/19 11:09:24 ==> AssignStmt [maxProblem]
2025/12/19 11:09:24 ==> AssignStmt [r]
2025/12/19 11:09:24 ==> AssignStmt [h4 h5 mp]
2025/12/19 11:09:24 ==> AssignStmt [has4]
2025/12/19 11:09:24 ==> AssignStmt [has5]
2025/12/19 11:09:24 ==> AssignStmt [maxProblem]
2025/12/19 11:09:24 ==> AssignStmt [maxProblem]
2025/12/19 11:09:24 ==> AssignStmt [maxProblem]
2025/12/19 11:09:24 ==> AssignStmt [maxProblem]
2025/12/19 11:09:24 ==> Format Func cutoff
2025/12/19 11:09:24 ==> AssignStmt [has4 has5 maxProblem]
2025/12/19 11:09:24 ==> Format Func diffPrec
2025/12/19 11:09:24 ==> AssignStmt [x ok]
2025/12/19 11:09:24 ==> Format Func reduceDepth
2025/12/19 11:09:24 ==> AssignStmt [depth]
2025/12/19 11:09:24 ==> Format Func binaryExpr
2025/12/19 11:09:24 ==> AssignStmt [prec]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [printBlank]
2025/12/19 11:09:24 ==> AssignStmt [ws]
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [xline]
2025/12/19 11:09:24 ==> AssignStmt [yline]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [ws]
2025/12/19 11:09:24 ==> AssignStmt [printBlank]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> Format Func isBinary
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> Format Func expr1
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [depth]
2025/12/19 11:09:24 ==> AssignStmt [v ok]
2025/12/19 11:09:24 ==> ExprStmt &{p binaryExpr}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [startCol]
2025/12/19 11:09:24 ==> ExprStmt &{p signature}
2025/12/19 11:09:24 ==> ExprStmt &{p funcBody}
2025/12/19 11:09:24 ==> AssignStmt [_ hasParens]
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p selectorExpr}
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [indices]
2025/12/19 11:09:24 ==> AssignStmt [indices]
2025/12/19 11:09:24 ==> AssignStmt [hasBinaries]
2025/12/19 11:09:24 ==> AssignStmt [needsBlanks]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [wasIndented]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [wasIndented]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> AssignStmt [mode]
2025/12/19 11:09:24 ==> AssignStmt [mode]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [incomplete]
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [mode]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p fieldList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p signature}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p fieldList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> AssignStmt [mode]
2025/12/19 11:09:24 ==> AssignStmt [mode]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p listForPhrase}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [elt ok]
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p listForPhrase}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p identList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p identList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p block}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{log Fatalf}
2025/12/19 11:09:24 ==> Format Func listForPhrase
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> Format Func possibleSelectorExpr
2025/12/19 11:09:24 ==> AssignStmt [x ok]
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> Format Func selectorExpr
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> Format Func expr0
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> Format Func expr
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> Format Func stmtList
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [_ isEmpty]
2025/12/19 11:09:24 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:24 ==> ExprStmt &{p recordLine}
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [lt _]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> Format Func block
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> Format Func isTypeName
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> Format Func stripParens
2025/12/19 11:09:24 ==> AssignStmt [px strip]
2025/12/19 11:09:24 ==> ExprStmt &{ast Inspect}
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [strip]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [strip]
2025/12/19 11:09:24 ==> Format Func stripParensAlways
2025/12/19 11:09:24 ==> AssignStmt [x ok]
2025/12/19 11:09:24 ==> Format Func controlClause
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [needsBlank]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [needsBlank]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [needsBlank]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [needsBlank]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> AssignStmt [needsBlank]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> Format Func indentList
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [xb]
2025/12/19 11:09:24 ==> AssignStmt [xe]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> Format Func stmt
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [e isEmpty]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> AssignStmt [e ok]
2025/12/19 11:09:24 ==> ExprStmt &{log Println}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr0}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{log Println}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p block}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p controlClause}
2025/12/19 11:09:24 ==> ExprStmt &{p block}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p controlClause}
2025/12/19 11:09:24 ==> ExprStmt &{p block}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p block}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [body]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p block}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p controlClause}
2025/12/19 11:09:24 ==> ExprStmt &{p block}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p block}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p block}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{log Printf}
2025/12/19 11:09:24 ==> Format Func keepTypeColumn
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [populate]
2025/12/19 11:09:24 ==> AssignStmt [0xc000308960]
2025/12/19 11:09:24 ==> AssignStmt [0xc000308960]
2025/12/19 11:09:24 ==> AssignStmt [i0]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [i0]
2025/12/19 11:09:24 ==> AssignStmt [keepType]
2025/12/19 11:09:24 ==> ExprStmt populate
2025/12/19 11:09:24 ==> AssignStmt [i0]
2025/12/19 11:09:24 ==> AssignStmt [keepType]
2025/12/19 11:09:24 ==> ExprStmt populate
2025/12/19 11:09:24 ==> Format Func valueSpec
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p identList}
2025/12/19 11:09:24 ==> AssignStmt [extraTabs]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> Format Func sanitizeImportPath
2025/12/19 11:09:24 ==> AssignStmt [s err]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> Format Func spec
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p identList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p exprList}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func genDecl
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p setPos}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p setPos}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [keepType]
2025/12/19 11:09:24 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:24 ==> ExprStmt &{p recordLine}
2025/12/19 11:09:24 ==> ExprStmt &{p valueSpec}
2025/12/19 11:09:24 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:24 ==> ExprStmt &{p recordLine}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p setPos}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> Format Func nodeSize
2025/12/19 11:09:24 ==> AssignStmt [size found]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [0xc00031d6e0]
2025/12/19 11:09:24 ==> AssignStmt [cfg]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [0xc00031da10]
2025/12/19 11:09:24 ==> Format Func numLines
2025/12/19 11:09:24 ==> AssignStmt [from]
2025/12/19 11:09:24 ==> AssignStmt [to]
2025/12/19 11:09:24 ==> Format Func bodySize
2025/12/19 11:09:24 ==> AssignStmt [pos1]
2025/12/19 11:09:24 ==> AssignStmt [pos2]
2025/12/19 11:09:24 ==> AssignStmt [bodySize]
2025/12/19 11:09:24 ==> AssignStmt [bodySize]
2025/12/19 11:09:24 ==> AssignStmt [bodySize]
2025/12/19 11:09:24 ==> Format Func funcBody
2025/12/19 11:09:24 ==> AssignStmt [0xc0003172f0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000317320]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p block}
2025/12/19 11:09:24 ==> Format Func funcBodyUnnamed
2025/12/19 11:09:24 ==> AssignStmt [_ _]
2025/12/19 11:09:24 ==> AssignStmt [0xc000317608]
2025/12/19 11:09:24 ==> AssignStmt [0xc000317638]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [_ isEmpty]
2025/12/19 11:09:24 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:24 ==> ExprStmt &{p recordLine}
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [lt _]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> Format Func distanceFrom
2025/12/19 11:09:24 ==> Format Func funcDecl
2025/12/19 11:09:24 ==> ExprStmt &{log Println}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p funcBodyUnnamed}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> AssignStmt [startCol]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p parameters}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p signature}
2025/12/19 11:09:24 ==> ExprStmt &{p funcBody}
2025/12/19 11:09:24 ==> Format Func overloadFuncDecl
2025/12/19 11:09:24 ==> ExprStmt &{log Println}
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p parameters}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr1}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> Format Func decl
2025/12/19 11:09:24 ==> AssignStmt [d]
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p genDecl}
2025/12/19 11:09:24 ==> ExprStmt &{p funcDecl}
2025/12/19 11:09:24 ==> ExprStmt &{p overloadFuncDecl}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func declToken
2025/12/19 11:09:24 ==> AssignStmt [tok]
2025/12/19 11:09:24 ==> AssignStmt [d]
2025/12/19 11:09:24 ==> AssignStmt [tok]
2025/12/19 11:09:24 ==> AssignStmt [tok]
2025/12/19 11:09:24 ==> Format Func declList
2025/12/19 11:09:24 ==> AssignStmt [tok]
2025/12/19 11:09:24 ==> AssignStmt [decl ok]
2025/12/19 11:09:24 ==> AssignStmt [prev]
2025/12/19 11:09:24 ==> AssignStmt [tok]
2025/12/19 11:09:24 ==> AssignStmt [min]
2025/12/19 11:09:24 ==> AssignStmt [min]
2025/12/19 11:09:24 ==> ExprStmt &{p linebreak}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> Format Func file
2025/12/19 11:09:24 ==> AssignStmt [0xc0003349f0]
2025/12/19 11:09:24 ==> ExprStmt &{p setComment}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p print}
=== RUN   TestFromGopPrinter/format.Source_printer.go
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [0xc000122a98]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ac8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ae0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122b10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122b40]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122b88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ba0]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122e88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ea0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122f00]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122fa8]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc000123158]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [0xc0001232a8]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [0xc0001234a0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001234b8]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> AssignStmt [0xc000123668]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001236e0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000123758]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001237e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000123830]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000123968]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001239e0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000123a10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000123a40]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc000123b48]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000123bd8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000123c50]
2025/12/19 11:09:24 ==> AssignStmt [0xc000123c80]
2025/12/19 11:09:24 ==> AssignStmt [0xc000123cb0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000123ce0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000123d10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000123d40]
2025/12/19 11:09:24 ==> AssignStmt [0xc000123d70]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc000010090]
2025/12/19 11:09:24 ==> AssignStmt [0xc000010120]
2025/12/19 11:09:24 ==> AssignStmt [0xc000010198]
2025/12/19 11:09:24 ==> AssignStmt [0xc0000101e0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000010210]
2025/12/19 11:09:24 ==> AssignStmt [0xc000010288]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc0000103d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000010408]
2025/12/19 11:09:24 ==> AssignStmt [0xc000010438]
2025/12/19 11:09:24 ==> AssignStmt [0xc000010468]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc000010498]
2025/12/19 11:09:24 ==> AssignStmt [0xc0000104c8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0000104f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000010528]
2025/12/19 11:09:24 ==> AssignStmt [0xc000010540]
2025/12/19 11:09:24 ==> AssignStmt [0xc000010588]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000222750]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000222bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000222ff0]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002e4660]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002e55c0]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002e58c0 0xc0002e5920]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002e5ce0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc000472000]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [0xc000011a58]
2025/12/19 11:09:24 ==> AssignStmt [0xc000011a58]
2025/12/19 11:09:24 ==> AssignStmt [0xc000011a88]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [0xc000472810]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> AssignStmt [0xc000472de0]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc000472ff0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0002fc690]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003f0900 0xc0003f0990]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002fc900]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> AssignStmt [0xc0002fcbb8]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> AssignStmt [0xc0002fce70]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002fced0]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002fcf30]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002fd080]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003f1a40]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002fd140]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002fd158]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002fd1e8]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002fd260]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0002fd3b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003f1e90]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002fd500]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002fd548]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002fd5f0]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002fd890]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002fd8d8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc0002fd908]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000142258]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001422d0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000142330]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000142498]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001425b8]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc000142888]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001428a0]
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc000142a50]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000142b58]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000142be8]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc000142ca8]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000142d98]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000143188]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func Fprint
=== RUN   TestFromGopPrinter/format.Node_printer.go
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [0xc0001ebc98]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001ebcc8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001ebce0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001ebd10]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001ebd40]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001ebd88]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001ebda0]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029c108]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029c120]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029c180]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029c228]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc00029c3d8]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [0xc00029c528]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [0xc00029c720]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029c738]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> AssignStmt [0xc00029c8e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029c960]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029c9d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029ca68]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029cab0]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029cbe8]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029cc60]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029cc90]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029ccc0]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029cdc8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029ce58]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029ced0]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029cf00]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029cf30]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029cf60]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029cf90]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029cfc0]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029cff0]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc00029d260]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029d2f0]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029d368]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029d3b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029d3e0]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029d458]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029d5a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029d5d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029d608]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029d638]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029d668]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029d698]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029d6c8]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029d6f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029d710]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029d758]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002a9320]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002a97a0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002a9b90]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b3200]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002bc1b0]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002bc4b0 0xc0002bc510]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002bc8d0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002bcb70]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b0c90]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b0c90]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b0cc0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002bd380]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> AssignStmt [0xc0002bd950]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002bdb60]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b1830]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002c9440 0xc0002c94d0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b1aa0]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b1d58]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> AssignStmt [0xc0002ce090]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002ce0f0]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002ce150]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002ce2a0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002cc600]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002ce360]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002ce378]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002ce408]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002ce480]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0002ce5d0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002cca50]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002ce720]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002ce768]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002ce810]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002ceab0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002ceaf8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc0002ceb28]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002cf3f8]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002cf470]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002cf4d0]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002cf638]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002cf758]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc0002cfa28]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002cfa40]
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002cfbf0]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002cfcf8]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002cfd88]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0002cfe48]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002cff38]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002ee3a8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [0xc000320e58]
2025/12/19 11:09:24 ==> AssignStmt [0xc000320e88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000320ea0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000320ed0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000320f00]
2025/12/19 11:09:24 ==> AssignStmt [0xc000320f48]
2025/12/19 11:09:24 ==> AssignStmt [0xc000320f60]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [0xc000321248]
2025/12/19 11:09:24 ==> AssignStmt [0xc000321260]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003212c0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000321368]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc000321518]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [0xc000321668]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [0xc000321860]
2025/12/19 11:09:24 ==> AssignStmt [0xc000321878]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> AssignStmt [0xc000321a28]
2025/12/19 11:09:24 ==> AssignStmt [0xc000321aa0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000321b18]
2025/12/19 11:09:24 ==> AssignStmt [0xc000321ba8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000321bf0]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000321d28]
2025/12/19 11:09:24 ==> AssignStmt [0xc000321da0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000321dd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000321e00]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc000321f08]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c018]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c090]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c0c0]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c0f0]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c120]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c150]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c180]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c1b0]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c420]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c4b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c528]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c570]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c5a0]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c618]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c768]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c798]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c7c8]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c7f8]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c828]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c858]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c888]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c8b8]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c8d0]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036c918]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000369dd0]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003742d0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003746c0]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [0xc000375cb0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc000380c60]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [0xc000380f60 0xc000380fc0]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [0xc000381380]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc000381620]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036ddd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036ddd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc00036de00]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [0xc000381e30]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> AssignStmt [0xc00039c480]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc00039c690]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc00039a9f0]
2025/12/19 11:09:24 ==> AssignStmt [0xc00039def0 0xc000404000]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc00039ac60]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> AssignStmt [0xc00039af18]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> AssignStmt [0xc00039b1d0]
2025/12/19 11:09:24 ==> AssignStmt [0xc00039b230]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc00039b290]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc00039b3e0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0004050b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc00039b4a0]
2025/12/19 11:09:24 ==> AssignStmt [0xc00039b4b8]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc00039b548]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc00039b5c0]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc00039b710]
2025/12/19 11:09:24 ==> AssignStmt [0xc000405500]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc00039b860]
2025/12/19 11:09:24 ==> AssignStmt [0xc00039b8a8]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc00039b950]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc00039bbf0]
2025/12/19 11:09:24 ==> AssignStmt [0xc00039bc38]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc00039bc68]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0004125b8]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000412630]
2025/12/19 11:09:24 ==> AssignStmt [0xc000412690]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc0004127f8]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000412918]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc000412be8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000412c00]
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc000412db0]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000412eb8]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000412f48]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc000413008]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0004130f8]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0004134e8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func Fprint
=== RUN   TestFromGopPrinter/format.Source_printer_test.go
2025/12/19 11:09:24 ==> Format Func format
2025/12/19 11:09:24 ==> AssignStmt [f err]
2025/12/19 11:09:24 ==> ExprStmt &{ast FileExports}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001229d8]
2025/12/19 11:09:24 ==> AssignStmt [cfg]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122a50]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [res]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func TestLineComments
2025/12/19 11:09:24 ==> AssignStmt [fset]
2025/12/19 11:09:24 ==> AssignStmt [f err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [fset]
2025/12/19 11:09:24 ==> ExprStmt Fprint
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func testComment
2025/12/19 11:09:24 ==> AssignStmt [0xc00062a900]
2025/12/19 11:09:24 ==> AssignStmt [offs]
2025/12/19 11:09:24 ==> ExprStmt &{buf Reset}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Error}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatalf}
2025/12/19 11:09:24 ==> Format Func TestBadComments
2025/12/19 11:09:24 ==> ExprStmt &{t Parallel}
2025/12/19 11:09:24 ==> AssignStmt [f err]
2025/12/19 11:09:24 ==> ExprStmt &{t Error}
2025/12/19 11:09:24 ==> AssignStmt [comment]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{t Error}
2025/12/19 11:09:24 ==> ExprStmt testComment
2025/12/19 11:09:24 ==> ExprStmt testComment
2025/12/19 11:09:24 ==> ExprStmt testComment
2025/12/19 11:09:24 ==> ExprStmt testComment
2025/12/19 11:09:24 ==> Format Func Visit
2025/12/19 11:09:24 ==> AssignStmt [ident ok]
2025/12/19 11:09:24 ==> Format Func idents
2025/12/19 11:09:24 ==> AssignStmt [v]
2025/12/19 11:09:24 ==> ExprStmt &{ast Walk}
2025/12/19 11:09:24 ==> ExprStmt close
2025/12/19 11:09:24 ==> Format Func identCount
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func TestSourcePos
2025/12/19 11:09:24 ==> AssignStmt [f1 err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [f2 err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatalf}
2025/12/19 11:09:24 ==> AssignStmt [n1]
2025/12/19 11:09:24 ==> AssignStmt [n2]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> AssignStmt [i2range]
2025/12/19 11:09:24 ==> AssignStmt [i2]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> AssignStmt [l1]
2025/12/19 11:09:24 ==> AssignStmt [l2]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> ExprStmt &{t Logf}
2025/12/19 11:09:24 ==> Format Func TestIssue5945
2025/12/19 11:09:24 ==> AssignStmt [f1 err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [got]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func TestDeclLists
2025/12/19 11:09:24 ==> AssignStmt [file err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [out]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func TestStmtLists
2025/12/19 11:09:24 ==> AssignStmt [file err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [out]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func TestBaseIndent
2025/12/19 11:09:24 ==> ExprStmt &{t Parallel}
2025/12/19 11:09:24 ==> AssignStmt [src err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [file err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [indent]
2025/12/19 11:09:24 ==> AssignStmt [indent]
2025/12/19 11:09:24 ==> ExprStmt &{t Run}
2025/12/19 11:09:24 ==> ExprStmt &{t Parallel}
2025/12/19 11:09:24 ==> ExprStmt &{0xc0002f0580 Fprint}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> ExprStmt &{t Parallel}
2025/12/19 11:09:24 ==> ExprStmt &{0xc0002f0580 Fprint}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func TestFuncType
2025/12/19 11:09:24 ==> AssignStmt [src]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [got]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatalf}
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000010390]
2025/12/19 11:09:24 ==> Format Func TestWriteErrors
2025/12/19 11:09:24 ==> ExprStmt &{t Parallel}
2025/12/19 11:09:24 ==> AssignStmt [src err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [file err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [lw]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> Format Func TestX
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{t Error}
2025/12/19 11:09:24 ==> Format Func TestCommentedNode
2025/12/19 11:09:24 ==> AssignStmt [fset]
2025/12/19 11:09:24 ==> AssignStmt [f err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> ExprStmt &{buf Reset}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func TestIssue11151
2025/12/19 11:09:24 ==> AssignStmt [fset]
2025/12/19 11:09:24 ==> AssignStmt [f err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> ExprStmt Fprint
2025/12/19 11:09:24 ==> AssignStmt [got]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func TestParenthesizedDecl
2025/12/19 11:09:24 ==> AssignStmt [fset]
2025/12/19 11:09:24 ==> AssignStmt [f err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [original]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000010b40]
2025/12/19 11:09:24 ==> ExprStmt &{buf Reset}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [noparen]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func TestIssue32854
2025/12/19 11:09:24 ==> AssignStmt [src]
2025/12/19 11:09:24 ==> AssignStmt [fset]
2025/12/19 11:09:24 ==> AssignStmt [file err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [fd]
2025/12/19 11:09:24 ==> AssignStmt [ret]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001f4ab0]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [want]
2025/12/19 11:09:24 ==> AssignStmt [got]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatalf}
2025/12/19 11:09:24 ==> Format Func TestStripParens
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [y ok]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
=== RUN   TestFromGopPrinter/format.Node_printer_test.go
2025/12/19 11:09:24 ==> Format Func format
2025/12/19 11:09:24 ==> AssignStmt [f err]
2025/12/19 11:09:24 ==> ExprStmt &{ast FileExports}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001ea468]
2025/12/19 11:09:24 ==> AssignStmt [cfg]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001ea4e0]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [res]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func TestLineComments
2025/12/19 11:09:24 ==> AssignStmt [fset]
2025/12/19 11:09:24 ==> AssignStmt [f err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [fset]
2025/12/19 11:09:24 ==> ExprStmt Fprint
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func testComment
2025/12/19 11:09:24 ==> AssignStmt [0xc0003696e0]
2025/12/19 11:09:24 ==> AssignStmt [offs]
2025/12/19 11:09:24 ==> ExprStmt &{buf Reset}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Error}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatalf}
2025/12/19 11:09:24 ==> Format Func TestBadComments
2025/12/19 11:09:24 ==> ExprStmt &{t Parallel}
2025/12/19 11:09:24 ==> AssignStmt [f err]
2025/12/19 11:09:24 ==> ExprStmt &{t Error}
2025/12/19 11:09:24 ==> AssignStmt [comment]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{t Error}
2025/12/19 11:09:24 ==> ExprStmt testComment
2025/12/19 11:09:24 ==> ExprStmt testComment
2025/12/19 11:09:24 ==> ExprStmt testComment
2025/12/19 11:09:24 ==> ExprStmt testComment
2025/12/19 11:09:24 ==> Format Func Visit
2025/12/19 11:09:24 ==> AssignStmt [ident ok]
2025/12/19 11:09:24 ==> Format Func idents
2025/12/19 11:09:24 ==> AssignStmt [v]
2025/12/19 11:09:24 ==> ExprStmt &{ast Walk}
2025/12/19 11:09:24 ==> ExprStmt close
2025/12/19 11:09:24 ==> Format Func identCount
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func TestSourcePos
2025/12/19 11:09:24 ==> AssignStmt [f1 err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [f2 err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatalf}
2025/12/19 11:09:24 ==> AssignStmt [n1]
2025/12/19 11:09:24 ==> AssignStmt [n2]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> AssignStmt [i2range]
2025/12/19 11:09:24 ==> AssignStmt [i2]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> AssignStmt [l1]
2025/12/19 11:09:24 ==> AssignStmt [l2]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> ExprStmt &{t Logf}
2025/12/19 11:09:24 ==> Format Func TestIssue5945
2025/12/19 11:09:24 ==> AssignStmt [f1 err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [got]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func TestDeclLists
2025/12/19 11:09:24 ==> AssignStmt [file err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [out]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func TestStmtLists
2025/12/19 11:09:24 ==> AssignStmt [file err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [out]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func TestBaseIndent
2025/12/19 11:09:24 ==> ExprStmt &{t Parallel}
2025/12/19 11:09:24 ==> AssignStmt [src err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [file err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [indent]
2025/12/19 11:09:24 ==> AssignStmt [indent]
2025/12/19 11:09:24 ==> ExprStmt &{t Run}
2025/12/19 11:09:24 ==> ExprStmt &{t Parallel}
2025/12/19 11:09:24 ==> ExprStmt &{0xc000285700 Fprint}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> ExprStmt &{t Parallel}
2025/12/19 11:09:24 ==> ExprStmt &{0xc000285700 Fprint}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func TestFuncType
2025/12/19 11:09:24 ==> AssignStmt [src]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [got]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatalf}
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001ebd88]
2025/12/19 11:09:24 ==> Format Func TestWriteErrors
2025/12/19 11:09:24 ==> ExprStmt &{t Parallel}
2025/12/19 11:09:24 ==> AssignStmt [src err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [file err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [lw]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> Format Func TestX
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{t Error}
2025/12/19 11:09:24 ==> Format Func TestCommentedNode
2025/12/19 11:09:24 ==> AssignStmt [fset]
2025/12/19 11:09:24 ==> AssignStmt [f err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> ExprStmt &{buf Reset}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func TestIssue11151
2025/12/19 11:09:24 ==> AssignStmt [fset]
2025/12/19 11:09:24 ==> AssignStmt [f err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> ExprStmt Fprint
2025/12/19 11:09:24 ==> AssignStmt [got]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func TestParenthesizedDecl
2025/12/19 11:09:24 ==> AssignStmt [fset]
2025/12/19 11:09:24 ==> AssignStmt [f err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [original]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000413ad0]
2025/12/19 11:09:24 ==> ExprStmt &{buf Reset}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [noparen]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func TestIssue32854
2025/12/19 11:09:24 ==> AssignStmt [src]
2025/12/19 11:09:24 ==> AssignStmt [fset]
2025/12/19 11:09:24 ==> AssignStmt [file err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [fd]
2025/12/19 11:09:24 ==> AssignStmt [ret]
2025/12/19 11:09:24 ==> AssignStmt [0xc000291110]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [want]
2025/12/19 11:09:24 ==> AssignStmt [got]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatalf}
2025/12/19 11:09:24 ==> Format Func TestStripParens
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [y ok]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> Format Func format
2025/12/19 11:09:24 ==> AssignStmt [f err]
2025/12/19 11:09:24 ==> ExprStmt &{ast FileExports}
2025/12/19 11:09:24 ==> AssignStmt [0xc0002993b0]
2025/12/19 11:09:24 ==> AssignStmt [cfg]
2025/12/19 11:09:24 ==> AssignStmt [0xc000299428]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [res]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func TestLineComments
2025/12/19 11:09:24 ==> AssignStmt [fset]
2025/12/19 11:09:24 ==> AssignStmt [f err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [fset]
2025/12/19 11:09:24 ==> ExprStmt Fprint
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func testComment
2025/12/19 11:09:24 ==> AssignStmt [0xc0002c9320]
2025/12/19 11:09:24 ==> AssignStmt [offs]
2025/12/19 11:09:24 ==> ExprStmt &{buf Reset}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Error}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatalf}
2025/12/19 11:09:24 ==> Format Func TestBadComments
2025/12/19 11:09:24 ==> ExprStmt &{t Parallel}
2025/12/19 11:09:24 ==> AssignStmt [f err]
2025/12/19 11:09:24 ==> ExprStmt &{t Error}
2025/12/19 11:09:24 ==> AssignStmt [comment]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{t Error}
2025/12/19 11:09:24 ==> ExprStmt testComment
2025/12/19 11:09:24 ==> ExprStmt testComment
2025/12/19 11:09:24 ==> ExprStmt testComment
2025/12/19 11:09:24 ==> ExprStmt testComment
2025/12/19 11:09:24 ==> Format Func Visit
2025/12/19 11:09:24 ==> AssignStmt [ident ok]
2025/12/19 11:09:24 ==> Format Func idents
2025/12/19 11:09:24 ==> AssignStmt [v]
2025/12/19 11:09:24 ==> ExprStmt &{ast Walk}
2025/12/19 11:09:24 ==> ExprStmt close
2025/12/19 11:09:24 ==> Format Func identCount
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func TestSourcePos
2025/12/19 11:09:24 ==> AssignStmt [f1 err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [f2 err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatalf}
2025/12/19 11:09:24 ==> AssignStmt [n1]
2025/12/19 11:09:24 ==> AssignStmt [n2]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> AssignStmt [i2range]
2025/12/19 11:09:24 ==> AssignStmt [i2]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> AssignStmt [l1]
2025/12/19 11:09:24 ==> AssignStmt [l2]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> ExprStmt &{t Logf}
2025/12/19 11:09:24 ==> Format Func TestIssue5945
2025/12/19 11:09:24 ==> AssignStmt [f1 err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [got]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func TestDeclLists
2025/12/19 11:09:24 ==> AssignStmt [file err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [out]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func TestStmtLists
2025/12/19 11:09:24 ==> AssignStmt [file err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [out]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func TestBaseIndent
2025/12/19 11:09:24 ==> ExprStmt &{t Parallel}
2025/12/19 11:09:24 ==> AssignStmt [src err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [file err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [indent]
2025/12/19 11:09:24 ==> AssignStmt [indent]
2025/12/19 11:09:24 ==> ExprStmt &{t Run}
2025/12/19 11:09:24 ==> ExprStmt &{t Parallel}
2025/12/19 11:09:24 ==> ExprStmt &{0xc0002e1600 Fprint}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> ExprStmt &{t Parallel}
2025/12/19 11:09:24 ==> ExprStmt &{0xc0002e1600 Fprint}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func TestFuncType
2025/12/19 11:09:24 ==> AssignStmt [src]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [got]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatalf}
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002dcd38]
2025/12/19 11:09:24 ==> Format Func TestWriteErrors
2025/12/19 11:09:24 ==> ExprStmt &{t Parallel}
2025/12/19 11:09:24 ==> AssignStmt [src err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [file err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [lw]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> Format Func TestX
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{t Error}
2025/12/19 11:09:24 ==> Format Func TestCommentedNode
2025/12/19 11:09:24 ==> AssignStmt [fset]
2025/12/19 11:09:24 ==> AssignStmt [f err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> ExprStmt &{buf Reset}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func TestIssue11151
2025/12/19 11:09:24 ==> AssignStmt [fset]
2025/12/19 11:09:24 ==> AssignStmt [f err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> ExprStmt Fprint
2025/12/19 11:09:24 ==> AssignStmt [got]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func TestParenthesizedDecl
2025/12/19 11:09:24 ==> AssignStmt [fset]
2025/12/19 11:09:24 ==> AssignStmt [f err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [original]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002dd4d0]
2025/12/19 11:09:24 ==> ExprStmt &{buf Reset}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [noparen]
2025/12/19 11:09:24 ==> ExprStmt &{t Errorf}
2025/12/19 11:09:24 ==> Format Func TestIssue32854
2025/12/19 11:09:24 ==> AssignStmt [src]
2025/12/19 11:09:24 ==> AssignStmt [fset]
2025/12/19 11:09:24 ==> AssignStmt [file err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [fd]
2025/12/19 11:09:24 ==> AssignStmt [ret]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002f8ed0]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [want]
2025/12/19 11:09:24 ==> AssignStmt [got]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatalf}
2025/12/19 11:09:24 ==> Format Func TestStripParens
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [y ok]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
--- PASS: TestFromGopPrinter (0.22s)
    --- PASS: TestFromGopPrinter/format.Source_nodes.go (0.04s)
    --- PASS: TestFromGopPrinter/format.Node_nodes.go (0.08s)
    --- PASS: TestFromGopPrinter/format.Source_printer.go (0.02s)
    --- PASS: TestFromGopPrinter/format.Node_printer.go (0.04s)
    --- PASS: TestFromGopPrinter/format.Source_printer_test.go (0.01s)
    --- PASS: TestFromGopPrinter/format.Node_printer_test.go (0.02s)
=== RUN   TestFromTestdata
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/02-Var-and-operator/var_and_op.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [y z]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/02-Var-and-operator/var_and_op.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [y z]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/03-Import-go-package/import.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/03-Import-go-package/import.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/04-Func/func.xgo
2025/12/19 11:09:24 ==> Format Func foo
2025/12/19 11:09:24 ==> Format Func printf
2025/12/19 11:09:24 ==> AssignStmt [n err]
2025/12/19 11:09:24 ==> Format Func bar
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt bar
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/04-Func/func.xgo
2025/12/19 11:09:24 ==> Format Func foo
2025/12/19 11:09:24 ==> Format Func printf
2025/12/19 11:09:24 ==> AssignStmt [n err]
2025/12/19 11:09:24 ==> Format Func bar
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt bar
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> Format Func foo
2025/12/19 11:09:24 ==> Format Func printf
2025/12/19 11:09:24 ==> AssignStmt [n err]
2025/12/19 11:09:24 ==> Format Func bar
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt bar
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/05-Closure/closure.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [foo]
2025/12/19 11:09:24 ==> AssignStmt [n err]
2025/12/19 11:09:24 ==> AssignStmt [n err]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> AssignStmt [printf]
2025/12/19 11:09:24 ==> AssignStmt [n err]
2025/12/19 11:09:24 ==> AssignStmt [n err]
2025/12/19 11:09:24 ==> AssignStmt [bar]
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt bar
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/05-Closure/closure.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [foo]
2025/12/19 11:09:24 ==> AssignStmt [n err]
2025/12/19 11:09:24 ==> AssignStmt [n err]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> AssignStmt [printf]
2025/12/19 11:09:24 ==> AssignStmt [n err]
2025/12/19 11:09:24 ==> AssignStmt [n err]
2025/12/19 11:09:24 ==> AssignStmt [bar]
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt bar
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/06-String-Map-Array-Slice/datastruct.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [y]
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003871a0 0xc000387200]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000387500 0xc000387530]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [arr]
2025/12/19 11:09:24 ==> AssignStmt [title]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/06-String-Map-Array-Slice/datastruct.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [y]
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc000390150 0xc0003901b0]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003904b0 0xc0003904e0]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [arr]
2025/12/19 11:09:24 ==> AssignStmt [title]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/07-MapLit/maplit.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [y]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/07-MapLit/maplit.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [y]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/08-SliceLit/slicelit.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [y]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [z]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/08-SliceLit/slicelit.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [y]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [z]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/09-IfElse-SwitchCase/flow.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [v]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [v]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [z]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/09-IfElse-SwitchCase/flow.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [v]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [v]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [z]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/10-List-comprehension/list_comprehens.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [y]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [y]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [z]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [arr]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/10-List-comprehension/list_comprehens.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [y]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [y]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [z]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [arr]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/11-Map-comprehension/map_comprehens.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [y]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [y]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [z]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/11-Map-comprehension/map_comprehens.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [y]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [y]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [z]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/12-Select-comprehension/select.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> AssignStmt [where]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [at ok]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/12-Select-comprehension/select.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> AssignStmt [where]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [at ok]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/12-Select-comprehension2/findscore.xgo
2025/12/19 11:09:24 ==> Format Func findScore
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/12-Select-comprehension2/findscore.xgo
2025/12/19 11:09:24 ==> Format Func findScore
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/13-Exists-comprehension/exists.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> AssignStmt [hasFullMark]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [hasFailed]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/13-Exists-comprehension/exists.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> AssignStmt [hasFullMark]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [hasFailed]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/14-Using-goplus-in-Go/foo/foo.xgo
2025/12/19 11:09:24 ==> Format Func ReverseMap
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/14-Using-goplus-in-Go/foo/foo.xgo
2025/12/19 11:09:24 ==> Format Func ReverseMap
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/14-Using-goplus-in-Go/foo/foo_test.xgo
2025/12/19 11:09:24 ==> Format Func TestReverseMap
2025/12/19 11:09:24 ==> AssignStmt [out]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/14-Using-goplus-in-Go/foo/foo_test.xgo
2025/12/19 11:09:24 ==> Format Func TestReverseMap
2025/12/19 11:09:24 ==> AssignStmt [out]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> Format Func TestReverseMap
2025/12/19 11:09:24 ==> AssignStmt [out]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/14-Using-goplus-in-Go/foo/footest_test.xgo
2025/12/19 11:09:24 ==> Format Func TestReverseMap
2025/12/19 11:09:24 ==> AssignStmt [out]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/14-Using-goplus-in-Go/foo/footest_test.xgo
2025/12/19 11:09:24 ==> Format Func TestReverseMap
2025/12/19 11:09:24 ==> AssignStmt [out]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
2025/12/19 11:09:24 ==> Format Func TestReverseMap
2025/12/19 11:09:24 ==> AssignStmt [out]
2025/12/19 11:09:24 ==> ExprStmt &{t Fatal}
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/15-ErrWrap/err_wrap.xgo
2025/12/19 11:09:24 ==> Format Func add
2025/12/19 11:09:24 ==> Format Func addSafe
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum err]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/15-ErrWrap/err_wrap.xgo
2025/12/19 11:09:24 ==> Format Func add
2025/12/19 11:09:24 ==> Format Func addSafe
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum err]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> Format Func add
2025/12/19 11:09:24 ==> Format Func addSafe
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum err]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/16-Fib/fib.xgo
2025/12/19 11:09:24 ==> Format Func fib
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/16-Fib/fib.xgo
2025/12/19 11:09:24 ==> Format Func fib
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/17-Fibtc/fibtc.xgo
2025/12/19 11:09:24 ==> Format Func fibtc
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/17-Fibtc/fibtc.xgo
2025/12/19 11:09:24 ==> Format Func fibtc
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/18-Rational/rational.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/18-Rational/rational.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/21-Break-continue-goto/flow.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> AssignStmt [arr]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [z]
2025/12/19 11:09:24 ==> AssignStmt [v]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/21-Break-continue-goto/flow.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> AssignStmt [arr]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [z]
2025/12/19 11:09:24 ==> AssignStmt [v]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/22-For-loop/for.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [fns]
2025/12/19 11:09:24 ==> AssignStmt [v]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003f9980]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> AssignStmt [v]
2025/12/19 11:09:24 ==> AssignStmt [0xc000002180]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> AssignStmt [arr]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/22-For-loop/for.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [fns]
2025/12/19 11:09:24 ==> AssignStmt [v]
2025/12/19 11:09:24 ==> AssignStmt [0xc000003560]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> AssignStmt [v]
2025/12/19 11:09:24 ==> AssignStmt [0xc000003ce0]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> AssignStmt [arr]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/23-Defer/defer.xgo
2025/12/19 11:09:24 ==> Format Func f
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> Format Func g
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> Format Func h
2025/12/19 11:09:24 ==> AssignStmt [v]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/23-Defer/defer.xgo
2025/12/19 11:09:24 ==> Format Func f
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> Format Func g
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> Format Func h
2025/12/19 11:09:24 ==> AssignStmt [v]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/24-Goroutine/goroutine.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt &{time Sleep}
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/24-Goroutine/goroutine.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt &{time Sleep}
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/25-Struct/struct.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a348 0xc00042a360]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a378 0xc00042a390]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a3a8 0xc00042a3c0]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/25-Struct/struct.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a5d0 0xc00042a5e8]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a600 0xc00042a618]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a630 0xc00042a648]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/26-Method/method.xgo
2025/12/19 11:09:24 ==> Format Func SetName
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a7c8]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> Format Func SetAge
2025/12/19 11:09:24 ==> AssignStmt [age]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a810]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> Format Func AddFriends
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a870]
2025/12/19 11:09:24 ==> Format Func Foo
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [p]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a8a0 0xc00042a8b8]
2025/12/19 11:09:24 ==> ExprStmt &{p SetName}
2025/12/19 11:09:24 ==> ExprStmt &{p SetAge}
2025/12/19 11:09:24 ==> ExprStmt &{p AddFriends}
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt &{m Foo}
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/26-Method/method.xgo
2025/12/19 11:09:24 ==> Format Func SetName
2025/12/19 11:09:24 ==> AssignStmt [0xc00042ab70]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> Format Func SetAge
2025/12/19 11:09:24 ==> AssignStmt [age]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042abb8]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> Format Func AddFriends
2025/12/19 11:09:24 ==> AssignStmt [0xc00042ac18]
2025/12/19 11:09:24 ==> Format Func Foo
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [p]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042ac48 0xc00042ac60]
2025/12/19 11:09:24 ==> ExprStmt &{p SetName}
2025/12/19 11:09:24 ==> ExprStmt &{p SetAge}
2025/12/19 11:09:24 ==> ExprStmt &{p AddFriends}
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt &{m Foo}
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/27-Func-Set/func.xgo
2025/12/19 11:09:24 ==> Format Func A
2025/12/19 11:09:24 ==> AssignStmt [0xc00042af78]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042afa8]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042afd8]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b008]
2025/12/19 11:09:24 ==> Format Func Index
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a1]
2025/12/19 11:09:24 ==> AssignStmt [a2]
2025/12/19 11:09:24 ==> AssignStmt [a3]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> ExprStmt A
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b0c8]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b0f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b128]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/27-Func-Set/func.xgo
2025/12/19 11:09:24 ==> Format Func A
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b3f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b428]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b458]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b488]
2025/12/19 11:09:24 ==> Format Func Index
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a1]
2025/12/19 11:09:24 ==> AssignStmt [a2]
2025/12/19 11:09:24 ==> AssignStmt [a3]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> ExprStmt A
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b548]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b578]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b5a8]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/28-Chan/chan.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> ExprStmt close
2025/12/19 11:09:24 ==> AssignStmt [d]
2025/12/19 11:09:24 ==> AssignStmt [e ok]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/28-Chan/chan.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> ExprStmt close
2025/12/19 11:09:24 ==> AssignStmt [d]
2025/12/19 11:09:24 ==> AssignStmt [e ok]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/29-CompareToNil/ref.xgo
2025/12/19 11:09:24 ==> Format Func foo
2025/12/19 11:09:24 ==> Format Func foo1
2025/12/19 11:09:24 ==> Format Func foo2
2025/12/19 11:09:24 ==> Format Func foo3
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/29-CompareToNil/ref.xgo
2025/12/19 11:09:24 ==> Format Func foo
2025/12/19 11:09:24 ==> Format Func foo1
2025/12/19 11:09:24 ==> Format Func foo2
2025/12/19 11:09:24 ==> Format Func foo3
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/30-Recover/recover.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt panic
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/30-Recover/recover.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt panic
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/31-Builtin-Typecast/builtin_and_typecast.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/31-Builtin-Typecast/builtin_and_typecast.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/32-Import-gop-package/import_gop_pkg.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [rmap]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/32-Import-gop-package/import_gop_pkg.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [rmap]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/33-Interface/shape.xgo
2025/12/19 11:09:24 ==> Format Func Area
2025/12/19 11:09:24 ==> Format Func Area
2025/12/19 11:09:24 ==> Format Func Area
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [rect]
2025/12/19 11:09:24 ==> AssignStmt [circle]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/33-Interface/shape.xgo
2025/12/19 11:09:24 ==> Format Func Area
2025/12/19 11:09:24 ==> Format Func Area
2025/12/19 11:09:24 ==> Format Func Area
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [rect]
2025/12/19 11:09:24 ==> AssignStmt [circle]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/34-Type-assert/type_assert.xgo
2025/12/19 11:09:24 ==> Format Func foo
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> Format Func add
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/34-Type-assert/type_assert.xgo
2025/12/19 11:09:24 ==> Format Func foo
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> Format Func add
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/35-Chan-select/select.xgo
2025/12/19 11:09:24 ==> Format Func consume
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> Format Func product
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [from]
2025/12/19 11:09:24 ==> AssignStmt [xchg]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt close
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/35-Chan-select/select.xgo
2025/12/19 11:09:24 ==> Format Func consume
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> Format Func product
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [from]
2025/12/19 11:09:24 ==> AssignStmt [xchg]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt close
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/36-Auto-Property/autoprop.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [script]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/36-Auto-Property/autoprop.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [script]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [script]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/37-Cmdline/cmdline.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/37-Cmdline/cmdline.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/38-Overload-operator/overload_op.xgo
2025/12/19 11:09:24 ==> Format Func Int
2025/12/19 11:09:24 ==> Format Func +
2025/12/19 11:09:24 ==> Format Func +=
2025/12/19 11:09:24 ==> ExprStmt &{0xc0001230e0 Add}
2025/12/19 11:09:24 ==> Format Func -
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/38-Overload-operator/overload_op.xgo
2025/12/19 11:09:24 ==> Format Func Int
2025/12/19 11:09:24 ==> Format Func +
2025/12/19 11:09:24 ==> Format Func +=
2025/12/19 11:09:24 ==> ExprStmt &{0xc000123338 Add}
2025/12/19 11:09:24 ==> Format Func -
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/39-Lambda-expression/lambda.xgo
2025/12/19 11:09:24 ==> Format Func Map
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/39-Lambda-expression/lambda.xgo
2025/12/19 11:09:24 ==> Format Func Map
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/40-Deduce-struct-type/deduce.xgo
2025/12/19 11:09:24 ==> Format Func foo
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [ret]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/40-Deduce-struct-type/deduce.xgo
2025/12/19 11:09:24 ==> Format Func foo
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [ret]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/41-UDT-RangeForEach/udt_range.xgo
2025/12/19 11:09:24 ==> Format Func Gop_Enum
2025/12/19 11:09:24 ==> ExprStmt proc
2025/12/19 11:09:24 ==> ExprStmt proc
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/41-UDT-RangeForEach/udt_range.xgo
2025/12/19 11:09:24 ==> Format Func Gop_Enum
2025/12/19 11:09:24 ==> ExprStmt proc
2025/12/19 11:09:24 ==> ExprStmt proc
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/42-UDT-RangeIterator/udt_range_iter.xgo
2025/12/19 11:09:24 ==> Format Func Next
2025/12/19 11:09:24 ==> AssignStmt [key val ok]
2025/12/19 11:09:24 ==> Format Func newFoo
2025/12/19 11:09:24 ==> Format Func Gop_Enum
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [obj]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/42-UDT-RangeIterator/udt_range_iter.xgo
2025/12/19 11:09:24 ==> Format Func Next
2025/12/19 11:09:24 ==> AssignStmt [key val ok]
2025/12/19 11:09:24 ==> Format Func newFoo
2025/12/19 11:09:24 ==> Format Func Gop_Enum
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [obj]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Source_/app/printer/_testdata/43-RangeExpr/rangeexpr.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromTestdata/format.Node_/app/printer/_testdata/43-RangeExpr/rangeexpr.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
--- PASS: TestFromTestdata (0.05s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/02-Var-and-operator/var_and_op.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/02-Var-and-operator/var_and_op.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/03-Import-go-package/import.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/03-Import-go-package/import.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/04-Func/func.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/04-Func/func.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/05-Closure/closure.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/05-Closure/closure.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/06-String-Map-Array-Slice/datastruct.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/06-String-Map-Array-Slice/datastruct.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/07-MapLit/maplit.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/07-MapLit/maplit.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/08-SliceLit/slicelit.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/08-SliceLit/slicelit.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/09-IfElse-SwitchCase/flow.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/09-IfElse-SwitchCase/flow.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/10-List-comprehension/list_comprehens.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/10-List-comprehension/list_comprehens.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/11-Map-comprehension/map_comprehens.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/11-Map-comprehension/map_comprehens.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/12-Select-comprehension/select.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/12-Select-comprehension/select.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/12-Select-comprehension2/findscore.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/12-Select-comprehension2/findscore.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/13-Exists-comprehension/exists.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/13-Exists-comprehension/exists.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/14-Using-goplus-in-Go/foo/foo.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/14-Using-goplus-in-Go/foo/foo.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/14-Using-goplus-in-Go/foo/foo_test.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/14-Using-goplus-in-Go/foo/foo_test.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/14-Using-goplus-in-Go/foo/footest_test.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/14-Using-goplus-in-Go/foo/footest_test.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/15-ErrWrap/err_wrap.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/15-ErrWrap/err_wrap.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/16-Fib/fib.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/16-Fib/fib.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/17-Fibtc/fibtc.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/17-Fibtc/fibtc.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/18-Rational/rational.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/18-Rational/rational.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/21-Break-continue-goto/flow.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/21-Break-continue-goto/flow.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/22-For-loop/for.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/22-For-loop/for.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/23-Defer/defer.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/23-Defer/defer.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/24-Goroutine/goroutine.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/24-Goroutine/goroutine.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/25-Struct/struct.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/25-Struct/struct.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/26-Method/method.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/26-Method/method.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/27-Func-Set/func.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/27-Func-Set/func.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/28-Chan/chan.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/28-Chan/chan.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/29-CompareToNil/ref.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/29-CompareToNil/ref.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/30-Recover/recover.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/30-Recover/recover.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/31-Builtin-Typecast/builtin_and_typecast.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/31-Builtin-Typecast/builtin_and_typecast.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/32-Import-gop-package/import_gop_pkg.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/32-Import-gop-package/import_gop_pkg.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/33-Interface/shape.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/33-Interface/shape.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/34-Type-assert/type_assert.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/34-Type-assert/type_assert.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/35-Chan-select/select.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/35-Chan-select/select.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/36-Auto-Property/autoprop.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/36-Auto-Property/autoprop.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/37-Cmdline/cmdline.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/37-Cmdline/cmdline.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/38-Overload-operator/overload_op.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/38-Overload-operator/overload_op.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/39-Lambda-expression/lambda.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/39-Lambda-expression/lambda.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/40-Deduce-struct-type/deduce.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/40-Deduce-struct-type/deduce.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/41-UDT-RangeForEach/udt_range.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/41-UDT-RangeForEach/udt_range.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/42-UDT-RangeIterator/udt_range_iter.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/42-UDT-RangeIterator/udt_range_iter.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Source_/app/printer/_testdata/43-RangeExpr/rangeexpr.xgo (0.00s)
    --- PASS: TestFromTestdata/format.Node_/app/printer/_testdata/43-RangeExpr/rangeexpr.xgo (0.00s)
=== RUN   TestFromParse
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/append1/append.xgo
2025/12/19 11:09:24 ==> Format Func main
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/append1/append.xgo
2025/12/19 11:09:24 ==> Format Func main
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/append2/append.xgo
2025/12/19 11:09:24 ==> Format Func main
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/append2/append.xgo
2025/12/19 11:09:24 ==> Format Func main
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/arrowop/arrowop.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt echo
2025/12/19 11:09:24 ==> ExprStmt echo
2025/12/19 11:09:24 ==> ExprStmt echo
2025/12/19 11:09:24 ==> ExprStmt echo
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/arrowop/arrowop.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt echo
2025/12/19 11:09:24 ==> ExprStmt echo
2025/12/19 11:09:24 ==> ExprStmt echo
2025/12/19 11:09:24 ==> ExprStmt echo
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/autoprop/goto.xgo
2025/12/19 11:09:24 ==> Format Func main
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/autoprop/goto.xgo
2025/12/19 11:09:24 ==> Format Func main
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/build/build.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [title]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/build/build.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [title]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/c2gohello/hello.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt &{C printf}
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/c2gohello/hello.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt &{C printf}
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/cmdlinestyle1/cmd.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/cmdlinestyle1/cmd.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/cmdlinestyle2/cmd2.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt x
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/cmdlinestyle2/cmd2.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt x
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/cmdlinestyle3/cmd3.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/cmdlinestyle3/cmd3.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/cmdlinestyle4/cmd4.xgo
2025/12/19 11:09:24 ==> Format Func call
2025/12/19 11:09:24 ==> ExprStmt fn
2025/12/19 11:09:24 ==> ExprStmt fn
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt call
2025/12/19 11:09:24 ==> ExprStmt call
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt call
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/cmdlinestyle4/cmd4.xgo
2025/12/19 11:09:24 ==> Format Func call
2025/12/19 11:09:24 ==> ExprStmt fn
2025/12/19 11:09:24 ==> ExprStmt fn
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt call
2025/12/19 11:09:24 ==> ExprStmt call
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt call
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/collection/collection.xgo
2025/12/19 11:09:24 ==> Format Func Index
2025/12/19 11:09:24 ==> Format Func Include
2025/12/19 11:09:24 ==> Format Func Any
2025/12/19 11:09:24 ==> Format Func All
2025/12/19 11:09:24 ==> Format Func Filter
2025/12/19 11:09:24 ==> AssignStmt [vsf]
2025/12/19 11:09:24 ==> AssignStmt [vsf]
2025/12/19 11:09:24 ==> Format Func Map
2025/12/19 11:09:24 ==> AssignStmt [vsm]
2025/12/19 11:09:24 ==> AssignStmt [0xc00027e000]
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/collection/collection.xgo
2025/12/19 11:09:24 ==> Format Func Index
2025/12/19 11:09:24 ==> Format Func Include
2025/12/19 11:09:24 ==> Format Func Any
2025/12/19 11:09:24 ==> Format Func All
2025/12/19 11:09:24 ==> Format Func Filter
2025/12/19 11:09:24 ==> AssignStmt [vsf]
2025/12/19 11:09:24 ==> AssignStmt [vsf]
2025/12/19 11:09:24 ==> Format Func Map
2025/12/19 11:09:24 ==> AssignStmt [vsm]
2025/12/19 11:09:24 ==> AssignStmt [0xc00028a870]
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> Format Func Index
2025/12/19 11:09:24 ==> Format Func Include
2025/12/19 11:09:24 ==> Format Func Any
2025/12/19 11:09:24 ==> Format Func All
2025/12/19 11:09:24 ==> Format Func Filter
2025/12/19 11:09:24 ==> AssignStmt [vsf]
2025/12/19 11:09:24 ==> AssignStmt [vsf]
2025/12/19 11:09:24 ==> Format Func Map
2025/12/19 11:09:24 ==> AssignStmt [vsm]
2025/12/19 11:09:24 ==> AssignStmt [0xc000299080]
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/complit/complit.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/complit/complit.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/domainhuh/huh.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [form]
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/domainhuh/huh.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [form]
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/domaintext/tpl.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [cl]
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/domaintext/tpl.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [cl]
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/domaintpl/tpl.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [cl]
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/domaintpl/tpl.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [cl]
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/embedded1/embtype.xgo
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/embedded1/embtype.xgo
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/envop1/envop.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt echo
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/envop1/envop.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt echo
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/envop2/envop.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt echo
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/envop2/envop.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt echo
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/errwrap1/errwrap.xgo
2025/12/19 11:09:24 ==> Format Func add
2025/12/19 11:09:24 ==> Format Func addSafe
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum err]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/errwrap1/errwrap.xgo
2025/12/19 11:09:24 ==> Format Func add
2025/12/19 11:09:24 ==> Format Func addSafe
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum err]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> Format Func add
2025/12/19 11:09:24 ==> Format Func addSafe
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum err]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/errwrap2/errwrap2.xgo
2025/12/19 11:09:24 ==> Format Func neg
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/errwrap2/errwrap2.xgo
2025/12/19 11:09:24 ==> Format Func neg
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/errwrap3/errwrap3.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt &{mkdir ! 6 <nil>}
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/errwrap3/errwrap3.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt &{mkdir ! 6 <nil>}
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/exists/exists.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> AssignStmt [hasEven]
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/exists/exists.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> AssignStmt [hasEven]
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/fnbody/fnbody.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/fnbody/fnbody.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/fncall/fncall.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt &{fn 3 [0xc0002cdbf0] 0 [] 5 0}
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/fncall/fncall.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt &{fn 3 [0xc0002cde60] 0 [] 5 0}
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/forloop/forloop.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/forloop/forloop.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [sum]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/funcdecl1/fndecl.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt &{0xc0002dada0 0xc0002dfad0}
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/funcdecl1/fndecl.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt &{0xc0002daec0 0xc0002dff20}
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/funcdecl2/fndecl.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt &{0xc0002daf60 0xc0002ec360}
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/funcdecl2/fndecl.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt &{0xc0002dafe0 0xc0002ec660}
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/funcdecl3/fndecl.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt &{0xc0002db0c0 0xc0002ec9c0}
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/funcdecl3/fndecl.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt &{0xc0002db180 0xc0002ecd80}
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/funcdoc/funcdoc.xgo
2025/12/19 11:09:24 ==> Format Func test
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/funcdoc/funcdoc.xgo
2025/12/19 11:09:24 ==> Format Func test
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/funclit/funclit.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt &{0xc0002db700 0xc0002ed8f0}
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/funclit/funclit.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt &{0xc0002db900 0xc0002ede30}
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/goto1/goto.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt goto
2025/12/19 11:09:24 ==> ExprStmt goto
2025/12/19 11:09:24 ==> ExprStmt goto
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/goto1/goto.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt goto
2025/12/19 11:09:24 ==> ExprStmt goto
2025/12/19 11:09:24 ==> ExprStmt goto
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/goto2/goto.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt goto
2025/12/19 11:09:24 ==> ExprStmt goto
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/goto2/goto.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt goto
2025/12/19 11:09:24 ==> ExprStmt goto
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/goxtest1/bar.gox
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/goxtest1/bar.gox
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/goxtest2/bar.gox
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/goxtest2/bar.gox
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/kwargs1/kwargs.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt playSound
2025/12/19 11:09:24 ==> ExprStmt listDir
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/kwargs1/kwargs.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt playSound
2025/12/19 11:09:24 ==> ExprStmt listDir
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/lambda1/lambda.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt foo
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/lambda1/lambda.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt foo
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/lambda2/lambda2.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/lambda2/lambda2.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/lambda3/lambda3.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/lambda3/lambda3.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt foo
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/lambda4/lambda4.xgo
2025/12/19 11:09:24 ==> Format Func main
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/lambda4/lambda4.xgo
2025/12/19 11:09:24 ==> Format Func main
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/listcompr/listcompr.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [y]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [y]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [z]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [arr]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/listcompr/listcompr.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [y]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [y]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [z]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [arr]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/mapfunc/map.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt map
2025/12/19 11:09:24 ==> ExprStmt map
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/mapfunc/map.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt map
2025/12/19 11:09:24 ==> ExprStmt map
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/matrix1/matrix.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt echo
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/matrix1/matrix.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt echo
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/matrix2/matrix.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt echo
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/matrix2/matrix.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt echo
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/mytest/mytest.xgo
2025/12/19 11:09:24 ==> Format Func bar
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [f err]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [foo ok]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/mytest/mytest.xgo
2025/12/19 11:09:24 ==> Format Func bar
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [f err]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [foo ok]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> Format Func bar
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [f err]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [foo ok]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/optparam/optparam.xgo
2025/12/19 11:09:24 ==> Format Func single
2025/12/19 11:09:24 ==> Format Func multiple
2025/12/19 11:09:24 ==> Format Func mixed
2025/12/19 11:09:24 ==> Format Func pointer
2025/12/19 11:09:24 ==> Format Func complex
2025/12/19 11:09:24 ==> Format Func arrays
2025/12/19 11:09:24 ==> Format Func interfaces
2025/12/19 11:09:24 ==> Format Func structs
2025/12/19 11:09:24 ==> Format Func funcs
2025/12/19 11:09:24 ==> Format Func qualified
2025/12/19 11:09:24 ==> Format Func unnamed
2025/12/19 11:09:24 ==> Format Func allOptional
2025/12/19 11:09:24 ==> Format Func withVariadic
2025/12/19 11:09:24 ==> Format Func Handle
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/optparam/optparam.xgo
2025/12/19 11:09:24 ==> Format Func single
2025/12/19 11:09:24 ==> Format Func multiple
2025/12/19 11:09:24 ==> Format Func mixed
2025/12/19 11:09:24 ==> Format Func pointer
2025/12/19 11:09:24 ==> Format Func complex
2025/12/19 11:09:24 ==> Format Func arrays
2025/12/19 11:09:24 ==> Format Func interfaces
2025/12/19 11:09:24 ==> Format Func structs
2025/12/19 11:09:24 ==> Format Func funcs
2025/12/19 11:09:24 ==> Format Func qualified
2025/12/19 11:09:24 ==> Format Func unnamed
2025/12/19 11:09:24 ==> Format Func allOptional
2025/12/19 11:09:24 ==> Format Func withVariadic
2025/12/19 11:09:24 ==> Format Func Handle
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/overload1/overload.xgo
2025/12/19 11:09:24 ==> Format OverloadFunc foo
2025/12/19 11:09:24 ==> Format OverloadFunc bar
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/overload1/overload.xgo
2025/12/19 11:09:24 ==> Format OverloadFunc foo
2025/12/19 11:09:24 ==> Format OverloadFunc bar
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/overload2/overload2.xgo
2025/12/19 11:09:24 ==> Format OverloadFunc *
2025/12/19 11:09:24 ==> Format OverloadFunc add
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/overload2/overload2.xgo
2025/12/19 11:09:24 ==> Format OverloadFunc *
2025/12/19 11:09:24 ==> Format OverloadFunc add
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/overloadop/op_overload.xgo
2025/12/19 11:09:24 ==> Format Func *
2025/12/19 11:09:24 ==> Format Func +
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> Format Func /
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> Format Func -
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> Format Func ++
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/overloadop/op_overload.xgo
2025/12/19 11:09:24 ==> Format Func *
2025/12/19 11:09:24 ==> Format Func +
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> Format Func /
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> Format Func -
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> Format Func ++
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/printvariadic/printv.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/printvariadic/printv.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/pystr/pystr.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt print
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/pystr/pystr.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt print
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/rangeexpr1/rangeexpr.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/rangeexpr1/rangeexpr.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/rangeexpr2/rangeexpr.xgo
2025/12/19 11:09:24 ==> Format Func main
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/rangeexpr2/rangeexpr.xgo
2025/12/19 11:09:24 ==> Format Func main
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/rangeexpr3/rangeexpr.xgo
2025/12/19 11:09:24 ==> Format Func main
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/rangeexpr3/rangeexpr.xgo
2025/12/19 11:09:24 ==> Format Func main
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/rational/rational.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/rational/rational.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/selectdata/select.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> AssignStmt [y]
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/selectdata/select.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> AssignStmt [y]
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/slice1/slice.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/slice1/slice.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/slice2/slice2.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/slice2/slice2.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/staticmthd1/static_method.xgo
2025/12/19 11:09:24 ==> Format Func foo
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/staticmthd1/static_method.xgo
2025/12/19 11:09:24 ==> Format Func foo
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/staticmthd2/a.gox
2025/12/19 11:09:24 ==> Format Func New
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/staticmthd2/a.gox
2025/12/19 11:09:24 ==> Format Func New
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/stdtype/stdtype.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [y]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/stdtype/stdtype.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [y]
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> AssignStmt [a]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/stringex1/string_lit.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/stringex1/string_lit.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/stringex2/string_lit.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/stringex2/string_lit.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/stringex3/string_lit.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/stringex3/string_lit.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt println
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/typeof/typeof.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt echo
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/typeof/typeof.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt echo
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/typeswitch/typeswitch.xgo
2025/12/19 11:09:24 ==> Format Func add
2025/12/19 11:09:24 ==> AssignStmt [a]
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/typeswitch/typeswitch.xgo
2025/12/19 11:09:24 ==> Format Func add
2025/12/19 11:09:24 ==> AssignStmt [a]
=== RUN   TestFromParse/format.Source_/app/parser/_testdata/unit/step.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt wait
=== RUN   TestFromParse/format.Node_/app/parser/_testdata/unit/step.xgo
2025/12/19 11:09:24 ==> Format Func main
2025/12/19 11:09:24 ==> ExprStmt wait
--- PASS: TestFromParse (0.04s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/append1/append.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/append1/append.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/append2/append.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/append2/append.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/arrowop/arrowop.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/arrowop/arrowop.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/autoprop/goto.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/autoprop/goto.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/build/build.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/build/build.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/c2gohello/hello.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/c2gohello/hello.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/cmdlinestyle1/cmd.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/cmdlinestyle1/cmd.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/cmdlinestyle2/cmd2.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/cmdlinestyle2/cmd2.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/cmdlinestyle3/cmd3.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/cmdlinestyle3/cmd3.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/cmdlinestyle4/cmd4.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/cmdlinestyle4/cmd4.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/collection/collection.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/collection/collection.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/complit/complit.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/complit/complit.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/domainhuh/huh.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/domainhuh/huh.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/domaintext/tpl.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/domaintext/tpl.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/domaintpl/tpl.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/domaintpl/tpl.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/embedded1/embtype.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/embedded1/embtype.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/envop1/envop.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/envop1/envop.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/envop2/envop.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/envop2/envop.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/errwrap1/errwrap.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/errwrap1/errwrap.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/errwrap2/errwrap2.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/errwrap2/errwrap2.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/errwrap3/errwrap3.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/errwrap3/errwrap3.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/exists/exists.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/exists/exists.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/fnbody/fnbody.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/fnbody/fnbody.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/fncall/fncall.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/fncall/fncall.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/forloop/forloop.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/forloop/forloop.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/funcdecl1/fndecl.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/funcdecl1/fndecl.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/funcdecl2/fndecl.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/funcdecl2/fndecl.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/funcdecl3/fndecl.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/funcdecl3/fndecl.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/funcdoc/funcdoc.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/funcdoc/funcdoc.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/funclit/funclit.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/funclit/funclit.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/goto1/goto.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/goto1/goto.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/goto2/goto.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/goto2/goto.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/goxtest1/bar.gox (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/goxtest1/bar.gox (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/goxtest2/bar.gox (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/goxtest2/bar.gox (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/kwargs1/kwargs.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/kwargs1/kwargs.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/lambda1/lambda.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/lambda1/lambda.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/lambda2/lambda2.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/lambda2/lambda2.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/lambda3/lambda3.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/lambda3/lambda3.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/lambda4/lambda4.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/lambda4/lambda4.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/listcompr/listcompr.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/listcompr/listcompr.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/mapfunc/map.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/mapfunc/map.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/matrix1/matrix.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/matrix1/matrix.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/matrix2/matrix.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/matrix2/matrix.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/mytest/mytest.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/mytest/mytest.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/optparam/optparam.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/optparam/optparam.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/overload1/overload.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/overload1/overload.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/overload2/overload2.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/overload2/overload2.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/overloadop/op_overload.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/overloadop/op_overload.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/printvariadic/printv.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/printvariadic/printv.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/pystr/pystr.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/pystr/pystr.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/rangeexpr1/rangeexpr.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/rangeexpr1/rangeexpr.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/rangeexpr2/rangeexpr.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/rangeexpr2/rangeexpr.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/rangeexpr3/rangeexpr.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/rangeexpr3/rangeexpr.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/rational/rational.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/rational/rational.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/selectdata/select.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/selectdata/select.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/slice1/slice.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/slice1/slice.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/slice2/slice2.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/slice2/slice2.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/staticmthd1/static_method.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/staticmthd1/static_method.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/staticmthd2/a.gox (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/staticmthd2/a.gox (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/stdtype/stdtype.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/stdtype/stdtype.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/stringex1/string_lit.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/stringex1/string_lit.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/stringex2/string_lit.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/stringex2/string_lit.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/stringex3/string_lit.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/stringex3/string_lit.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/typeof/typeof.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/typeof/typeof.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/typeswitch/typeswitch.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/typeswitch/typeswitch.xgo (0.00s)
    --- PASS: TestFromParse/format.Source_/app/parser/_testdata/unit/step.xgo (0.00s)
    --- PASS: TestFromParse/format.Node_/app/parser/_testdata/unit/step.xgo (0.00s)
=== CONT  TestBadComments
=== CONT  TestWriteErrors
=== CONT  TestBaseIndent
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
=== RUN   TestBaseIndent/0
=== PAUSE TestBaseIndent/0
=== RUN   TestBaseIndent/1
=== PAUSE TestBaseIndent/1
=== RUN   TestBaseIndent/2
=== PAUSE TestBaseIndent/2
=== RUN   TestBaseIndent/3
=== PAUSE TestBaseIndent/3
=== CONT  TestBaseIndent/0
=== CONT  TestBaseIndent/2
2025/12/19 11:09:24 ==> Format Func init
=== CONT  TestBaseIndent/3
=== CONT  TestBaseIndent/1
2025/12/19 11:09:24 ==> AssignStmt [0xc0005962e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596318]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596330]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596360]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596390]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963c0]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [0xc0005965e8]
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [0xc000596600]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a22a0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a22a0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596660]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a22d0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a22d0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596690]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a22e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a22e8]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2318]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2318]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2348]
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2348]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2360]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2378]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2360]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a22a0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a22d0]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a22e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2378]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2318]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2348]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596768]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2360]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2378]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a22a0]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a22d0]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a22e8]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [0xc000596840]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2318]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2348]
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2360]
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2378]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a25a0]
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a25b8]
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2618]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596960]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a25a0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596978]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a25b8]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2648]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2618]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2648]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a25a0]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a25b8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2618]
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ac8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2648]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b10]
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b88]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2720]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2720]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596be8]
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596c30]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2720]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a27f8]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a27f8]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> AssignStmt [0xc000596cc0]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d08]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d38]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a27f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d68]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596db0]
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2918]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2930]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2918]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2918]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2930]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2930]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e10]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e58]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e88]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596eb8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2a80]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ee8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f18]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2a80]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2ac8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2a80]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f48]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2ac8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f78]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a25a0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2b40]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2ac8]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a25b8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2b40]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2ba0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2be8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2ba0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2b40]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2be8]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2618]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2ba0]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2be8]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2648]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597068]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2c78]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc000597080]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2cc0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2c78]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2cf0]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2d20]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2cc0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005970f8]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2cf0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2c78]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2d20]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597140]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2cc0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2cf0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597170]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2d20]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971b8]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2d68]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2d68]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2d68]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2dc8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2dc8]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2e10]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2e10]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597218]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2dc8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2720]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2e40]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2e40]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597248]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2e70]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2e10]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2e70]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2ea0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597278]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2ed0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2ea0]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2f00]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2f30]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2e40]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972d8]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2ed0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597308]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2f00]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2f30]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2e70]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597338]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2ea0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597350]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2ed0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [0xc000597398]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3020]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a27f8]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2f00]
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3038]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2f30]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3020]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a30b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3038]
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a30f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a30b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3128]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a30f8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3170]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3128]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2918]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2930]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3170]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002966c0]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a31a0]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a31d0]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2a80]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3200]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2ac8]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3230]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a31a0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3020]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a31d0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2b40]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3260]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3290]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3038]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2ba0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3200]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3230]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2be8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a32c0]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a32f0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3260]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296b40]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3290]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3308]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a30b0]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a32c0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3350]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2c78]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a32f0]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2cc0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3308]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a30f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2cf0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2d20]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3350]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> AssignStmt [0xc000296f30]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3128]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2d68]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3170]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2dc8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2e10]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001bc0f0]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2e40]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2e70]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2ea0]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001bc0f0]
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2ed0]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2f00]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a2f30]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc000297a10]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a31a0]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a31d0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc000297a10]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3020]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3038]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3200]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3230]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a30b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000297e00]
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [0xc000297e00]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a30f8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3260]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3128]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3170]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [0xc000449cb0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3290]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a32c0]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a32f0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3308]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a31a0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3350]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a31d0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3200]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3230]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3260]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3290]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a32c0]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a32f0]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3308]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005a3350]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001bc0f0]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cc60]
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [0xc000297a10]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cf60 0xc00045cfc0]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001bc0f0]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029d470]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [0xc000297e00]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d380]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d620]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [0xc000297a10]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029d470]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000297e00]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6c18]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b4420]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045de30]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b4720 0xc0002b4780]
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029d470]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b4b40]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b4420]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b4de0]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b4720 0xc0002b4780]
2025/12/19 11:09:24 ==> AssignStmt [0xc000466480]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000466690]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597c20]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597c20]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [0xc000597c50]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b4b40]
2025/12/19 11:09:24 ==> AssignStmt [0xc00029d470]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b4de0]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b55f0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597c20]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597c20]
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b4420]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597c50]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b5bc0]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b4720 0xc0002b4780]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b55f0]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b5dd0]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b4420]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b4b40]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b4720 0xc0002b4780]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b5bc0]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b4de0]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b5dd0]
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b4b40]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b4de0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b71b8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597c20]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000597c20]
2025/12/19 11:09:24 ==> AssignStmt [0xc000467ef0 0xc00046c000]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597c50]
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7290]
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> AssignStmt [0xc000597c20]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b55f0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597c20]
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597c50]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b55f0]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a288]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b5bc0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> AssignStmt [0xc0002bd6b0 0xc0002bd740]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b73b0]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b5dd0]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b5bc0]
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7470]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a360]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74a0]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0002b5dd0]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74d0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a288]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7560]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002bd6b0 0xc0002bd740]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d0b0]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75a8]
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75c0]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7650]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a360]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b76c8]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a480]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7770]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d500]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a540]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a570]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a5a0]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7890]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b78d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a480]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a630]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002d0870]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7920]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a678]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a690]
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a720]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a540]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a570]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a288]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a798]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a5a0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a288]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002bd6b0 0xc0002bd740]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a840]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0002bd6b0 0xc0002bd740]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002d0cc0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7a70]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a630]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ab8]
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc0002d0870]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ae8]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a360]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a678]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a690]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a360]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a960]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a720]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a9a8]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a798]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a9f0]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a840]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a480]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002d0cc0]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a480]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a540]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042ab40]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a960]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a540]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a570]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a570]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042ab88]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a9a8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a5a0]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042abb8]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a5a0]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a9f0]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a630]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a630]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002d0870]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0002d0870]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a678]
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a678]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a690]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a690]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a720]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a720]
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a798]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00042ab40]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042ab88]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a798]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042abb8]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a840]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002d0cc0]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122300]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a840]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002d0cc0]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122348]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122378]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a960]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122438]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a9a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a960]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a9a8]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a9f0]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> AssignStmt [0xc00042a9f0]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> AssignStmt [0xc000122510]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc00042ab40]
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042ab40]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122630]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042ab88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122648]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc00042ab88]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042abb8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [0xc00042abb8]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b260]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [0xc0001226a8]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b2a8]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b2d8]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122780]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b398]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001227e0]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b470]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001228a0]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b260]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b2a8]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b2d8]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [0xc000122990]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b398]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b590]
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b5a8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b470]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b608]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ac8]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b6e0]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b590]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b5a8]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b740]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b260]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b2a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b260]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b2d8]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b2a8]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b2d8]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b608]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b800]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b398]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b6e0]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b398]
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b740]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b470]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b8f0]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b470]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b800]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b8f0]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b590]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b5a8]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b590]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b5a8]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042ba28]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b608]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b608]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc00042ba28]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b6e0]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b6e0]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b740]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005962e8]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596318]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b740]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596330]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596360]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596390]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963a8]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963c0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b800]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b800]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b8f0]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042b8f0]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc00042ba28]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00042ba28]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005965e8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [0xc000596600]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596660]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596690]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596768]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596840]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [0xc000596960]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596978]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ac8]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596be8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596c30]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596cc0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d08]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d38]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d68]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596db0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e58]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e88]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596eb8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ee8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f18]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f48]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f78]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc000597068]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597080]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> AssignStmt [0xc0005970f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597140]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597170]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971b8]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597218]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597248]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597278]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597308]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597338]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597350]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597398]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002966c0]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000296b40]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296f30]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [0xc000449cb0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cc60]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cf60 0xc00045cfc0]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d380]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d620]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6c18]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045de30]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> AssignStmt [0xc000466480]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc000466690]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b71b8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000467ef0 0xc00046c000]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7290]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b73b0]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7470]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74a0]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74d0]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7560]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d0b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75c0]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7650]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b76c8]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7770]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d500]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7890]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b78d8]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7920]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7a70]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ab8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ae8]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122300]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122348]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122378]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122438]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122510]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc000122630]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122648]
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001226a8]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122780]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001227e0]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001228a0]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122990]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ac8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
--- PASS: TestBaseIndent (0.03s)
    --- PASS: TestBaseIndent/2 (0.07s)
    --- PASS: TestBaseIndent/1 (0.07s)
    --- PASS: TestBaseIndent/3 (0.07s)
    --- PASS: TestBaseIndent/0 (0.07s)
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005962e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596318]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596330]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596360]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596390]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963c0]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005965e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596600]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596660]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596690]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596768]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [0xc000596840]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [0xc000596960]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596978]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ac8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596be8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596c30]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596cc0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d08]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d38]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d68]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596db0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e58]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596eb8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ee8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f18]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f48]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f78]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc000597068]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597080]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005970f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597140]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597170]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971b8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597218]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597248]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597278]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597308]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597338]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597350]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597398]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002966c0]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296b40]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296f30]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [0xc000449cb0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cc60]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cf60 0xc00045cfc0]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d380]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d620]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6c18]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045de30]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000466480]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc000466690]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b71b8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000467ef0 0xc00046c000]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7290]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b73b0]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7470]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74a0]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74d0]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7560]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d0b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75c0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7650]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b76c8]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7770]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d500]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7890]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b78d8]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7920]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7a70]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ab8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ae8]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122300]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122348]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122378]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122438]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122510]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc000122630]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122648]
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001226a8]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122780]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001227e0]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001228a0]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122990]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ac8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [0xc0005962e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596318]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596330]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596360]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596390]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963c0]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005965e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596600]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596660]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596690]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc000596768]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [0xc000596840]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596960]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596978]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ac8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596be8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596c30]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596cc0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d08]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d38]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d68]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596db0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e58]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596eb8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ee8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f18]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f48]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f78]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc000597068]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597080]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005970f8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000597140]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597170]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971b8]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597218]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597248]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000597278]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597308]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597338]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597350]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597398]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002966c0]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296b40]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296f30]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [0xc000449cb0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cc60]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cf60 0xc00045cfc0]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d380]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d620]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6c18]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045de30]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000466480]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc000466690]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b71b8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000467ef0 0xc00046c000]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7290]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b73b0]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7470]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74a0]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74d0]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7560]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d0b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75c0]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7650]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b76c8]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7770]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d500]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7890]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b78d8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7920]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7a70]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ab8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ae8]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122300]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000122348]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122378]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122438]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000122510]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc000122630]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122648]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001226a8]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122780]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001227e0]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001228a0]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122990]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ac8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [0xc0005962e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596318]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596330]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596360]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596390]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963c0]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005965e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596600]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596660]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596690]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc000596768]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596840]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [0xc000596960]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596978]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ac8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596be8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596c30]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596cc0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d08]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d38]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d68]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596db0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e58]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596eb8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ee8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f18]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f48]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f78]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc000597068]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597080]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005970f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597140]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597170]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971b8]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971e8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000597218]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597248]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597278]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597308]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597338]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597350]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000597398]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002966c0]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296b40]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000296f30]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [0xc000449cb0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cc60]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cf60 0xc00045cfc0]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d380]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d620]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6c18]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045de30]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000466480]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc000466690]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b71b8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000467ef0 0xc00046c000]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7290]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b73b0]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7470]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74a0]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74d0]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7560]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d0b0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75c0]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7650]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b76c8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7770]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d500]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7890]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b78d8]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7920]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7a70]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ab8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ae8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122300]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122348]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122378]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122438]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122510]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc000122630]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122648]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001226a8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122780]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001227e0]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001228a0]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000122990]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ac8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [0xc0005962e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596318]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596330]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596360]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596390]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963a8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963c0]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005965e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596600]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596660]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596690]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc000596768]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [0xc000596840]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [0xc000596960]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596978]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ac8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596be8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596c30]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596cc0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d08]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d38]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d68]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596db0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e58]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596eb8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ee8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f18]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f48]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f78]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc000597068]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597080]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005970f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597140]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597170]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971b8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597218]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000597248]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597278]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597308]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597338]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597350]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000597398]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0002966c0]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296b40]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000296f30]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [0xc000449cb0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cc60]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cf60 0xc00045cfc0]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d380]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d620]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6c18]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045de30]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000466480]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc000466690]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b71b8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000467ef0 0xc00046c000]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7290]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b73b0]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7470]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74a0]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74d0]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7560]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d0b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75c0]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7650]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b76c8]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7770]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d500]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7890]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b78d8]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7920]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7a70]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ab8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ae8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122300]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000122348]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122378]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122438]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000122510]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc000122630]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122648]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001226a8]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122780]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0001227e0]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001228a0]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000122990]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ac8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005962e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596318]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596330]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596360]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596390]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963c0]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005965e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596600]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596660]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596690]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc000596768]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [0xc000596840]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [0xc000596960]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596978]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ac8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596be8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596c30]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596cc0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d08]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d38]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d68]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596db0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e58]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596eb8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ee8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f18]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f48]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f78]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc000597068]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597080]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005970f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597140]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597170]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971b8]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597218]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597248]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597278]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597308]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597338]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597350]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597398]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002966c0]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296b40]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000296f30]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [0xc000449cb0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cc60]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cf60 0xc00045cfc0]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d380]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d620]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6c18]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045de30]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> AssignStmt [0xc000466480]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc000466690]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b71b8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000467ef0 0xc00046c000]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7290]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b73b0]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7470]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74a0]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74d0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7560]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d0b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75c0]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7650]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b76c8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7770]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d500]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7890]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b78d8]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7920]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7a70]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ab8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ae8]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000122300]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122348]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122378]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122438]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122510]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc000122630]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122648]
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001226a8]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122780]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001227e0]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001228a0]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122990]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ac8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [0xc0005962e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596318]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596330]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596360]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596390]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963c0]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005965e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596600]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596660]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596690]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc000596768]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596840]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596960]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596978]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ac8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596be8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596c30]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596cc0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d08]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d38]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d68]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596db0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e58]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596eb8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ee8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f18]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f48]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f78]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc000597068]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597080]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005970f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597140]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000597170]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971b8]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597218]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000597248]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597278]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597308]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597338]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597350]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597398]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002966c0]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296b40]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296f30]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [0xc000449cb0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cc60]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cf60 0xc00045cfc0]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d380]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d620]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6c18]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045de30]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> AssignStmt [0xc000466480]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc000466690]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b71b8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000467ef0 0xc00046c000]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7290]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b73b0]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7470]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74a0]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74d0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7560]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d0b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75c0]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7650]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b76c8]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7770]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d500]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7890]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b78d8]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7920]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7a70]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ab8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ae8]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122300]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122348]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122378]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000122438]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122510]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc000122630]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122648]
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001226a8]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000122780]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001227e0]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001228a0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122990]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ac8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [0xc0005962e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596318]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596330]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596360]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596390]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963c0]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005965e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596600]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596660]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596690]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc000596768]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [0xc000596840]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [0xc000596960]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596978]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ac8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596be8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596c30]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596cc0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d08]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d38]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d68]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596db0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e58]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596eb8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ee8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f18]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f48]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f78]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc000597068]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597080]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005970f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597140]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597170]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971b8]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597218]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597248]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597278]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972a8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597308]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597338]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597350]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597398]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002966c0]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296b40]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000296f30]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [0xc000449cb0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cc60]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cf60 0xc00045cfc0]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d380]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d620]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6c18]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00045de30]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000466480]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc000466690]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b71b8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000467ef0 0xc00046c000]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7290]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b73b0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7470]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74a0]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74d0]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7560]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d0b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75c0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7650]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b76c8]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7770]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d500]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7890]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b78d8]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7920]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7a70]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ab8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ae8]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000122300]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122348]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122378]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122438]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122510]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc000122630]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122648]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001226a8]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122780]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001227e0]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001228a0]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122990]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ac8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [0xc0005962e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596318]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596330]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596360]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596390]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963c0]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005965e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596600]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596660]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596690]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc000596768]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [0xc000596840]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [0xc000596960]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596978]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ac8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596be8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596c30]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596cc0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d08]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d38]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d68]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596db0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e58]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596eb8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ee8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f18]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f48]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f78]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc000597068]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597080]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005970f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597140]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597170]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971b8]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597218]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597248]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597278]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597308]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597338]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597350]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597398]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002966c0]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296b40]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296f30]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000449cb0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cc60]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cf60 0xc00045cfc0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d380]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d620]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6c18]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045de30]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> AssignStmt [0xc000466480]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc000466690]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b71b8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000467ef0 0xc00046c000]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7290]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b73b0]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7470]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74a0]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74d0]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7560]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d0b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75c0]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7650]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b76c8]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7770]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d500]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7890]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b78d8]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7920]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7a70]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ab8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ae8]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122300]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122348]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122378]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122438]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122510]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc000122630]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122648]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001226a8]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122780]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001227e0]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001228a0]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122990]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ac8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [0xc0005962e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596318]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596330]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596360]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596390]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963c0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005965e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596600]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596660]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596690]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc000596768]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [0xc000596840]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [0xc000596960]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596978]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ac8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b88]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596be8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596c30]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596cc0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d08]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d38]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d68]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596db0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e10]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e58]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596eb8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ee8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f18]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f48]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f78]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc000597068]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597080]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005970f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597140]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597170]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971b8]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597218]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597248]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597278]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597308]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597338]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597350]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597398]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002966c0]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296b40]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000296f30]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [0xc000449cb0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cc60]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cf60 0xc00045cfc0]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d380]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d620]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6c18]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045de30]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000466480]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc000466690]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b71b8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000467ef0 0xc00046c000]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7290]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b73b0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7470]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74a0]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74d0]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7560]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d0b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75c0]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7650]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b76c8]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7770]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d500]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7890]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b78d8]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7920]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7a70]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ab8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ae8]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000122300]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122348]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122378]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122438]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122510]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc000122630]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122648]
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001226a8]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122780]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001227e0]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001228a0]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122990]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ac8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [0xc0005962e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596318]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596330]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596360]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596390]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963c0]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005965e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596600]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596660]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596690]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc000596768]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [0xc000596840]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596960]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596978]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ac8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596be8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596c30]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596cc0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d08]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d38]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d68]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596db0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e58]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596eb8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ee8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f18]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f48]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f78]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc000597068]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597080]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005970f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597140]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000597170]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971b8]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597218]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597248]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597278]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597308]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597338]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597350]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597398]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002966c0]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296b40]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296f30]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000449cb0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cc60]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cf60 0xc00045cfc0]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d380]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d620]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6c18]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045de30]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000466480]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc000466690]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b71b8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000467ef0 0xc00046c000]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7290]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b73b0]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7470]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74a0]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74d0]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7560]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d0b0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75c0]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7650]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b76c8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7770]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d500]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7890]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b78d8]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7920]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7a70]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ab8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ae8]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122300]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122348]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122378]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122438]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122510]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc000122630]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122648]
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001226a8]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122780]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001227e0]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001228a0]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000122990]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ac8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [0xc0005962e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596318]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596330]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596360]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596390]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963c0]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005965e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596600]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596660]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596690]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc000596768]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596840]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [0xc000596960]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596978]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ac8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b88]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596be8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596c30]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596cc0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d08]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d38]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d68]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596db0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e58]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596eb8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ee8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f18]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f48]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f78]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc000597068]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597080]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005970f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597140]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597170]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971b8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597218]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597248]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597278]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597308]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000597338]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597350]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597398]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002966c0]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296b40]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000296f30]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [0xc000449cb0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cc60]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cf60 0xc00045cfc0]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d380]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d620]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6c18]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045de30]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> AssignStmt [0xc000466480]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc000466690]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b71b8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000467ef0 0xc00046c000]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7290]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b73b0]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7470]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74a0]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74d0]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7560]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d0b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75c0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7650]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b76c8]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7770]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d500]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7890]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b78d8]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7920]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7a70]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ab8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ae8]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122300]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122348]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122378]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122438]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122510]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc000122630]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122648]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0001226a8]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122780]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0001227e0]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001228a0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122990]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ac8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [0xc0005962e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596318]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596330]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596360]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596390]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963c0]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005965e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596600]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596660]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596690]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc000596768]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [0xc000596840]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [0xc000596960]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596978]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ac8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596be8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596c30]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596cc0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d08]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d38]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d68]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596db0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e58]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596eb8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ee8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f18]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f48]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f78]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc000597068]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597080]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005970f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597140]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597170]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971b8]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597218]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597248]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597278]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597308]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597338]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597350]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597398]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002966c0]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296b40]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296f30]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [0xc000449cb0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cc60]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cf60 0xc00045cfc0]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d380]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d620]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6c18]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045de30]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000466480]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc000466690]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b71b8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000467ef0 0xc00046c000]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7290]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b73b0]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7470]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74a0]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74d0]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7560]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d0b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75a8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75c0]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7650]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b76c8]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7770]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d500]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7890]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b78d8]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7920]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7a70]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ab8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ae8]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122300]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000122348]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122378]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122438]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122510]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc000122630]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122648]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001226a8]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122780]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001227e0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001228a0]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000122990]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ac8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005962e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596318]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596330]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596360]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596390]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963c0]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005965e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596600]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596660]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596690]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc000596768]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [0xc000596840]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [0xc000596960]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596978]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ac8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b88]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596be8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596c30]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596cc0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d08]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d38]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d68]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596db0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e58]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596eb8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ee8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f18]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f48]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f78]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc000597068]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597080]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005970f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597140]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597170]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971b8]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597218]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597248]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597278]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597308]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000597338]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597350]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597398]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002966c0]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000296b40]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296f30]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [0xc000449cb0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cc60]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cf60 0xc00045cfc0]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d380]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d620]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6c18]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045de30]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000466480]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc000466690]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b71b8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000467ef0 0xc00046c000]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7290]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b73b0]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7470]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74a0]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74d0]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7560]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d0b0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75c0]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7650]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b76c8]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7770]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d500]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7890]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b78d8]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7920]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7a70]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ab8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ae8]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122300]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122348]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122378]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122438]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122510]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc000122630]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122648]
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001226a8]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122780]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001227e0]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001228a0]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122990]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ac8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [0xc0005962e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596318]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596330]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596360]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596390]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963c0]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005965e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596600]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596660]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596690]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596768]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [0xc000596840]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [0xc000596960]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596978]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ac8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596be8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596c30]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596cc0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d08]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d38]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d68]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596db0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e58]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596eb8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ee8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f18]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f48]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f78]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc000597068]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597080]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005970f8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000597140]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597170]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971b8]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597218]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597248]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597278]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597308]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597338]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597350]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597398]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002966c0]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296b40]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296f30]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000449cb0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cc60]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cf60 0xc00045cfc0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d380]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d620]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6c18]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045de30]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000466480]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc000466690]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b71b8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000467ef0 0xc00046c000]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7290]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b73b0]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7470]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74a0]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74d0]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7560]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d0b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75c0]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7650]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b76c8]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7770]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d500]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7890]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b78d8]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7920]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7a70]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ab8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ae8]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122300]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122348]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122378]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122438]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122510]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc000122630]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122648]
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001226a8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122780]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0001227e0]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001228a0]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122990]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ac8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005962e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596318]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596330]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596360]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596390]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963c0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005965e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596600]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596660]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596690]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc000596768]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [0xc000596840]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [0xc000596960]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596978]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ac8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596be8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596c30]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596cc0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d08]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d38]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d68]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596db0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e58]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596eb8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ee8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f18]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f48]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f78]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000597068]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597080]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005970f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597140]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597170]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971b8]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597218]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597248]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597278]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597308]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597338]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597350]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597398]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002966c0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296b40]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000296f30]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [0xc000449cb0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cc60]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cf60 0xc00045cfc0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d380]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d620]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6c18]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00045de30]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> AssignStmt [0xc000466480]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc000466690]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b71b8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000467ef0 0xc00046c000]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7290]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b73b0]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7470]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74a0]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74d0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7560]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d0b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75c0]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7650]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b76c8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7770]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d500]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7890]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b78d8]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7920]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7a70]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ab8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ae8]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122300]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122348]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122378]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122438]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122510]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc000122630]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122648]
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001226a8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122780]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001227e0]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0001228a0]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122990]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ac8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [0xc0005962e8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596318]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596330]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596360]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596390]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963c0]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005965e8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596600]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596660]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596690]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc000596768]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [0xc000596840]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [0xc000596960]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596978]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ac8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596be8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596c30]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596cc0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d08]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d38]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d68]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596db0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e58]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596eb8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ee8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f18]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f48]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f78]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc000597068]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000597080]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005970f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597140]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597170]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971b8]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971e8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000597218]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597248]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597278]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972d8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000597308]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597338]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597350]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597398]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002966c0]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296b40]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000296f30]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [0xc000449cb0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cc60]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cf60 0xc00045cfc0]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d380]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d620]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6c18]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045de30]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> AssignStmt [0xc000466480]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc000466690]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b71b8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000467ef0 0xc00046c000]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7290]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b73b0]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7470]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74a0]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74d0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7560]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d0b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75c0]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7650]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b76c8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7770]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d500]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7890]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b78d8]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7920]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7a70]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ab8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ae8]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000122300]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122348]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122378]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000122438]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122510]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc000122630]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122648]
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001226a8]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000122780]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001227e0]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001228a0]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122990]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ac8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005962e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596318]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596330]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596360]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596390]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963c0]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005965e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596600]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596660]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596690]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc000596768]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [0xc000596840]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [0xc000596960]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596978]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ac8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596be8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596c30]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596cc0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d08]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d38]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d68]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596db0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e58]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596eb8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ee8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f18]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f48]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f78]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc000597068]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597080]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005970f8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000597140]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597170]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971b8]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597218]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597248]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597278]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597308]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597338]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597350]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597398]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002966c0]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296b40]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000296f30]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [0xc000449cb0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cc60]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cf60 0xc00045cfc0]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d380]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d620]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6c18]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00045de30]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> AssignStmt [0xc000466480]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc000466690]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b71b8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000467ef0 0xc00046c000]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7290]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b73b0]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7470]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74a0]
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74d0]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7560]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d0b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75c0]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7650]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b76c8]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7770]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d500]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7890]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b78d8]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7920]
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7a70]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ab8]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ae8]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000122300]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122348]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122378]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122438]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122510]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> AssignStmt [0xc000122630]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122648]
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001226a8]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122780]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001227e0]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001228a0]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122990]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ac8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func init
2025/12/19 11:09:24 ==> AssignStmt [0xc0005962e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596318]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596330]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596360]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596390]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005963c0]
2025/12/19 11:09:24 ==> Format Func internalError
2025/12/19 11:09:24 ==> ExprStmt &{fmt Print}
2025/12/19 11:09:24 ==> ExprStmt &{fmt Println}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commentsHaveNewline
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [t]
2025/12/19 11:09:24 ==> AssignStmt [_]
2025/12/19 11:09:24 ==> Format Func nextComment
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> AssignStmt [list]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005965e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596600]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596660]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596690]
2025/12/19 11:09:24 ==> Format Func commentBefore
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commentSizeBefore
2025/12/19 11:09:24 ==> AssignStmt [0xc000596768]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> AssignStmt [size]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> Format Func recordLine
2025/12/19 11:09:24 ==> AssignStmt [0xc000596840]
2025/12/19 11:09:24 ==> Format Func linesFrom
2025/12/19 11:09:24 ==> Format Func posFor
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func lineFor
2025/12/19 11:09:24 ==> AssignStmt [0xc000596960]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596978]
2025/12/19 11:09:24 ==> Format Func writeLineDirective
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ac8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b10]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596b88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596be8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596c30]
2025/12/19 11:09:24 ==> Format Func writeIndent
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596cc0]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d08]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d38]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596d68]
2025/12/19 11:09:24 ==> Format Func writeByte
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596db0]
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e10]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e58]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596e88]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596eb8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596ee8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f18]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f48]
2025/12/19 11:09:24 ==> AssignStmt [0xc000596f78]
2025/12/19 11:09:24 ==> Format Func writeString
2025/12/19 11:09:24 ==> ExprStmt &{p writeLineDirective}
2025/12/19 11:09:24 ==> ExprStmt &{p writeIndent}
2025/12/19 11:09:24 ==> AssignStmt [0xc000597068]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597080]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005970f8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597140]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000597170]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971b8]
2025/12/19 11:09:24 ==> AssignStmt [nlines]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [li]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005971e8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597218]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597248]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597278]
2025/12/19 11:09:24 ==> AssignStmt [c]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0005972d8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597308]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597338]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597350]
2025/12/19 11:09:24 ==> AssignStmt [0xc000597398]
2025/12/19 11:09:24 ==> Format Func writeCommentPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc0002966c0]
2025/12/19 11:09:24 ==> AssignStmt [hasSep]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> AssignStmt [sep]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296b40]
2025/12/19 11:09:24 ==> AssignStmt [0xc000296f30]
2025/12/19 11:09:24 ==> AssignStmt [droppedLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> Format Func isBlank
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func commonPrefix
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> Format Func trimRight
2025/12/19 11:09:24 ==> Format Func stripCommonPrefix
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000449cb0]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [prefixSet]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [line]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [lineOfStars]
2025/12/19 11:09:24 ==> AssignStmt [first]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cc60]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045cf60 0xc00045cfc0]
2025/12/19 11:09:24 ==> AssignStmt [suffix]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [closing]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d380]
2025/12/19 11:09:24 ==> AssignStmt [prefix]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00045d620]
2025/12/19 11:09:24 ==> Format Func writeComment
2025/12/19 11:09:24 ==> AssignStmt [text]
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6bd0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b6c18]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [lines]
2025/12/19 11:09:24 ==> AssignStmt [0xc00045de30]
2025/12/19 11:09:24 ==> ExprStmt stripCommonPrefix
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [pos]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> Format Func writeCommentSuffix
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000466480]
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> AssignStmt [droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [0xc000466690]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline]
2025/12/19 11:09:24 ==> Format Func containsLinebreak
2025/12/19 11:09:24 ==> Format Func intersperseComments
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p writeCommentPrefix}
2025/12/19 11:09:24 ==> ExprStmt &{p writeComment}
2025/12/19 11:09:24 ==> AssignStmt [last]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [needsLinebreak]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> Format Func writeWhitespace
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b71b8]
2025/12/19 11:09:24 ==> AssignStmt [0xc000467ef0 0xc00046c000]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [l]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7290]
2025/12/19 11:09:24 ==> Format Func nlimit
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func mayCombine
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func setPos
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b73b0]
2025/12/19 11:09:24 ==> Format Func print
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7470]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74a0]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [x]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b74d0]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7560]
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d0b0]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75a8]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b75c0]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7650]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b76c8]
2025/12/19 11:09:24 ==> AssignStmt [s]
2025/12/19 11:09:24 ==> ExprStmt &{p internalError}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7770]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc00046d500]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7890]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b78d8]
2025/12/19 11:09:24 ==> AssignStmt [data]
2025/12/19 11:09:24 ==> AssignStmt [isLit]
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7920]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> ExprStmt &{fmt Fprintf}
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [next]
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> AssignStmt [ch]
2025/12/19 11:09:24 ==> ExprStmt &{p writeByte}
2025/12/19 11:09:24 ==> AssignStmt [impliedSemi]
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7a70]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ab8]
2025/12/19 11:09:24 ==> ExprStmt &{p writeString}
2025/12/19 11:09:24 ==> AssignStmt [0xc0003b7ae8]
2025/12/19 11:09:24 ==> Format Func flush
2025/12/19 11:09:24 ==> AssignStmt [wroteNewline droppedFF]
2025/12/19 11:09:24 ==> ExprStmt &{p writeWhitespace}
2025/12/19 11:09:24 ==> Format Func getDoc
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func getLastComment
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func printNode
2025/12/19 11:09:24 ==> AssignStmt [cnode ok]
2025/12/19 11:09:24 ==> AssignStmt [node]
2025/12/19 11:09:24 ==> AssignStmt [comments]
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [doc]
2025/12/19 11:09:24 ==> AssignStmt [beg]
2025/12/19 11:09:24 ==> AssignStmt [com]
2025/12/19 11:09:24 ==> AssignStmt [e]
2025/12/19 11:09:24 ==> AssignStmt [end]
2025/12/19 11:09:24 ==> AssignStmt [i]
2025/12/19 11:09:24 ==> AssignStmt [j]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122300]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [n ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122348]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122378]
2025/12/19 11:09:24 ==> ExprStmt &{p nextComment}
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> ExprStmt &{p expr}
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122438]
2025/12/19 11:09:24 ==> ExprStmt &{p stmt}
2025/12/19 11:09:24 ==> ExprStmt &{p decl}
2025/12/19 11:09:24 ==> ExprStmt &{p spec}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ ok]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122510]
2025/12/19 11:09:24 ==> ExprStmt &{p stmtList}
2025/12/19 11:09:24 ==> ExprStmt &{p declList}
2025/12/19 11:09:24 ==> ExprStmt &{p file}
2025/12/19 11:09:24 ==> Format Func resetSpace
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [0xc000122630]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122648]
2025/12/19 11:09:24 ==> Format Func Write
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [b]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001226a8]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122780]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc0001227e0]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> AssignStmt [0xc0001228a0]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122990]
2025/12/19 11:09:24 ==> AssignStmt [m]
2025/12/19 11:09:24 ==> ExprStmt panic
2025/12/19 11:09:24 ==> AssignStmt [n]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> ExprStmt &{p resetSpace}
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fprint
2025/12/19 11:09:24 ==> ExprStmt &{p init}
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> AssignStmt [0xc000122ac8]
2025/12/19 11:09:24 ==> ExprStmt &{p flush}
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> AssignStmt [padchar]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [minwidth]
2025/12/19 11:09:24 ==> AssignStmt [twmode]
2025/12/19 11:09:24 ==> AssignStmt [output]
2025/12/19 11:09:24 ==> AssignStmt [_ err]
2025/12/19 11:09:24 ==> AssignStmt [tw _]
2025/12/19 11:09:24 ==> AssignStmt [err]
2025/12/19 11:09:24 ==> Format Func Fprint
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func Fprint
--- PASS: TestWriteErrors (0.46s)
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
2025/12/19 11:09:24 ==> Format Func fibo
--- PASS: TestBadComments (0.48s)
PASS
coverage: 64.9% of statements
ok  	github.com/goplus/xgo/printer	0.827s	coverage: 64.9% of statements
=== RUN   TestArrowOp
--- PASS: TestArrowOp (0.00s)
=== RUN   TestPrecedence
--- PASS: TestPrecedence (0.00s)
=== RUN   TestLookup
--- PASS: TestLookup (0.00s)
=== RUN   TestBasic
--- PASS: TestBasic (0.00s)
=== RUN   TestLines
--- PASS: TestLines (0.00s)
PASS
coverage: 100.0% of statements
ok  	github.com/goplus/xgo/token	0.013s	coverage: 100.0% of statements
=== RUN   TestLines
--- PASS: TestLines (0.00s)
PASS
coverage: 100.0% of statements
ok  	github.com/goplus/xgo/token/internal/tokenutil	0.012s	coverage: 100.0% of statements
=== RUN   TestFromTestdata
=== RUN   TestFromTestdata/adjoin
2025/12/19 11:09:23 Parsing /app/tpl/parser/_testdata/adjoin
=== RUN   TestFromTestdata/pseudo
2025/12/19 11:09:23 Parsing /app/tpl/parser/_testdata/pseudo
=== RUN   TestFromTestdata/simple1
2025/12/19 11:09:23 Parsing /app/tpl/parser/_testdata/simple1
=== RUN   TestFromTestdata/simple2
2025/12/19 11:09:23 Parsing /app/tpl/parser/_testdata/simple2
--- PASS: TestFromTestdata (0.00s)
    --- PASS: TestFromTestdata/adjoin (0.00s)
    --- PASS: TestFromTestdata/pseudo (0.00s)
    --- PASS: TestFromTestdata/simple1 (0.00s)
    --- PASS: TestFromTestdata/simple2 (0.00s)
PASS
coverage: 16.9% of statements
ok  	github.com/goplus/xgo/tpl/parser	0.023s	coverage: 16.9% of statements
=== RUN   TestScanner
--- PASS: TestScanner (0.00s)
=== RUN   TestFromTestdata
=== RUN   TestFromTestdata/cstr
2025/12/19 11:09:23 Scanning /app/tpl/scanner/_testdata/cstr
=== RUN   TestFromTestdata/num
2025/12/19 11:09:23 Scanning /app/tpl/scanner/_testdata/num
=== RUN   TestFromTestdata/pow
2025/12/19 11:09:23 Scanning /app/tpl/scanner/_testdata/pow
=== RUN   TestFromTestdata/rat
2025/12/19 11:09:23 Scanning /app/tpl/scanner/_testdata/rat
=== RUN   TestFromTestdata/unit
2025/12/19 11:09:23 Scanning /app/tpl/scanner/_testdata/unit
--- PASS: TestFromTestdata (0.00s)
    --- PASS: TestFromTestdata/cstr (0.00s)
    --- PASS: TestFromTestdata/num (0.00s)
    --- PASS: TestFromTestdata/pow (0.00s)
    --- PASS: TestFromTestdata/rat (0.00s)
    --- PASS: TestFromTestdata/unit (0.00s)
PASS
coverage: 48.2% of statements
ok  	github.com/goplus/xgo/tpl/scanner	0.019s	coverage: 48.2% of statements
=== RUN   TestToken
--- PASS: TestToken (0.00s)
PASS
coverage: 100.0% of statements
ok  	github.com/goplus/xgo/tpl/token	0.011s	coverage: 100.0% of statements
=== RUN   TestKind
--- PASS: TestKind (0.00s)
=== RUN   TestGop
--- PASS: TestGop (1.03s)
=== RUN   TestGox
--- PASS: TestGox (0.14s)
=== RUN   TestBig
--- PASS: TestBig (0.13s)
=== RUN   TestIoxLines
--- PASS: TestIoxLines (0.12s)
=== RUN   TestErrorWrap
--- PASS: TestErrorWrap (0.10s)
=== RUN   TestSpx
--- PASS: TestSpx (0.04s)
=== RUN   TestFromTestdata
=== RUN   TestFromTestdata/hello
=== RUN   TestFromTestdata/multi
=== RUN   TestFromTestdata/pkg
--- PASS: TestFromTestdata (0.00s)
    --- PASS: TestFromTestdata/hello (0.00s)
    --- PASS: TestFromTestdata/multi (0.00s)
    --- PASS: TestFromTestdata/pkg (0.00s)
=== RUN   TestFS
--- PASS: TestFS (0.00s)
=== RUN   TestAst
--- PASS: TestAst (0.00s)
=== RUN   TestError
--- PASS: TestError (0.00s)
=== RUN   TestContext
--- PASS: TestContext (0.00s)
PASS
coverage: 19.6% of statements
ok  	github.com/goplus/xgo/x/build	1.582s	coverage: 19.6% of statements
=== RUN   TestMain
=== RUN   TestMain/hello_world_1
=== RUN   TestMain/hello_world_2
=== RUN   TestMain/hello_world_3
--- PASS: TestMain (0.00s)
    --- PASS: TestMain/hello_world_1 (0.00s)
    --- PASS: TestMain/hello_world_2 (0.00s)
    --- PASS: TestMain/hello_world_3 (0.00s)
=== RUN   TestPrint
=== RUN   TestPrint/print
--- PASS: TestPrint (0.00s)
    --- PASS: TestPrint/print (0.00s)
=== RUN   TestPrintf
=== RUN   TestPrintf/print
--- PASS: TestPrintf (0.00s)
    --- PASS: TestPrintf/print (0.00s)
=== RUN   TestPrintln
=== RUN   TestPrintln/print
--- PASS: TestPrintln (0.00s)
    --- PASS: TestPrintln/print (0.00s)
=== RUN   TestPrintlnGroup
=== RUN   TestPrintlnGroup/print
--- PASS: TestPrintlnGroup (0.00s)
    --- PASS: TestPrintlnGroup/print (0.00s)
=== RUN   TestPrintlnWithOtherFmtCalls
=== RUN   TestPrintlnWithOtherFmtCalls/print
--- PASS: TestPrintlnWithOtherFmtCalls (0.00s)
    --- PASS: TestPrintlnWithOtherFmtCalls/print (0.00s)
=== RUN   TestPrintlnWithOtherFmtCallsGroup
=== RUN   TestPrintlnWithOtherFmtCallsGroup/print
--- PASS: TestPrintlnWithOtherFmtCallsGroup (0.00s)
    --- PASS: TestPrintlnWithOtherFmtCallsGroup/print (0.00s)
=== RUN   TestPrintlnWithOtherFmtCallsWithAssign
=== RUN   TestPrintlnWithOtherFmtCallsWithAssign/print
--- PASS: TestPrintlnWithOtherFmtCallsWithAssign (0.00s)
    --- PASS: TestPrintlnWithOtherFmtCallsWithAssign/print (0.00s)
=== RUN   TestPrintlnWithOtherFmtCallsWithGroupWithAssign
=== RUN   TestPrintlnWithOtherFmtCallsWithGroupWithAssign/print
--- PASS: TestPrintlnWithOtherFmtCallsWithGroupWithAssign (0.00s)
    --- PASS: TestPrintlnWithOtherFmtCallsWithGroupWithAssign/print (0.00s)
=== RUN   TestPrintlnWithOtherFmtDecls
=== RUN   TestPrintlnWithOtherFmtDecls/print
--- PASS: TestPrintlnWithOtherFmtDecls (0.00s)
    --- PASS: TestPrintlnWithOtherFmtDecls/print (0.00s)
=== RUN   TestPrintlnWithOtherFmtVars
=== RUN   TestPrintlnWithOtherFmtVars/print
--- PASS: TestPrintlnWithOtherFmtVars (0.00s)
    --- PASS: TestPrintlnWithOtherFmtVars/print (0.00s)
=== RUN   TestPrintlnWithOtherFmtType
=== RUN   TestPrintlnWithOtherFmtType/print
--- PASS: TestPrintlnWithOtherFmtType (0.00s)
    --- PASS: TestPrintlnWithOtherFmtType/print (0.00s)
=== RUN   TestPrintlnImportAlias
=== RUN   TestPrintlnImportAlias/print
--- PASS: TestPrintlnImportAlias (0.00s)
    --- PASS: TestPrintlnImportAlias/print (0.00s)
=== RUN   TestPrintlnImportMultiAliases
=== RUN   TestPrintlnImportMultiAliases/print
--- PASS: TestPrintlnImportMultiAliases (0.00s)
    --- PASS: TestPrintlnImportMultiAliases/print (0.00s)
=== RUN   TestPrintlnImportMultiAliasesDifferentGroups
=== RUN   TestPrintlnImportMultiAliasesDifferentGroups/print
--- PASS: TestPrintlnImportMultiAliasesDifferentGroups (0.00s)
    --- PASS: TestPrintlnImportMultiAliasesDifferentGroups/print (0.00s)
=== RUN   TestErrorfWithPackageLevelVar
=== RUN   TestErrorfWithPackageLevelVar/print
--- PASS: TestErrorfWithPackageLevelVar (0.00s)
    --- PASS: TestErrorfWithPackageLevelVar/print (0.00s)
=== RUN   TestPrintlnWithFmtVarNoImport
=== RUN   TestPrintlnWithFmtVarNoImport/print
--- PASS: TestPrintlnWithFmtVarNoImport (0.00s)
    --- PASS: TestPrintlnWithFmtVarNoImport/print (0.00s)
=== RUN   TestPrintlnWithFmtVar
=== RUN   TestPrintlnWithFmtVar/print
--- PASS: TestPrintlnWithFmtVar (0.00s)
    --- PASS: TestPrintlnWithFmtVar/print (0.00s)
=== RUN   TestPrintlnWithFmtVarAfter
=== RUN   TestPrintlnWithFmtVarAfter/print
--- PASS: TestPrintlnWithFmtVarAfter (0.00s)
    --- PASS: TestPrintlnWithFmtVarAfter/print (0.00s)
=== RUN   TestPrintlnWithPackageLevelFmtVar
=== RUN   TestPrintlnWithPackageLevelFmtVar/print
--- PASS: TestPrintlnWithPackageLevelFmtVar (0.00s)
    --- PASS: TestPrintlnWithPackageLevelFmtVar/print (0.00s)
=== RUN   TestPrintlnWithPackageLevelFmtVarAfter
=== RUN   TestPrintlnWithPackageLevelFmtVarAfter/print
--- PASS: TestPrintlnWithPackageLevelFmtVarAfter (0.00s)
    --- PASS: TestPrintlnWithPackageLevelFmtVarAfter/print (0.00s)
=== RUN   TestPrintlnWithVarFromCall
=== RUN   TestPrintlnWithVarFromCall/print
--- PASS: TestPrintlnWithVarFromCall (0.00s)
    --- PASS: TestPrintlnWithVarFromCall/print (0.00s)
=== RUN   TestLambdaFromFuncLit
=== RUN   TestLambdaFromFuncLit/funclit_to_lambda
--- PASS: TestLambdaFromFuncLit (0.00s)
    --- PASS: TestLambdaFromFuncLit/funclit_to_lambda (0.00s)
=== RUN   TestFromTestdata
=== RUN   TestFromTestdata/collection
2025/12/19 11:09:23 Formatting /app/x/format/_testdata/collection
=== RUN   TestFromTestdata/gopsyntax
2025/12/19 11:09:23 Formatting /app/x/format/_testdata/gopsyntax
=== RUN   TestFromTestdata/syntax
2025/12/19 11:09:23 Formatting /app/x/format/_testdata/syntax
--- PASS: TestFromTestdata (0.00s)
    --- PASS: TestFromTestdata/collection (0.00s)
    --- PASS: TestFromTestdata/gopsyntax (0.00s)
    --- PASS: TestFromTestdata/syntax (0.00s)
PASS
coverage: 31.9% of statements
ok  	github.com/goplus/xgo/x/format	0.027s	coverage: 31.9% of statements
=== RUN   TestNetPipeDone
--- PASS: TestNetPipeDone (0.00s)
=== RUN   TestNetPipe
=== RUN   TestNetPipe/no_args
2025/12/19 11:09:23 Call no_args params: <nil>
2025/12/19 11:09:23 handleAsync {1} no_args
2025/12/19 11:09:23 processResult {1} true <nil>
2025/12/19 11:09:23 Connection.write {1} no_args <nil>
=== RUN   TestNetPipe/one_string
2025/12/19 11:09:23 Call one_string params: fish
2025/12/19 11:09:23 handleAsync {1} one_string "fish"
2025/12/19 11:09:23 processResult {1} "got:fish" <nil>
2025/12/19 11:09:23 Connection.write {1} one_string <nil>
=== RUN   TestNetPipe/one_number
2025/12/19 11:09:23 Call one_number params: 10
2025/12/19 11:09:23 handleAsync {1} one_number 10
2025/12/19 11:09:23 processResult {1} "got:10" <nil>
2025/12/19 11:09:23 Connection.write {1} one_number <nil>
=== RUN   TestNetPipe/join
2025/12/19 11:09:23 Call join params: [a b c]
2025/12/19 11:09:23 handleAsync {1} join ["a","b","c"]
2025/12/19 11:09:23 processResult {1} "a/b/c" <nil>
2025/12/19 11:09:23 Connection.write {1} join <nil>
=== RUN   TestNetPipe/notify
2025/12/19 11:09:23 Notify set params: 3
2025/12/19 11:09:23 Connection.write set <nil>
2025/12/19 11:09:23 Notify add params: 5
2025/12/19 11:09:23 Connection.write add <nil>
2025/12/19 11:09:23 Call get params: <nil>
2025/12/19 11:09:23 Connection.write {1} get <nil>
2025/12/19 11:09:23 handleAsync {} set 3
2025/12/19 11:09:23 handleAsync {} add 5
2025/12/19 11:09:23 handleAsync {1} get
2025/12/19 11:09:23 processResult {1} 8 <nil>
=== RUN   TestNetPipe/preempt
2025/12/19 11:09:23 Call wait params: a
2025/12/19 11:09:23 handleAsync {1} wait "a"
2025/12/19 11:09:23 waiter: a
2025/12/19 11:09:23 Connection.write {1} wait <nil>
2025/12/19 11:09:23 Notify unblock params: a
2025/12/19 11:09:23 closeWaiter: a
2025/12/19 11:09:23 processResult {1} true <nil>
2025/12/19 11:09:23 Connection.write unblock <nil>
=== RUN   TestNetPipe/basic_cancel
2025/12/19 11:09:23 Call wait params: b
2025/12/19 11:09:23 handleAsync {1} wait "b"
2025/12/19 11:09:23 waiter: b
2025/12/19 11:09:23 Connection.write {1} wait <nil>
2025/12/19 11:09:23 Notify cancel params: &{1}
2025/12/19 11:09:23 processResult {1}  context canceled
2025/12/19 11:09:23 Connection.write cancel <nil>
=== RUN   TestNetPipe/queue
2025/12/19 11:09:23 Call wait params: a
2025/12/19 11:09:23 handleAsync {1} wait "a"
2025/12/19 11:09:23 waiter: a
2025/12/19 11:09:23 Connection.write {1} wait <nil>
2025/12/19 11:09:23 Notify set params: 1
2025/12/19 11:09:23 Connection.write set <nil>
2025/12/19 11:09:23 Notify add params: 2
2025/12/19 11:09:23 Connection.write add <nil>
2025/12/19 11:09:23 Notify add params: 3
2025/12/19 11:09:23 Connection.write add <nil>
2025/12/19 11:09:23 Notify add params: 4
2025/12/19 11:09:23 Connection.write add <nil>
2025/12/19 11:09:23 Notify unblock params: a
2025/12/19 11:09:23 closeWaiter: a
2025/12/19 11:09:23 processResult {1} true <nil>
2025/12/19 11:09:23 handleAsync {} set 1
2025/12/19 11:09:23 Connection.write unblock <nil>
2025/12/19 11:09:23 Call get params: <nil>
2025/12/19 11:09:23 handleAsync {} add 2
2025/12/19 11:09:23 handleAsync {} add 3
2025/12/19 11:09:23 handleAsync {} add 4
2025/12/19 11:09:23 Connection.write {2} get <nil>
2025/12/19 11:09:23 handleAsync {2} get
2025/12/19 11:09:23 processResult {2} 10 <nil>
=== RUN   TestNetPipe/fork
2025/12/19 11:09:23 Call fork params: a
2025/12/19 11:09:23 handleAsync {1} fork "a"
2025/12/19 11:09:23 waiter: a
2025/12/19 11:09:23 Connection.write {1} fork <nil>
2025/12/19 11:09:23 Notify set params: 1
2025/12/19 11:09:23 handleAsync {} set 1
2025/12/19 11:09:23 Connection.write set <nil>
2025/12/19 11:09:23 Notify add params: 2
2025/12/19 11:09:23 handleAsync {} add 2
2025/12/19 11:09:23 Connection.write add <nil>
2025/12/19 11:09:23 Notify add params: 3
2025/12/19 11:09:23 handleAsync {} add 3
2025/12/19 11:09:23 Connection.write add <nil>
2025/12/19 11:09:23 Notify add params: 4
2025/12/19 11:09:23 handleAsync {} add 4
2025/12/19 11:09:23 Connection.write add <nil>
2025/12/19 11:09:23 Call get params: <nil>
2025/12/19 11:09:23 handleAsync {2} get
2025/12/19 11:09:23 processResult {2} 10 <nil>
2025/12/19 11:09:23 Connection.write {2} get <nil>
2025/12/19 11:09:23 Notify unblock params: a
2025/12/19 11:09:23 closeWaiter: a
2025/12/19 11:09:23 processResult {1} true <nil>
2025/12/19 11:09:23 Connection.write unblock <nil>
=== RUN   TestNetPipe/concurrent
2025/12/19 11:09:23 Call fork params: a
2025/12/19 11:09:23 handleAsync {1} fork "a"
2025/12/19 11:09:23 waiter: a
2025/12/19 11:09:23 Connection.write {1} fork <nil>
2025/12/19 11:09:23 Notify unblock params: a
2025/12/19 11:09:23 closeWaiter: a
2025/12/19 11:09:23 processResult {1} true <nil>
2025/12/19 11:09:23 Connection.write unblock <nil>
2025/12/19 11:09:23 Call fork params: b
2025/12/19 11:09:23 handleAsync {2} fork "b"
2025/12/19 11:09:23 waiter: b
2025/12/19 11:09:23 Connection.write {2} fork <nil>
2025/12/19 11:09:23 Notify unblock params: b
2025/12/19 11:09:23 closeWaiter: b
2025/12/19 11:09:23 processResult {2} true <nil>
2025/12/19 11:09:23 Connection.write unblock <nil>
--- PASS: TestNetPipe (0.01s)
    --- PASS: TestNetPipe/no_args (0.00s)
    --- PASS: TestNetPipe/one_string (0.00s)
    --- PASS: TestNetPipe/one_number (0.00s)
    --- PASS: TestNetPipe/join (0.00s)
    --- PASS: TestNetPipe/notify (0.00s)
    --- PASS: TestNetPipe/preempt (0.00s)
    --- PASS: TestNetPipe/basic_cancel (0.00s)
    --- PASS: TestNetPipe/queue (0.00s)
    --- PASS: TestNetPipe/fork (0.00s)
    --- PASS: TestNetPipe/concurrent (0.00s)
PASS
coverage: 63.0% of statements
ok  	github.com/goplus/xgo/x/jsonrpc2/jsonrpc2test	0.023s	coverage: 63.0% of statements
2025/12/19 11:09:23 SetDebug: import=true, match=true, instr=true
=== RUN   TestConvErr
--- PASS: TestConvErr (0.00s)
=== RUN   TestCheckFiles
2025/12/19 11:09:23.957324 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 2 goFiles = 1
2025/12/19 11:09:24.693007 [INFO] typesutil/gopinfo.go:332: ==> Scope: Rect.gox scope 0xc000257740 {
}

2025/12/19 11:09:24 ==> Preload var [x]
2025/12/19 11:09:24 ==> Preload var [y]
2025/12/19 11:09:24.693141 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0002577a0 {
}

2025/12/19 11:09:24.693295 [INFO] typesutil/gopinfo.go:292: ==> Implicit: package fmt
2025/12/19 11:09:24 ==> Preload type Point
2025/12/19 11:09:24 ==> Preload func main
2025/12/19 11:09:24 ==> Preload var [GoValue]
2025/12/19 11:09:24 ==> Preload type GoPoint
2025/12/19 11:09:24 ==> Preload method GoPoint.Test
2025/12/19 11:09:24 ==> Preload func gotest
2025/12/19 11:09:24 ==> Load > NewType GoPoint
2025/12/19 11:09:24 ==> Load > InitType GoPoint
2025/12/19 11:09:24 ==> LookupParent GoPoint => type main.GoPoint struct{x int; y int}
2025/12/19 11:09:24 ==> Load method *main.GoPoint.Test
2025/12/19 11:09:24.693442 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:24.693459 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:24.693471 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:24 ==> Load var int [x]
2025/12/19 11:09:24 NewVarDefs
2025/12/19 11:09:24 NewVar [x]
2025/12/19 11:09:24.693508 [INFO] typesutil/gopinfo.go:251: ==> Def: x var main.x int
2025/12/19 11:09:24.693525 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:24.693535 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:24.693544 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:24 ==> Load var int [y]
2025/12/19 11:09:24 NewVarDefs
2025/12/19 11:09:24 NewVar [y]
2025/12/19 11:09:24.693568 [INFO] typesutil/gopinfo.go:251: ==> Def: y var main.y int
2025/12/19 11:09:24 ==> Load > NewType Point
2025/12/19 11:09:24 NewType Point
2025/12/19 11:09:24 ==> Load > InitType Point
2025/12/19 11:09:24.693594 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:24.693605 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:24.693614 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:24.693624 [INFO] typesutil/gopinfo.go:251: ==> Def: x field x int
2025/12/19 11:09:24.693634 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:24.693643 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:24.693651 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:24.693661 [INFO] typesutil/gopinfo.go:251: ==> Def: y field y int
2025/12/19 11:09:24.693687 [INFO] typesutil/gopinfo.go:215: ==> Type: &{27 0xc000113ce0 false} struct{x int; y int}
2025/12/19 11:09:24 InitType Point struct{x int; y int}
2025/12/19 11:09:24.693708 [INFO] typesutil/gopinfo.go:251: ==> Def: Point type main.Point struct{x int; y int}
2025/12/19 11:09:24 ==> Load func main
2025/12/19 11:09:24.693733 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:09:24 NewFunc main func()
2025/12/19 11:09:24 DefineVarStart [pt]
2025/12/19 11:09:24 ==> LookupParent Point => type main.Point struct{x int; y int}
2025/12/19 11:09:24.693785 [INFO] typesutil/gopinfo.go:265: ==> Use: Point type main.Point struct{x int; y int}
2025/12/19 11:09:24.693798 [INFO] typesutil/gopinfo.go:215: ==> Type: Point main.Point
2025/12/19 11:09:24.693809 [INFO] typesutil/gopinfo.go:215: ==> Type: Point main.Point
2025/12/19 11:09:24 StructLit main.Point 0 false
2025/12/19 11:09:24.693830 [INFO] typesutil/gopinfo.go:215: ==> Type: Point main.Point
2025/12/19 11:09:24.693848 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Point 64 [] 65 false} main.Point
2025/12/19 11:09:24 UnaryOp & flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:24.693900 [INFO] typesutil/gopinfo.go:215: ==> Type: &{58 & 0xc00011f340} *main.Point
2025/12/19 11:09:24 EndInit 1
2025/12/19 11:09:24.693919 [INFO] typesutil/gopinfo.go:251: ==> Def: pt var pt *main.Point
2025/12/19 11:09:24 Val pt *main.Point
2025/12/19 11:09:24.693943 [INFO] typesutil/gopinfo.go:265: ==> Use: pt var pt *main.Point
2025/12/19 11:09:24.693956 [INFO] typesutil/gopinfo.go:215: ==> Type: pt *main.Point
2025/12/19 11:09:24 Member x -1 // *main.Point
2025/12/19 11:09:24.693978 [INFO] typesutil/gopinfo.go:265: ==> Use: x field x int
2025/12/19 11:09:24.693992 [INFO] typesutil/gopinfo.go:215: ==> Type: &{pt x} int
2025/12/19 11:09:24 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:24.694033 [INFO] typesutil/gopinfo.go:215: ==> Type: &{74 INT 100 <nil>} untyped int
2025/12/19 11:09:24 Assign 1 1
2025/12/19 11:09:24 ==> MatchType untyped int (100), int
2025/12/19 11:09:24 Val pt *main.Point
2025/12/19 11:09:24.694075 [INFO] typesutil/gopinfo.go:265: ==> Use: pt var pt *main.Point
2025/12/19 11:09:24.694084 [INFO] typesutil/gopinfo.go:215: ==> Type: pt *main.Point
2025/12/19 11:09:24 Member y -1 // *main.Point
2025/12/19 11:09:24.694108 [INFO] typesutil/gopinfo.go:265: ==> Use: y field y int
2025/12/19 11:09:24.694119 [INFO] typesutil/gopinfo.go:215: ==> Type: &{pt y} int
2025/12/19 11:09:24 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:24.694143 [INFO] typesutil/gopinfo.go:215: ==> Type: &{85 INT 200 <nil>} untyped int
2025/12/19 11:09:24 Assign 1 1
2025/12/19 11:09:24 ==> MatchType untyped int (200), int
2025/12/19 11:09:24.694174 [INFO] typesutil/gopinfo.go:265: ==> Use: fmt package fmt
2025/12/19 11:09:24.694188 [INFO] typesutil/gopinfo.go:265: ==> Use: Println func fmt.Println(a ...any) (n int, err error)
2025/12/19 11:09:24 Val Println func(a ...any) (n int, err error)
2025/12/19 11:09:24 Val pt *main.Point
2025/12/19 11:09:24.694239 [INFO] typesutil/gopinfo.go:265: ==> Use: pt var pt *main.Point
2025/12/19 11:09:24.694252 [INFO] typesutil/gopinfo.go:215: ==> Type: pt *main.Point
2025/12/19 11:09:24 Call 1 0 // func(a ...any) (n int, err error)
2025/12/19 11:09:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType *main.Point, any
2025/12/19 11:09:24 ==> EnsureLoaded main.Point
2025/12/19 11:09:24.694309 [INFO] typesutil/gopinfo.go:215: ==> Type: &{fmt Println} func(a ...any) (n int, err error)
2025/12/19 11:09:24.694331 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0000103f0 100 [pt] 0 [] 103 0} (n int, err error)
2025/12/19 11:09:24 DefineVarStart [gopt]
2025/12/19 11:09:24 ==> LookupParent GoPoint => type main.GoPoint struct{x int; y int}
2025/12/19 11:09:24.694358 [INFO] typesutil/gopinfo.go:265: ==> Use: GoPoint type main.GoPoint struct{x int; y int}
2025/12/19 11:09:24.694367 [INFO] typesutil/gopinfo.go:215: ==> Type: GoPoint main.GoPoint
2025/12/19 11:09:24.694377 [INFO] typesutil/gopinfo.go:215: ==> Type: GoPoint main.GoPoint
2025/12/19 11:09:24 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:24.694446 [INFO] typesutil/gopinfo.go:215: ==> Type: &{122 INT 100 <nil>} untyped int
2025/12/19 11:09:24 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:24.694466 [INFO] typesutil/gopinfo.go:215: ==> Type: &{126 INT 200 <nil>} untyped int
2025/12/19 11:09:24 StructLit main.GoPoint 2 false
2025/12/19 11:09:24.694486 [INFO] typesutil/gopinfo.go:215: ==> Type: GoPoint main.GoPoint
2025/12/19 11:09:24.694502 [INFO] typesutil/gopinfo.go:215: ==> Type: &{GoPoint 121 [0xc000113dd0 0xc000113e00] 129 false} main.GoPoint
2025/12/19 11:09:24 EndInit 1
2025/12/19 11:09:24.694521 [INFO] typesutil/gopinfo.go:251: ==> Def: gopt var gopt main.GoPoint
2025/12/19 11:09:24 Val gopt main.GoPoint
2025/12/19 11:09:24.694541 [INFO] typesutil/gopinfo.go:265: ==> Use: gopt var gopt main.GoPoint
2025/12/19 11:09:24.694553 [INFO] typesutil/gopinfo.go:215: ==> Type: gopt main.GoPoint
2025/12/19 11:09:24 Member Test 1 // main.GoPoint
2025/12/19 11:09:24.694573 [INFO] typesutil/gopinfo.go:265: ==> Use: Test func (*main.GoPoint).Test()
2025/12/19 11:09:24.694588 [INFO] typesutil/gopinfo.go:215: ==> Type: &{gopt Test} func()
2025/12/19 11:09:24 Call 0 0 // func()
2025/12/19 11:09:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:24.694616 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000010408 140 [] 0 [] 141 0} ()
2025/12/19 11:09:24 ==> Load func gotest
2025/12/19 11:09:24 Val gotest func()
2025/12/19 11:09:24.694641 [INFO] typesutil/gopinfo.go:265: ==> Use: gotest func main.gotest()
2025/12/19 11:09:24.694649 [INFO] typesutil/gopinfo.go:215: ==> Type: gotest func()
2025/12/19 11:09:24 Call 0 0 // func()
2025/12/19 11:09:24 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:24.694672 [INFO] typesutil/gopinfo.go:215: ==> Type: &{gotest 149 [] 0 [] 150 0} ()
2025/12/19 11:09:24.694686 [INFO] typesutil/gopinfo.go:265: ==> Use: fmt package fmt
2025/12/19 11:09:24.694696 [INFO] typesutil/gopinfo.go:265: ==> Use: Println func fmt.Println(a ...any) (n int, err error)
2025/12/19 11:09:24 Val Println func(a ...any) (n int, err error)
2025/12/19 11:09:24 ==> Load var string [GoValue]
2025/12/19 11:09:24 NewVarDefs
2025/12/19 11:09:24 NewVar [GoValue]
2025/12/19 11:09:24 Val GoValue string
2025/12/19 11:09:24.694752 [INFO] typesutil/gopinfo.go:265: ==> Use: GoValue var main.GoValue string
2025/12/19 11:09:24.694765 [INFO] typesutil/gopinfo.go:215: ==> Type: GoValue string
2025/12/19 11:09:24 Call 1 0 // func(a ...any) (n int, err error)
2025/12/19 11:09:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType string, any
2025/12/19 11:09:24.694808 [INFO] typesutil/gopinfo.go:215: ==> Type: &{fmt Println} func(a ...any) (n int, err error)
2025/12/19 11:09:24.694826 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000010420 163 [GoValue] 0 [] 171 0} (n int, err error)
2025/12/19 11:09:24.694839 [INFO] typesutil/gopinfo.go:265: ==> Use: fmt package fmt
2025/12/19 11:09:24.694850 [INFO] typesutil/gopinfo.go:265: ==> Use: Println func fmt.Println(a ...any) (n int, err error)
2025/12/19 11:09:24 Val Println func(a ...any) (n int, err error)
2025/12/19 11:09:24.694871 [INFO] typesutil/gopinfo.go:215: ==> Type: Rect invalid type
2025/12/19 11:09:24 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:24.694898 [INFO] typesutil/gopinfo.go:215: ==> Type: &{191 INT 100 <nil>} untyped int
2025/12/19 11:09:24 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:24.694918 [INFO] typesutil/gopinfo.go:215: ==> Type: &{195 INT 200 <nil>} untyped int
2025/12/19 11:09:24 ResetStmt
2025/12/19 11:09:24.694957 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc000257c80 {
.  var gopt main.GoPoint
.  var pt *main.Point
}

2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 main.xgo:17:14: Rect is not a type
2025/12/19 11:09:24 main.xgo:17:14: invalid composite literal type invalid type
2025/12/19 11:09:24.695216 [INFO] typesutil/check.go:179: typesutil.Check err: main.xgo:17:14: Rect is not a type
main.xgo:17:14: invalid composite literal type invalid type
2025/12/19 11:09:24.696468 [ERROR] log/logext.go:606:
goroutine 9 [running]:
github.com/qiniu/x/log.(*Logger).SingleStack(0xc423e0, {0x0?, 0xc0003371d0?, 0xc000593bf8?})
	/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:385 +0x7b
github.com/qiniu/x/log.SingleStack(...)
	/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:606
github.com/goplus/xgo/x/typesutil.(*Checker).Files(0xc000593d48, {0xc0000de1e8, 0x1, 0x4?}, {0xc00002cb80, 0x2, 0x0?})
	/app/x/typesutil/check.go:180 +0xd39
github.com/goplus/xgo/x/typesutil_test.checkInfo(0xc00011f240, {0xc00002cb80, 0x2, 0x2}, {0xc0000de1e8, 0x1, 0x1}, 0x0)
	/app/x/typesutil/check_test.go:104 +0x42b
github.com/goplus/xgo/x/typesutil_test.checkFiles(0xc00011f240, {0x8dc7e0?, 0x9ee512?}, {0x84f1a0?, 0x9a9d30?}, {0x8dc7e8?, 0x604?}, {0x84f1a0?, 0x9a9d40?}, {0x8dbf61, ...}, ...)
	/app/x/typesutil/check_test.go:61 +0xb7
github.com/goplus/xgo/x/typesutil_test.TestCheckFiles(0xc00012cb60)
	/app/x/typesutil/check_test.go:110 +0x93
testing.tRunner(0xc00012cb60, 0x92d100)
	/usr/local/go/src/testing/testing.go:1689 +0xfb
created by testing.(*T).Run in goroutine 1
	/usr/local/go/src/testing/testing.go:1742 +0x390

--- PASS: TestCheckFiles (0.74s)
=== RUN   TestCheckGoFiles
--- PASS: TestCheckGoFiles (0.00s)
=== RUN   TestCheckError
2025/12/19 11:09:24.698389 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:09:24.708549 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0004fc000 {
}

2025/12/19 11:09:24 ==> Preload type Point
2025/12/19 11:09:24 ==> Preload func main
2025/12/19 11:09:24 ==> Load > NewType Point
2025/12/19 11:09:24 NewType Point
2025/12/19 11:09:24 ==> Load > InitType Point
2025/12/19 11:09:24.708657 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:24.708683 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:24.708699 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:24.708718 [INFO] typesutil/gopinfo.go:251: ==> Def: x field x int
2025/12/19 11:09:24.708733 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:24.708745 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:24.708755 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:24.708766 [INFO] typesutil/gopinfo.go:251: ==> Def: y field y int
2025/12/19 11:09:24.708797 [INFO] typesutil/gopinfo.go:215: ==> Type: &{13 0xc000336f60 false} struct{x int; y int}
2025/12/19 11:09:24 InitType Point struct{x int; y int}
2025/12/19 11:09:24.708846 [INFO] typesutil/gopinfo.go:251: ==> Def: Point type main.Point struct{x int; y int}
2025/12/19 11:09:24 ==> Load func main
2025/12/19 11:09:24.708877 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:09:24 NewFunc main func()
2025/12/19 11:09:24 DefineVarStart [pt]
2025/12/19 11:09:24.708920 [INFO] typesutil/gopinfo.go:215: ==> Type: Point1 invalid type
2025/12/19 11:09:24 MapLit <nil> 0
2025/12/19 11:09:24.708941 [INFO] typesutil/gopinfo.go:215: ==> Type: Point1 invalid type
2025/12/19 11:09:24.708960 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Point1 51 [] 52 false} invalid type
2025/12/19 11:09:24 UnaryOp & flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:24.708995 [INFO] typesutil/gopinfo.go:215: ==> Type: &{44 & 0xc0002ac180} *map[string]interface{}
2025/12/19 11:09:24 EndInit 1
2025/12/19 11:09:24.709015 [INFO] typesutil/gopinfo.go:251: ==> Def: pt var pt *map[string]interface{}
2025/12/19 11:09:24 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24.709120 [INFO] typesutil/gopinfo.go:265: ==> Use: println builtin println
2025/12/19 11:09:24.709135 [INFO] typesutil/gopinfo.go:215: ==> Type: println invalid type
2025/12/19 11:09:24 Val pt *map[string]interface{}
2025/12/19 11:09:24.709164 [INFO] typesutil/gopinfo.go:265: ==> Use: pt var pt *map[string]interface{}
2025/12/19 11:09:24.709177 [INFO] typesutil/gopinfo.go:215: ==> Type: pt *map[string]interface{}
2025/12/19 11:09:24 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:24 ==> MatchType *map[string]interface{}, any
2025/12/19 11:09:24.709260 [INFO] typesutil/gopinfo.go:265: ==> Use: println func fmt.Println(a ...any) (n int, err error)
2025/12/19 11:09:24.709274 [INFO] typesutil/gopinfo.go:215: ==> Type: println func(a ...any) (n int, err error)
2025/12/19 11:09:24.709297 [INFO] typesutil/gopinfo.go:215: ==> Type: &{println 61 [pt] 0 [] 64 0} (n int, err error)
2025/12/19 11:09:24.709322 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0004fc1e0 {
.  var pt *map[string]interface{}
}

2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 main.xgo:6:8: Point1 is not a type
2025/12/19 11:09:24.709367 [INFO] typesutil/check.go:179: typesutil.Check err: main.xgo:6:8: Point1 is not a type
2025/12/19 11:09:24.709483 [ERROR] log/logext.go:606:
goroutine 75 [running]:
github.com/qiniu/x/log.(*Logger).SingleStack(0xc423e0, {0x0?, 0xc00049ff50?, 0xc0001bdce8?})
	/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:385 +0x7b
github.com/qiniu/x/log.SingleStack(...)
	/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:606
github.com/goplus/xgo/x/typesutil.(*Checker).Files(0xc0001bde38, {0x0, 0x0, 0x4?}, {0xc000198cc8, 0x1, 0xc000011098?})
	/app/x/typesutil/check.go:180 +0xd39
github.com/goplus/xgo/x/typesutil_test.checkInfo(0xc0002ac080, {0xc000198cc8, 0x1, 0x1}, {0x0, 0x0, 0x0}, 0x0)
	/app/x/typesutil/check_test.go:104 +0x42b
github.com/goplus/xgo/x/typesutil_test.checkFiles(0xc0002ac080, {0x8dc7e0?, 0x5490a0?}, {0x84f1a0?, 0x9a9d90?}, {0x0?, 0x548edc?}, {0x84f1a0?, 0x9a9ae0?}, {0x0, ...}, ...)
	/app/x/typesutil/check_test.go:61 +0xb7
github.com/goplus/xgo/x/typesutil_test.TestCheckError(0xc00012c680)
	/app/x/typesutil/check_test.go:183 +0x7f
testing.tRunner(0xc00012c680, 0x92d0e8)
	/usr/local/go/src/testing/testing.go:1689 +0xfb
created by testing.(*T).Run in goroutine 1
	/usr/local/go/src/testing/testing.go:1742 +0x390

2025/12/19 11:09:24.709545 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:09:24.717284 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc00026ab40 {
}

2025/12/19 11:09:24 ==> Preload var [i]
2025/12/19 11:09:24.717325 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:24.717340 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:24.717347 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:24 ==> Load var int [i]
2025/12/19 11:09:24 NewVarDefs
2025/12/19 11:09:24 NewVar [i]
2025/12/19 11:09:24 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:24.717383 [INFO] typesutil/gopinfo.go:215: ==> Type: &{80 STRING "hello" <nil>} untyped string
2025/12/19 11:09:24 EndInit 1
2025/12/19 11:09:24 ==> MatchType untyped string ("hello"), int
2025/12/19 11:09:24 ResetInit
2025/12/19 11:09:24 main.xgo:2:13: cannot use "hello" (type untyped string) as type int in assignment
2025/12/19 11:09:24.717450 [INFO] typesutil/check.go:179: typesutil.Check err: main.xgo:2:13: cannot use "hello" (type untyped string) as type int in assignment
2025/12/19 11:09:24.718452 [ERROR] log/logext.go:606:
goroutine 75 [running]:
github.com/qiniu/x/log.(*Logger).SingleStack(0xc423e0, {0x0?, 0xc000173a40?, 0xc0001a1ce8?})
	/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:385 +0x7b
github.com/qiniu/x/log.SingleStack(...)
	/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:606
github.com/goplus/xgo/x/typesutil.(*Checker).Files(0xc0001a1e38, {0x0, 0x0, 0x4?}, {0xc0000de808, 0x1, 0xc0004f4cf0?})
	/app/x/typesutil/check.go:180 +0xd39
github.com/goplus/xgo/x/typesutil_test.checkInfo(0xc0002ac080, {0xc0000de808, 0x1, 0x1}, {0x0, 0x0, 0x0}, 0x0)
	/app/x/typesutil/check_test.go:104 +0x42b
github.com/goplus/xgo/x/typesutil_test.checkFiles(0xc0002ac080, {0x8dc7e0?, 0x5490a0?}, {0x84f1a0?, 0x9a9db0?}, {0x0?, 0x548edc?}, {0x84f1a0?, 0x9a9ae0?}, {0x0, ...}, ...)
	/app/x/typesutil/check_test.go:61 +0xb7
github.com/goplus/xgo/x/typesutil_test.TestCheckError(0xc00012c680)
	/app/x/typesutil/check_test.go:194 +0x109
testing.tRunner(0xc00012c680, 0x92d0e8)
	/usr/local/go/src/testing/testing.go:1689 +0xfb
created by testing.(*T).Run in goroutine 1
	/usr/local/go/src/testing/testing.go:1742 +0x390

2025/12/19 11:09:24.719377 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:09:24.727047 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc000357500 {
}

2025/12/19 11:09:24 ==> Preload var [nums]
2025/12/19 11:09:24 ==> Preload func main
2025/12/19 11:09:24.727091 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:24.727101 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:24.727107 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:24.727122 [INFO] typesutil/gopinfo.go:215: ==> Type: &{99 <nil> int} []int
2025/12/19 11:09:24 ==> Load var []int [nums]
2025/12/19 11:09:24 NewVarDefs
2025/12/19 11:09:24 NewVar [nums]
2025/12/19 11:09:24.727147 [INFO] typesutil/gopinfo.go:251: ==> Def: nums var main.nums []int
2025/12/19 11:09:24 ==> Load func main
2025/12/19 11:09:24.727171 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:09:24 NewFunc main func()
2025/12/19 11:09:24 VarRef nums []int
2025/12/19 11:09:24.727195 [INFO] typesutil/gopinfo.go:265: ==> Use: nums var main.nums []int
2025/12/19 11:09:24.727202 [INFO] typesutil/gopinfo.go:215: ==> Type: nums []int
2025/12/19 11:09:24 Val append func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24.727217 [INFO] typesutil/gopinfo.go:265: ==> Use: append builtin append
2025/12/19 11:09:24.727222 [INFO] typesutil/gopinfo.go:215: ==> Type: append invalid type
2025/12/19 11:09:24 Val nums []int
2025/12/19 11:09:24.727235 [INFO] typesutil/gopinfo.go:265: ==> Use: nums var main.nums []int
2025/12/19 11:09:24.727240 [INFO] typesutil/gopinfo.go:215: ==> Type: nums []int
2025/12/19 11:09:24 Val &{0 STRING "NaN"} *ast.BasicLit
2025/12/19 11:09:24.727256 [INFO] typesutil/gopinfo.go:215: ==> Type: &{125 STRING "NaN" <nil>} untyped string
2025/12/19 11:09:24 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:24 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/12/19 11:09:24 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/12/19 11:09:24 ==> MatchType []int, []unboundFuncParam{typ: <nil>}
2025/12/19 11:09:24 ==> MatchType untyped string ("NaN"), unboundFuncParam{typ: int}
2025/12/19 11:09:24 ResetStmt
2025/12/19 11:09:24.727335 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc000357620 {
}

2025/12/19 11:09:24 End // Func
2025/12/19 11:09:24 main.xgo:3:21: boundType untyped string => int failed
2025/12/19 11:09:24.727365 [INFO] typesutil/check.go:179: typesutil.Check err: boundType untyped string => int failed
2025/12/19 11:09:24.728343 [ERROR] log/logext.go:606:
goroutine 75 [running]:
github.com/qiniu/x/log.(*Logger).SingleStack(0xc423e0, {0x0?, 0xc0003602c0?, 0xc00001bce8?})
	/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:385 +0x7b
github.com/qiniu/x/log.SingleStack(...)
	/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:606
github.com/goplus/xgo/x/typesutil.(*Checker).Files(0xc00001be38, {0x0, 0x0, 0x4?}, {0xc000198010, 0x1, 0xc00024ba70?})
	/app/x/typesutil/check.go:180 +0xd39
github.com/goplus/xgo/x/typesutil_test.checkInfo(0xc0002ac080, {0xc000198010, 0x1, 0x1}, {0x0, 0x0, 0x0}, 0x0)
	/app/x/typesutil/check_test.go:104 +0x42b
github.com/goplus/xgo/x/typesutil_test.checkFiles(0xc0002ac080, {0x8dc7e0?, 0x5490a0?}, {0x84f1a0?, 0x9a9dc0?}, {0x0?, 0x548edc?}, {0x84f1a0?, 0x9a9ae0?}, {0x0, ...}, ...)
	/app/x/typesutil/check_test.go:61 +0xb7
github.com/goplus/xgo/x/typesutil_test.TestCheckError(0xc00012c680)
	/app/x/typesutil/check_test.go:200 +0x192
testing.tRunner(0xc00012c680, 0x92d0e8)
	/usr/local/go/src/testing/testing.go:1689 +0xfb
created by testing.(*T).Run in goroutine 1
	/usr/local/go/src/testing/testing.go:1742 +0x390

--- PASS: TestCheckError (0.03s)
=== RUN   TestBadFile
2025/12/19 11:09:24.728679 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 0 goFiles = 0
2025/12/19 11:09:25 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:25 ==> NewOverloadFunc NewRange
2025/12/19 11:09:25 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:25 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:25 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:25 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:25 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:25 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:25 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:25 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:25 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:25 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:25 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:25 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:25 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:25 ==> NewOverloadMethod Int128 Gop_Rem
--- PASS: TestBadFile (0.99s)
=== RUN   TestCheckOverload
2025/12/19 11:09:25.715315 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:09:25.725827 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc00025bd40 {
}

2025/12/19 11:09:25 ==> Preload type foo
2025/12/19 11:09:25 ==> Preload method foo.mulInt
2025/12/19 11:09:25 ==> Preload method foo.mulFoo
2025/12/19 11:09:25 NewConstDefs
2025/12/19 11:09:25 ==> Preload const [Gopo_foo_mul]
2025/12/19 11:09:25 ==> Preload func addInt0
2025/12/19 11:09:25 ==> Preload func addInt1
2025/12/19 11:09:25 ==> Preload func addInt2
2025/12/19 11:09:25 ==> Preload var [addInt3]
2025/12/19 11:09:25 ==> Preload func add__4
2025/12/19 11:09:25 NewConstDefs
2025/12/19 11:09:25 ==> Preload const [Gopo_add]
2025/12/19 11:09:25 ==> Preload var [a b]
2025/12/19 11:09:25 ==> Preload var [c]
2025/12/19 11:09:25 ==> Preload var [d]
2025/12/19 11:09:25 ==> Preload func init
2025/12/19 11:09:25 ==> Load > NewType foo
2025/12/19 11:09:25 NewType foo
2025/12/19 11:09:25 ==> Load > InitType foo
2025/12/19 11:09:25.726051 [INFO] typesutil/gopinfo.go:215: ==> Type: &{11 0xc000113bf0 false} struct{}
2025/12/19 11:09:25 InitType foo struct{}
2025/12/19 11:09:25.726081 [INFO] typesutil/gopinfo.go:251: ==> Def: foo type main.foo struct{}
2025/12/19 11:09:25 ==> LookupParent foo => type main.foo struct{}
2025/12/19 11:09:25.726104 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/12/19 11:09:25.726118 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/12/19 11:09:25.726133 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a *main.foo
2025/12/19 11:09:25 ==> Load method *main.foo.mulInt
2025/12/19 11:09:25.726157 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:25.726169 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:25.726180 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:25.726192 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b int
2025/12/19 11:09:25 ==> LookupParent foo => type main.foo struct{}
2025/12/19 11:09:25.726212 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/12/19 11:09:25.726223 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/12/19 11:09:25.726234 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/12/19 11:09:25.726257 [INFO] typesutil/gopinfo.go:215: ==> Type: &{51 foo} *main.foo
2025/12/19 11:09:25.726296 [INFO] typesutil/gopinfo.go:251: ==> Def: mulInt func (*main.foo).mulInt(b int) *main.foo
2025/12/19 11:09:25 ==> LookupParent foo => type main.foo struct{}
2025/12/19 11:09:25.726317 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/12/19 11:09:25.726328 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/12/19 11:09:25.726341 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a *main.foo
2025/12/19 11:09:25 ==> Load method *main.foo.mulFoo
2025/12/19 11:09:25 ==> LookupParent foo => type main.foo struct{}
2025/12/19 11:09:25.726368 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/12/19 11:09:25.726379 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/12/19 11:09:25.726390 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/12/19 11:09:25.726404 [INFO] typesutil/gopinfo.go:215: ==> Type: &{94 foo} *main.foo
2025/12/19 11:09:25.726418 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b *main.foo
2025/12/19 11:09:25 ==> LookupParent foo => type main.foo struct{}
2025/12/19 11:09:25.726447 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/12/19 11:09:25.726461 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/12/19 11:09:25.726474 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/12/19 11:09:25.726488 [INFO] typesutil/gopinfo.go:215: ==> Type: &{100 foo} *main.foo
2025/12/19 11:09:25.726506 [INFO] typesutil/gopinfo.go:251: ==> Def: mulFoo func (*main.foo).mulFoo(b *main.foo) *main.foo
2025/12/19 11:09:25 ==> Load const [Gopo_foo_mul] <nil>
2025/12/19 11:09:25 NewConst [Gopo_foo_mul] 0
2025/12/19 11:09:25 Val &{0 STRING ".mulInt,.mulFoo"} *ast.BasicLit
2025/12/19 11:09:25.726559 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0 STRING ".mulInt,.mulFoo" <nil>} untyped string
2025/12/19 11:09:25 EndInit 1
2025/12/19 11:09:25.726593 [INFO] typesutil/gopinfo.go:251: ==> Def: Gopo_foo_mul const main.Gopo_foo_mul untyped string
2025/12/19 11:09:25 ==> Load func addInt0
2025/12/19 11:09:25.726620 [INFO] typesutil/gopinfo.go:251: ==> Def: addInt0 func main.addInt0()
2025/12/19 11:09:25 NewFunc addInt0 func()
2025/12/19 11:09:25.726648 [INFO] typesutil/gopinfo.go:332: ==> Scope: func addInt0 scope 0xc00027c300 {
}

2025/12/19 11:09:25 End // Func
2025/12/19 11:09:25 ==> Load func addInt1
2025/12/19 11:09:25.726677 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:25.726690 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:25.726701 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:25.726712 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/12/19 11:09:25.726732 [INFO] typesutil/gopinfo.go:251: ==> Def: addInt1 func main.addInt1(i int)
2025/12/19 11:09:25 NewFunc addInt1 func(i int)
2025/12/19 11:09:25.726761 [INFO] typesutil/gopinfo.go:332: ==> Scope: func addInt1 scope 0xc00027c420 {
.  var i int
}

2025/12/19 11:09:25 End // Func
2025/12/19 11:09:25 ==> Load func addInt2
2025/12/19 11:09:25.726796 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:25.726808 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:25.726818 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:25.726829 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/12/19 11:09:25.726841 [INFO] typesutil/gopinfo.go:251: ==> Def: j var j int
2025/12/19 11:09:25.726855 [INFO] typesutil/gopinfo.go:251: ==> Def: addInt2 func main.addInt2(i int, j int)
2025/12/19 11:09:25 NewFunc addInt2 func(i int, j int)
2025/12/19 11:09:25.726887 [INFO] typesutil/gopinfo.go:332: ==> Scope: func addInt2 scope 0xc00027c5a0 {
.  var i int
.  var j int
}

2025/12/19 11:09:25 End // Func
2025/12/19 11:09:25 ==> Load var <nil> [addInt3]
2025/12/19 11:09:25 NewVarDefs
2025/12/19 11:09:25 NewVar [addInt3]
2025/12/19 11:09:25.726935 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:25.726952 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:25.726967 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:25.726979 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/12/19 11:09:25.726989 [INFO] typesutil/gopinfo.go:251: ==> Def: j var j int
2025/12/19 11:09:25.727000 [INFO] typesutil/gopinfo.go:251: ==> Def: k var k int
2025/12/19 11:09:25.727022 [INFO] typesutil/gopinfo.go:215: ==> Type: &{256 <nil> 0xc000336330 <nil>} func(i int, j int, k int)
2025/12/19 11:09:25.727051 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0000fcec0 0xc000336390} func(i int, j int, k int)
2025/12/19 11:09:25 NewClosure func(i int, j int, k int)
2025/12/19 11:09:25.727090 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc00027c780 {
.  var i int
.  var j int
.  var k int
}

2025/12/19 11:09:25 End // Func
2025/12/19 11:09:25 EndInit 1
2025/12/19 11:09:25.727130 [INFO] typesutil/gopinfo.go:251: ==> Def: addInt3 var main.addInt3 func(i int, j int, k int)
2025/12/19 11:09:25 ==> Load func add__4
2025/12/19 11:09:25.727149 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/12/19 11:09:25.727160 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:25.727171 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:25.727181 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a string
2025/12/19 11:09:25.727193 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b string
2025/12/19 11:09:25.727204 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/12/19 11:09:25.727215 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:25.727225 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:25.727241 [INFO] typesutil/gopinfo.go:251: ==> Def: add__4 func main.add__4(a string, b string) string
2025/12/19 11:09:25 NewFunc add__4 func(a string, b string) string
2025/12/19 11:09:25 Val a string
2025/12/19 11:09:25.727276 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a string
2025/12/19 11:09:25.727287 [INFO] typesutil/gopinfo.go:215: ==> Type: a string
2025/12/19 11:09:25 Val b string
2025/12/19 11:09:25.727303 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b string
2025/12/19 11:09:25.727316 [INFO] typesutil/gopinfo.go:215: ==> Type: b string
2025/12/19 11:09:25 BinaryOp +
2025/12/19 11:09:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:25 ==> MatchType string, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:25 ==> MatchType string, unboundFuncParam{typ: string}
2025/12/19 11:09:25.727404 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 367 + b} string
2025/12/19 11:09:25 Return 1
2025/12/19 11:09:25 ==> MatchType string, string
2025/12/19 11:09:25.727443 [INFO] typesutil/gopinfo.go:332: ==> Scope: func add__4 scope 0xc00027c9c0 {
.  var a string
.  var b string
}

2025/12/19 11:09:25 End // Func
2025/12/19 11:09:25 ==> Load const [Gopo_add] <nil>
2025/12/19 11:09:25 NewConst [Gopo_add] 0
2025/12/19 11:09:25 Val &{0 STRING "addInt0,addInt1,addInt2,addInt3,"} *ast.BasicLit
2025/12/19 11:09:25.727496 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0 STRING "addInt0,addInt1,addInt2,addInt3," <nil>} untyped string
2025/12/19 11:09:25 EndInit 1
2025/12/19 11:09:25.727514 [INFO] typesutil/gopinfo.go:251: ==> Def: Gopo_add const main.Gopo_add untyped string
2025/12/19 11:09:25 ==> NewOverloadFunc add
2025/12/19 11:09:25 ==> NewOverloadMethod foo mul
2025/12/19 11:09:25 ==> LookupParent foo => type main.foo struct{}
2025/12/19 11:09:25.727582 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/12/19 11:09:25.727598 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/12/19 11:09:25.727609 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/12/19 11:09:25.727624 [INFO] typesutil/gopinfo.go:215: ==> Type: &{386 foo} *main.foo
2025/12/19 11:09:25 ==> Load var *main.foo [a b]
2025/12/19 11:09:25 NewVarDefs
2025/12/19 11:09:25 NewVar [a b]
2025/12/19 11:09:25.727661 [INFO] typesutil/gopinfo.go:251: ==> Def: a var main.a *main.foo
2025/12/19 11:09:25.727673 [INFO] typesutil/gopinfo.go:251: ==> Def: b var main.b *main.foo
2025/12/19 11:09:25 ==> Load var <nil> [c]
2025/12/19 11:09:25 NewVarDefs
2025/12/19 11:09:25 NewVar [c]
2025/12/19 11:09:25 Val a *main.foo
2025/12/19 11:09:25.727711 [INFO] typesutil/gopinfo.go:265: ==> Use: a var main.a *main.foo
2025/12/19 11:09:25.727724 [INFO] typesutil/gopinfo.go:215: ==> Type: a *main.foo
2025/12/19 11:09:25 Member mul 1 // *main.foo
2025/12/19 11:09:25.727753 [INFO] typesutil/gopinfo.go:265: ==> Use: mul func (main.foo).mul(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25.727774 [INFO] typesutil/gopinfo.go:274: ==> Overloads: mul TyOverloadMethod
2025/12/19 11:09:25.727790 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a mul} func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:25.727823 [INFO] typesutil/gopinfo.go:215: ==> Type: &{405 INT 100 <nil>} untyped int
2025/12/19 11:09:25 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall func(b int) *main.foo args: 1 flags: 0
2025/12/19 11:09:25 ==> MatchType untyped int (100), int
2025/12/19 11:09:25.727886 [INFO] typesutil/gopinfo.go:265: ==> Use: mul func (*main.foo).mulInt(b int) *main.foo
2025/12/19 11:09:25.727911 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a mul} func(b int) *main.foo
2025/12/19 11:09:25.727935 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003d8600 404 [0xc000336510] 0 [] 408 0} *main.foo
2025/12/19 11:09:25 EndInit 1
2025/12/19 11:09:25.727958 [INFO] typesutil/gopinfo.go:251: ==> Def: c var main.c *main.foo
2025/12/19 11:09:25 ==> Load var <nil> [d]
2025/12/19 11:09:25 NewVarDefs
2025/12/19 11:09:25 NewVar [d]
2025/12/19 11:09:25 Val a *main.foo
2025/12/19 11:09:25.728006 [INFO] typesutil/gopinfo.go:265: ==> Use: a var main.a *main.foo
2025/12/19 11:09:25.728017 [INFO] typesutil/gopinfo.go:215: ==> Type: a *main.foo
2025/12/19 11:09:25 Member mul 1 // *main.foo
2025/12/19 11:09:25.728040 [INFO] typesutil/gopinfo.go:265: ==> Use: mul func (main.foo).mul(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25.728050 [INFO] typesutil/gopinfo.go:274: ==> Overloads: mul TyOverloadMethod
2025/12/19 11:09:25.728063 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a mul} func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25 Val c *main.foo
2025/12/19 11:09:25.728086 [INFO] typesutil/gopinfo.go:265: ==> Use: c var main.c *main.foo
2025/12/19 11:09:25.728097 [INFO] typesutil/gopinfo.go:215: ==> Type: c *main.foo
2025/12/19 11:09:25 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall func(b int) *main.foo args: 1 flags: 0
2025/12/19 11:09:25 ==> MatchType *main.foo, int
2025/12/19 11:09:25 ==> MatchFuncCall func(b *main.foo) *main.foo args: 1 flags: 0
2025/12/19 11:09:25 ==> MatchType *main.foo, *main.foo
2025/12/19 11:09:25.728172 [INFO] typesutil/gopinfo.go:265: ==> Use: mul func (*main.foo).mulFoo(b *main.foo) *main.foo
2025/12/19 11:09:25.728188 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a mul} func(b *main.foo) *main.foo
2025/12/19 11:09:25.728206 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003d8618 423 [c] 0 [] 425 0} *main.foo
2025/12/19 11:09:25 EndInit 1
2025/12/19 11:09:25.728225 [INFO] typesutil/gopinfo.go:251: ==> Def: d var main.d *main.foo
2025/12/19 11:09:25 ==> Load func init
2025/12/19 11:09:25.728245 [INFO] typesutil/gopinfo.go:251: ==> Def: init func main.init()
2025/12/19 11:09:25 NewFunc init func()
2025/12/19 11:09:25 Val add func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25.728280 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25.728288 [INFO] typesutil/gopinfo.go:274: ==> Overloads: add TyOverloadFunc
2025/12/19 11:09:25.728300 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:25.728328 [INFO] typesutil/gopinfo.go:215: ==> Type: &{447 INT 100 <nil>} untyped int
2025/12/19 11:09:25 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:25.728351 [INFO] typesutil/gopinfo.go:215: ==> Type: &{452 INT 200 <nil>} untyped int
2025/12/19 11:09:25 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall func() args: 2 flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall func(i int) args: 2 flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall func(i int, j int) args: 2 flags: 0
2025/12/19 11:09:25 ==> MatchType untyped int (100), int
2025/12/19 11:09:25 ==> MatchType untyped int (200), int
2025/12/19 11:09:25.728446 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.addInt2(i int, j int)
2025/12/19 11:09:25.728460 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(i int, j int)
2025/12/19 11:09:25.728480 [INFO] typesutil/gopinfo.go:215: ==> Type: &{add 0 [0xc0003365d0 0xc000336600] 0 [] 0 455} ()
2025/12/19 11:09:25 Val add func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25.728505 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25.728515 [INFO] typesutil/gopinfo.go:274: ==> Overloads: add TyOverloadFunc
2025/12/19 11:09:25.728527 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:25.728552 [INFO] typesutil/gopinfo.go:215: ==> Type: &{461 INT 100 <nil>} untyped int
2025/12/19 11:09:25 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:25.728573 [INFO] typesutil/gopinfo.go:215: ==> Type: &{466 INT 200 <nil>} untyped int
2025/12/19 11:09:25 Val &{0 INT 300} *ast.BasicLit
2025/12/19 11:09:25.728592 [INFO] typesutil/gopinfo.go:215: ==> Type: &{471 INT 300 <nil>} untyped int
2025/12/19 11:09:25 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall func() args: 3 flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall func(i int) args: 3 flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall func(i int, j int) args: 3 flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall func(i int, j int, k int) args: 3 flags: 0
2025/12/19 11:09:25 ==> MatchType untyped int (100), int
2025/12/19 11:09:25 ==> MatchType untyped int (200), int
2025/12/19 11:09:25 ==> MatchType untyped int (300), int
2025/12/19 11:09:25.728712 [INFO] typesutil/gopinfo.go:265: ==> Use: add var main.addInt3 func(i int, j int, k int)
2025/12/19 11:09:25.728725 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(i int, j int, k int)
2025/12/19 11:09:25.728747 [INFO] typesutil/gopinfo.go:215: ==> Type: &{add 0 [0xc000336630 0xc000336660 0xc000336690] 0 [] 0 474} ()
2025/12/19 11:09:25 Val add func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25.728769 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25.728778 [INFO] typesutil/gopinfo.go:274: ==> Overloads: add TyOverloadFunc
2025/12/19 11:09:25.728791 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:25.728816 [INFO] typesutil/gopinfo.go:215: ==> Type: &{480 STRING "hello" <nil>} untyped string
2025/12/19 11:09:25 Val &{0 STRING "world"} *ast.BasicLit
2025/12/19 11:09:25.728837 [INFO] typesutil/gopinfo.go:215: ==> Type: &{489 STRING "world" <nil>} untyped string
2025/12/19 11:09:25 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall func() args: 2 flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall func(i int) args: 2 flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall func(i int, j int) args: 2 flags: 0
2025/12/19 11:09:25 ==> MatchType untyped string ("hello"), int
2025/12/19 11:09:25 ==> MatchFuncCall func(i int, j int, k int) args: 2 flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall func(a string, b string) string args: 2 flags: 0
2025/12/19 11:09:25 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:25 ==> MatchType untyped string ("world"), string
2025/12/19 11:09:25.728962 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add__4(a string, b string) string
2025/12/19 11:09:25.728974 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(a string, b string) string
2025/12/19 11:09:25.728992 [INFO] typesutil/gopinfo.go:215: ==> Type: &{add 479 [0xc0003366c0 0xc0003366f0] 0 [] 496 0} string
2025/12/19 11:09:25.729007 [INFO] typesutil/gopinfo.go:332: ==> Scope: func init scope 0xc00027d1a0 {
}

2025/12/19 11:09:25 End // Func
2025/12/19 11:09:25 NewFunc mulInt (*main.foo) func(b int) *main.foo
2025/12/19 11:09:25 Val a *main.foo
2025/12/19 11:09:25.729060 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a *main.foo
2025/12/19 11:09:25.729071 [INFO] typesutil/gopinfo.go:215: ==> Type: a *main.foo
2025/12/19 11:09:25 Return 1
2025/12/19 11:09:25 ==> MatchType *main.foo, *main.foo
2025/12/19 11:09:25.729167 [INFO] typesutil/gopinfo.go:332: ==> Scope: func mulInt scope 0xc00027d380 {
.  var a *main.foo
.  var b int
}

2025/12/19 11:09:25 End // Func
2025/12/19 11:09:25 NewFunc mulFoo (*main.foo) func(b *main.foo) *main.foo
2025/12/19 11:09:25 Val a *main.foo
2025/12/19 11:09:25.729194 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a *main.foo
2025/12/19 11:09:25.729199 [INFO] typesutil/gopinfo.go:215: ==> Type: a *main.foo
2025/12/19 11:09:25 Return 1
2025/12/19 11:09:25 ==> MatchType *main.foo, *main.foo
2025/12/19 11:09:25.729216 [INFO] typesutil/gopinfo.go:332: ==> Scope: func mulFoo scope 0xc00027d3e0 {
.  var a *main.foo
.  var b *main.foo
}

2025/12/19 11:09:25 End // Func
2025/12/19 11:09:25.729228 [INFO] typesutil/gopinfo.go:251: ==> Def: add func main.add(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25.729235 [INFO] typesutil/gopinfo.go:251: ==> Def: mul func (main.foo).mul(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25.729244 [INFO] typesutil/gopinfo.go:215: ==> Type: &{329 <nil> 0xc000336420 0xc000336450} func(a string, b string) string
2025/12/19 11:09:25.729251 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0000fd020 0xc0003364e0} func(a string, b string) string
2025/12/19 11:09:25.729256 [INFO] typesutil/gopinfo.go:292: ==> Implicit: func main.add__4(a string, b string) string
2025/12/19 11:09:25.729263 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/12/19 11:09:25.729269 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/12/19 11:09:25.729274 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/12/19 11:09:25.729281 [INFO] typesutil/gopinfo.go:265: ==> Use: mulInt func (*main.foo).mulInt(b int) *main.foo
2025/12/19 11:09:25.729288 [INFO] typesutil/gopinfo.go:265: ==> Use: mulFoo func (*main.foo).mulFoo(b *main.foo) *main.foo
2025/12/19 11:09:25.729294 [INFO] typesutil/gopinfo.go:265: ==> Use: addInt0 func main.addInt0()
2025/12/19 11:09:25.729298 [INFO] typesutil/gopinfo.go:265: ==> Use: addInt1 func main.addInt1(i int)
2025/12/19 11:09:25.729303 [INFO] typesutil/gopinfo.go:265: ==> Use: addInt2 func main.addInt2(i int, j int)
2025/12/19 11:09:25.729309 [INFO] typesutil/gopinfo.go:265: ==> Use: addInt3 var main.addInt3 func(i int, j int, k int)
--- PASS: TestCheckOverload (0.01s)
=== RUN   TestCheckError2
2025/12/19 11:09:25.729544 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:09:25.740130 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc00026a300 {
}

2025/12/19 11:09:25 ==> Preload type Foo
2025/12/19 11:09:25 ==> Preload func main
2025/12/19 11:09:25 ==> Load > NewType Foo
2025/12/19 11:09:25 NewType Foo
2025/12/19 11:09:25 ==> Load > InitType Foo
2025/12/19 11:09:25.740235 [INFO] typesutil/gopinfo.go:265: ==> Use: bool type bool
2025/12/19 11:09:25.740256 [INFO] typesutil/gopinfo.go:215: ==> Type: bool bool
2025/12/19 11:09:25.740270 [INFO] typesutil/gopinfo.go:215: ==> Type: bool bool
2025/12/19 11:09:25.740287 [INFO] typesutil/gopinfo.go:251: ==> Def: B field B bool
2025/12/19 11:09:25.740312 [INFO] typesutil/gopinfo.go:215: ==> Type: &{11 0xc00029fc20 false} struct{B bool}
2025/12/19 11:09:25 InitType Foo struct{B bool}
2025/12/19 11:09:25.740347 [INFO] typesutil/gopinfo.go:251: ==> Def: Foo type main.Foo struct{B bool}
2025/12/19 11:09:25 ==> Load func main
2025/12/19 11:09:25.740379 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:09:25 NewFunc main func()
2025/12/19 11:09:25 DefineVarStart [bar]
2025/12/19 11:09:25 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:25.740445 [INFO] typesutil/gopinfo.go:215: ==> Type: &{38 INT 2 <nil>} untyped int
2025/12/19 11:09:25 EndInit 1
2025/12/19 11:09:25.740468 [INFO] typesutil/gopinfo.go:251: ==> Def: bar var bar int
2025/12/19 11:09:25 DefineVarStart [gotbar]
2025/12/19 11:09:25 Val false untyped bool
2025/12/19 11:09:25.740511 [INFO] typesutil/gopinfo.go:265: ==> Use: false const false untyped bool
2025/12/19 11:09:25.740524 [INFO] typesutil/gopinfo.go:215: ==> Type: false untyped bool
2025/12/19 11:09:25 EndInit 1
2025/12/19 11:09:25.740543 [INFO] typesutil/gopinfo.go:251: ==> Def: gotbar var gotbar bool
2025/12/19 11:09:25 DefineVarStart [boolBar]
2025/12/19 11:09:25 Val false untyped bool
2025/12/19 11:09:25.740573 [INFO] typesutil/gopinfo.go:265: ==> Use: false const false untyped bool
2025/12/19 11:09:25.740585 [INFO] typesutil/gopinfo.go:215: ==> Type: false untyped bool
2025/12/19 11:09:25 EndInit 1
2025/12/19 11:09:25.740604 [INFO] typesutil/gopinfo.go:251: ==> Def: boolBar var boolBar bool
2025/12/19 11:09:25 DefineVarStart [gg]
2025/12/19 11:09:25 ==> LookupParent Foo => type main.Foo struct{B bool}
2025/12/19 11:09:25.740638 [INFO] typesutil/gopinfo.go:265: ==> Use: Foo type main.Foo struct{B bool}
2025/12/19 11:09:25.740651 [INFO] typesutil/gopinfo.go:215: ==> Type: Foo main.Foo
2025/12/19 11:09:25.740664 [INFO] typesutil/gopinfo.go:215: ==> Type: Foo main.Foo
2025/12/19 11:09:25 Val 0 int
2025/12/19 11:09:25.740685 [INFO] typesutil/gopinfo.go:265: ==> Use: B field B bool
2025/12/19 11:09:25 Val true untyped bool
2025/12/19 11:09:25.740708 [INFO] typesutil/gopinfo.go:265: ==> Use: true const true untyped bool
2025/12/19 11:09:25.740720 [INFO] typesutil/gopinfo.go:215: ==> Type: true untyped bool
2025/12/19 11:09:25 StructLit main.Foo 2 true
2025/12/19 11:09:25.740748 [INFO] typesutil/gopinfo.go:215: ==> Type: Foo main.Foo
2025/12/19 11:09:25.740776 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Foo 83 [0xc00029fce0] 91 false} main.Foo
2025/12/19 11:09:25 UnaryOp & flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:25.740829 [INFO] typesutil/gopinfo.go:215: ==> Type: &{79 & 0xc00028f240} *main.Foo
2025/12/19 11:09:25 EndInit 1
2025/12/19 11:09:25.740857 [INFO] typesutil/gopinfo.go:251: ==> Def: gg var gg *main.Foo
2025/12/19 11:09:25 If
2025/12/19 11:09:25 Val bar int
2025/12/19 11:09:25.740894 [INFO] typesutil/gopinfo.go:265: ==> Use: bar var bar int
2025/12/19 11:09:25.740906 [INFO] typesutil/gopinfo.go:215: ==> Type: bar int
2025/12/19 11:09:25 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:25.740934 [INFO] typesutil/gopinfo.go:215: ==> Type: &{103 INT 2 <nil>} untyped int
2025/12/19 11:09:25 BinaryOp ==
2025/12/19 11:09:25.740959 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar 100 == 0xc00029fd40} untyped bool
2025/12/19 11:09:25 Val gotbar bool
2025/12/19 11:09:25.740985 [INFO] typesutil/gopinfo.go:265: ==> Use: gotbar var gotbar bool
2025/12/19 11:09:25.740998 [INFO] typesutil/gopinfo.go:215: ==> Type: gotbar bool
2025/12/19 11:09:25 UnaryOp ! flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/12/19 11:09:25 ==> MatchType bool, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:25.741107 [INFO] typesutil/gopinfo.go:215: ==> Type: &{108 ! gotbar} bool
2025/12/19 11:09:25 BinaryOp &&
2025/12/19 11:09:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:25 ==> MatchType untyped bool, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:25 ==> MatchType bool, unboundFuncParam{typ: untyped bool}
2025/12/19 11:09:25.741201 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00029fd70 105 && 0xc000289180} bool
2025/12/19 11:09:25.741219 [INFO] typesutil/gopinfo.go:332: ==> Scope: if statement scope 0xc00026a660 {
}

2025/12/19 11:09:25 Then
2025/12/19 11:09:25 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25.741257 [INFO] typesutil/gopinfo.go:265: ==> Use: println builtin println
2025/12/19 11:09:25.741275 [INFO] typesutil/gopinfo.go:215: ==> Type: println invalid type
2025/12/19 11:09:25 Val &{0 STRING "wow!"} *ast.BasicLit
2025/12/19 11:09:25.741303 [INFO] typesutil/gopinfo.go:215: ==> Type: &{127 STRING "wow!" <nil>} untyped string
2025/12/19 11:09:25 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:25 ==> MatchType untyped string ("wow!"), any
2025/12/19 11:09:25.741371 [INFO] typesutil/gopinfo.go:265: ==> Use: println func fmt.Println(a ...any) (n int, err error)
2025/12/19 11:09:25.741394 [INFO] typesutil/gopinfo.go:215: ==> Type: println func(a ...any) (n int, err error)
2025/12/19 11:09:25.741418 [INFO] typesutil/gopinfo.go:215: ==> Type: &{println 126 [0xc00029fe00] 0 [] 133 0} (n int, err error)
2025/12/19 11:09:25 Else
2025/12/19 11:09:25 If
2025/12/19 11:09:25 Val bar int
2025/12/19 11:09:25.741461 [INFO] typesutil/gopinfo.go:265: ==> Use: bar var bar int
2025/12/19 11:09:25.741473 [INFO] typesutil/gopinfo.go:215: ==> Type: bar int
2025/12/19 11:09:25 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:25.741498 [INFO] typesutil/gopinfo.go:215: ==> Type: &{152 INT 1 <nil>} untyped int
2025/12/19 11:09:25 BinaryOp ==
2025/12/19 11:09:25.741521 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar 149 == 0xc00029fe90} untyped bool
2025/12/19 11:09:25 Val gotbar bool
2025/12/19 11:09:25.741546 [INFO] typesutil/gopinfo.go:265: ==> Use: gotbar var gotbar bool
2025/12/19 11:09:25.741559 [INFO] typesutil/gopinfo.go:215: ==> Type: gotbar bool
2025/12/19 11:09:25 BinaryOp &&
2025/12/19 11:09:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:25 ==> MatchType untyped bool, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:25 ==> MatchType bool, unboundFuncParam{typ: untyped bool}
2025/12/19 11:09:25.741622 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00029fec0 154 && gotbar} bool
2025/12/19 11:09:25.741635 [INFO] typesutil/gopinfo.go:332: ==> Scope: if statement scope 0xc00026a9c0 {
}

2025/12/19 11:09:25 Then
2025/12/19 11:09:25 If
2025/12/19 11:09:25 Val boolBar bool
2025/12/19 11:09:25.741669 [INFO] typesutil/gopinfo.go:265: ==> Use: boolBar var boolBar bool
2025/12/19 11:09:25.741681 [INFO] typesutil/gopinfo.go:215: ==> Type: boolBar bool
2025/12/19 11:09:25 UnaryOp ! flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/12/19 11:09:25 ==> MatchType bool, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:25.741728 [INFO] typesutil/gopinfo.go:215: ==> Type: &{170 ! boolBar} bool
2025/12/19 11:09:25.741740 [INFO] typesutil/gopinfo.go:332: ==> Scope: if statement scope 0xc00026aba0 {
}

2025/12/19 11:09:25 Then
2025/12/19 11:09:25 VarRef boolBar bool
2025/12/19 11:09:25.741767 [INFO] typesutil/gopinfo.go:265: ==> Use: boolBar var boolBar bool
2025/12/19 11:09:25.741778 [INFO] typesutil/gopinfo.go:215: ==> Type: boolBar bool
2025/12/19 11:09:25 Val true untyped bool
2025/12/19 11:09:25.741803 [INFO] typesutil/gopinfo.go:265: ==> Use: true const true untyped bool
2025/12/19 11:09:25.741824 [INFO] typesutil/gopinfo.go:215: ==> Type: true untyped bool
2025/12/19 11:09:25 Assign 1 1
2025/12/19 11:09:25 ==> MatchType untyped bool (true), bool
2025/12/19 11:09:25 For
2025/12/19 11:09:25.741889 [INFO] typesutil/gopinfo.go:332: ==> Scope: for statement scope 0xc00026ad20 {
}

2025/12/19 11:09:25 DefineVarStart [i]
2025/12/19 11:09:25 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:25.741926 [INFO] typesutil/gopinfo.go:215: ==> Type: &{209 INT 0 <nil>} untyped int
2025/12/19 11:09:25 EndInit 1
2025/12/19 11:09:25.741949 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/12/19 11:09:25 Val i int
2025/12/19 11:09:25.741977 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/12/19 11:09:25.741990 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/12/19 11:09:25 Val &{0 INT 20} *ast.BasicLit
2025/12/19 11:09:25.742012 [INFO] typesutil/gopinfo.go:215: ==> Type: &{216 INT 20 <nil>} untyped int
2025/12/19 11:09:25 BinaryOp <
2025/12/19 11:09:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:25 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:25 ==> MatchType untyped int (20), unboundFuncParam{typ: int}
2025/12/19 11:09:25.742077 [INFO] typesutil/gopinfo.go:215: ==> Type: &{i 214 < 0xc0002b2090} untyped bool
2025/12/19 11:09:25 Then
2025/12/19 11:09:25.742102 [INFO] typesutil/gopinfo.go:332: ==> Scope: for body scope 0xc00026aea0 {
}

2025/12/19 11:09:25 If
2025/12/19 11:09:25 Val gg *main.Foo
2025/12/19 11:09:25.742131 [INFO] typesutil/gopinfo.go:265: ==> Use: gg var gg *main.Foo
2025/12/19 11:09:25.742144 [INFO] typesutil/gopinfo.go:215: ==> Type: gg *main.Foo
2025/12/19 11:09:25 Member P 2 // *main.Foo
2025/12/19 11:09:25 ResetStmt
2025/12/19 11:09:25 End // If
2025/12/19 11:09:25 Post
2025/12/19 11:09:25 VarRef i int
2025/12/19 11:09:25.742213 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/12/19 11:09:25.742225 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/12/19 11:09:25 IncDec ++
2025/12/19 11:09:25 End // For
2025/12/19 11:09:25.742255 [INFO] typesutil/gopinfo.go:332: ==> Scope: if body scope 0xc00026acc0 {
}

2025/12/19 11:09:25 End // If
2025/12/19 11:09:25.742274 [INFO] typesutil/gopinfo.go:332: ==> Scope: if body scope 0xc00026ab40 {
}

2025/12/19 11:09:25 End // If
2025/12/19 11:09:25.742292 [INFO] typesutil/gopinfo.go:332: ==> Scope: else body scope 0xc00026a960 {
}

2025/12/19 11:09:25 End // If
2025/12/19 11:09:25.742332 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc00026a480 {
.  var bar int
.  var boolBar bool
.  var gg *main.Foo
.  var gotbar bool
}

2025/12/19 11:09:25 End // Func
2025/12/19 11:09:25.742365 [INFO] typesutil/check.go:179: typesutil.Check err: main.xgo:16:7: gg.P undefined (type *main.Foo has no field or method P)
2025/12/19 11:09:25.744240 [ERROR] log/logext.go:606:
goroutine 150 [running]:
github.com/qiniu/x/log.(*Logger).SingleStack(0xc423e0, {0x0?, 0xc0002a5a70?, 0xc0002e9cd8?})
	/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:385 +0x7b
github.com/qiniu/x/log.SingleStack(...)
	/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:606
github.com/goplus/xgo/x/typesutil.(*Checker).Files(0xc0002e9e28, {0x0, 0x0, 0x4?}, {0xc000199cf8, 0x1, 0xc00028a600?})
	/app/x/typesutil/check.go:180 +0xd39
github.com/goplus/xgo/x/typesutil_test.checkInfo(0xc00028f080, {0xc000199cf8, 0x1, 0x1}, {0x0, 0x0, 0x0}, 0xc000523d90)
	/app/x/typesutil/check_test.go:104 +0x42b
github.com/goplus/xgo/x/typesutil_test.checkFilesWithErrorHandler(0xc00028f080, {0x8dc7e0?, 0x603?}, {0x84f1a0?, 0x9a9df0?}, {0x0?, 0xc000586f60?}, {0x84f1a0?, 0x9a9ae0?}, {0x0, ...}, ...)
	/app/x/typesutil/check_test.go:69 +0xbc
github.com/goplus/xgo/x/typesutil_test.TestCheckError2(0xc00012cea0)
	/app/x/typesutil/check_test.go:302 +0xe5
testing.tRunner(0xc00012cea0, 0x92d0f0)
	/usr/local/go/src/testing/testing.go:1689 +0xfb
created by testing.(*T).Run in goroutine 1
	/usr/local/go/src/testing/testing.go:1742 +0x390

--- PASS: TestCheckError2 (0.01s)
=== RUN   TestCheckError3
2025/12/19 11:09:25.745861 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:09:25.755385 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0004cb380 {
}

2025/12/19 11:09:25 ==> Preload type Foo
2025/12/19 11:09:25 ==> Preload func main
2025/12/19 11:09:25 ==> Load > NewType Foo
2025/12/19 11:09:25 NewType Foo
2025/12/19 11:09:25 ==> Load > InitType Foo
2025/12/19 11:09:25.755457 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/12/19 11:09:25.755468 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:25.755475 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:25.755488 [INFO] typesutil/gopinfo.go:215: ==> Type: &{23 <nil> string} []string
2025/12/19 11:09:25.755495 [INFO] typesutil/gopinfo.go:251: ==> Def: B field B []string
2025/12/19 11:09:25.755507 [INFO] typesutil/gopinfo.go:215: ==> Type: &{11 0xc0002a4030 false} struct{B []string}
2025/12/19 11:09:25 InitType Foo struct{B []string}
2025/12/19 11:09:25.755522 [INFO] typesutil/gopinfo.go:251: ==> Def: Foo type main.Foo struct{B []string}
2025/12/19 11:09:25 ==> Load func main
2025/12/19 11:09:25.755534 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:09:25 NewFunc main func()
2025/12/19 11:09:25 DefineVarStart [bar]
2025/12/19 11:09:25 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:25.755567 [INFO] typesutil/gopinfo.go:215: ==> Type: &{42 INT 2 <nil>} untyped int
2025/12/19 11:09:25 EndInit 1
2025/12/19 11:09:25.755577 [INFO] typesutil/gopinfo.go:251: ==> Def: bar var bar int
2025/12/19 11:09:25 DefineVarStart [gotbar]
2025/12/19 11:09:25 Val false untyped bool
2025/12/19 11:09:25.755597 [INFO] typesutil/gopinfo.go:265: ==> Use: false const false untyped bool
2025/12/19 11:09:25.755603 [INFO] typesutil/gopinfo.go:215: ==> Type: false untyped bool
2025/12/19 11:09:25 EndInit 1
2025/12/19 11:09:25.755611 [INFO] typesutil/gopinfo.go:251: ==> Def: gotbar var gotbar bool
2025/12/19 11:09:25 DefineVarStart [boolBar]
2025/12/19 11:09:25 Val false untyped bool
2025/12/19 11:09:25.755626 [INFO] typesutil/gopinfo.go:265: ==> Use: false const false untyped bool
2025/12/19 11:09:25.755632 [INFO] typesutil/gopinfo.go:215: ==> Type: false untyped bool
2025/12/19 11:09:25 EndInit 1
2025/12/19 11:09:25.755641 [INFO] typesutil/gopinfo.go:251: ==> Def: boolBar var boolBar bool
2025/12/19 11:09:25 DefineVarStart [gg]
2025/12/19 11:09:25 ==> LookupParent Foo => type main.Foo struct{B []string}
2025/12/19 11:09:25.755660 [INFO] typesutil/gopinfo.go:265: ==> Use: Foo type main.Foo struct{B []string}
2025/12/19 11:09:25.755666 [INFO] typesutil/gopinfo.go:215: ==> Type: Foo main.Foo
2025/12/19 11:09:25.755672 [INFO] typesutil/gopinfo.go:215: ==> Type: Foo main.Foo
2025/12/19 11:09:25 Val 0 int
2025/12/19 11:09:25.755682 [INFO] typesutil/gopinfo.go:265: ==> Use: B field B []string
2025/12/19 11:09:25.755689 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/12/19 11:09:25.755693 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:25.755698 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:25.755708 [INFO] typesutil/gopinfo.go:215: ==> Type: &{91 <nil> string} []string
2025/12/19 11:09:25 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:25.755721 [INFO] typesutil/gopinfo.go:215: ==> Type: &{100 STRING "hello" <nil>} untyped string
2025/12/19 11:09:25 Val &{0 STRING "world"} *ast.BasicLit
2025/12/19 11:09:25.755741 [INFO] typesutil/gopinfo.go:215: ==> Type: &{109 STRING "world" <nil>} untyped string
2025/12/19 11:09:25 SliceLit []string 2 false
2025/12/19 11:09:25.755757 [INFO] typesutil/gopinfo.go:215: ==> Type: &{91 <nil> string} []string
2025/12/19 11:09:25.755767 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002a4120 99 [0xc0002a4150 0xc0002a4180] 116 false} []string
2025/12/19 11:09:25 StructLit main.Foo 2 true
2025/12/19 11:09:25.755778 [INFO] typesutil/gopinfo.go:215: ==> Type: Foo main.Foo
2025/12/19 11:09:25.755786 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Foo 87 [0xc0002a41b0] 117 false} main.Foo
2025/12/19 11:09:25 UnaryOp & flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:25.755807 [INFO] typesutil/gopinfo.go:215: ==> Type: &{83 & 0xc000272180} *main.Foo
2025/12/19 11:09:25 EndInit 1
2025/12/19 11:09:25.755817 [INFO] typesutil/gopinfo.go:251: ==> Def: gg var gg *main.Foo
2025/12/19 11:09:25 If
2025/12/19 11:09:25 Val bar int
2025/12/19 11:09:25.755831 [INFO] typesutil/gopinfo.go:265: ==> Use: bar var bar int
2025/12/19 11:09:25.755841 [INFO] typesutil/gopinfo.go:215: ==> Type: bar int
2025/12/19 11:09:25 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:25.755851 [INFO] typesutil/gopinfo.go:215: ==> Type: &{129 INT 2 <nil>} untyped int
2025/12/19 11:09:25 BinaryOp ==
2025/12/19 11:09:25.755862 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar 126 == 0xc0002a4210} untyped bool
2025/12/19 11:09:25 Val gotbar bool
2025/12/19 11:09:25.755870 [INFO] typesutil/gopinfo.go:265: ==> Use: gotbar var gotbar bool
2025/12/19 11:09:25.755874 [INFO] typesutil/gopinfo.go:215: ==> Type: gotbar bool
2025/12/19 11:09:25 UnaryOp ! flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/12/19 11:09:25 ==> MatchType bool, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:25.755904 [INFO] typesutil/gopinfo.go:215: ==> Type: &{134 ! gotbar} bool
2025/12/19 11:09:25 BinaryOp &&
2025/12/19 11:09:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:25 ==> MatchType untyped bool, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:25 ==> MatchType bool, unboundFuncParam{typ: untyped bool}
2025/12/19 11:09:25.755935 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002a4240 131 && 0xc000482200} bool
2025/12/19 11:09:25.755940 [INFO] typesutil/gopinfo.go:332: ==> Scope: if statement scope 0xc0004cb6e0 {
}

2025/12/19 11:09:25 Then
2025/12/19 11:09:25 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25.755955 [INFO] typesutil/gopinfo.go:265: ==> Use: println builtin println
2025/12/19 11:09:25.755961 [INFO] typesutil/gopinfo.go:215: ==> Type: println invalid type
2025/12/19 11:09:25 Val &{0 STRING "Double jump activated!"} *ast.BasicLit
2025/12/19 11:09:25.755974 [INFO] typesutil/gopinfo.go:215: ==> Type: &{153 STRING "Double jump activated!" <nil>} untyped string
2025/12/19 11:09:25 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:25 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:25 ==> MatchType untyped string ("Double jump activated!"), any
2025/12/19 11:09:25.756007 [INFO] typesutil/gopinfo.go:265: ==> Use: println func fmt.Println(a ...any) (n int, err error)
2025/12/19 11:09:25.756014 [INFO] typesutil/gopinfo.go:215: ==> Type: println func(a ...any) (n int, err error)
2025/12/19 11:09:25.756024 [INFO] typesutil/gopinfo.go:215: ==> Type: &{println 152 [0xc0002a42d0] 0 [] 177 0} (n int, err error)
2025/12/19 11:09:25 Else
2025/12/19 11:09:25 If
2025/12/19 11:09:25 Val bar int
2025/12/19 11:09:25.756039 [INFO] typesutil/gopinfo.go:265: ==> Use: bar var bar int
2025/12/19 11:09:25.756044 [INFO] typesutil/gopinfo.go:215: ==> Type: bar int
2025/12/19 11:09:25 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:25.756053 [INFO] typesutil/gopinfo.go:215: ==> Type: &{196 INT 1 <nil>} untyped int
2025/12/19 11:09:25 BinaryOp ==
2025/12/19 11:09:25.756061 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar 193 == 0xc0002a4360} untyped bool
2025/12/19 11:09:25 Val gotbar bool
2025/12/19 11:09:25.756069 [INFO] typesutil/gopinfo.go:265: ==> Use: gotbar var gotbar bool
2025/12/19 11:09:25.756076 [INFO] typesutil/gopinfo.go:215: ==> Type: gotbar bool
2025/12/19 11:09:25 BinaryOp &&
2025/12/19 11:09:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:25 ==> MatchType untyped bool, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:25 ==> MatchType bool, unboundFuncParam{typ: untyped bool}
2025/12/19 11:09:25.756109 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002a4390 198 && gotbar} bool
2025/12/19 11:09:25.756115 [INFO] typesutil/gopinfo.go:332: ==> Scope: if statement scope 0xc0004cba40 {
}

2025/12/19 11:09:25 Then
2025/12/19 11:09:25 If
2025/12/19 11:09:25 Val boolBar bool
2025/12/19 11:09:25.756128 [INFO] typesutil/gopinfo.go:265: ==> Use: boolBar var boolBar bool
2025/12/19 11:09:25.756138 [INFO] typesutil/gopinfo.go:215: ==> Type: boolBar bool
2025/12/19 11:09:25 UnaryOp ! flags: 0
2025/12/19 11:09:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}) TemplateParamType{name: T}} args: 1 flags: 0
2025/12/19 11:09:25 ==> MatchType bool, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:25.756163 [INFO] typesutil/gopinfo.go:215: ==> Type: &{214 ! boolBar} bool
2025/12/19 11:09:25.756167 [INFO] typesutil/gopinfo.go:332: ==> Scope: if statement scope 0xc0004cbc20 {
}

2025/12/19 11:09:25 Then
2025/12/19 11:09:25 VarRef boolBar bool
2025/12/19 11:09:25.756178 [INFO] typesutil/gopinfo.go:265: ==> Use: boolBar var boolBar bool
2025/12/19 11:09:25.756183 [INFO] typesutil/gopinfo.go:215: ==> Type: boolBar bool
2025/12/19 11:09:25 Val true untyped bool
2025/12/19 11:09:25.756192 [INFO] typesutil/gopinfo.go:265: ==> Use: true const true untyped bool
2025/12/19 11:09:25.756198 [INFO] typesutil/gopinfo.go:215: ==> Type: true untyped bool
2025/12/19 11:09:25 Assign 1 1
2025/12/19 11:09:25 ==> MatchType untyped bool (true), bool
2025/12/19 11:09:25 ForRange [item]
2025/12/19 11:09:25 Val gg *main.Foo
2025/12/19 11:09:25.756219 [INFO] typesutil/gopinfo.go:265: ==> Use: gg var gg *main.Foo
2025/12/19 11:09:25.756224 [INFO] typesutil/gopinfo.go:215: ==> Type: gg *main.Foo
2025/12/19 11:09:25 Member P 2 // *main.Foo
2025/12/19 11:09:25 ResetStmt
2025/12/19 11:09:25 End // ForRange
2025/12/19 11:09:25.756249 [INFO] typesutil/gopinfo.go:332: ==> Scope: if body scope 0xc0004cbd40 {
}

2025/12/19 11:09:25 End // If
2025/12/19 11:09:25.756257 [INFO] typesutil/gopinfo.go:332: ==> Scope: if body scope 0xc0004cbbc0 {
}

2025/12/19 11:09:25 End // If
2025/12/19 11:09:25.756264 [INFO] typesutil/gopinfo.go:332: ==> Scope: else body scope 0xc0004cb9e0 {
}

2025/12/19 11:09:25 End // If
2025/12/19 11:09:25.756285 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0004cb500 {
.  var bar int
.  var boolBar bool
.  var gg *main.Foo
.  var gotbar bool
}

2025/12/19 11:09:25 End // Func
2025/12/19 11:09:25.756299 [INFO] typesutil/check.go:179: typesutil.Check err: main.xgo:15:21: gg.P undefined (type *main.Foo has no field or method P)
2025/12/19 11:09:25.756999 [ERROR] log/logext.go:606:
goroutine 177 [running]:
github.com/qiniu/x/log.(*Logger).SingleStack(0xc423e0, {0x0?, 0xc000113ec0?, 0xc0002b1cd8?})
	/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:385 +0x7b
github.com/qiniu/x/log.SingleStack(...)
	/go/pkg/mod/github.com/qiniu/x@v1.15.1/log/logext.go:606
github.com/goplus/xgo/x/typesutil.(*Checker).Files(0xc0002b1e28, {0x0, 0x0, 0x4?}, {0xc00081a040, 0x1, 0xc000394048?})
	/app/x/typesutil/check.go:180 +0xd39
github.com/goplus/xgo/x/typesutil_test.checkInfo(0xc000398000, {0xc00081a040, 0x1, 0x1}, {0x0, 0x0, 0x0}, 0xc000716060)
	/app/x/typesutil/check_test.go:104 +0x42b
github.com/goplus/xgo/x/typesutil_test.checkFilesWithErrorHandler(0xc000398000, {0x8dc7e0?, 0x603?}, {0x84f1a0?, 0x9a9e10?}, {0x0?, 0xc000586f60?}, {0x84f1a0?, 0x9a9ae0?}, {0x0, ...}, ...)
	/app/x/typesutil/check_test.go:69 +0xbc
github.com/goplus/xgo/x/typesutil_test.TestCheckError3(0xc00012c000)
	/app/x/typesutil/check_test.go:335 +0xe5
testing.tRunner(0xc00012c000, 0x92d0f8)
	/usr/local/go/src/testing/testing.go:1689 +0xfb
created by testing.(*T).Run in goroutine 1
	/usr/local/go/src/testing/testing.go:1742 +0x390

--- PASS: TestCheckError3 (0.01s)
=== RUN   TestExprString
--- PASS: TestExprString (0.00s)
=== RUN   TestVarTypes
2025/12/19 11:09:25.757938 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:09:26 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:26 ==> NewOverloadFunc NewRange
2025/12/19 11:09:26 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:26 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:26 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:26 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:26 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:26 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:26 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:26 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:26 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:26 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:26 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:26 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:26 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:26 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:26.788074 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0002f9920 {
}

2025/12/19 11:09:26 ==> Preload type T
2025/12/19 11:09:26 ==> Preload var [v]
2025/12/19 11:09:26 ==> Preload var [v1]
2025/12/19 11:09:26 ==> Preload var [v2]
2025/12/19 11:09:26 ==> Preload var [v3]
2025/12/19 11:09:26 ==> Preload var [v4]
2025/12/19 11:09:26 ==> Preload var [v5]
2025/12/19 11:09:26 ==> Preload var [v6]
2025/12/19 11:09:26 ==> Preload var [v7]
2025/12/19 11:09:26 ==> Preload var [m]
2025/12/19 11:09:26 ==> Preload func init
2025/12/19 11:09:26 ==> Load > NewType T
2025/12/19 11:09:26 NewType T
2025/12/19 11:09:26 ==> Load > InitType T
2025/12/19 11:09:26.788249 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:26.788280 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:26.788293 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:26.788310 [INFO] typesutil/gopinfo.go:251: ==> Def: x field x int
2025/12/19 11:09:26.788323 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:26.788335 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:26.788346 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:26.788359 [INFO] typesutil/gopinfo.go:251: ==> Def: y field y int
2025/12/19 11:09:26.788385 [INFO] typesutil/gopinfo.go:215: ==> Type: &{21 0xc0004ee5d0 false} struct{x int; y int}
2025/12/19 11:09:26 InitType T struct{x int; y int}
2025/12/19 11:09:26.788416 [INFO] typesutil/gopinfo.go:251: ==> Def: T type T struct{x int; y int}
2025/12/19 11:09:26.788433 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:26.788445 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:26.788456 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:26.788474 [INFO] typesutil/gopinfo.go:215: ==> Type: &{52 int} *int
2025/12/19 11:09:26 ==> Load var *int [v]
2025/12/19 11:09:26 NewVarDefs
2025/12/19 11:09:26 NewVar [v]
2025/12/19 11:09:26 Val nil untyped nil
2025/12/19 11:09:26.788529 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/12/19 11:09:26.788547 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/12/19 11:09:26 EndInit 1
2025/12/19 11:09:26 ==> MatchType untyped nil, *int
2025/12/19 11:09:26.788583 [INFO] typesutil/gopinfo.go:251: ==> Def: v var v *int
2025/12/19 11:09:26.788601 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:26.788613 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:26.788623 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:26.788643 [INFO] typesutil/gopinfo.go:215: ==> Type: &{70 <nil> int} []int
2025/12/19 11:09:26 ==> Load var []int [v1]
2025/12/19 11:09:26 NewVarDefs
2025/12/19 11:09:26 NewVar [v1]
2025/12/19 11:09:26.788682 [INFO] typesutil/gopinfo.go:251: ==> Def: v1 var v1 []int
2025/12/19 11:09:26.788694 [INFO] typesutil/gopinfo.go:265: ==> Use: int8 type int8
2025/12/19 11:09:26.788710 [INFO] typesutil/gopinfo.go:215: ==> Type: int8 int8
2025/12/19 11:09:26.788722 [INFO] typesutil/gopinfo.go:215: ==> Type: int8 int8
2025/12/19 11:09:26.788734 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/12/19 11:09:26.788744 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:26.788755 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:26.788779 [INFO] typesutil/gopinfo.go:215: ==> Type: &{83 int8 string} map[int8]string
2025/12/19 11:09:26 ==> Load var map[int8]string [v2]
2025/12/19 11:09:26 NewVarDefs
2025/12/19 11:09:26 NewVar [v2]
2025/12/19 11:09:26.788821 [INFO] typesutil/gopinfo.go:251: ==> Def: v2 var v2 map[int8]string
2025/12/19 11:09:26.788844 [INFO] typesutil/gopinfo.go:215: ==> Type: &{106 0xc0004ee660 false} struct{}
2025/12/19 11:09:26 ==> Load var struct{} [v3]
2025/12/19 11:09:26 NewVarDefs
2025/12/19 11:09:26 NewVar [v3]
2025/12/19 11:09:26.788881 [INFO] typesutil/gopinfo.go:251: ==> Def: v3 var v3 struct{}
2025/12/19 11:09:26 ==> LookupParent T => type T struct{x int; y int}
2025/12/19 11:09:26.788906 [INFO] typesutil/gopinfo.go:265: ==> Use: T type T struct{x int; y int}
2025/12/19 11:09:26.788918 [INFO] typesutil/gopinfo.go:215: ==> Type: T T
2025/12/19 11:09:26.788937 [INFO] typesutil/gopinfo.go:215: ==> Type: T T
2025/12/19 11:09:26.788957 [INFO] typesutil/gopinfo.go:215: ==> Type: &{122 T} *T
2025/12/19 11:09:26 ==> Load var *T [v4]
2025/12/19 11:09:26 NewVarDefs
2025/12/19 11:09:26 NewVar [v4]
2025/12/19 11:09:26 ==> LookupParent T => type T struct{x int; y int}
2025/12/19 11:09:26.789012 [INFO] typesutil/gopinfo.go:265: ==> Use: T type T struct{x int; y int}
2025/12/19 11:09:26.789025 [INFO] typesutil/gopinfo.go:215: ==> Type: T T
2025/12/19 11:09:26.789036 [INFO] typesutil/gopinfo.go:215: ==> Type: T T
2025/12/19 11:09:26 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:26.789074 [INFO] typesutil/gopinfo.go:215: ==> Type: &{130 INT 100 <nil>} untyped int
2025/12/19 11:09:26 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:26.789137 [INFO] typesutil/gopinfo.go:215: ==> Type: &{134 INT 200 <nil>} untyped int
2025/12/19 11:09:26 StructLit T 2 false
2025/12/19 11:09:26.789166 [INFO] typesutil/gopinfo.go:215: ==> Type: T T
2025/12/19 11:09:26.789191 [INFO] typesutil/gopinfo.go:215: ==> Type: &{T 129 [0xc0004ee690 0xc0004ee6c0] 137 false} T
2025/12/19 11:09:26 UnaryOp & flags: 0
2025/12/19 11:09:26 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:26.789233 [INFO] typesutil/gopinfo.go:215: ==> Type: &{127 & 0xc0004d9940} *T
2025/12/19 11:09:26 EndInit 1
2025/12/19 11:09:26 ==> MatchType *T, *T
2025/12/19 11:09:26 ==> EnsureLoaded T
2025/12/19 11:09:26 ==> EnsureLoaded T
2025/12/19 11:09:26.789280 [INFO] typesutil/gopinfo.go:251: ==> Def: v4 var v4 *T
2025/12/19 11:09:26 ==> Load var <nil> [v5]
2025/12/19 11:09:26 NewVarDefs
2025/12/19 11:09:26 NewVar [v5]
2025/12/19 11:09:26.789312 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:26.789324 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:26.789334 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:26 Val &{0 INT 6} *ast.BasicLit
2025/12/19 11:09:26.789360 [INFO] typesutil/gopinfo.go:215: ==> Type: &{149 INT 6 <nil>} untyped int
2025/12/19 11:09:26.789380 [INFO] typesutil/gopinfo.go:215: ==> Type: &{148 0xc0004ee6f0 int} [6]int
2025/12/19 11:09:26 ArrayLit [6]int 0 false
2025/12/19 11:09:26.789412 [INFO] typesutil/gopinfo.go:215: ==> Type: &{148 0xc0004ee6f0 int} [6]int
2025/12/19 11:09:26.789428 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0004ee750 154 [] 155 false} [6]int
2025/12/19 11:09:26 EndInit 1
2025/12/19 11:09:26.789453 [INFO] typesutil/gopinfo.go:251: ==> Def: v5 var v5 [6]int
2025/12/19 11:09:26 ==> Load var <nil> [v6]
2025/12/19 11:09:26 NewVarDefs
2025/12/19 11:09:26 NewVar [v6]
2025/12/19 11:09:26 Val v5 [6]int
2025/12/19 11:09:26.789502 [INFO] typesutil/gopinfo.go:265: ==> Use: v5 var v5 [6]int
2025/12/19 11:09:26.789516 [INFO] typesutil/gopinfo.go:215: ==> Type: v5 [6]int
2025/12/19 11:09:26 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:26.789539 [INFO] typesutil/gopinfo.go:215: ==> Type: &{169 INT 0 <nil>} untyped int
2025/12/19 11:09:26 Index 1 false
2025/12/19 11:09:26.789565 [INFO] typesutil/gopinfo.go:215: ==> Type: &{v5 168 0xc0004ee780 170} int
2025/12/19 11:09:26 EndInit 1
2025/12/19 11:09:26.789587 [INFO] typesutil/gopinfo.go:251: ==> Def: v6 var v6 int
2025/12/19 11:09:26 ==> Load var <nil> [v7]
2025/12/19 11:09:26 NewVarDefs
2025/12/19 11:09:26 NewVar [v7]
2025/12/19 11:09:26.789624 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:26.789641 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:26.789657 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:26 Val &{0 INT 6} *ast.BasicLit
2025/12/19 11:09:26.789683 [INFO] typesutil/gopinfo.go:215: ==> Type: &{182 INT 6 <nil>} untyped int
2025/12/19 11:09:26.789698 [INFO] typesutil/gopinfo.go:215: ==> Type: &{181 0xc0004ee7e0 int} [6]int
2025/12/19 11:09:26 ArrayLit [6]int 0 false
2025/12/19 11:09:26.789719 [INFO] typesutil/gopinfo.go:215: ==> Type: &{181 0xc0004ee7e0 int} [6]int
2025/12/19 11:09:26.789733 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0004ee840 187 [] 188 false} [6]int
2025/12/19 11:09:26 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:26.789764 [INFO] typesutil/gopinfo.go:215: ==> Type: &{190 INT 0 <nil>} untyped int
2025/12/19 11:09:26 Index 1 false
2025/12/19 11:09:26.789790 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0004d9a80 189 0xc0004ee870 191} int
2025/12/19 11:09:26 EndInit 1
2025/12/19 11:09:26.789808 [INFO] typesutil/gopinfo.go:251: ==> Def: v7 var v7 int
2025/12/19 11:09:26.789826 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:26.789836 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:26.789849 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:26.789860 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/12/19 11:09:26.789879 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:26.789894 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:26.789910 [INFO] typesutil/gopinfo.go:215: ==> Type: &{199 int string} map[int]string
2025/12/19 11:09:26 ==> Load var map[int]string [m]
2025/12/19 11:09:26 NewVarDefs
2025/12/19 11:09:26 NewVar [m]
2025/12/19 11:09:26.789951 [INFO] typesutil/gopinfo.go:251: ==> Def: m var m map[int]string
2025/12/19 11:09:26 ==> Load func init
2025/12/19 11:09:26.789990 [INFO] typesutil/gopinfo.go:251: ==> Def: init func init()
2025/12/19 11:09:26 NewFunc init func()
2025/12/19 11:09:26 Val v5 [6]int
2025/12/19 11:09:26.790040 [INFO] typesutil/gopinfo.go:265: ==> Use: v5 var v5 [6]int
2025/12/19 11:09:26.790052 [INFO] typesutil/gopinfo.go:215: ==> Type: v5 [6]int
2025/12/19 11:09:26 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:26.790077 [INFO] typesutil/gopinfo.go:215: ==> Type: &{232 INT 0 <nil>} untyped int
2025/12/19 11:09:26 IndexRef 1
2025/12/19 11:09:26.790104 [INFO] typesutil/gopinfo.go:215: ==> Type: &{v5 231 0xc0004ee990 233} int
2025/12/19 11:09:26 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:26.790131 [INFO] typesutil/gopinfo.go:215: ==> Type: &{237 INT 100 <nil>} untyped int
2025/12/19 11:09:26 Assign 1 1
2025/12/19 11:09:26 ==> MatchType untyped int (100), int
2025/12/19 11:09:26 VarRef _
2025/12/19 11:09:26 Val v5 [6]int
2025/12/19 11:09:26.790188 [INFO] typesutil/gopinfo.go:265: ==> Use: v5 var v5 [6]int
2025/12/19 11:09:26.790199 [INFO] typesutil/gopinfo.go:215: ==> Type: v5 [6]int
2025/12/19 11:09:26 None
2025/12/19 11:09:26 None
2025/12/19 11:09:26 Slice false
2025/12/19 11:09:26.790233 [INFO] typesutil/gopinfo.go:215: ==> Type: &{v5 248 <nil> <nil> <nil> false 250} []int
2025/12/19 11:09:26 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:26.790261 [INFO] typesutil/gopinfo.go:215: ==> Type: &{252 INT 0 <nil>} untyped int
2025/12/19 11:09:26 Index 1 false
2025/12/19 11:09:26.790281 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0004ebe60 251 0xc0004eea20 253} int
2025/12/19 11:09:26 Assign 1 1
2025/12/19 11:09:26 Val m map[int]string
2025/12/19 11:09:26.790313 [INFO] typesutil/gopinfo.go:265: ==> Use: m var m map[int]string
2025/12/19 11:09:26.790324 [INFO] typesutil/gopinfo.go:215: ==> Type: m map[int]string
2025/12/19 11:09:26 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:26.790346 [INFO] typesutil/gopinfo.go:215: ==> Type: &{258 INT 0 <nil>} untyped int
2025/12/19 11:09:26 IndexRef 1
2025/12/19 11:09:26.790373 [INFO] typesutil/gopinfo.go:215: ==> Type: &{m 257 0xc0004eea80 259} string
2025/12/19 11:09:26 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:26.790400 [INFO] typesutil/gopinfo.go:215: ==> Type: &{263 STRING "hello" <nil>} untyped string
2025/12/19 11:09:26 Assign 1 1
2025/12/19 11:09:26 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:26 VarRef _
2025/12/19 11:09:26 Val m map[int]string
2025/12/19 11:09:26.790448 [INFO] typesutil/gopinfo.go:265: ==> Use: m var m map[int]string
2025/12/19 11:09:26.790459 [INFO] typesutil/gopinfo.go:215: ==> Type: m map[int]string
2025/12/19 11:09:26 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:26.790480 [INFO] typesutil/gopinfo.go:215: ==> Type: &{278 INT 0 <nil>} untyped int
2025/12/19 11:09:26 Index 1 false
2025/12/19 11:09:26.790504 [INFO] typesutil/gopinfo.go:215: ==> Type: &{m 277 0xc0004eeb10 279} string
2025/12/19 11:09:26 Assign 1 1
2025/12/19 11:09:26 VarRef _
2025/12/19 11:09:26.790531 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:26.790542 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:26.790552 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:26.790563 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/12/19 11:09:26.790573 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:26.790583 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:26.790605 [INFO] typesutil/gopinfo.go:215: ==> Type: &{286 int string} map[int]string
2025/12/19 11:09:26 MapLit map[int]string 0
2025/12/19 11:09:26.790640 [INFO] typesutil/gopinfo.go:215: ==> Type: &{286 int string} map[int]string
2025/12/19 11:09:26.790665 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0004eeb70 300 [] 301 false} map[int]string
2025/12/19 11:09:26 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:26.790696 [INFO] typesutil/gopinfo.go:215: ==> Type: &{303 INT 0 <nil>} untyped int
2025/12/19 11:09:26 Index 1 false
2025/12/19 11:09:26.790718 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0004d9c80 302 0xc0004eeba0 304} string
2025/12/19 11:09:26 Assign 1 1
2025/12/19 11:09:26 VarRef _
2025/12/19 11:09:26 Val v3 struct{}
2025/12/19 11:09:26.790754 [INFO] typesutil/gopinfo.go:265: ==> Use: v3 var v3 struct{}
2025/12/19 11:09:26.790766 [INFO] typesutil/gopinfo.go:215: ==> Type: v3 struct{}
2025/12/19 11:09:26 UnaryOp & flags: 0
2025/12/19 11:09:26 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:26.790797 [INFO] typesutil/gopinfo.go:215: ==> Type: &{311 & v3} *struct{}
2025/12/19 11:09:26 Assign 1 1
2025/12/19 11:09:26 VarRef _
2025/12/19 11:09:26 Val v3 struct{}
2025/12/19 11:09:26.790827 [INFO] typesutil/gopinfo.go:265: ==> Use: v3 var v3 struct{}
2025/12/19 11:09:26.790837 [INFO] typesutil/gopinfo.go:215: ==> Type: v3 struct{}
2025/12/19 11:09:26 UnaryOp & flags: 0
2025/12/19 11:09:26 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:26.790862 [INFO] typesutil/gopinfo.go:215: ==> Type: &{322 & v3} *struct{}
2025/12/19 11:09:26.790888 [INFO] typesutil/gopinfo.go:215: ==> Type: &{321 0xc0000fca60 325} *struct{}
2025/12/19 11:09:26 Star
2025/12/19 11:09:26.790910 [INFO] typesutil/gopinfo.go:215: ==> Type: &{320 0xc0000fca80} struct{}
2025/12/19 11:09:26 Assign 1 1
2025/12/19 11:09:26 DefineVarStart [a]
2025/12/19 11:09:26.790936 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:26.790946 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:26.790956 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:26.790971 [INFO] typesutil/gopinfo.go:215: ==> Type: &{333 <nil> int} []int
2025/12/19 11:09:26 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:26.791001 [INFO] typesutil/gopinfo.go:215: ==> Type: &{339 INT 1 <nil>} untyped int
2025/12/19 11:09:26 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:26.791022 [INFO] typesutil/gopinfo.go:215: ==> Type: &{341 INT 2 <nil>} untyped int
2025/12/19 11:09:26 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:26.791042 [INFO] typesutil/gopinfo.go:215: ==> Type: &{343 INT 3 <nil>} untyped int
2025/12/19 11:09:26 Val &{0 INT 4} *ast.BasicLit
2025/12/19 11:09:26.791062 [INFO] typesutil/gopinfo.go:215: ==> Type: &{345 INT 4 <nil>} untyped int
2025/12/19 11:09:26 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:26.791082 [INFO] typesutil/gopinfo.go:215: ==> Type: &{347 INT 5 <nil>} untyped int
2025/12/19 11:09:26 SliceLit []int 5 false
2025/12/19 11:09:26.791107 [INFO] typesutil/gopinfo.go:215: ==> Type: &{333 <nil> int} []int
2025/12/19 11:09:26.791126 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0004eec30 338 [0xc0004eec60 0xc0004eec90 0xc0004eecc0 0xc0004eecf0 0xc0004eed20] 348 false} []int
2025/12/19 11:09:26 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:26.791155 [INFO] typesutil/gopinfo.go:215: ==> Type: &{350 INT 0 <nil>} untyped int
2025/12/19 11:09:26 Index 1 false
2025/12/19 11:09:26.791179 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0004d9dc0 349 0xc0004eed50 351} int
2025/12/19 11:09:26 EndInit 1
2025/12/19 11:09:26.791205 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a int
2025/12/19 11:09:26 VarRef _
2025/12/19 11:09:26 Val a int
2025/12/19 11:09:26.791235 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a int
2025/12/19 11:09:26.791246 [INFO] typesutil/gopinfo.go:215: ==> Type: a int
2025/12/19 11:09:26 Assign 1 1
2025/12/19 11:09:26.791274 [INFO] typesutil/gopinfo.go:332: ==> Scope: func init scope 0xc0002f9e60 {
.  var a int
}

2025/12/19 11:09:26 End // Func
    info_test.go:226: ====== check types pass (count: 73) ======
        000:  2: 8 | struct {
        	x int
        	y int
        } *ast.StructType                | type    : struct{x int; y int} | type
        001:  3: 4 | int                 *ast.Ident                     | type    : int | type
        002:  4: 4 | int                 *ast.Ident                     | type    : int | type
        003:  6: 7 | *int                *ast.StarExpr                  | type    : *int | type
        004:  6: 8 | int                 *ast.Ident                     | type    : int | type
        005:  6:14 | nil                 *ast.Ident                     | nil     : untyped nil | value
        006:  7: 8 | []int               *ast.ArrayType                 | type    : []int | type
        007:  7:10 | int                 *ast.Ident                     | type    : int | type
        008:  8: 8 | map[int8]string     *ast.MapType                   | type    : map[int8]string | type
        009:  8:12 | int8                *ast.Ident                     | type    : int8 | type
        010:  8:17 | string              *ast.Ident                     | type    : string | type
        011:  9: 8 | struct{}            *ast.StructType                | type    : struct{} | type
        012: 10: 8 | *T                  *ast.StarExpr                  | type    : *T | type
        013: 10: 9 | T                   *ast.Ident                     | type    : T | type
        014: 10:13 | &T{100, 200}        *ast.UnaryExpr                 | value   : *T | value
        015: 10:14 | T                   *ast.Ident                     | type    : T | type
        016: 10:14 | T{100, 200}         *ast.CompositeLit              | value   : T | value
        017: 10:16 | 100                 *ast.BasicLit                  | value   : INT = 100 | constant
        018: 10:20 | 200                 *ast.BasicLit                  | value   : INT = 200 | constant
        019: 11:10 | [6]int              *ast.ArrayType                 | type    : [6]int | type
        020: 11:10 | [6]int{}            *ast.CompositeLit              | value   : [6]int | value
        021: 11:11 | 6                   *ast.BasicLit                  | value   : INT = 6 | constant
        022: 11:13 | int                 *ast.Ident                     | type    : int | type
        023: 12:10 | v5                  *ast.Ident                     | var     : [6]int | variable
        024: 12:10 | v5[0]               *ast.IndexExpr                 | var     : int | variable
        025: 12:13 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        026: 13:10 | [6]int              *ast.ArrayType                 | type    : [6]int | type
        027: 13:10 | [6]int{}            *ast.CompositeLit              | value   : [6]int | value
        028: 13:10 | [6]int{}[0]         *ast.IndexExpr                 | value   : int | value
        029: 13:11 | 6                   *ast.BasicLit                  | value   : INT = 6 | constant
        030: 13:13 | int                 *ast.Ident                     | type    : int | type
        031: 13:19 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        032: 14: 7 | map[int]string      *ast.MapType                   | type    : map[int]string | type
        033: 14:11 | int                 *ast.Ident                     | type    : int | type
        034: 14:15 | string              *ast.Ident                     | type    : string | type
        035: 16: 2 | v5                  *ast.Ident                     | var     : [6]int | variable
        036: 16: 2 | v5[0]               *ast.IndexExpr                 | var     : int | variable
        037: 16: 5 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        038: 16:10 | 100                 *ast.BasicLit                  | value   : INT = 100 | constant
        039: 17: 6 | v5                  *ast.Ident                     | var     : [6]int | variable
        040: 17: 6 | v5[:]               *ast.SliceExpr                 | value   : []int | value
        041: 17: 6 | v5[:][0]            *ast.IndexExpr                 | var     : int | variable
        042: 17:12 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        043: 18: 2 | m                   *ast.Ident                     | var     : map[int]string | variable
        044: 18: 2 | m[0]                *ast.IndexExpr                 | mapindex : string | map index expression
        045: 18: 4 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        046: 18: 9 | "hello"             *ast.BasicLit                  | value   : STRING = "hello" | constant
        047: 19: 6 | m                   *ast.Ident                     | var     : map[int]string | variable
        048: 19: 6 | m[0]                *ast.IndexExpr                 | mapindex : string | map index expression
        049: 19: 8 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        050: 20: 6 | map[int]string      *ast.MapType                   | type    : map[int]string | type
        051: 20: 6 | map[int]string{}    *ast.CompositeLit              | value   : map[int]string | value
        052: 20: 6 | map[int]string{}[0] *ast.IndexExpr                 | mapindex : string | map index expression
        053: 20:10 | int                 *ast.Ident                     | type    : int | type
        054: 20:14 | string              *ast.Ident                     | type    : string | type
        055: 20:23 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        056: 21: 6 | &v3                 *ast.UnaryExpr                 | value   : *struct{} | value
        057: 21: 7 | v3                  *ast.Ident                     | var     : struct{} | variable
        058: 22: 6 | *(&v3)              *ast.StarExpr                  | var     : struct{} | variable
        059: 22: 7 | (&v3)               *ast.ParenExpr                 | value   : *struct{} | value
        060: 22: 8 | &v3                 *ast.UnaryExpr                 | value   : *struct{} | value
        061: 22: 9 | v3                  *ast.Ident                     | var     : struct{} | variable
        062: 23: 7 | []int               *ast.ArrayType                 | type    : []int | type
        063: 23: 7 | []int{1, 2, 3, 4, 5} *ast.CompositeLit              | value   : []int | value
        064: 23: 7 | []int{1, 2, 3, 4, 5}[0] *ast.IndexExpr                 | var     : int | variable
        065: 23: 9 | int                 *ast.Ident                     | type    : int | type
        066: 23:13 | 1                   *ast.BasicLit                  | value   : INT = 1 | constant
        067: 23:15 | 2                   *ast.BasicLit                  | value   : INT = 2 | constant
        068: 23:17 | 3                   *ast.BasicLit                  | value   : INT = 3 | constant
        069: 23:19 | 4                   *ast.BasicLit                  | value   : INT = 4 | constant
        070: 23:21 | 5                   *ast.BasicLit                  | value   : INT = 5 | constant
        071: 23:24 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        072: 24: 6 | a                   *ast.Ident                     | var     : int | variable
    info_test.go:226: ====== check defs pass (count: 14) ======
        000:  2: 6 | T                   | type T struct{x int; y int}
        001:  3: 2 | x                   | field x int
        002:  4: 2 | y                   | field y int
        003:  6: 5 | v                   | var v *int
        004:  7: 5 | v1                  | var v1 []int
        005:  8: 5 | v2                  | var v2 map[int8]string
        006:  9: 5 | v3                  | var v3 struct{}
        007: 10: 5 | v4                  | var v4 *T
        008: 11: 5 | v5                  | var v5 [6]int
        009: 12: 5 | v6                  | var v6 int
        010: 13: 5 | v7                  | var v7 int
        011: 14: 5 | m                   | var m map[int]string
        012: 15: 6 | init                | func init()
        013: 23: 2 | a                   | var a int
    info_test.go:226: ====== check uses pass (count: 24) ======
        000:  3: 4 | int                 | type int
        001:  4: 4 | int                 | type int
        002:  6: 8 | int                 | type int
        003:  6:14 | nil                 | nil
        004:  7:10 | int                 | type int
        005:  8:12 | int8                | type int8
        006:  8:17 | string              | type string
        007: 10: 9 | T                   | type T struct{x int; y int}
        008: 10:14 | T                   | type T struct{x int; y int}
        009: 11:13 | int                 | type int
        010: 12:10 | v5                  | var v5 [6]int
        011: 13:13 | int                 | type int
        012: 14:11 | int                 | type int
        013: 14:15 | string              | type string
        014: 16: 2 | v5                  | var v5 [6]int
        015: 17: 6 | v5                  | var v5 [6]int
        016: 18: 2 | m                   | var m map[int]string
        017: 19: 6 | m                   | var m map[int]string
        018: 20:10 | int                 | type int
        019: 20:14 | string              | type string
        020: 21: 7 | v3                  | var v3 struct{}
        021: 22: 9 | v3                  | var v3 struct{}
        022: 23: 9 | int                 | type int
        023: 24: 6 | a                   | var a int
--- PASS: TestVarTypes (1.04s)
=== RUN   TestStruct
2025/12/19 11:09:26.795468 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:09:27 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:27 ==> NewOverloadFunc NewRange
2025/12/19 11:09:27 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:27 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:27 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:27 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:27 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:27 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:27 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:27 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:27 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:27 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:27 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:27 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:27 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:27 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:27.947331 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0001a2780 {
}

2025/12/19 11:09:27.947393 [INFO] typesutil/gopinfo.go:292: ==> Implicit: package fmt
2025/12/19 11:09:27 ==> Preload type Person
2025/12/19 11:09:27 ==> Preload func test
2025/12/19 11:09:27 ==> Load > NewType Person
2025/12/19 11:09:27 NewType Person
2025/12/19 11:09:27 ==> Load > InitType Person
2025/12/19 11:09:27.947489 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/12/19 11:09:27.947513 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:27.947529 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:27.947544 [INFO] typesutil/gopinfo.go:251: ==> Def: name field name string
2025/12/19 11:09:27.947559 [INFO] typesutil/gopinfo.go:265: ==> Use: int8 type int8
2025/12/19 11:09:27.947572 [INFO] typesutil/gopinfo.go:215: ==> Type: int8 int8
2025/12/19 11:09:27.947585 [INFO] typesutil/gopinfo.go:215: ==> Type: int8 int8
2025/12/19 11:09:27.947599 [INFO] typesutil/gopinfo.go:251: ==> Def: age field age int8
2025/12/19 11:09:27.947631 [INFO] typesutil/gopinfo.go:215: ==> Type: &{40 0xc0002a58c0 false} struct{name string; age int8}
2025/12/19 11:09:27 InitType Person struct{name string; age int8}
2025/12/19 11:09:27.947670 [INFO] typesutil/gopinfo.go:251: ==> Def: Person type Person struct{name string; age int8}
2025/12/19 11:09:27 ==> Load func test
2025/12/19 11:09:27.947704 [INFO] typesutil/gopinfo.go:251: ==> Def: test func test()
2025/12/19 11:09:27 NewFunc test func()
2025/12/19 11:09:27 DefineVarStart [p]
2025/12/19 11:09:27 ==> LookupParent Person => type Person struct{name string; age int8}
2025/12/19 11:09:27.947763 [INFO] typesutil/gopinfo.go:265: ==> Use: Person type Person struct{name string; age int8}
2025/12/19 11:09:27.947777 [INFO] typesutil/gopinfo.go:215: ==> Type: Person Person
2025/12/19 11:09:27.947791 [INFO] typesutil/gopinfo.go:215: ==> Type: Person Person
2025/12/19 11:09:27 Val 0 int
2025/12/19 11:09:27.947817 [INFO] typesutil/gopinfo.go:265: ==> Use: name field name string
2025/12/19 11:09:27 Val &{0 STRING "jack"} *ast.BasicLit
2025/12/19 11:09:27.947853 [INFO] typesutil/gopinfo.go:215: ==> Type: &{112 STRING "jack" <nil>} untyped string
2025/12/19 11:09:27 StructLit Person 2 true
2025/12/19 11:09:27.947885 [INFO] typesutil/gopinfo.go:215: ==> Type: Person Person
2025/12/19 11:09:27.947913 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Person 102 [0xc0002a59b0] 121 false} Person
2025/12/19 11:09:27 EndInit 1
2025/12/19 11:09:27.947936 [INFO] typesutil/gopinfo.go:251: ==> Def: p var p Person
2025/12/19 11:09:27 VarRef _
2025/12/19 11:09:27 Val p Person
2025/12/19 11:09:27.947967 [INFO] typesutil/gopinfo.go:265: ==> Use: p var p Person
2025/12/19 11:09:27.947980 [INFO] typesutil/gopinfo.go:215: ==> Type: p Person
2025/12/19 11:09:27 Member name 2 // Person
2025/12/19 11:09:27.948008 [INFO] typesutil/gopinfo.go:265: ==> Use: name field name string
2025/12/19 11:09:27.948025 [INFO] typesutil/gopinfo.go:215: ==> Type: &{p name} string
2025/12/19 11:09:27 Assign 1 1
2025/12/19 11:09:27 Val p Person
2025/12/19 11:09:27.948054 [INFO] typesutil/gopinfo.go:265: ==> Use: p var p Person
2025/12/19 11:09:27.948086 [INFO] typesutil/gopinfo.go:215: ==> Type: p Person
2025/12/19 11:09:27 Member name -1 // Person
2025/12/19 11:09:27.948116 [INFO] typesutil/gopinfo.go:265: ==> Use: name field name string
2025/12/19 11:09:27.948130 [INFO] typesutil/gopinfo.go:215: ==> Type: &{p name} string
2025/12/19 11:09:27 Val &{0 STRING "name"} *ast.BasicLit
2025/12/19 11:09:27.948160 [INFO] typesutil/gopinfo.go:215: ==> Type: &{145 STRING "name" <nil>} untyped string
2025/12/19 11:09:27 Assign 1 1
2025/12/19 11:09:27 ==> MatchType untyped string ("name"), string
2025/12/19 11:09:27.948199 [INFO] typesutil/gopinfo.go:265: ==> Use: fmt package fmt
2025/12/19 11:09:27.948222 [INFO] typesutil/gopinfo.go:265: ==> Use: Println func fmt.Println(a ...any) (n int, err error)
2025/12/19 11:09:27 Val Println func(a ...any) (n int, err error)
2025/12/19 11:09:27 Val p Person
2025/12/19 11:09:27.948266 [INFO] typesutil/gopinfo.go:265: ==> Use: p var p Person
2025/12/19 11:09:27.948281 [INFO] typesutil/gopinfo.go:215: ==> Type: p Person
2025/12/19 11:09:27 Call 1 0 // func(a ...any) (n int, err error)
2025/12/19 11:09:27 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:27 ==> MatchType Person, any
2025/12/19 11:09:27 ==> EnsureLoaded Person
2025/12/19 11:09:27.948348 [INFO] typesutil/gopinfo.go:215: ==> Type: &{fmt Println} func(a ...any) (n int, err error)
2025/12/19 11:09:27.948375 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002fa0a8 164 [p] 0 [] 166 0} (n int, err error)
2025/12/19 11:09:27.948404 [INFO] typesutil/gopinfo.go:332: ==> Scope: func test scope 0xc0001a29c0 {
.  var p Person
}

2025/12/19 11:09:27 End // Func
    info_test.go:226: ====== check types pass (count: 14) ======
        000:  4:13 | struct {
        	name string
        	age  int8
        } *ast.StructType                | type    : struct{name string; age int8} | type
        001:  5: 7 | string              *ast.Ident                     | type    : string | type
        002:  6: 7 | int8                *ast.Ident                     | type    : int8 | type
        003: 10: 7 | Person              *ast.Ident                     | type    : Person | type
        004: 10: 7 | Person{
        	name: "jack",
        } *ast.CompositeLit              | value   : Person | value
        005: 11: 9 | "jack"              *ast.BasicLit                  | value   : STRING = "jack" | constant
        006: 13: 6 | p                   *ast.Ident                     | var     : Person | variable
        007: 13: 6 | p.name              *ast.SelectorExpr              | var     : string | variable
        008: 14: 2 | p                   *ast.Ident                     | var     : Person | variable
        009: 14: 2 | p.name              *ast.SelectorExpr              | var     : string | variable
        010: 14:11 | "name"              *ast.BasicLit                  | value   : STRING = "name" | constant
        011: 15: 2 | fmt.Println         *ast.SelectorExpr              | value   : func(a ...any) (n int, err error) | value
        012: 15: 2 | fmt.Println(p)      *ast.CallExpr                  | value   : (n int, err error) | value
        013: 15:14 | p                   *ast.Ident                     | var     : Person | variable
    info_test.go:226: ====== check defs pass (count: 5) ======
        000:  4: 6 | Person              | type Person struct{name string; age int8}
        001:  5: 2 | name                | field name string
        002:  6: 2 | age                 | field age int8
        003:  9: 6 | test                | func test()
        004: 10: 2 | p                   | var p Person
    info_test.go:226: ====== check uses pass (count: 11) ======
        000:  5: 7 | string              | type string
        001:  6: 7 | int8                | type int8
        002: 10: 7 | Person              | type Person struct{name string; age int8}
        003: 11: 3 | name                | field name string
        004: 13: 6 | p                   | var p Person
        005: 13: 8 | name                | field name string
        006: 14: 2 | p                   | var p Person
        007: 14: 4 | name                | field name string
        008: 15: 2 | fmt                 | package fmt
        009: 15: 6 | Println             | func fmt.Println(a ...any) (n int, err error)
        010: 15:14 | p                   | var p Person
--- PASS: TestStruct (1.16s)
=== RUN   TestTypeAssert
2025/12/19 11:09:27.953047 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:09:28 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:28 ==> NewOverloadFunc NewRange
2025/12/19 11:09:28 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:28 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:28 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:28 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:28 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:28 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:28 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:28 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:28 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:28 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:28 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:28 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:28 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:28 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:28 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:28 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:28 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:28 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:28 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:28 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:28 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:28 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:28 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:28 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:28 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:28 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:28 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:28 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:28 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:28 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:28 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:28 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:28 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:28 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:28 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:28 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:28 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:28 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:28 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:28 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:28 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:28 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:29.088332 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc000387080 {
}

2025/12/19 11:09:29 ==> Preload func test
2025/12/19 11:09:29 ==> Load func test
2025/12/19 11:09:29.088431 [INFO] typesutil/gopinfo.go:251: ==> Def: test func test()
2025/12/19 11:09:29 NewFunc test func()
2025/12/19 11:09:29.088499 [INFO] typesutil/gopinfo.go:215: ==> Type: &{36 0xc0002a4ba0 false} interface{}
2025/12/19 11:09:29 ==> Load var interface{} [a]
2025/12/19 11:09:29 NewVarDefs
2025/12/19 11:09:29 NewVar [a]
2025/12/19 11:09:29 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:29.088575 [INFO] typesutil/gopinfo.go:215: ==> Type: &{50 INT 100 <nil>} untyped int
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29 ==> MatchType untyped int (100), interface{}
2025/12/19 11:09:29.088633 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a interface{}
2025/12/19 11:09:29 If
2025/12/19 11:09:29 DefineVarStart [n ok]
2025/12/19 11:09:29 Val a interface{}
2025/12/19 11:09:29.088683 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a interface{}
2025/12/19 11:09:29.088698 [INFO] typesutil/gopinfo.go:215: ==> Type: a interface{}
2025/12/19 11:09:29.088715 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:29.088728 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:29.088743 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:29 TypeAssert int true
2025/12/19 11:09:29.088790 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 69 int 73} (int, bool)
2025/12/19 11:09:29 EndInit 1
2025/12/19 11:09:29.088817 [INFO] typesutil/gopinfo.go:251: ==> Def: n var n int
2025/12/19 11:09:29.088833 [INFO] typesutil/gopinfo.go:251: ==> Def: ok var ok bool
2025/12/19 11:09:29 Val ok bool
2025/12/19 11:09:29.088855 [INFO] typesutil/gopinfo.go:265: ==> Use: ok var ok bool
2025/12/19 11:09:29.088868 [INFO] typesutil/gopinfo.go:215: ==> Type: ok bool
2025/12/19 11:09:29.088893 [INFO] typesutil/gopinfo.go:332: ==> Scope: if statement scope 0xc000387200 {
.  var n int
.  var ok bool
}

2025/12/19 11:09:29 Then
2025/12/19 11:09:29 VarRef _
2025/12/19 11:09:29 Val n int
2025/12/19 11:09:29.088931 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n int
2025/12/19 11:09:29.088943 [INFO] typesutil/gopinfo.go:215: ==> Type: n int
2025/12/19 11:09:29 Assign 1 1
2025/12/19 11:09:29.088964 [INFO] typesutil/gopinfo.go:332: ==> Scope: if body scope 0xc0003873e0 {
}

2025/12/19 11:09:29 End // If
2025/12/19 11:09:29.088992 [INFO] typesutil/gopinfo.go:332: ==> Scope: func test scope 0xc000387140 {
.  var a interface{}
}

2025/12/19 11:09:29 End // Func
    info_test.go:226: ====== check types pass (count: 7) ======
        000:  4: 8 | interface{}         *ast.InterfaceType             | type    : interface{} | type
        001:  4:22 | 100                 *ast.BasicLit                  | value   : INT = 100 | constant
        002:  5:14 | a                   *ast.Ident                     | var     : interface{} | variable
        003:  5:14 | a.(int)             *ast.TypeAssertExpr            | value   : (int, bool) | comma, ok expression
        004:  5:17 | int                 *ast.Ident                     | type    : int | type
        005:  5:23 | ok                  *ast.Ident                     | var     : bool | variable
        006:  6: 7 | n                   *ast.Ident                     | var     : int | variable
    info_test.go:226: ====== check defs pass (count: 4) ======
        000:  3: 6 | test                | func test()
        001:  4: 6 | a                   | var a interface{}
        002:  5: 5 | n                   | var n int
        003:  5: 8 | ok                  | var ok bool
    info_test.go:226: ====== check uses pass (count: 4) ======
        000:  5:14 | a                   | var a interface{}
        001:  5:17 | int                 | type int
        002:  5:23 | ok                  | var ok bool
        003:  6: 7 | n                   | var n int
--- PASS: TestTypeAssert (1.14s)
=== RUN   TestChan
2025/12/19 11:09:29.090027 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:09:29 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:29 ==> NewOverloadFunc NewRange
2025/12/19 11:09:29 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:29 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:29 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:29 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:29 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:29 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:29 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:29 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:29 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:29 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:29 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:29 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:29 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:29 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:29 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:29 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:29 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:29 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:29 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:29 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:29 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:29 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:29 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:29 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:29 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:29 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:29 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:29 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:29 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:29 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:29 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:29 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:29 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:29 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:29 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:29 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:29 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:29 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:29 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:29 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:29 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:29 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:30.224080 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0006b7200 {
}

2025/12/19 11:09:30 ==> Preload func test
2025/12/19 11:09:30 ==> Load func test
2025/12/19 11:09:30.224146 [INFO] typesutil/gopinfo.go:251: ==> Def: test func test()
2025/12/19 11:09:30 NewFunc test func()
2025/12/19 11:09:30.224172 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:30.224184 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:30.224192 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:30.224230 [INFO] typesutil/gopinfo.go:215: ==> Type: &{37 0 3 int} chan int
2025/12/19 11:09:30 ==> Load var chan int [ch]
2025/12/19 11:09:30 NewVarDefs
2025/12/19 11:09:30 NewVar [ch]
2025/12/19 11:09:30.224263 [INFO] typesutil/gopinfo.go:251: ==> Def: ch var ch chan int
2025/12/19 11:09:30 Select
2025/12/19 11:09:30 CommCase
2025/12/19 11:09:30 DefineVarStart [n ok]
2025/12/19 11:09:30 Val ch chan int
2025/12/19 11:09:30.224299 [INFO] typesutil/gopinfo.go:265: ==> Use: ch var ch chan int
2025/12/19 11:09:30.224307 [INFO] typesutil/gopinfo.go:215: ==> Type: ch chan int
2025/12/19 11:09:30 UnaryOp <- flags: 2
2025/12/19 11:09:30 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 2
2025/12/19 11:09:30.224343 [INFO] typesutil/gopinfo.go:215: ==> Type: &{71 <- ch} (int, bool)
2025/12/19 11:09:30 EndInit 1
2025/12/19 11:09:30.224365 [INFO] typesutil/gopinfo.go:251: ==> Def: n var n int
2025/12/19 11:09:30.224373 [INFO] typesutil/gopinfo.go:251: ==> Def: ok var ok bool
2025/12/19 11:09:30 Then
2025/12/19 11:09:30 VarRef _
2025/12/19 11:09:30 Val n int
2025/12/19 11:09:30.224398 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n int
2025/12/19 11:09:30.224406 [INFO] typesutil/gopinfo.go:215: ==> Type: n int
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 VarRef _
2025/12/19 11:09:30 Val ok bool
2025/12/19 11:09:30.224425 [INFO] typesutil/gopinfo.go:265: ==> Use: ok var ok bool
2025/12/19 11:09:30.224433 [INFO] typesutil/gopinfo.go:215: ==> Type: ok bool
2025/12/19 11:09:30 Assign 1 1
2025/12/19 11:09:30 Break
2025/12/19 11:09:30.224454 [INFO] typesutil/gopinfo.go:332: ==> Scope: comm case statement scope 0xc0006b7440 {
.  var n int
.  var ok bool
}

2025/12/19 11:09:30 End // CommCase
2025/12/19 11:09:30 End // Select
2025/12/19 11:09:30.224476 [INFO] typesutil/gopinfo.go:332: ==> Scope: func test scope 0xc0006b72c0 {
.  var ch chan int
}

2025/12/19 11:09:30 End // Func
    info_test.go:226: ====== check types pass (count: 6) ======
        000:  4: 9 | chan int            *ast.ChanType                  | type    : chan int | type
        001:  4:14 | int                 *ast.Ident                     | type    : int | type
        002:  6:16 | <-ch                *ast.UnaryExpr                 | value   : (int, bool) | comma, ok expression
        003:  6:18 | ch                  *ast.Ident                     | var     : chan int | variable
        004:  7: 7 | n                   *ast.Ident                     | var     : int | variable
        005:  8: 7 | ok                  *ast.Ident                     | var     : bool | variable
    info_test.go:226: ====== check defs pass (count: 4) ======
        000:  3: 6 | test                | func test()
        001:  4: 6 | ch                  | var ch chan int
        002:  6: 7 | n                   | var n int
        003:  6:10 | ok                  | var ok bool
    info_test.go:226: ====== check uses pass (count: 4) ======
        000:  4:14 | int                 | type int
        001:  6:18 | ch                  | var ch chan int
        002:  7: 7 | n                   | var n int
        003:  8: 7 | ok                  | var ok bool
--- PASS: TestChan (1.14s)
=== RUN   TestRange
2025/12/19 11:09:30.226576 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:09:30 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:30 ==> NewOverloadFunc NewRange
2025/12/19 11:09:30 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:30 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:30 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:30 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:30 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:30 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:30 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:30 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:30 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:30 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:30 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:30 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:30 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:30 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:30 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:30 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:30 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:30 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:30 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:30 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:30 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:30 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:30 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:30 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:30 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:30 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:30 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:30 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:30 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:30 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:30 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:30 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:30 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:30 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:30 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:30 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:30 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:30 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:30 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:30 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:30 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:30 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:31.178963 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0004abce0 {
}

2025/12/19 11:09:31 ==> Preload func test
2025/12/19 11:09:31 ==> Load func test
2025/12/19 11:09:31.179048 [INFO] typesutil/gopinfo.go:251: ==> Def: test func test()
2025/12/19 11:09:31 NewFunc test func()
2025/12/19 11:09:31 DefineVarStart [a]
2025/12/19 11:09:31.179107 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:31.179127 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:31.179142 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:31.179167 [INFO] typesutil/gopinfo.go:215: ==> Type: &{34 <nil> int} []int
2025/12/19 11:09:31 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:31.179217 [INFO] typesutil/gopinfo.go:215: ==> Type: &{40 INT 100 <nil>} untyped int
2025/12/19 11:09:31 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:31.179248 [INFO] typesutil/gopinfo.go:215: ==> Type: &{44 INT 200 <nil>} untyped int
2025/12/19 11:09:31 SliceLit []int 2 false
2025/12/19 11:09:31.179287 [INFO] typesutil/gopinfo.go:215: ==> Type: &{34 <nil> int} []int
2025/12/19 11:09:31.179310 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0006643c0 39 [0xc0006643f0 0xc000664420] 47 false} []int
2025/12/19 11:09:31 EndInit 1
2025/12/19 11:09:31.179343 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a []int
2025/12/19 11:09:31 ForRange [k v]
2025/12/19 11:09:31 Val a []int
2025/12/19 11:09:31.179383 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a []int
2025/12/19 11:09:31.179397 [INFO] typesutil/gopinfo.go:215: ==> Type: a []int
2025/12/19 11:09:31 RangeAssignThen
2025/12/19 11:09:31.179432 [INFO] typesutil/gopinfo.go:251: ==> Def: k var k int
2025/12/19 11:09:31.179448 [INFO] typesutil/gopinfo.go:251: ==> Def: v var v int
2025/12/19 11:09:31.179474 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc0004abe60 {
.  var k int
.  var v int
}

2025/12/19 11:09:31 VBlock
2025/12/19 11:09:31 VarRef _
2025/12/19 11:09:31 Val k int
2025/12/19 11:09:31.179512 [INFO] typesutil/gopinfo.go:265: ==> Use: k var k int
2025/12/19 11:09:31.179524 [INFO] typesutil/gopinfo.go:215: ==> Type: k int
2025/12/19 11:09:31 Assign 1 1
2025/12/19 11:09:31 VarRef _
2025/12/19 11:09:31 Val v int
2025/12/19 11:09:31.179555 [INFO] typesutil/gopinfo.go:265: ==> Use: v var v int
2025/12/19 11:09:31.179567 [INFO] typesutil/gopinfo.go:215: ==> Type: v int
2025/12/19 11:09:31 Assign 1 1
2025/12/19 11:09:31.179586 [INFO] typesutil/gopinfo.go:332: ==> Scope: vblock statement scope 0xc0004be060 {
}

2025/12/19 11:09:31 End // Vblock
2025/12/19 11:09:31 End // ForRange
2025/12/19 11:09:31.179628 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:31.179672 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:31.179693 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:31.179707 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/12/19 11:09:31.179719 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:31.179734 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:31.179754 [INFO] typesutil/gopinfo.go:215: ==> Type: &{98 int string} map[int]string
2025/12/19 11:09:31 ==> Load var map[int]string [m]
2025/12/19 11:09:31 NewVarDefs
2025/12/19 11:09:31 NewVar [m]
2025/12/19 11:09:31.179800 [INFO] typesutil/gopinfo.go:251: ==> Def: m var m map[int]string
2025/12/19 11:09:31 ForRange [k v]
2025/12/19 11:09:31 Val m map[int]string
2025/12/19 11:09:31.179833 [INFO] typesutil/gopinfo.go:265: ==> Use: m var m map[int]string
2025/12/19 11:09:31.179847 [INFO] typesutil/gopinfo.go:215: ==> Type: m map[int]string
2025/12/19 11:09:31 RangeAssignThen
2025/12/19 11:09:31.179870 [INFO] typesutil/gopinfo.go:251: ==> Def: k var k int
2025/12/19 11:09:31.179884 [INFO] typesutil/gopinfo.go:251: ==> Def: v var v string
2025/12/19 11:09:31.179907 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc0004be120 {
.  var k int
.  var v string
}

2025/12/19 11:09:31 VBlock
2025/12/19 11:09:31 VarRef _
2025/12/19 11:09:31 Val k int
2025/12/19 11:09:31.179938 [INFO] typesutil/gopinfo.go:265: ==> Use: k var k int
2025/12/19 11:09:31.179950 [INFO] typesutil/gopinfo.go:215: ==> Type: k int
2025/12/19 11:09:31 Assign 1 1
2025/12/19 11:09:31 VarRef _
2025/12/19 11:09:31 Val v string
2025/12/19 11:09:31.179987 [INFO] typesutil/gopinfo.go:265: ==> Use: v var v string
2025/12/19 11:09:31.180008 [INFO] typesutil/gopinfo.go:215: ==> Type: v string
2025/12/19 11:09:31 Assign 1 1
2025/12/19 11:09:31.180033 [INFO] typesutil/gopinfo.go:332: ==> Scope: vblock statement scope 0xc0004be2a0 {
}

2025/12/19 11:09:31 End // Vblock
2025/12/19 11:09:31 End // ForRange
2025/12/19 11:09:31 ForRange [v]
2025/12/19 11:09:31 Val m map[int]string
2025/12/19 11:09:31.180081 [INFO] typesutil/gopinfo.go:265: ==> Use: m var m map[int]string
2025/12/19 11:09:31.180094 [INFO] typesutil/gopinfo.go:215: ==> Type: m map[int]string
2025/12/19 11:09:31 RangeAssignThen
2025/12/19 11:09:31.180113 [INFO] typesutil/gopinfo.go:251: ==> Def: v var v int
2025/12/19 11:09:31.180130 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc0004be300 {
.  var v int
}

2025/12/19 11:09:31 VBlock
2025/12/19 11:09:31 VarRef _
2025/12/19 11:09:31 Val v int
2025/12/19 11:09:31.180162 [INFO] typesutil/gopinfo.go:265: ==> Use: v var v int
2025/12/19 11:09:31.180173 [INFO] typesutil/gopinfo.go:215: ==> Type: v int
2025/12/19 11:09:31 Assign 1 1
2025/12/19 11:09:31.180190 [INFO] typesutil/gopinfo.go:332: ==> Scope: vblock statement scope 0xc0004be420 {
}

2025/12/19 11:09:31 End // Vblock
2025/12/19 11:09:31 End // ForRange
2025/12/19 11:09:31.180224 [INFO] typesutil/gopinfo.go:332: ==> Scope: func test scope 0xc0004abda0 {
.  var a []int
.  var m map[int]string
}

2025/12/19 11:09:31 End // Func
    info_test.go:226: ====== check types pass (count: 16) ======
        000:  3: 7 | []int               *ast.ArrayType                 | type    : []int | type
        001:  3: 7 | []int{100, 200}     *ast.CompositeLit              | value   : []int | value
        002:  3: 9 | int                 *ast.Ident                     | type    : int | type
        003:  3:13 | 100                 *ast.BasicLit                  | value   : INT = 100 | constant
        004:  3:17 | 200                 *ast.BasicLit                  | value   : INT = 200 | constant
        005:  4:20 | a                   *ast.Ident                     | var     : []int | variable
        006:  5: 7 | k                   *ast.Ident                     | var     : int | variable
        007:  6: 7 | v                   *ast.Ident                     | var     : int | variable
        008:  8: 8 | map[int]string      *ast.MapType                   | type    : map[int]string | type
        009:  8:12 | int                 *ast.Ident                     | type    : int | type
        010:  8:16 | string              *ast.Ident                     | type    : string | type
        011:  9:20 | m                   *ast.Ident                     | var     : map[int]string | variable
        012: 10: 7 | k                   *ast.Ident                     | var     : int | variable
        013: 11: 7 | v                   *ast.Ident                     | var     : string | variable
        014: 13:17 | m                   *ast.Ident                     | var     : map[int]string | variable
        015: 14: 7 | v                   *ast.Ident                     | var     : int | variable
    info_test.go:226: ====== check defs pass (count: 8) ======
        000:  2: 6 | test                | func test()
        001:  3: 2 | a                   | var a []int
        002:  4: 6 | k                   | var k int
        003:  4: 9 | v                   | var v int
        004:  8: 6 | m                   | var m map[int]string
        005:  9: 6 | k                   | var k int
        006:  9: 9 | v                   | var v string
        007: 13: 6 | v                   | var v int
    info_test.go:226: ====== check uses pass (count: 11) ======
        000:  3: 9 | int                 | type int
        001:  4:20 | a                   | var a []int
        002:  5: 7 | k                   | var k int
        003:  6: 7 | v                   | var v int
        004:  8:12 | int                 | type int
        005:  8:16 | string              | type string
        006:  9:20 | m                   | var m map[int]string
        007: 10: 7 | k                   | var k int
        008: 11: 7 | v                   | var v string
        009: 13:17 | m                   | var m map[int]string
        010: 14: 7 | v                   | var v int
--- PASS: TestRange (0.96s)
=== RUN   TestFuncLit
2025/12/19 11:09:31.181842 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:09:31 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:31 ==> NewOverloadFunc NewRange
2025/12/19 11:09:31 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:31 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:31 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:31 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:31 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:31 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:31 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:31 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:31 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:31 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:31 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:31 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:31 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:31 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:32.314377 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc00027ad80 {
}

2025/12/19 11:09:32 ==> Preload func test
2025/12/19 11:09:32 ==> Load func test
2025/12/19 11:09:32.314468 [INFO] typesutil/gopinfo.go:251: ==> Def: test func test()
2025/12/19 11:09:32 NewFunc test func()
2025/12/19 11:09:32 DefineVarStart [add]
2025/12/19 11:09:32.314530 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:32.314548 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:32.314564 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:32.314580 [INFO] typesutil/gopinfo.go:251: ==> Def: n1 var n1 int
2025/12/19 11:09:32.314594 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:32.314607 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:32.314620 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:32.314633 [INFO] typesutil/gopinfo.go:251: ==> Def: n2 var n2 int
2025/12/19 11:09:32.314649 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:32.314661 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:32.314674 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:32.314703 [INFO] typesutil/gopinfo.go:215: ==> Type: &{36 <nil> 0xc00049f590 0xc00049f5f0} func(n1 int, n2 int) int
2025/12/19 11:09:32.314724 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0000fce40 0xc00049f770} func(n1 int, n2 int) int
2025/12/19 11:09:32 NewClosure func(n1 int, n2 int) int
2025/12/19 11:09:32 Val n1 int
2025/12/19 11:09:32.314768 [INFO] typesutil/gopinfo.go:265: ==> Use: n1 var n1 int
2025/12/19 11:09:32.314782 [INFO] typesutil/gopinfo.go:215: ==> Type: n1 int
2025/12/19 11:09:32 Val n2 int
2025/12/19 11:09:32.314804 [INFO] typesutil/gopinfo.go:265: ==> Use: n2 var n2 int
2025/12/19 11:09:32.314816 [INFO] typesutil/gopinfo.go:215: ==> Type: n2 int
2025/12/19 11:09:32 BinaryOp +
2025/12/19 11:09:32 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:32 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:32 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:32.314916 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n1 74 + n2} int
2025/12/19 11:09:32 Return 1
2025/12/19 11:09:32 ==> MatchType int, int
2025/12/19 11:09:32.314960 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc00027b020 {
.  var n1 int
.  var n2 int
}

2025/12/19 11:09:32 End // Func
2025/12/19 11:09:32 EndInit 1
2025/12/19 11:09:32.315003 [INFO] typesutil/gopinfo.go:251: ==> Def: add var add func(n1 int, n2 int) int
2025/12/19 11:09:32 VarRef _
2025/12/19 11:09:32 Val add func(n1 int, n2 int) int
2025/12/19 11:09:32.315038 [INFO] typesutil/gopinfo.go:265: ==> Use: add var add func(n1 int, n2 int) int
2025/12/19 11:09:32.315061 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(n1 int, n2 int) int
2025/12/19 11:09:32 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:32.315101 [INFO] typesutil/gopinfo.go:215: ==> Type: &{90 INT 1 <nil>} untyped int
2025/12/19 11:09:32 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:32.315129 [INFO] typesutil/gopinfo.go:215: ==> Type: &{92 INT 2 <nil>} untyped int
2025/12/19 11:09:32 Call 2 0 // func(n1 int, n2 int) int
2025/12/19 11:09:32 ==> MatchFuncCall func(n1 int, n2 int) int args: 2 flags: 0
2025/12/19 11:09:32 ==> MatchType untyped int (1), int
2025/12/19 11:09:32 ==> MatchType untyped int (2), int
2025/12/19 11:09:32.315203 [INFO] typesutil/gopinfo.go:215: ==> Type: &{add 89 [0xc00049f7d0 0xc00049f830] 0 [] 93 0} int
2025/12/19 11:09:32 Assign 1 1
2025/12/19 11:09:32.315227 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:32.315240 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:32.315252 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:32.315265 [INFO] typesutil/gopinfo.go:251: ==> Def: n var n int
2025/12/19 11:09:32.315288 [INFO] typesutil/gopinfo.go:215: ==> Type: &{100 <nil> 0xc00049f920 <nil>} func(n int)
2025/12/19 11:09:32.315308 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0000fcfa0 0xc00049fa10} func(n int)
2025/12/19 11:09:32 NewClosure func(n int)
2025/12/19 11:09:32 VarRef _
2025/12/19 11:09:32 Val n int
2025/12/19 11:09:32.315348 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n int
2025/12/19 11:09:32.315361 [INFO] typesutil/gopinfo.go:215: ==> Type: n int
2025/12/19 11:09:32 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:32.315392 [INFO] typesutil/gopinfo.go:215: ==> Type: &{122 INT 100 <nil>} untyped int
2025/12/19 11:09:32 BinaryOp +
2025/12/19 11:09:32 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:32 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:32 ==> MatchType untyped int (100), unboundFuncParam{typ: int}
2025/12/19 11:09:32.315461 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n 121 + 0xc00049f9b0} int
2025/12/19 11:09:32 Assign 1 1
2025/12/19 11:09:32.315489 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc00027b320 {
.  var n int
}

2025/12/19 11:09:32 End // Func
2025/12/19 11:09:32 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:32.315525 [INFO] typesutil/gopinfo.go:215: ==> Type: &{129 INT 100 <nil>} untyped int
2025/12/19 11:09:32 Call 1 0 // func(n int)
2025/12/19 11:09:32 ==> MatchFuncCall func(n int) args: 1 flags: 0
2025/12/19 11:09:32 ==> MatchType untyped int (100), int
2025/12/19 11:09:32.315579 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0004cb040 128 [0xc00049fa40] 0 [] 132 0} ()
2025/12/19 11:09:32 Go
2025/12/19 11:09:32.315605 [INFO] typesutil/gopinfo.go:332: ==> Scope: func test scope 0xc00027ae40 {
.  var add func(n1 int, n2 int) int
}

2025/12/19 11:09:32 End // Func
    info_test.go:226: ====== check types pass (count: 20) ======
        000:  3: 9 | func(n1 int, n2 int) int *ast.FuncType                  | type    : func(n1 int, n2 int) int | type
        001:  3: 9 | func(n1 int, n2 int) int {
        	return n1 + n2
        } *ast.FuncLit                   | value   : func(n1 int, n2 int) int | value
        002:  3:17 | int                 *ast.Ident                     | type    : int | type
        003:  3:25 | int                 *ast.Ident                     | type    : int | type
        004:  3:30 | int                 *ast.Ident                     | type    : int | type
        005:  4:10 | n1                  *ast.Ident                     | var     : int | variable
        006:  4:10 | n1 + n2             *ast.BinaryExpr                | value   : int | value
        007:  4:13 | n2                  *ast.Ident                     | var     : int | variable
        008:  6: 6 | add                 *ast.Ident                     | var     : func(n1 int, n2 int) int | variable
        009:  6: 6 | add(1, 2)           *ast.CallExpr                  | value   : int | value
        010:  6:10 | 1                   *ast.BasicLit                  | value   : INT = 1 | constant
        011:  6:12 | 2                   *ast.BasicLit                  | value   : INT = 2 | constant
        012:  8: 5 | func(n int)         *ast.FuncType                  | type    : func(n int) | type
        013:  8: 5 | func(n int) {
        	_ = n + 100
        } *ast.FuncLit                   | value   : func(n int) | value
        014:  8: 5 | func(n int) {
        	_ = n + 100
        }(100) *ast.CallExpr                  | void    : () | no value
        015:  8:12 | int                 *ast.Ident                     | type    : int | type
        016:  9: 7 | n                   *ast.Ident                     | var     : int | variable
        017:  9: 7 | n + 100             *ast.BinaryExpr                | value   : int | value
        018:  9: 9 | 100                 *ast.BasicLit                  | value   : INT = 100 | constant
        019: 10: 4 | 100                 *ast.BasicLit                  | value   : INT = 100 | constant
    info_test.go:226: ====== check defs pass (count: 5) ======
        000:  2: 6 | test                | func test()
        001:  3: 2 | add                 | var add func(n1 int, n2 int) int
        002:  3:14 | n1                  | var n1 int
        003:  3:22 | n2                  | var n2 int
        004:  8:10 | n                   | var n int
    info_test.go:226: ====== check uses pass (count: 8) ======
        000:  3:17 | int                 | type int
        001:  3:25 | int                 | type int
        002:  3:30 | int                 | type int
        003:  4:10 | n1                  | var n1 int
        004:  4:13 | n2                  | var n2 int
        005:  6: 6 | add                 | var add func(n1 int, n2 int) int
        006:  8:12 | int                 | type int
        007:  9: 7 | n                   | var n int
--- PASS: TestFuncLit (1.14s)
=== RUN   TestSliceLit
2025/12/19 11:09:32.317935 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:09:32 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:32 ==> NewOverloadFunc NewRange
2025/12/19 11:09:33 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:33 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:33 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:33 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:33 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:33 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:33 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:33 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:33 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:33 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:33 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:33 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:33 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:33 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:33.476151 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc000578ea0 {
}

2025/12/19 11:09:33 ==> Preload func main
2025/12/19 11:09:33 ==> Load func main
2025/12/19 11:09:33.476228 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:09:33 NewFunc main func()
2025/12/19 11:09:33 DefineVarStart [a]
2025/12/19 11:09:33 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:33.476298 [INFO] typesutil/gopinfo.go:215: ==> Type: &{8 INT 100 <nil>} untyped int
2025/12/19 11:09:33 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:33.476319 [INFO] typesutil/gopinfo.go:215: ==> Type: &{12 INT 200 <nil>} untyped int
2025/12/19 11:09:33 SliceLit <nil> 2 false
2025/12/19 11:09:33 EndInit 1
2025/12/19 11:09:33.476348 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a []int
2025/12/19 11:09:33 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:33.476392 [INFO] typesutil/gopinfo.go:265: ==> Use: println builtin println
2025/12/19 11:09:33.476404 [INFO] typesutil/gopinfo.go:215: ==> Type: println invalid type
2025/12/19 11:09:33 Val a []int
2025/12/19 11:09:33.476426 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a []int
2025/12/19 11:09:33.476438 [INFO] typesutil/gopinfo.go:215: ==> Type: a []int
2025/12/19 11:09:33 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:33 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:33 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:33 ==> MatchType []int, any
2025/12/19 11:09:33.476503 [INFO] typesutil/gopinfo.go:265: ==> Use: println func fmt.Println(a ...any) (n int, err error)
2025/12/19 11:09:33.476516 [INFO] typesutil/gopinfo.go:215: ==> Type: println func(a ...any) (n int, err error)
2025/12/19 11:09:33.476536 [INFO] typesutil/gopinfo.go:215: ==> Type: &{println 0 [a] 0 [] 0 26} (n int, err error)
2025/12/19 11:09:33.476558 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc000578f60 {
.  var a []int
}

2025/12/19 11:09:33 End // Func
    info_test.go:190: == types ==
        000:  2: 7 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        001:  2:11 | 200                 *ast.BasicLit                  | value   : untyped int = 200 | constant
        002:  3: 1 | println             *ast.Ident                     | value   : func(a ...any) (n int, err error) | value
        003:  3: 1 | println a           *ast.CallExpr                  | value   : (n int, err error) | value
        004:  3: 9 | a                   *ast.Ident                     | var     : []int | variable
        == defs ==
        000:  2: 1 | a                   | var a []int
        001:  2: 1 | main                | func main.main()
        == uses ==
        000:  3: 1 | println             | func fmt.Println(a ...any) (n int, err error)
        001:  3: 9 | a                   | var a []int
--- PASS: TestSliceLit (1.16s)
=== RUN   TestForPhrase1
2025/12/19 11:09:33.478512 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:09:34 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:34 ==> NewOverloadFunc NewRange
2025/12/19 11:09:34 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:34 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:34 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:34 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:34 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:34 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:34 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:34 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:34 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:34 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:34 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:34 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:34 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:34 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:34 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:34 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:34 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:34 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:34 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:34 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:34 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:34 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:34 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:34 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:34 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:34 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:34 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:34 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:34 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:34 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:34 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:34 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:34 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:34 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:34 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:34 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:34 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:34 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:34 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:34 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:34 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:34 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:34.568102 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc000491320 {
}

2025/12/19 11:09:34 ==> Preload func main
2025/12/19 11:09:34 ==> Load func main
2025/12/19 11:09:34.568161 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:09:34 NewFunc main func()
2025/12/19 11:09:34 DefineVarStart [sum]
2025/12/19 11:09:34 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:34.568215 [INFO] typesutil/gopinfo.go:215: ==> Type: &{9 INT 0 <nil>} untyped int
2025/12/19 11:09:34 EndInit 1
2025/12/19 11:09:34.568232 [INFO] typesutil/gopinfo.go:251: ==> Def: sum var sum int
2025/12/19 11:09:34 ForRange [_ x]
2025/12/19 11:09:34 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:34.568266 [INFO] typesutil/gopinfo.go:215: ==> Type: &{21 INT 1 <nil>} untyped int
2025/12/19 11:09:34 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:34.568281 [INFO] typesutil/gopinfo.go:215: ==> Type: &{24 INT 3 <nil>} untyped int
2025/12/19 11:09:34 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:34.568300 [INFO] typesutil/gopinfo.go:215: ==> Type: &{27 INT 5 <nil>} untyped int
2025/12/19 11:09:34 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:09:34.568314 [INFO] typesutil/gopinfo.go:215: ==> Type: &{30 INT 7 <nil>} untyped int
2025/12/19 11:09:34 Val &{0 INT 11} *ast.BasicLit
2025/12/19 11:09:34.568329 [INFO] typesutil/gopinfo.go:215: ==> Type: &{33 INT 11 <nil>} untyped int
2025/12/19 11:09:34 Val &{0 INT 13} *ast.BasicLit
2025/12/19 11:09:34.568344 [INFO] typesutil/gopinfo.go:215: ==> Type: &{37 INT 13 <nil>} untyped int
2025/12/19 11:09:34 Val &{0 INT 17} *ast.BasicLit
2025/12/19 11:09:34.568356 [INFO] typesutil/gopinfo.go:215: ==> Type: &{41 INT 17 <nil>} untyped int
2025/12/19 11:09:34 SliceLit <nil> 7 false
2025/12/19 11:09:34 RangeAssignThen
2025/12/19 11:09:34.568381 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:09:34.568395 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc0004914a0 {
.  var x int
}

2025/12/19 11:09:34 If
2025/12/19 11:09:34 Val x int
2025/12/19 11:09:34.568417 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:09:34.568428 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:09:34 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:34.568454 [INFO] typesutil/gopinfo.go:215: ==> Type: &{50 INT 3 <nil>} untyped int
2025/12/19 11:09:34 BinaryOp >
2025/12/19 11:09:34 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:34 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:34 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/12/19 11:09:34.568519 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 48 > 0xc0003e31a0} untyped bool
2025/12/19 11:09:34 Then
2025/12/19 11:09:34 VarRef sum int
2025/12/19 11:09:34.568540 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/12/19 11:09:34.568547 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/12/19 11:09:34 Val sum int
2025/12/19 11:09:34.568560 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/12/19 11:09:34.568568 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/12/19 11:09:34 Val x int
2025/12/19 11:09:34.568582 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:09:34.568593 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:09:34 BinaryOp +
2025/12/19 11:09:34 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:34 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:34 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:34.568647 [INFO] typesutil/gopinfo.go:215: ==> Type: &{sum 65 + x} int
2025/12/19 11:09:34 Assign 1 1
2025/12/19 11:09:34 ==> MatchType int, int
2025/12/19 11:09:34.568666 [INFO] typesutil/gopinfo.go:332: ==> Scope: if body scope 0xc0004916e0 {
}

2025/12/19 11:09:34 End // If
2025/12/19 11:09:34 End // ForRange
2025/12/19 11:09:34 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:34.568699 [INFO] typesutil/gopinfo.go:265: ==> Use: println builtin println
2025/12/19 11:09:34.568706 [INFO] typesutil/gopinfo.go:215: ==> Type: println invalid type
2025/12/19 11:09:34 Val sum int
2025/12/19 11:09:34.568722 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/12/19 11:09:34.568730 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/12/19 11:09:34 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:34 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:34 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:34 ==> MatchType int, any
2025/12/19 11:09:34.568775 [INFO] typesutil/gopinfo.go:265: ==> Use: println func fmt.Println(a ...any) (n int, err error)
2025/12/19 11:09:34.568785 [INFO] typesutil/gopinfo.go:215: ==> Type: println func(a ...any) (n int, err error)
2025/12/19 11:09:34.568800 [INFO] typesutil/gopinfo.go:215: ==> Type: &{println 0 [sum] 0 [] 0 82} (n int, err error)
2025/12/19 11:09:34.568813 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0004913e0 {
.  var sum int
}

2025/12/19 11:09:34 End // Func
    info_test.go:190: == types ==
        000:  2: 8 | 0                   *ast.BasicLit                  | value   : untyped int = 0 | constant
        001:  3:11 | 1                   *ast.BasicLit                  | value   : untyped int = 1 | constant
        002:  3:14 | 3                   *ast.BasicLit                  | value   : untyped int = 3 | constant
        003:  3:17 | 5                   *ast.BasicLit                  | value   : untyped int = 5 | constant
        004:  3:20 | 7                   *ast.BasicLit                  | value   : untyped int = 7 | constant
        005:  3:23 | 11                  *ast.BasicLit                  | value   : untyped int = 11 | constant
        006:  3:27 | 13                  *ast.BasicLit                  | value   : untyped int = 13 | constant
        007:  3:31 | 17                  *ast.BasicLit                  | value   : untyped int = 17 | constant
        008:  3:36 | x                   *ast.Ident                     | var     : int | variable
        009:  3:36 | x > 3               *ast.BinaryExpr                | value   : untyped bool | value
        010:  3:40 | 3                   *ast.BasicLit                  | value   : untyped int = 3 | constant
        011:  4: 2 | sum                 *ast.Ident                     | var     : int | variable
        012:  4: 8 | sum                 *ast.Ident                     | var     : int | variable
        013:  4: 8 | sum + x             *ast.BinaryExpr                | value   : int | value
        014:  4:14 | x                   *ast.Ident                     | var     : int | variable
        015:  6: 1 | println             *ast.Ident                     | value   : func(a ...any) (n int, err error) | value
        016:  6: 1 | println sum         *ast.CallExpr                  | value   : (n int, err error) | value
        017:  6: 9 | sum                 *ast.Ident                     | var     : int | variable
        == defs ==
        000:  2: 1 | main                | func main.main()
        001:  2: 1 | sum                 | var sum int
        002:  3: 5 | x                   | var x int
        == uses ==
        000:  3:36 | x                   | var x int
        001:  4: 2 | sum                 | var sum int
        002:  4: 8 | sum                 | var sum int
        003:  4:14 | x                   | var x int
        004:  6: 1 | println             | func fmt.Println(a ...any) (n int, err error)
        005:  6: 9 | sum                 | var sum int
--- PASS: TestForPhrase1 (1.09s)
=== RUN   TestForPhrase2
2025/12/19 11:09:34.569796 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:09:35 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:35 ==> NewOverloadFunc NewRange
2025/12/19 11:09:35 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:35 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:35 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:35 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:35 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:35 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:35 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:35 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:35 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:35 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:35 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:35 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:35 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:35 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:35 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:35 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:35 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:35 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:35 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:35 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:35 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:35 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:35 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:35 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:35 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:35 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:35 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:35 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:35 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:35 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:35 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:35 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:35 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:35 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:35 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:35 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:35 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:35 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:35 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:35 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:35 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:35 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:35.760417 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0003355c0 {
}

2025/12/19 11:09:35 ==> Preload func main
2025/12/19 11:09:35 ==> Load func main
2025/12/19 11:09:35.760511 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:09:35 NewFunc main func()
2025/12/19 11:09:35 DefineVarStart [sum]
2025/12/19 11:09:35 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:35.760595 [INFO] typesutil/gopinfo.go:215: ==> Type: &{9 INT 0 <nil>} untyped int
2025/12/19 11:09:35 EndInit 1
2025/12/19 11:09:35.760623 [INFO] typesutil/gopinfo.go:251: ==> Def: sum var sum int
2025/12/19 11:09:35 ForRange [i x]
2025/12/19 11:09:35 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:35.760664 [INFO] typesutil/gopinfo.go:215: ==> Type: &{24 INT 1 <nil>} untyped int
2025/12/19 11:09:35 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:35.760689 [INFO] typesutil/gopinfo.go:215: ==> Type: &{27 INT 3 <nil>} untyped int
2025/12/19 11:09:35 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:35.760714 [INFO] typesutil/gopinfo.go:215: ==> Type: &{30 INT 5 <nil>} untyped int
2025/12/19 11:09:35 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:09:35.760738 [INFO] typesutil/gopinfo.go:215: ==> Type: &{33 INT 7 <nil>} untyped int
2025/12/19 11:09:35 Val &{0 INT 11} *ast.BasicLit
2025/12/19 11:09:35.760763 [INFO] typesutil/gopinfo.go:215: ==> Type: &{36 INT 11 <nil>} untyped int
2025/12/19 11:09:35 Val &{0 INT 13} *ast.BasicLit
2025/12/19 11:09:35.760786 [INFO] typesutil/gopinfo.go:215: ==> Type: &{40 INT 13 <nil>} untyped int
2025/12/19 11:09:35 Val &{0 INT 17} *ast.BasicLit
2025/12/19 11:09:35.760808 [INFO] typesutil/gopinfo.go:215: ==> Type: &{44 INT 17 <nil>} untyped int
2025/12/19 11:09:35 SliceLit <nil> 7 false
2025/12/19 11:09:35 RangeAssignThen
2025/12/19 11:09:35.760840 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/12/19 11:09:35.760852 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:09:35.760878 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc000335740 {
.  var i int
.  var x int
}

2025/12/19 11:09:35 If
2025/12/19 11:09:35 Val i int
2025/12/19 11:09:35.760914 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/12/19 11:09:35.760931 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/12/19 11:09:35 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:35.760959 [INFO] typesutil/gopinfo.go:215: ==> Type: &{51 INT 2 <nil>} untyped int
2025/12/19 11:09:35 BinaryOp %
2025/12/19 11:09:35 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:35 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:35 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/12/19 11:09:35.761067 [INFO] typesutil/gopinfo.go:215: ==> Type: &{i 50 % 0xc0004b23c0} int
2025/12/19 11:09:35 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:35.761131 [INFO] typesutil/gopinfo.go:215: ==> Type: &{56 INT 1 <nil>} untyped int
2025/12/19 11:09:35 BinaryOp ==
2025/12/19 11:09:35.761161 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0004b23f0 53 == 0xc0004b2420} untyped bool
2025/12/19 11:09:35 Val x int
2025/12/19 11:09:35.761188 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:09:35.761206 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:09:35 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:35.761234 [INFO] typesutil/gopinfo.go:215: ==> Type: &{65 INT 3 <nil>} untyped int
2025/12/19 11:09:35 BinaryOp >
2025/12/19 11:09:35 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:35 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:35 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/12/19 11:09:35.761304 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 63 > 0xc0004b2480} untyped bool
2025/12/19 11:09:35 BinaryOp &&
2025/12/19 11:09:35 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:35 ==> MatchType untyped bool, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:35 ==> MatchType untyped bool, unboundFuncParam{typ: untyped bool}
2025/12/19 11:09:35.761366 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0004b2450 58 && 0xc0004b24b0} untyped bool
2025/12/19 11:09:35 Then
2025/12/19 11:09:35 VarRef sum int
2025/12/19 11:09:35.761396 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/12/19 11:09:35.761408 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/12/19 11:09:35 Val sum int
2025/12/19 11:09:35.761428 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/12/19 11:09:35.761440 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/12/19 11:09:35 Val x int
2025/12/19 11:09:35.761463 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:09:35.761476 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:09:35 BinaryOp +
2025/12/19 11:09:35 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:35 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:35 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:35.761537 [INFO] typesutil/gopinfo.go:215: ==> Type: &{sum 80 + x} int
2025/12/19 11:09:35 Assign 1 1
2025/12/19 11:09:35 ==> MatchType int, int
2025/12/19 11:09:35.761569 [INFO] typesutil/gopinfo.go:332: ==> Scope: if body scope 0xc000335c20 {
}

2025/12/19 11:09:35 End // If
2025/12/19 11:09:35 End // ForRange
2025/12/19 11:09:35 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:35.761621 [INFO] typesutil/gopinfo.go:265: ==> Use: println builtin println
2025/12/19 11:09:35.761634 [INFO] typesutil/gopinfo.go:215: ==> Type: println invalid type
2025/12/19 11:09:35 Val sum int
2025/12/19 11:09:35.761658 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/12/19 11:09:35.761670 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/12/19 11:09:35 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:35 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:35 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:35 ==> MatchType int, any
2025/12/19 11:09:35.761739 [INFO] typesutil/gopinfo.go:265: ==> Use: println func fmt.Println(a ...any) (n int, err error)
2025/12/19 11:09:35.761793 [INFO] typesutil/gopinfo.go:215: ==> Type: println func(a ...any) (n int, err error)
2025/12/19 11:09:35.761820 [INFO] typesutil/gopinfo.go:215: ==> Type: &{println 0 [sum] 0 [] 0 97} (n int, err error)
2025/12/19 11:09:35.761846 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc000335680 {
.  var sum int
}

2025/12/19 11:09:35 End // Func
    info_test.go:190: == types ==
        000:  2: 8 | 0                   *ast.BasicLit                  | value   : untyped int = 0 | constant
        001:  3:14 | 1                   *ast.BasicLit                  | value   : untyped int = 1 | constant
        002:  3:17 | 3                   *ast.BasicLit                  | value   : untyped int = 3 | constant
        003:  3:20 | 5                   *ast.BasicLit                  | value   : untyped int = 5 | constant
        004:  3:23 | 7                   *ast.BasicLit                  | value   : untyped int = 7 | constant
        005:  3:26 | 11                  *ast.BasicLit                  | value   : untyped int = 11 | constant
        006:  3:30 | 13                  *ast.BasicLit                  | value   : untyped int = 13 | constant
        007:  3:34 | 17                  *ast.BasicLit                  | value   : untyped int = 17 | constant
        008:  3:39 | i                   *ast.Ident                     | var     : int | variable
        009:  3:39 | i % 2               *ast.BinaryExpr                | value   : int | value
        010:  3:39 | i%2 == 1            *ast.BinaryExpr                | value   : untyped bool | value
        011:  3:39 | i%2 == 1 && x > 3   *ast.BinaryExpr                | value   : untyped bool | value
        012:  3:41 | 2                   *ast.BasicLit                  | value   : untyped int = 2 | constant
        013:  3:46 | 1                   *ast.BasicLit                  | value   : untyped int = 1 | constant
        014:  3:51 | x                   *ast.Ident                     | var     : int | variable
        015:  3:51 | x > 3               *ast.BinaryExpr                | value   : untyped bool | value
        016:  3:55 | 3                   *ast.BasicLit                  | value   : untyped int = 3 | constant
        017:  4: 2 | sum                 *ast.Ident                     | var     : int | variable
        018:  4: 8 | sum                 *ast.Ident                     | var     : int | variable
        019:  4: 8 | sum + x             *ast.BinaryExpr                | value   : int | value
        020:  4:14 | x                   *ast.Ident                     | var     : int | variable
        021:  6: 1 | println             *ast.Ident                     | value   : func(a ...any) (n int, err error) | value
        022:  6: 1 | println sum         *ast.CallExpr                  | value   : (n int, err error) | value
        023:  6: 9 | sum                 *ast.Ident                     | var     : int | variable
        == defs ==
        000:  2: 1 | main                | func main.main()
        001:  2: 1 | sum                 | var sum int
        002:  3: 5 | i                   | var i int
        003:  3: 8 | x                   | var x int
        == uses ==
        000:  3:39 | i                   | var i int
        001:  3:51 | x                   | var x int
        002:  4: 2 | sum                 | var sum int
        003:  4: 8 | sum                 | var sum int
        004:  4:14 | x                   | var x int
        005:  6: 1 | println             | func fmt.Println(a ...any) (n int, err error)
        006:  6: 9 | sum                 | var sum int
--- PASS: TestForPhrase2 (1.19s)
=== RUN   TestMapComprehension
2025/12/19 11:09:35.763183 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:09:36 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:36 ==> NewOverloadFunc NewRange
2025/12/19 11:09:36 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:36 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:36 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:36 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:36 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:36 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:36 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:36 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:36 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:36 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:36 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:36 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:36 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:36 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:36 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:36 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:36 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:36 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:36 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:36 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:36 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:36 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:36 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:36 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:36 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:36 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:36 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:36 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:36 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:36 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:36 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:36 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:36 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:36 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:36 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:36 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:36 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:36 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:36 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:36 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:36 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:36 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:36.856420 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0003af980 {
}

2025/12/19 11:09:36 ==> Preload func main
2025/12/19 11:09:36 ==> Load func main
2025/12/19 11:09:36.856500 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:09:36 NewFunc main func()
2025/12/19 11:09:36 DefineVarStart [y]
2025/12/19 11:09:36 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:36 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:36 ZeroLit // unboundType{typ: <nil>}
2025/12/19 11:09:36 Assign 1 1
2025/12/19 11:09:36 ==> MatchType unboundType{typ: <nil>}, unboundType{typ: <nil>}
2025/12/19 11:09:36 ForRange [i x]
2025/12/19 11:09:36 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:09:36.856627 [INFO] typesutil/gopinfo.go:215: ==> Type: &{26 STRING "1" <nil>} untyped string
2025/12/19 11:09:36 Val &{0 STRING "3"} *ast.BasicLit
2025/12/19 11:09:36.856652 [INFO] typesutil/gopinfo.go:215: ==> Type: &{31 STRING "3" <nil>} untyped string
2025/12/19 11:09:36 Val &{0 STRING "5"} *ast.BasicLit
2025/12/19 11:09:36.856674 [INFO] typesutil/gopinfo.go:215: ==> Type: &{36 STRING "5" <nil>} untyped string
2025/12/19 11:09:36 Val &{0 STRING "7"} *ast.BasicLit
2025/12/19 11:09:36.856694 [INFO] typesutil/gopinfo.go:215: ==> Type: &{41 STRING "7" <nil>} untyped string
2025/12/19 11:09:36 Val &{0 STRING "11"} *ast.BasicLit
2025/12/19 11:09:36.856795 [INFO] typesutil/gopinfo.go:215: ==> Type: &{46 STRING "11" <nil>} untyped string
2025/12/19 11:09:36 SliceLit <nil> 5 false
2025/12/19 11:09:36 RangeAssignThen
2025/12/19 11:09:36.856839 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/12/19 11:09:36.856851 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x string
2025/12/19 11:09:36.856873 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc0003afbc0 {
.  var i int
.  var x string
}

2025/12/19 11:09:36 Val _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:36 Val x string
2025/12/19 11:09:36.856899 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x string
2025/12/19 11:09:36.856912 [INFO] typesutil/gopinfo.go:215: ==> Type: x string
2025/12/19 11:09:36 IndexRef 1
2025/12/19 11:09:36 Val i int
2025/12/19 11:09:36.856934 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/12/19 11:09:36.856943 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/12/19 11:09:36 Assign 1 1
2025/12/19 11:09:36 ==> MatchType int, unboundMapElemType{key: string}
2025/12/19 11:09:36 End // ForRange
2025/12/19 11:09:36 Return 0
2025/12/19 11:09:36 End // Func
2025/12/19 11:09:36 Call 0 0 // func() (_xgo_ret map[string]int)
2025/12/19 11:09:36 ==> MatchFuncCall func() (_xgo_ret map[string]int) args: 0 flags: 0
2025/12/19 11:09:36 EndInit 1
2025/12/19 11:09:36.857030 [INFO] typesutil/gopinfo.go:251: ==> Def: y var y map[string]int
2025/12/19 11:09:36 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:36.857059 [INFO] typesutil/gopinfo.go:265: ==> Use: println builtin println
2025/12/19 11:09:36.857070 [INFO] typesutil/gopinfo.go:215: ==> Type: println invalid type
2025/12/19 11:09:36 Val y map[string]int
2025/12/19 11:09:36.857124 [INFO] typesutil/gopinfo.go:265: ==> Use: y var y map[string]int
2025/12/19 11:09:36.857142 [INFO] typesutil/gopinfo.go:215: ==> Type: y map[string]int
2025/12/19 11:09:36 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:36 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:36 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:36 ==> MatchType map[string]int, any
2025/12/19 11:09:36.857200 [INFO] typesutil/gopinfo.go:265: ==> Use: println func fmt.Println(a ...any) (n int, err error)
2025/12/19 11:09:36.857216 [INFO] typesutil/gopinfo.go:215: ==> Type: println func(a ...any) (n int, err error)
2025/12/19 11:09:36.857238 [INFO] typesutil/gopinfo.go:215: ==> Type: &{println 0 [y] 0 [] 0 62} (n int, err error)
2025/12/19 11:09:36.857258 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0003afa40 {
.  var y map[string]int
}

2025/12/19 11:09:36 End // Func
    info_test.go:190: == types ==
        000:  2: 7 | x                   *ast.Ident                     | var     : string | variable
        001:  2:10 | i                   *ast.Ident                     | var     : int | variable
        002:  2:25 | "1"                 *ast.BasicLit                  | value   : untyped string = "1" | constant
        003:  2:30 | "3"                 *ast.BasicLit                  | value   : untyped string = "3" | constant
        004:  2:35 | "5"                 *ast.BasicLit                  | value   : untyped string = "5" | constant
        005:  2:40 | "7"                 *ast.BasicLit                  | value   : untyped string = "7" | constant
        006:  2:45 | "11"                *ast.BasicLit                  | value   : untyped string = "11" | constant
        007:  3: 1 | println             *ast.Ident                     | value   : func(a ...any) (n int, err error) | value
        008:  3: 1 | println y           *ast.CallExpr                  | value   : (n int, err error) | value
        009:  3: 9 | y                   *ast.Ident                     | var     : map[string]int | variable
        == defs ==
        000:  2: 1 | main                | func main.main()
        001:  2: 1 | y                   | var y map[string]int
        002:  2:16 | i                   | var i int
        003:  2:19 | x                   | var x string
        == uses ==
        000:  2: 7 | x                   | var x string
        001:  2:10 | i                   | var i int
        002:  3: 1 | println             | func fmt.Println(a ...any) (n int, err error)
        003:  3: 9 | y                   | var y map[string]int
--- PASS: TestMapComprehension (1.10s)
=== RUN   TestListComprehension
2025/12/19 11:09:36.858208 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:09:37 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:37 ==> NewOverloadFunc NewRange
2025/12/19 11:09:37 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:37 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:37 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:37 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:37 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:37 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:37 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:37 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:37 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:37 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:37 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:37 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:37 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:37 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:37 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:37 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:37 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:37 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:37 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:37 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:37 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:37 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:37 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:37 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:37 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:37 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:37 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:37 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:37 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:37 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:37 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:37 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:37 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:37 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:37 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:37 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:37 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:37 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:37 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:37 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:37 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:37 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:37.856299 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0004a7440 {
}

2025/12/19 11:09:37 ==> Preload func main
2025/12/19 11:09:37 ==> Load func main
2025/12/19 11:09:37.856369 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:09:37 NewFunc main func()
2025/12/19 11:09:37 DefineVarStart [a]
2025/12/19 11:09:37 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:37.856427 [INFO] typesutil/gopinfo.go:215: ==> Type: &{8 INT 1 <nil>} untyped int
2025/12/19 11:09:37 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/12/19 11:09:37.856461 [INFO] typesutil/gopinfo.go:215: ==> Type: &{11 FLOAT 3.4 <nil>} untyped float
2025/12/19 11:09:37 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:37.856480 [INFO] typesutil/gopinfo.go:215: ==> Type: &{16 INT 5 <nil>} untyped int
2025/12/19 11:09:37 SliceLit <nil> 3 false
2025/12/19 11:09:37 EndInit 1
2025/12/19 11:09:37.856506 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a []float64
2025/12/19 11:09:37 DefineVarStart [b]
2025/12/19 11:09:37 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:37 ForRange [_ x]
2025/12/19 11:09:37 Val a []float64
2025/12/19 11:09:37.856554 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a []float64
2025/12/19 11:09:37.856563 [INFO] typesutil/gopinfo.go:215: ==> Type: a []float64
2025/12/19 11:09:37 RangeAssignThen
2025/12/19 11:09:37.856574 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x float64
2025/12/19 11:09:37.856586 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc0004a76e0 {
.  var x float64
}

2025/12/19 11:09:37 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:37 Val append func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:37 Val _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:37 Val x float64
2025/12/19 11:09:37.856621 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/12/19 11:09:37.856628 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/12/19 11:09:37 Val x float64
2025/12/19 11:09:37.856639 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/12/19 11:09:37.856645 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/12/19 11:09:37 BinaryOp *
2025/12/19 11:09:37 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:37 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:37 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:37.856698 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 26 * x} float64
2025/12/19 11:09:37 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:37 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:37 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/12/19 11:09:37 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/12/19 11:09:37 ==> MatchType unboundType{typ: <nil>}, []unboundFuncParam{typ: <nil>}
2025/12/19 11:09:37 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:37 Assign 1 1
2025/12/19 11:09:37 ==> MatchType []float64, unboundType{typ: <nil>}
2025/12/19 11:09:37 End // ForRange
2025/12/19 11:09:37 Return 0
2025/12/19 11:09:37 End // Func
2025/12/19 11:09:37 Call 0 0 // func() (_xgo_ret []float64)
2025/12/19 11:09:37 ==> MatchFuncCall func() (_xgo_ret []float64) args: 0 flags: 0
2025/12/19 11:09:37 EndInit 1
2025/12/19 11:09:37.856796 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b []float64
2025/12/19 11:09:37 VarRef _
2025/12/19 11:09:37 Val b []float64
2025/12/19 11:09:37.856813 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b []float64
2025/12/19 11:09:37.856820 [INFO] typesutil/gopinfo.go:215: ==> Type: b []float64
2025/12/19 11:09:37 Assign 1 1
2025/12/19 11:09:37.856838 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0004a7500 {
.  var a []float64
.  var b []float64
}

2025/12/19 11:09:37 End // Func
    info_test.go:190: == types ==
        000:  2: 7 | 1                   *ast.BasicLit                  | value   : untyped int = 1 | constant
        001:  2:10 | 3.4                 *ast.BasicLit                  | value   : untyped float = 3.4 | constant
        002:  2:15 | 5                   *ast.BasicLit                  | value   : untyped int = 5 | constant
        003:  3: 7 | x                   *ast.Ident                     | var     : float64 | variable
        004:  3: 7 | x * x               *ast.BinaryExpr                | value   : float64 | value
        005:  3: 9 | x                   *ast.Ident                     | var     : float64 | variable
        006:  3:20 | a                   *ast.Ident                     | var     : []float64 | variable
        007:  4: 5 | b                   *ast.Ident                     | var     : []float64 | variable
        == defs ==
        000:  2: 1 | a                   | var a []float64
        001:  2: 1 | main                | func main.main()
        002:  3: 1 | b                   | var b []float64
        003:  3:15 | x                   | var x float64
        == uses ==
        000:  3: 7 | x                   | var x float64
        001:  3: 9 | x                   | var x float64
        002:  3:20 | a                   | var a []float64
        003:  4: 5 | b                   | var b []float64
--- PASS: TestListComprehension (1.00s)
=== RUN   TestListComprehensionMultiLevel
2025/12/19 11:09:37.857641 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:09:38 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:38 ==> NewOverloadFunc NewRange
2025/12/19 11:09:38 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:38 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:38 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:38 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:38 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:38 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:38 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:38 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:38 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:38 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:38 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:38 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:38 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:38 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:38 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:38 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:38 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:38 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:38 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:38 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:38 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:38 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:38 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:38 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:38 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:38 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:38 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:38 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:38 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:38 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:38 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:38 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:38 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:38 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:38 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:38 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:38 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:38 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:38 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:38 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:38 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:38 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:38.874483 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc00024aba0 {
}

2025/12/19 11:09:38 ==> Preload func main
2025/12/19 11:09:38 ==> Load func main
2025/12/19 11:09:38.874569 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:09:38 NewFunc main func()
2025/12/19 11:09:38 DefineVarStart [arr]
2025/12/19 11:09:38 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:38.874647 [INFO] typesutil/gopinfo.go:215: ==> Type: &{10 INT 1 <nil>} untyped int
2025/12/19 11:09:38 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:38.874677 [INFO] typesutil/gopinfo.go:215: ==> Type: &{13 INT 2 <nil>} untyped int
2025/12/19 11:09:38 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:38.874702 [INFO] typesutil/gopinfo.go:215: ==> Type: &{16 INT 3 <nil>} untyped int
2025/12/19 11:09:38 Val &{0 FLOAT 4.1} *ast.BasicLit
2025/12/19 11:09:38.874744 [INFO] typesutil/gopinfo.go:215: ==> Type: &{19 FLOAT 4.1 <nil>} untyped float
2025/12/19 11:09:38 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:09:38.874770 [INFO] typesutil/gopinfo.go:215: ==> Type: &{24 INT 5 <nil>} untyped int
2025/12/19 11:09:38 Val &{0 INT 6} *ast.BasicLit
2025/12/19 11:09:38.874794 [INFO] typesutil/gopinfo.go:215: ==> Type: &{27 INT 6 <nil>} untyped int
2025/12/19 11:09:38 SliceLit <nil> 6 false
2025/12/19 11:09:38 EndInit 1
2025/12/19 11:09:38.874835 [INFO] typesutil/gopinfo.go:251: ==> Def: arr var arr []float64
2025/12/19 11:09:38 DefineVarStart [x]
2025/12/19 11:09:38 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:09:38 ForRange [_ b]
2025/12/19 11:09:38 Val arr []float64
2025/12/19 11:09:38.874901 [INFO] typesutil/gopinfo.go:265: ==> Use: arr var arr []float64
2025/12/19 11:09:38.874918 [INFO] typesutil/gopinfo.go:215: ==> Type: arr []float64
2025/12/19 11:09:38 RangeAssignThen
2025/12/19 11:09:38.874940 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b float64
2025/12/19 11:09:38.874962 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc00024aea0 {
.  var b float64
}

2025/12/19 11:09:38 If
2025/12/19 11:09:38 Val b float64
2025/12/19 11:09:38.874995 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b float64
2025/12/19 11:09:38.875010 [INFO] typesutil/gopinfo.go:215: ==> Type: b float64
2025/12/19 11:09:38 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:38.875044 [INFO] typesutil/gopinfo.go:215: ==> Type: &{81 INT 2 <nil>} untyped int
2025/12/19 11:09:38 BinaryOp >
2025/12/19 11:09:38 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:38 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:38 ==> MatchType untyped int (2), unboundFuncParam{typ: float64}
2025/12/19 11:09:38.875144 [INFO] typesutil/gopinfo.go:215: ==> Type: &{b 79 > 0xc00049ed20} untyped bool
2025/12/19 11:09:38 Then
2025/12/19 11:09:38 ForRange [_ a]
2025/12/19 11:09:38 Val arr []float64
2025/12/19 11:09:38.875181 [INFO] typesutil/gopinfo.go:265: ==> Use: arr var arr []float64
2025/12/19 11:09:38.875197 [INFO] typesutil/gopinfo.go:215: ==> Type: arr []float64
2025/12/19 11:09:38 RangeAssignThen
2025/12/19 11:09:38.875220 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a float64
2025/12/19 11:09:38.875240 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc00024b140 {
.  var a float64
}

2025/12/19 11:09:38 If
2025/12/19 11:09:38 Val a float64
2025/12/19 11:09:38.875267 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a float64
2025/12/19 11:09:38.875284 [INFO] typesutil/gopinfo.go:215: ==> Type: a float64
2025/12/19 11:09:38 Val b float64
2025/12/19 11:09:38.875305 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b float64
2025/12/19 11:09:38.875315 [INFO] typesutil/gopinfo.go:215: ==> Type: b float64
2025/12/19 11:09:38 BinaryOp <
2025/12/19 11:09:38 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:38 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:38 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:38.875382 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 59 < b} untyped bool
2025/12/19 11:09:38 Then
2025/12/19 11:09:38 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:38 Val append func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:38 Val _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:09:38 Val a float64
2025/12/19 11:09:38.875438 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a float64
2025/12/19 11:09:38.875448 [INFO] typesutil/gopinfo.go:215: ==> Type: a float64
2025/12/19 11:09:38 Val b float64
2025/12/19 11:09:38.875465 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b float64
2025/12/19 11:09:38.875478 [INFO] typesutil/gopinfo.go:215: ==> Type: b float64
2025/12/19 11:09:38 SliceLit <nil> 2 false
2025/12/19 11:09:38 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:38 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:38 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/12/19 11:09:38 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/12/19 11:09:38 ==> MatchType unboundType{typ: <nil>}, []unboundFuncParam{typ: <nil>}
2025/12/19 11:09:38 ==> MatchType []float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:38 Assign 1 1
2025/12/19 11:09:38 ==> MatchType [][]float64, unboundType{typ: <nil>}
2025/12/19 11:09:38 End // If
2025/12/19 11:09:38 End // ForRange
2025/12/19 11:09:38 End // If
2025/12/19 11:09:38 End // ForRange
2025/12/19 11:09:38 Return 0
2025/12/19 11:09:38 End // Func
2025/12/19 11:09:38 Call 0 0 // func() (_xgo_ret [][]float64)
2025/12/19 11:09:38 ==> MatchFuncCall func() (_xgo_ret [][]float64) args: 0 flags: 0
2025/12/19 11:09:38 EndInit 1
2025/12/19 11:09:38.875660 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x [][]float64
2025/12/19 11:09:38 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:38.875694 [INFO] typesutil/gopinfo.go:265: ==> Use: println builtin println
2025/12/19 11:09:38.875708 [INFO] typesutil/gopinfo.go:215: ==> Type: println invalid type
2025/12/19 11:09:38 Val &{0 STRING "x:"} *ast.BasicLit
2025/12/19 11:09:38.875738 [INFO] typesutil/gopinfo.go:215: ==> Type: &{92 STRING "x:" <nil>} untyped string
2025/12/19 11:09:38 Val x [][]float64
2025/12/19 11:09:38.875764 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x [][]float64
2025/12/19 11:09:38.875781 [INFO] typesutil/gopinfo.go:215: ==> Type: x [][]float64
2025/12/19 11:09:38 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:38 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:38 ==> MatchFuncCall func(a ...any) (n int, err error) args: 2 flags: 0
2025/12/19 11:09:38 ==> MatchType untyped string ("x:"), any
2025/12/19 11:09:38 ==> MatchType [][]float64, any
2025/12/19 11:09:38.875865 [INFO] typesutil/gopinfo.go:265: ==> Use: println func fmt.Println(a ...any) (n int, err error)
2025/12/19 11:09:38.875885 [INFO] typesutil/gopinfo.go:215: ==> Type: println func(a ...any) (n int, err error)
2025/12/19 11:09:38.875912 [INFO] typesutil/gopinfo.go:215: ==> Type: &{println 91 [0xc00049ed80 x] 0 [] 99 0} (n int, err error)
2025/12/19 11:09:38.875940 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc00024ac60 {
.  var arr []float64
.  var x [][]float64
}

2025/12/19 11:09:38 End // Func
    info_test.go:190: == types ==
        000:  2: 9 | 1                   *ast.BasicLit                  | value   : untyped int = 1 | constant
        001:  2:12 | 2                   *ast.BasicLit                  | value   : untyped int = 2 | constant
        002:  2:15 | 3                   *ast.BasicLit                  | value   : untyped int = 3 | constant
        003:  2:18 | 4.1                 *ast.BasicLit                  | value   : untyped float = 4.1 | constant
        004:  2:23 | 5                   *ast.BasicLit                  | value   : untyped int = 5 | constant
        005:  2:26 | 6                   *ast.BasicLit                  | value   : untyped int = 6 | constant
        006:  3: 8 | a                   *ast.Ident                     | var     : float64 | variable
        007:  3:11 | b                   *ast.Ident                     | var     : float64 | variable
        008:  3:23 | arr                 *ast.Ident                     | var     : []float64 | variable
        009:  3:28 | a                   *ast.Ident                     | var     : float64 | variable
        010:  3:28 | a < b               *ast.BinaryExpr                | value   : untyped bool | value
        011:  3:32 | b                   *ast.Ident                     | var     : float64 | variable
        012:  3:43 | arr                 *ast.Ident                     | var     : []float64 | variable
        013:  3:48 | b                   *ast.Ident                     | var     : float64 | variable
        014:  3:48 | b > 2               *ast.BinaryExpr                | value   : untyped bool | value
        015:  3:52 | 2                   *ast.BasicLit                  | value   : untyped int = 2 | constant
        016:  4: 1 | println             *ast.Ident                     | value   : func(a ...any) (n int, err error) | value
        017:  4: 1 | println("x:", x)    *ast.CallExpr                  | value   : (n int, err error) | value
        018:  4: 9 | "x:"                *ast.BasicLit                  | value   : untyped string = "x:" | constant
        019:  4:15 | x                   *ast.Ident                     | var     : [][]float64 | variable
        == defs ==
        000:  2: 1 | arr                 | var arr []float64
        001:  2: 1 | main                | func main.main()
        002:  3: 1 | x                   | var x [][]float64
        003:  3:18 | a                   | var a float64
        004:  3:38 | b                   | var b float64
        == uses ==
        000:  3: 8 | a                   | var a float64
        001:  3:11 | b                   | var b float64
        002:  3:23 | arr                 | var arr []float64
        003:  3:28 | a                   | var a float64
        004:  3:32 | b                   | var b float64
        005:  3:43 | arr                 | var arr []float64
        006:  3:48 | b                   | var b float64
        007:  4: 1 | println             | func fmt.Println(a ...any) (n int, err error)
        008:  4:15 | x                   | var x [][]float64
--- PASS: TestListComprehensionMultiLevel (1.02s)
=== RUN   TestFileEnumLines
2025/12/19 11:09:38.877073 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:09:39 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:39 ==> NewOverloadFunc NewRange
2025/12/19 11:09:39 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:39 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:39 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:39 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:39 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:39 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:39 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:39 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:39 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:39 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:39 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:39 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:39 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:39 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:39 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:39 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:39 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:39 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:39 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:39 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:39 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:39 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:39 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:39 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:39 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:39 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:39 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:39 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:39 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:39 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:39 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:39 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:39 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:39 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:39 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:39 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:39 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:39 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:39 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:39 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:39 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:39 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:39.929901 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc00021ccc0 {
}

2025/12/19 11:09:39.929945 [INFO] typesutil/gopinfo.go:292: ==> Implicit: package os
2025/12/19 11:09:39 ==> Preload func main
2025/12/19 11:09:39 ==> Load func main
2025/12/19 11:09:39.929987 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:09:39 NewFunc main func()
2025/12/19 11:09:39 ForRange [_ line]
2025/12/19 11:09:39.930018 [INFO] typesutil/gopinfo.go:265: ==> Use: os package os
2025/12/19 11:09:39.930036 [INFO] typesutil/gopinfo.go:265: ==> Use: Stdin var os.Stdin *os.File
2025/12/19 11:09:39 Val Stdin *os.File
2025/12/19 11:09:39.930061 [INFO] typesutil/gopinfo.go:215: ==> Type: &{os Stdin} *os.File
2025/12/19 11:09:39 RangeAssignThen
2025/12/19 11:09:39.930082 [INFO] typesutil/gopinfo.go:251: ==> Def: line var line string
2025/12/19 11:09:39.930096 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc00021cea0 {
.  var line string
}

2025/12/19 11:09:39 VBlock
2025/12/19 11:09:39 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39.930120 [INFO] typesutil/gopinfo.go:265: ==> Use: println builtin println
2025/12/19 11:09:39.930129 [INFO] typesutil/gopinfo.go:215: ==> Type: println invalid type
2025/12/19 11:09:39 Val line string
2025/12/19 11:09:39.930143 [INFO] typesutil/gopinfo.go:265: ==> Use: line var line string
2025/12/19 11:09:39.930151 [INFO] typesutil/gopinfo.go:215: ==> Type: line string
2025/12/19 11:09:39 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:39 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType string, any
2025/12/19 11:09:39.930214 [INFO] typesutil/gopinfo.go:265: ==> Use: println func fmt.Println(a ...any) (n int, err error)
2025/12/19 11:09:39.930230 [INFO] typesutil/gopinfo.go:215: ==> Type: println func(a ...any) (n int, err error)
2025/12/19 11:09:39.930247 [INFO] typesutil/gopinfo.go:215: ==> Type: &{println 0 [line] 0 [] 0 51} (n int, err error)
2025/12/19 11:09:39.930262 [INFO] typesutil/gopinfo.go:332: ==> Scope: vblock statement scope 0xc00021cfc0 {
}

2025/12/19 11:09:39 End // Vblock
2025/12/19 11:09:39 End // ForRange
2025/12/19 11:09:39 Member Gop_Enum 0 // *os.File
2025/12/19 11:09:39 Val EnumLines func(r io.Reader) github.com/qiniu/x/osx.LineIter
2025/12/19 11:09:39 Call 1 0 // func(r io.Reader) github.com/qiniu/x/osx.LineIter
2025/12/19 11:09:39 ==> MatchFuncCall func(r io.Reader) github.com/qiniu/x/osx.LineIter args: 1 flags: 0
2025/12/19 11:09:39 ==> MatchType *os.File, io.Reader
2025/12/19 11:09:39 ==> EnsureLoaded io.Reader
2025/12/19 11:09:39.930341 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc00021ce40 {
}

2025/12/19 11:09:39 End // Func
    info_test.go:190: == types ==
        000:  4:13 | os.Stdin            *ast.SelectorExpr              | var     : *os.File | variable
        001:  5: 2 | println             *ast.Ident                     | value   : func(a ...any) (n int, err error) | value
        002:  5: 2 | println line        *ast.CallExpr                  | value   : (n int, err error) | value
        003:  5:10 | line                *ast.Ident                     | var     : string | variable
        == defs ==
        000:  4: 1 | main                | func main.main()
        001:  4: 5 | line                | var line string
        == uses ==
        000:  4:13 | os                  | package os
        001:  4:16 | Stdin               | var os.Stdin *os.File
        002:  5: 2 | println             | func fmt.Println(a ...any) (n int, err error)
        003:  5:10 | line                | var line string
--- PASS: TestFileEnumLines (1.05s)
=== RUN   TestLambdaExpr
2025/12/19 11:09:39.931067 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:09:40 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:40 ==> NewOverloadFunc NewRange
2025/12/19 11:09:40 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:40 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:40 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:40 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:40 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:40 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:40 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:40 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:40 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:40 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:40 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:40 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:40 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:40 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:40 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:40 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:40 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:40 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:40 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:40 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:40 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:40 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:40 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:40 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:40 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:40 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:40 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:40 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:40 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:40 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:40 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:40 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:40 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:40 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:40 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:40 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:40 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:40 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:40 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:40 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:40 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:40 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:41.009564 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc00024aba0 {
}

2025/12/19 11:09:41 ==> Preload func Map
2025/12/19 11:09:41 ==> Preload func Map2
2025/12/19 11:09:41 ==> Preload func main
2025/12/19 11:09:41 ==> Load func Map
2025/12/19 11:09:41.009652 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/12/19 11:09:41.009672 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:41.009684 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:41.009705 [INFO] typesutil/gopinfo.go:215: ==> Type: &{25 <nil> float64} []float64
2025/12/19 11:09:41.009718 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c []float64
2025/12/19 11:09:41.009730 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/12/19 11:09:41.009739 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:41.009749 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:41.009760 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/12/19 11:09:41.009769 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:41.009777 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:41.009799 [INFO] typesutil/gopinfo.go:215: ==> Type: &{38 <nil> 0xc00036fb30 0xc00036fb60} func(float64) float64
2025/12/19 11:09:41.009822 [INFO] typesutil/gopinfo.go:251: ==> Def: t var t func(float64) float64
2025/12/19 11:09:41.009840 [INFO] typesutil/gopinfo.go:251: ==> Def: Map func main.Map(c []float64, t func(float64) float64)
2025/12/19 11:09:41 NewFunc Map func(c []float64, t func(float64) float64)
2025/12/19 11:09:41.009877 [INFO] typesutil/gopinfo.go:332: ==> Scope: func Map scope 0xc00024ba40 {
.  var c []float64
.  var t func(float64) float64
}

2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Load func Map2
2025/12/19 11:09:41.009909 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/12/19 11:09:41.009919 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:41.009929 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:41.009943 [INFO] typesutil/gopinfo.go:215: ==> Type: &{86 <nil> float64} []float64
2025/12/19 11:09:41.009954 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c []float64
2025/12/19 11:09:41.009967 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/12/19 11:09:41.009978 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:41.009986 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:41.009996 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/12/19 11:09:41.010008 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:41.010019 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:41.010030 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/12/19 11:09:41.010039 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:41.010050 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:41.010064 [INFO] typesutil/gopinfo.go:215: ==> Type: &{99 <nil> 0xc00036fce0 0xc00036fd10} func(float64) (float64, float64)
2025/12/19 11:09:41.010076 [INFO] typesutil/gopinfo.go:251: ==> Def: t var t func(float64) (float64, float64)
2025/12/19 11:09:41.010091 [INFO] typesutil/gopinfo.go:251: ==> Def: Map2 func main.Map2(c []float64, t func(float64) (float64, float64))
2025/12/19 11:09:41 NewFunc Map2 func(c []float64, t func(float64) (float64, float64))
2025/12/19 11:09:41.010120 [INFO] typesutil/gopinfo.go:332: ==> Scope: func Map2 scope 0xc0001c2180 {
.  var c []float64
.  var t func(float64) (float64, float64)
}

2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 ==> Load func main
2025/12/19 11:09:41.010148 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:09:41 NewFunc main func()
2025/12/19 11:09:41 Val Map func(c []float64, t func(float64) float64)
2025/12/19 11:09:41.010182 [INFO] typesutil/gopinfo.go:265: ==> Use: Map func main.Map(c []float64, t func(float64) float64)
2025/12/19 11:09:41.010197 [INFO] typesutil/gopinfo.go:215: ==> Type: Map func(c []float64, t func(float64) float64)
2025/12/19 11:09:41 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/12/19 11:09:41.010244 [INFO] typesutil/gopinfo.go:215: ==> Type: &{151 FLOAT 1.2 <nil>} untyped float
2025/12/19 11:09:41 Val &{0 FLOAT 3.5} *ast.BasicLit
2025/12/19 11:09:41.010280 [INFO] typesutil/gopinfo.go:215: ==> Type: &{156 FLOAT 3.5 <nil>} untyped float
2025/12/19 11:09:41 Val &{0 INT 6} *ast.BasicLit
2025/12/19 11:09:41.010318 [INFO] typesutil/gopinfo.go:215: ==> Type: &{161 INT 6 <nil>} untyped int
2025/12/19 11:09:41 SliceLit []float64 3 false
2025/12/19 11:09:41.010355 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x float64
2025/12/19 11:09:41 NewClosure func(x float64) float64
2025/12/19 11:09:41.010385 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x float64
2025/12/19 11:09:41 Val x float64
2025/12/19 11:09:41.010407 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/12/19 11:09:41.010422 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/12/19 11:09:41 Val x float64
2025/12/19 11:09:41.010442 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/12/19 11:09:41.010453 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/12/19 11:09:41 BinaryOp *
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:41.010539 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 172 * x} float64
2025/12/19 11:09:41.010558 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0001c23c0 {
.  var x float64
}

2025/12/19 11:09:41 Return 1
2025/12/19 11:09:41 ==> MatchType float64, float64
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 Call 2 0 // func(c []float64, t func(float64) float64)
2025/12/19 11:09:41 ==> MatchFuncCall func(c []float64, t func(float64) float64) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType []float64, []float64
2025/12/19 11:09:41 ==> MatchType func(x float64) float64, func(float64) float64
2025/12/19 11:09:41.010677 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Map 149 [0xc00036fef0 0xc00071db30] 0 [] 175 0} ()
2025/12/19 11:09:41 Val Map2 func(c []float64, t func(float64) (float64, float64))
2025/12/19 11:09:41.010712 [INFO] typesutil/gopinfo.go:265: ==> Use: Map2 func main.Map2(c []float64, t func(float64) (float64, float64))
2025/12/19 11:09:41.010727 [INFO] typesutil/gopinfo.go:215: ==> Type: Map2 func(c []float64, t func(float64) (float64, float64))
2025/12/19 11:09:41 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/12/19 11:09:41.010757 [INFO] typesutil/gopinfo.go:215: ==> Type: &{183 FLOAT 1.2 <nil>} untyped float
2025/12/19 11:09:41 Val &{0 FLOAT 3.5} *ast.BasicLit
2025/12/19 11:09:41.010789 [INFO] typesutil/gopinfo.go:215: ==> Type: &{188 FLOAT 3.5 <nil>} untyped float
2025/12/19 11:09:41 Val &{0 INT 6} *ast.BasicLit
2025/12/19 11:09:41.010808 [INFO] typesutil/gopinfo.go:215: ==> Type: &{193 INT 6 <nil>} untyped int
2025/12/19 11:09:41 SliceLit []float64 3 false
2025/12/19 11:09:41.010830 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x float64
2025/12/19 11:09:41 NewClosure func(x float64) (float64, float64)
2025/12/19 11:09:41.010853 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x float64
2025/12/19 11:09:41 Val x float64
2025/12/19 11:09:41.010869 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/12/19 11:09:41.010879 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/12/19 11:09:41 Val x float64
2025/12/19 11:09:41.010894 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/12/19 11:09:41.010905 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/12/19 11:09:41 BinaryOp *
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:41.010957 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 205 * x} float64
2025/12/19 11:09:41 Val x float64
2025/12/19 11:09:41.010976 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/12/19 11:09:41.010994 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/12/19 11:09:41 Val x float64
2025/12/19 11:09:41.011014 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/12/19 11:09:41.011026 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/12/19 11:09:41 BinaryOp +
2025/12/19 11:09:41 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:41 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:41.011089 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 212 + x} float64
2025/12/19 11:09:41.011104 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0001c2720 {
.  var x float64
}

2025/12/19 11:09:41 Return 2
2025/12/19 11:09:41 ==> MatchType float64, float64
2025/12/19 11:09:41 ==> MatchType float64, float64
2025/12/19 11:09:41 End // Func
2025/12/19 11:09:41 Call 2 0 // func(c []float64, t func(float64) (float64, float64))
2025/12/19 11:09:41 ==> MatchFuncCall func(c []float64, t func(float64) (float64, float64)) args: 2 flags: 0
2025/12/19 11:09:41 ==> MatchType []float64, []float64
2025/12/19 11:09:41 ==> MatchType func(x float64) (float64, float64), func(float64) (float64, float64)
2025/12/19 11:09:41.011186 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Map2 181 [0xc0003740c0 0xc00071db80] 0 [] 216 0} ()
2025/12/19 11:09:41.011198 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0001c2240 {
}

2025/12/19 11:09:41 End // Func
    info_test.go:190: == types ==
        000:  2:12 | []float64           *ast.ArrayType                 | type    : []float64 | type
        001:  2:14 | float64             *ast.Ident                     | type    : float64 | type
        002:  2:25 | func(float64) float64 *ast.FuncType                  | type    : func(float64) float64 | type
        003:  2:30 | float64             *ast.Ident                     | type    : float64 | type
        004:  2:39 | float64             *ast.Ident                     | type    : float64 | type
        005:  6:13 | []float64           *ast.ArrayType                 | type    : []float64 | type
        006:  6:15 | float64             *ast.Ident                     | type    : float64 | type
        007:  6:26 | func(float64) (float64, float64) *ast.FuncType                  | type    : func(float64) (float64, float64) | type
        008:  6:31 | float64             *ast.Ident                     | type    : float64 | type
        009:  6:41 | float64             *ast.Ident                     | type    : float64 | type
        010:  6:50 | float64             *ast.Ident                     | type    : float64 | type
        011: 10: 1 | Map                 *ast.Ident                     | value   : func(c []float64, t func(float64) float64) | value
        012: 10: 1 | Map([1.2, 3.5, 6], x => x * x) *ast.CallExpr                  | void    : () | no value
        013: 10: 6 | 1.2                 *ast.BasicLit                  | value   : untyped float = 1.2 | constant
        014: 10:11 | 3.5                 *ast.BasicLit                  | value   : untyped float = 3.5 | constant
        015: 10:16 | 6                   *ast.BasicLit                  | value   : untyped int = 6 | constant
        016: 10:25 | x                   *ast.Ident                     | var     : float64 | variable
        017: 10:25 | x * x               *ast.BinaryExpr                | value   : float64 | value
        018: 10:29 | x                   *ast.Ident                     | var     : float64 | variable
        019: 11: 1 | Map2                *ast.Ident                     | value   : func(c []float64, t func(float64) (float64, float64)) | value
        020: 11: 1 | Map2([1.2, 3.5, 6], x => (x * x, x + x)) *ast.CallExpr                  | void    : () | no value
        021: 11: 7 | 1.2                 *ast.BasicLit                  | value   : untyped float = 1.2 | constant
        022: 11:12 | 3.5                 *ast.BasicLit                  | value   : untyped float = 3.5 | constant
        023: 11:17 | 6                   *ast.BasicLit                  | value   : untyped int = 6 | constant
        024: 11:27 | x                   *ast.Ident                     | var     : float64 | variable
        025: 11:27 | x * x               *ast.BinaryExpr                | value   : float64 | value
        026: 11:31 | x                   *ast.Ident                     | var     : float64 | variable
        027: 11:34 | x                   *ast.Ident                     | var     : float64 | variable
        028: 11:34 | x + x               *ast.BinaryExpr                | value   : float64 | value
        029: 11:38 | x                   *ast.Ident                     | var     : float64 | variable
        == defs ==
        000:  2: 6 | Map                 | func main.Map(c []float64, t func(float64) float64)
        001:  2:10 | c                   | var c []float64
        002:  2:23 | t                   | var t func(float64) float64
        003:  6: 6 | Map2                | func main.Map2(c []float64, t func(float64) (float64, float64))
        004:  6:11 | c                   | var c []float64
        005:  6:24 | t                   | var t func(float64) (float64, float64)
        006: 10: 1 | main                | func main.main()
        007: 10:20 | x                   | var x float64
        008: 11:21 | x                   | var x float64
        == uses ==
        000:  2:14 | float64             | type float64
        001:  2:30 | float64             | type float64
        002:  2:39 | float64             | type float64
        003:  6:15 | float64             | type float64
        004:  6:31 | float64             | type float64
        005:  6:41 | float64             | type float64
        006:  6:50 | float64             | type float64
        007: 10: 1 | Map                 | func main.Map(c []float64, t func(float64) float64)
        008: 10:25 | x                   | var x float64
        009: 10:29 | x                   | var x float64
        010: 11: 1 | Map2                | func main.Map2(c []float64, t func(float64) (float64, float64))
        011: 11:27 | x                   | var x float64
        012: 11:31 | x                   | var x float64
        013: 11:34 | x                   | var x float64
        014: 11:38 | x                   | var x float64
--- PASS: TestLambdaExpr (1.08s)
=== RUN   TestLambdaExpr2
2025/12/19 11:09:41.012510 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:09:41 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:41 ==> NewOverloadFunc NewRange
2025/12/19 11:09:41 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:41 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:41 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:41 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:41 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:41 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:41 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:41 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:41 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:41 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:41 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:41 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:41 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:41 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:41 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:41 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:41 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:41 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:41 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:41 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:41 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:41 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:41 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:41 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:41 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:41 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:41 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:41 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:41 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:41 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:41 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:41 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:41 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:41 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:41 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:41 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:41 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:41 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:41 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:41 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:41 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:41 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:42.129212 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc000389500 {
}

2025/12/19 11:09:42 ==> Preload func Map
2025/12/19 11:09:42 ==> Preload func Map2
2025/12/19 11:09:42 ==> Preload func main
2025/12/19 11:09:42 ==> Load func Map
2025/12/19 11:09:42.129307 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/12/19 11:09:42.129328 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:42.129342 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:42.129366 [INFO] typesutil/gopinfo.go:215: ==> Type: &{25 <nil> float64} []float64
2025/12/19 11:09:42.129386 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c []float64
2025/12/19 11:09:42.129401 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/12/19 11:09:42.129412 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:42.129424 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:42.129437 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/12/19 11:09:42.129450 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:42.129461 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:42.129481 [INFO] typesutil/gopinfo.go:215: ==> Type: &{38 <nil> 0xc00049f7d0 0xc00049f800} func(float64) float64
2025/12/19 11:09:42.129494 [INFO] typesutil/gopinfo.go:251: ==> Def: t var t func(float64) float64
2025/12/19 11:09:42.129518 [INFO] typesutil/gopinfo.go:251: ==> Def: Map func main.Map(c []float64, t func(float64) float64)
2025/12/19 11:09:42 NewFunc Map func(c []float64, t func(float64) float64)
2025/12/19 11:09:42.129564 [INFO] typesutil/gopinfo.go:332: ==> Scope: func Map scope 0xc000389740 {
.  var c []float64
.  var t func(float64) float64
}

2025/12/19 11:09:42 End // Func
2025/12/19 11:09:42 ==> Load func Map2
2025/12/19 11:09:42.129603 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/12/19 11:09:42.129616 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:42.129627 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:42.129643 [INFO] typesutil/gopinfo.go:215: ==> Type: &{86 <nil> float64} []float64
2025/12/19 11:09:42.129659 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c []float64
2025/12/19 11:09:42.129671 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/12/19 11:09:42.129682 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:42.129693 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:42.129703 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/12/19 11:09:42.129718 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:42.129730 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:42.129750 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/12/19 11:09:42.129761 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:42.129772 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:09:42.129790 [INFO] typesutil/gopinfo.go:215: ==> Type: &{99 <nil> 0xc00049f980 0xc00049f9b0} func(float64) (float64, float64)
2025/12/19 11:09:42.129804 [INFO] typesutil/gopinfo.go:251: ==> Def: t var t func(float64) (float64, float64)
2025/12/19 11:09:42.129822 [INFO] typesutil/gopinfo.go:251: ==> Def: Map2 func main.Map2(c []float64, t func(float64) (float64, float64))
2025/12/19 11:09:42 NewFunc Map2 func(c []float64, t func(float64) (float64, float64))
2025/12/19 11:09:42.129859 [INFO] typesutil/gopinfo.go:332: ==> Scope: func Map2 scope 0xc0003899e0 {
.  var c []float64
.  var t func(float64) (float64, float64)
}

2025/12/19 11:09:42 End // Func
2025/12/19 11:09:42 ==> Load func main
2025/12/19 11:09:42.129897 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:09:42 NewFunc main func()
2025/12/19 11:09:42 Val Map func(c []float64, t func(float64) float64)
2025/12/19 11:09:42.129937 [INFO] typesutil/gopinfo.go:265: ==> Use: Map func main.Map(c []float64, t func(float64) float64)
2025/12/19 11:09:42.129951 [INFO] typesutil/gopinfo.go:215: ==> Type: Map func(c []float64, t func(float64) float64)
2025/12/19 11:09:42 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/12/19 11:09:42.130006 [INFO] typesutil/gopinfo.go:215: ==> Type: &{151 FLOAT 1.2 <nil>} untyped float
2025/12/19 11:09:42 Val &{0 FLOAT 3.5} *ast.BasicLit
2025/12/19 11:09:42.130045 [INFO] typesutil/gopinfo.go:215: ==> Type: &{156 FLOAT 3.5 <nil>} untyped float
2025/12/19 11:09:42 Val &{0 INT 6} *ast.BasicLit
2025/12/19 11:09:42.130076 [INFO] typesutil/gopinfo.go:215: ==> Type: &{161 INT 6 <nil>} untyped int
2025/12/19 11:09:42 SliceLit []float64 3 false
2025/12/19 11:09:42.130109 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x float64
2025/12/19 11:09:42 NewClosure func(x float64) float64
2025/12/19 11:09:42.130136 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x float64
2025/12/19 11:09:42 Val x float64
2025/12/19 11:09:42.130161 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/12/19 11:09:42.130175 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/12/19 11:09:42 Val x float64
2025/12/19 11:09:42.130194 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/12/19 11:09:42.130214 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/12/19 11:09:42 BinaryOp *
2025/12/19 11:09:42 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:42 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:42.130298 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 182 * x} float64
2025/12/19 11:09:42 Return 1
2025/12/19 11:09:42 ==> MatchType float64, float64
2025/12/19 11:09:42.130332 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc000389c20 {
.  var x float64
}

2025/12/19 11:09:42 End // Func
2025/12/19 11:09:42 Call 2 0 // func(c []float64, t func(float64) float64)
2025/12/19 11:09:42 ==> MatchFuncCall func(c []float64, t func(float64) float64) args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchType []float64, []float64
2025/12/19 11:09:42 ==> MatchType func(x float64) float64, func(float64) float64
2025/12/19 11:09:42.130426 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Map 149 [0xc00049fb90 0xc00061ec00] 0 [] 187 0} ()
2025/12/19 11:09:42 Val Map2 func(c []float64, t func(float64) (float64, float64))
2025/12/19 11:09:42.130461 [INFO] typesutil/gopinfo.go:265: ==> Use: Map2 func main.Map2(c []float64, t func(float64) (float64, float64))
2025/12/19 11:09:42.130476 [INFO] typesutil/gopinfo.go:215: ==> Type: Map2 func(c []float64, t func(float64) (float64, float64))
2025/12/19 11:09:42 Val &{0 FLOAT 1.2} *ast.BasicLit
2025/12/19 11:09:42.130511 [INFO] typesutil/gopinfo.go:215: ==> Type: &{195 FLOAT 1.2 <nil>} untyped float
2025/12/19 11:09:42 Val &{0 FLOAT 3.5} *ast.BasicLit
2025/12/19 11:09:42.130545 [INFO] typesutil/gopinfo.go:215: ==> Type: &{200 FLOAT 3.5 <nil>} untyped float
2025/12/19 11:09:42 Val &{0 INT 6} *ast.BasicLit
2025/12/19 11:09:42.130566 [INFO] typesutil/gopinfo.go:215: ==> Type: &{205 INT 6 <nil>} untyped int
2025/12/19 11:09:42 SliceLit []float64 3 false
2025/12/19 11:09:42.130589 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x float64
2025/12/19 11:09:42 NewClosure func(x float64) (float64, float64)
2025/12/19 11:09:42.130619 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x float64
2025/12/19 11:09:42 Val x float64
2025/12/19 11:09:42.130641 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/12/19 11:09:42.130652 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/12/19 11:09:42 Val x float64
2025/12/19 11:09:42.130670 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/12/19 11:09:42.130681 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/12/19 11:09:42 BinaryOp *
2025/12/19 11:09:42 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:42 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:42.130749 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 226 * x} float64
2025/12/19 11:09:42 Val x float64
2025/12/19 11:09:42.130768 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/12/19 11:09:42.130786 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/12/19 11:09:42 Val x float64
2025/12/19 11:09:42.130809 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/12/19 11:09:42.130822 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/12/19 11:09:42 BinaryOp +
2025/12/19 11:09:42 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:42 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:09:42.130881 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 233 + x} float64
2025/12/19 11:09:42 Return 2
2025/12/19 11:09:42 ==> MatchType float64, float64
2025/12/19 11:09:42 ==> MatchType float64, float64
2025/12/19 11:09:42.130923 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0003a2000 {
.  var x float64
}

2025/12/19 11:09:42 End // Func
2025/12/19 11:09:42 Call 2 0 // func(c []float64, t func(float64) (float64, float64))
2025/12/19 11:09:42 ==> MatchFuncCall func(c []float64, t func(float64) (float64, float64)) args: 2 flags: 0
2025/12/19 11:09:42 ==> MatchType []float64, []float64
2025/12/19 11:09:42 ==> MatchType func(x float64) (float64, float64), func(float64) (float64, float64)
2025/12/19 11:09:42.131000 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Map2 193 [0xc00049fce0 0xc00061ec40] 0 [] 238 0} ()
2025/12/19 11:09:42.131014 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc000389aa0 {
}

2025/12/19 11:09:42 End // Func
    info_test.go:190: == types ==
        000:  2:12 | []float64           *ast.ArrayType                 | type    : []float64 | type
        001:  2:14 | float64             *ast.Ident                     | type    : float64 | type
        002:  2:25 | func(float64) float64 *ast.FuncType                  | type    : func(float64) float64 | type
        003:  2:30 | float64             *ast.Ident                     | type    : float64 | type
        004:  2:39 | float64             *ast.Ident                     | type    : float64 | type
        005:  6:13 | []float64           *ast.ArrayType                 | type    : []float64 | type
        006:  6:15 | float64             *ast.Ident                     | type    : float64 | type
        007:  6:26 | func(float64) (float64, float64) *ast.FuncType                  | type    : func(float64) (float64, float64) | type
        008:  6:31 | float64             *ast.Ident                     | type    : float64 | type
        009:  6:41 | float64             *ast.Ident                     | type    : float64 | type
        010:  6:50 | float64             *ast.Ident                     | type    : float64 | type
        011: 10: 1 | Map                 *ast.Ident                     | value   : func(c []float64, t func(float64) float64) | value
        012: 10: 1 | Map([1.2, 3.5, 6], x => {
        	return x * x
        }) *ast.CallExpr                  | void    : () | no value
        013: 10: 6 | 1.2                 *ast.BasicLit                  | value   : untyped float = 1.2 | constant
        014: 10:11 | 3.5                 *ast.BasicLit                  | value   : untyped float = 3.5 | constant
        015: 10:16 | 6                   *ast.BasicLit                  | value   : untyped int = 6 | constant
        016: 11: 9 | x                   *ast.Ident                     | var     : float64 | variable
        017: 11: 9 | x * x               *ast.BinaryExpr                | value   : float64 | value
        018: 11:13 | x                   *ast.Ident                     | var     : float64 | variable
        019: 13: 1 | Map2                *ast.Ident                     | value   : func(c []float64, t func(float64) (float64, float64)) | value
        020: 13: 1 | Map2([1.2, 3.5, 6], x => {
        	return x * x, x + x
        }) *ast.CallExpr                  | void    : () | no value
        021: 13: 7 | 1.2                 *ast.BasicLit                  | value   : untyped float = 1.2 | constant
        022: 13:12 | 3.5                 *ast.BasicLit                  | value   : untyped float = 3.5 | constant
        023: 13:17 | 6                   *ast.BasicLit                  | value   : untyped int = 6 | constant
        024: 14: 9 | x                   *ast.Ident                     | var     : float64 | variable
        025: 14: 9 | x * x               *ast.BinaryExpr                | value   : float64 | value
        026: 14:13 | x                   *ast.Ident                     | var     : float64 | variable
        027: 14:16 | x                   *ast.Ident                     | var     : float64 | variable
        028: 14:16 | x + x               *ast.BinaryExpr                | value   : float64 | value
        029: 14:20 | x                   *ast.Ident                     | var     : float64 | variable
        == defs ==
        000:  2: 6 | Map                 | func main.Map(c []float64, t func(float64) float64)
        001:  2:10 | c                   | var c []float64
        002:  2:23 | t                   | var t func(float64) float64
        003:  6: 6 | Map2                | func main.Map2(c []float64, t func(float64) (float64, float64))
        004:  6:11 | c                   | var c []float64
        005:  6:24 | t                   | var t func(float64) (float64, float64)
        006: 10: 1 | main                | func main.main()
        007: 10:20 | x                   | var x float64
        008: 13:21 | x                   | var x float64
        == uses ==
        000:  2:14 | float64             | type float64
        001:  2:30 | float64             | type float64
        002:  2:39 | float64             | type float64
        003:  6:15 | float64             | type float64
        004:  6:31 | float64             | type float64
        005:  6:41 | float64             | type float64
        006:  6:50 | float64             | type float64
        007: 10: 1 | Map                 | func main.Map(c []float64, t func(float64) float64)
        008: 11: 9 | x                   | var x float64
        009: 11:13 | x                   | var x float64
        010: 13: 1 | Map2                | func main.Map2(c []float64, t func(float64) (float64, float64))
        011: 14: 9 | x                   | var x float64
        012: 14:13 | x                   | var x float64
        013: 14:16 | x                   | var x float64
        014: 14:20 | x                   | var x float64
--- PASS: TestLambdaExpr2 (1.12s)
=== RUN   TestMixedOverload1
2025/12/19 11:09:42.133278 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 1
2025/12/19 11:09:42 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:42 ==> NewOverloadFunc NewRange
2025/12/19 11:09:42 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:42 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:42 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:42 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:42 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:42 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:42 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:42 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:42 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:42 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:42 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:42 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:42 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:42 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:42 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:42 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:42 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:42 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:42 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:42 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:42 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:42 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:42 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:42 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:42 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:42 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:42 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:42 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:42 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:42 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:42 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:42 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:42 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:42 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:42 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:42 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:42 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:42 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:42 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:42 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:42 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:42 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:43.136280 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0003600c0 {
}

2025/12/19 11:09:43 ==> Preload type Mesh
2025/12/19 11:09:43 ==> Preload method Mesh.Name
2025/12/19 11:09:43 ==> Preload var [m1]
2025/12/19 11:09:43 ==> Preload var [m2]
2025/12/19 11:09:43 ==> Preload func main
2025/12/19 11:09:43 ==> Preload type Mesher
2025/12/19 11:09:43 ==> Preload type N
2025/12/19 11:09:43 ==> Preload method N.OnKey__0
2025/12/19 11:09:43 ==> Preload method N.OnKey__1
2025/12/19 11:09:43 ==> Preload method N.OnKey__2
2025/12/19 11:09:43 ==> Preload method N.OnKey__3
2025/12/19 11:09:43 ==> Preload method N.OnKey__4
2025/12/19 11:09:43 ==> Preload method N.OnKey__5
2025/12/19 11:09:43 ==> Preload method N.OnKey__6
2025/12/19 11:09:43 ==> Preload method N.OnKey__7
2025/12/19 11:09:43 ==> Preload method N.OnKey__8
2025/12/19 11:09:43 ==> Preload func OnKey__0
2025/12/19 11:09:43 ==> Preload func OnKey__1
2025/12/19 11:09:43 ==> Preload func OnKey__2
2025/12/19 11:09:43 ==> Preload func OnKey__3
2025/12/19 11:09:43 ==> Preload func OnKey__4
2025/12/19 11:09:43 ==> Preload func OnKey__5
2025/12/19 11:09:43 ==> Preload func OnKey__6
2025/12/19 11:09:43 ==> Preload func OnKey__7
2025/12/19 11:09:43 ==> Preload func OnKey__8
2025/12/19 11:09:43 ==> Preload func OnKey__9
2025/12/19 11:09:43 ==> Preload func OnKey__a
2025/12/19 11:09:43 ==> Load func OnKey__2
2025/12/19 11:09:43 ==> Load func OnKey__8
2025/12/19 11:09:43 ==> Load func OnKey__9
2025/12/19 11:09:43 ==> Load > NewType N
2025/12/19 11:09:43 ==> Load > InitType N
2025/12/19 11:09:43 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:43 ==> Load method *main.N.OnKey__0
2025/12/19 11:09:43 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:43 ==> Load method *main.N.OnKey__1
2025/12/19 11:09:43 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:43 ==> Load method *main.N.OnKey__2
2025/12/19 11:09:43 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:43 ==> Load method *main.N.OnKey__3
2025/12/19 11:09:43 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:43 ==> Load method *main.N.OnKey__4
2025/12/19 11:09:43 ==> Load > NewType Mesher
2025/12/19 11:09:43 ==> Lookup (LoadSymbol) Mesher => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:43 ==> Load > InitType Mesher
2025/12/19 11:09:43 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:43 ==> Load method *main.N.OnKey__5
2025/12/19 11:09:43 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/12/19 11:09:43 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/12/19 11:09:43 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:43 ==> Load method *main.N.OnKey__6
2025/12/19 11:09:43 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:43 ==> Load method *main.N.OnKey__7
2025/12/19 11:09:43 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/12/19 11:09:43 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:43 ==> Load method *main.N.OnKey__8
2025/12/19 11:09:43 ==> Load func OnKey__7
2025/12/19 11:09:43 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/12/19 11:09:43 ==> Load func OnKey__a
2025/12/19 11:09:43 ==> Load func OnKey__1
2025/12/19 11:09:43 ==> Load func OnKey__3
2025/12/19 11:09:43 ==> Load func OnKey__6
2025/12/19 11:09:43 ==> Load func OnKey__4
2025/12/19 11:09:43 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/12/19 11:09:43 ==> Load func OnKey__5
2025/12/19 11:09:43 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/12/19 11:09:43 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/12/19 11:09:43 ==> Load func OnKey__0
2025/12/19 11:09:43 ==> NewOverloadMethod N OnKey
2025/12/19 11:09:43 ==> NewOverloadFunc OnKey
2025/12/19 11:09:43 ==> Load > NewType Mesh
2025/12/19 11:09:43 NewType Mesh
2025/12/19 11:09:43 ==> Load > InitType Mesh
2025/12/19 11:09:43.137224 [INFO] typesutil/gopinfo.go:215: ==> Type: &{12 0xc0002a4780 false} struct{}
2025/12/19 11:09:43 InitType Mesh struct{}
2025/12/19 11:09:43.137252 [INFO] typesutil/gopinfo.go:251: ==> Def: Mesh type main.Mesh struct{}
2025/12/19 11:09:43 ==> LookupParent Mesh => type main.Mesh struct{}
2025/12/19 11:09:43.137273 [INFO] typesutil/gopinfo.go:265: ==> Use: Mesh type main.Mesh struct{}
2025/12/19 11:09:43.137287 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/12/19 11:09:43.137302 [INFO] typesutil/gopinfo.go:251: ==> Def: p var p *main.Mesh
2025/12/19 11:09:43 ==> Load method *main.Mesh.Name
2025/12/19 11:09:43.137322 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/12/19 11:09:43.137334 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:43.137345 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:43.137362 [INFO] typesutil/gopinfo.go:251: ==> Def: Name func (*main.Mesh).Name() string
2025/12/19 11:09:43 ==> Load var <nil> [m1]
2025/12/19 11:09:43 NewVarDefs
2025/12/19 11:09:43 NewVar [m1]
2025/12/19 11:09:43 ==> LookupParent Mesh => type main.Mesh struct{}
2025/12/19 11:09:43.137429 [INFO] typesutil/gopinfo.go:265: ==> Use: Mesh type main.Mesh struct{}
2025/12/19 11:09:43.137441 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/12/19 11:09:43.137454 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/12/19 11:09:43 StructLit main.Mesh 0 false
2025/12/19 11:09:43.137476 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/12/19 11:09:43.137494 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Mesh 91 [] 92 false} main.Mesh
2025/12/19 11:09:43 UnaryOp & flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:43.137533 [INFO] typesutil/gopinfo.go:215: ==> Type: &{86 & 0xc0002bf740} *main.Mesh
2025/12/19 11:09:43 EndInit 1
2025/12/19 11:09:43.137553 [INFO] typesutil/gopinfo.go:251: ==> Def: m1 var main.m1 *main.Mesh
2025/12/19 11:09:43 ==> Load var <nil> [m2]
2025/12/19 11:09:43 NewVarDefs
2025/12/19 11:09:43 NewVar [m2]
2025/12/19 11:09:43 ==> LookupParent Mesh => type main.Mesh struct{}
2025/12/19 11:09:43.137593 [INFO] typesutil/gopinfo.go:265: ==> Use: Mesh type main.Mesh struct{}
2025/12/19 11:09:43.137604 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/12/19 11:09:43.137616 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/12/19 11:09:43 StructLit main.Mesh 0 false
2025/12/19 11:09:43.137637 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/12/19 11:09:43.137652 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Mesh 105 [] 106 false} main.Mesh
2025/12/19 11:09:43 UnaryOp & flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:43.137684 [INFO] typesutil/gopinfo.go:215: ==> Type: &{100 & 0xc0002bf780} *main.Mesh
2025/12/19 11:09:43 EndInit 1
2025/12/19 11:09:43.137710 [INFO] typesutil/gopinfo.go:251: ==> Def: m2 var main.m2 *main.Mesh
2025/12/19 11:09:43 ==> Load func main
2025/12/19 11:09:43.137732 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:09:43 NewFunc main func()
2025/12/19 11:09:43 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.137780 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.137791 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/12/19 11:09:43.137805 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:43.137837 [INFO] typesutil/gopinfo.go:215: ==> Type: &{117 STRING "hello" <nil>} untyped string
2025/12/19 11:09:43 NewClosure func()
2025/12/19 11:09:43.137860 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0003c4a20 {
}

2025/12/19 11:09:43 End // Func
2025/12/19 11:09:43 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:43 ==> MatchType func(), func()
2025/12/19 11:09:43.137952 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__0(a string, fn func())
2025/12/19 11:09:43.137966 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a string, fn func())
2025/12/19 11:09:43.137989 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc0002a49f0 0xc0002bf840] 0 [] 0 132} ()
2025/12/19 11:09:43 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.138013 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.138023 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/12/19 11:09:43.138035 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:43.138067 [INFO] typesutil/gopinfo.go:215: ==> Type: &{139 STRING "hello" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:43.138115 [INFO] typesutil/gopinfo.go:215: ==> Type: &{139 STRING "hello" <nil>} untyped string
2025/12/19 11:09:43.138127 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:43 NewClosure func(key string)
2025/12/19 11:09:43.138150 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:43.138166 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0003c4ba0 {
.  var key string
}

2025/12/19 11:09:43 End // Func
2025/12/19 11:09:43 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:43 ==> MatchType func(key string), func()
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:43 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:43.138272 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__1(a string, fn func(key string))
2025/12/19 11:09:43.138285 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a string, fn func(key string))
2025/12/19 11:09:43.138304 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc0002a4a80 0xc0002bf8c0] 0 [] 0 158} ()
2025/12/19 11:09:43 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.138327 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.138335 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/12/19 11:09:43.138347 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:09:43.138373 [INFO] typesutil/gopinfo.go:215: ==> Type: &{166 STRING "1" <nil>} untyped string
2025/12/19 11:09:43 SliceLit <nil> 1 false
2025/12/19 11:09:43 NewClosure func()
2025/12/19 11:09:43.138402 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0003c4cc0 {
}

2025/12/19 11:09:43 End // Func
2025/12/19 11:09:43 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []string, string
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []string, string
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []string, []string
2025/12/19 11:09:43 ==> MatchType func(), func()
2025/12/19 11:09:43.138505 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__2(a []string, fn func())
2025/12/19 11:09:43.138518 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a []string, fn func())
2025/12/19 11:09:43.138537 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc0002a4b40 0xc0002bf900] 0 [] 0 178} ()
2025/12/19 11:09:43 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.138557 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.138566 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/12/19 11:09:43.138587 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 Val &{0 STRING "2"} *ast.BasicLit
2025/12/19 11:09:43.138613 [INFO] typesutil/gopinfo.go:215: ==> Type: &{186 STRING "2" <nil>} untyped string
2025/12/19 11:09:43 SliceLit <nil> 1 false
2025/12/19 11:09:43 Val &{0 STRING "2"} *ast.BasicLit
2025/12/19 11:09:43.138644 [INFO] typesutil/gopinfo.go:215: ==> Type: &{186 STRING "2" <nil>} untyped string
2025/12/19 11:09:43 SliceLit <nil> 1 false
2025/12/19 11:09:43.138663 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:43 NewClosure func(key string)
2025/12/19 11:09:43.138685 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:43.138701 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0003c4e40 {
.  var key string
}

2025/12/19 11:09:43 End // Func
2025/12/19 11:09:43 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []string, string
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []string, string
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []string, []string
2025/12/19 11:09:43 ==> MatchType func(key string), func()
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []string, []string
2025/12/19 11:09:43 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:43.138840 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__3(a []string, fn func(key string))
2025/12/19 11:09:43.138853 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a []string, fn func(key string))
2025/12/19 11:09:43.138871 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc0002a4c00 0xc0002bf980] 0 [] 0 202} ()
2025/12/19 11:09:43 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.138892 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.138904 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/12/19 11:09:43.138917 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 Val m1 *main.Mesh
2025/12/19 11:09:43.138941 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:43.138953 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:43 Val m2 *main.Mesh
2025/12/19 11:09:43.138975 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:43.138985 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:43 SliceLit <nil> 2 false
2025/12/19 11:09:43 NewClosure func()
2025/12/19 11:09:43.139013 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0003c4f60 {
}

2025/12/19 11:09:43 End // Func
2025/12/19 11:09:43 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []*main.Mesh, string
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []*main.Mesh, string
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []*main.Mesh, []string
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []*main.Mesh, []string
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []*main.Mesh, []main.Mesher
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []*main.Mesh, []main.Mesher
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []*main.Mesh, int
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []*main.Mesh, string
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, b string, v ...int) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []*main.Mesh, string
2025/12/19 11:09:43 Val m1 *main.Mesh
2025/12/19 11:09:43.139317 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:43.139329 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:43 Val m2 *main.Mesh
2025/12/19 11:09:43.139359 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:43.139369 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:43 SliceLit <nil> 2 false
2025/12/19 11:09:43 Val m1 *main.Mesh
2025/12/19 11:09:43.139403 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:43.139414 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:43 Val m2 *main.Mesh
2025/12/19 11:09:43.139432 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:43.139442 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:43 SliceLit []string 2 false
2025/12/19 11:09:43 Val m1 *main.Mesh
2025/12/19 11:09:43.139491 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:43.139504 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:43 Val m2 *main.Mesh
2025/12/19 11:09:43.139524 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:43.139534 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:43 SliceLit []string 2 false
2025/12/19 11:09:43 Val m1 *main.Mesh
2025/12/19 11:09:43.139568 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:43.139579 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:43 Val m2 *main.Mesh
2025/12/19 11:09:43.139603 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:43.139614 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:43 SliceLit []main.Mesher 2 false
2025/12/19 11:09:43 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:43 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:43 NewClosure func()
2025/12/19 11:09:43.139677 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0003c5020 {
}

2025/12/19 11:09:43 End // Func
2025/12/19 11:09:43 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []main.Mesher, string
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []main.Mesher, string
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []main.Mesher, []string
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []main.Mesher, []string
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []main.Mesher, []main.Mesher
2025/12/19 11:09:43 ==> MatchType func(), func()
2025/12/19 11:09:43.139825 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__4(a []main.Mesher, fn func())
2025/12/19 11:09:43.139839 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a []main.Mesher, fn func())
2025/12/19 11:09:43.139858 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc0002a4c90 0xc0002bf9c0] 0 [] 0 225} ()
2025/12/19 11:09:43 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.139880 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.139889 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/12/19 11:09:43.139899 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 Val m1 *main.Mesh
2025/12/19 11:09:43.139922 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:43.139942 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:43 Val m2 *main.Mesh
2025/12/19 11:09:43.139967 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:43.139984 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:43 SliceLit <nil> 2 false
2025/12/19 11:09:43 Val m1 *main.Mesh
2025/12/19 11:09:43.140030 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:43.140041 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:43 Val m2 *main.Mesh
2025/12/19 11:09:43.140060 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:43.140071 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:43 SliceLit <nil> 2 false
2025/12/19 11:09:43.140088 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:43 NewClosure func(key string)
2025/12/19 11:09:43.140113 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:43.140129 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0003c51a0 {
.  var key string
}

2025/12/19 11:09:43 End // Func
2025/12/19 11:09:43 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []*main.Mesh, string
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []*main.Mesh, string
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []*main.Mesh, []string
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []*main.Mesh, []string
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []*main.Mesh, []main.Mesher
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []*main.Mesh, []main.Mesher
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []*main.Mesh, int
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []*main.Mesh, string
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, b string, v ...int) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []*main.Mesh, string
2025/12/19 11:09:43 Val m1 *main.Mesh
2025/12/19 11:09:43.140422 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:43.140433 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:43 Val m2 *main.Mesh
2025/12/19 11:09:43.140453 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:43.140464 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:43 SliceLit []string 2 false
2025/12/19 11:09:43 Val m1 *main.Mesh
2025/12/19 11:09:43.140510 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:43.140521 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:43 Val m2 *main.Mesh
2025/12/19 11:09:43.140540 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:43.140551 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:43 SliceLit []string 2 false
2025/12/19 11:09:43 Val m1 *main.Mesh
2025/12/19 11:09:43.140586 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:43.140597 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:43 Val m2 *main.Mesh
2025/12/19 11:09:43.140619 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:43.140629 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:43 SliceLit []main.Mesher 2 false
2025/12/19 11:09:43 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:43 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:43 Val m1 *main.Mesh
2025/12/19 11:09:43.140697 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:43.140709 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:43 Val m2 *main.Mesh
2025/12/19 11:09:43.140728 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:43.140738 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:43 SliceLit []main.Mesher 2 false
2025/12/19 11:09:43 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:43 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:43.140786 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key main.Mesher
2025/12/19 11:09:43 NewClosure func(key main.Mesher)
2025/12/19 11:09:43.140810 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key main.Mesher
2025/12/19 11:09:43.140826 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0003c52c0 {
.  var key main.Mesher
}

2025/12/19 11:09:43 End // Func
2025/12/19 11:09:43 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []main.Mesher, string
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []main.Mesher, string
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []main.Mesher, []string
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []main.Mesher, []string
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []main.Mesher, []main.Mesher
2025/12/19 11:09:43 ==> MatchType func(key main.Mesher), func()
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType []main.Mesher, []main.Mesher
2025/12/19 11:09:43 ==> MatchType func(key main.Mesher), func(key main.Mesher)
2025/12/19 11:09:43.140993 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__5(a []main.Mesher, fn func(key main.Mesher))
2025/12/19 11:09:43.141008 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a []main.Mesher, fn func(key main.Mesher))
2025/12/19 11:09:43.141029 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc0002a4d20 0xc0002bfa00] 0 [] 0 252} ()
2025/12/19 11:09:43 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.141051 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.141060 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/12/19 11:09:43.141072 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.141150 [INFO] typesutil/gopinfo.go:215: ==> Type: &{260 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit <nil> 1 false
2025/12/19 11:09:43 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:43.141180 [INFO] typesutil/gopinfo.go:215: ==> Type: &{267 STRING "b" <nil>} untyped string
2025/12/19 11:09:43 SliceLit <nil> 1 false
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.141214 [INFO] typesutil/gopinfo.go:215: ==> Type: &{260 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit <nil> 1 false
2025/12/19 11:09:43 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:43.141240 [INFO] typesutil/gopinfo.go:215: ==> Type: &{267 STRING "b" <nil>} untyped string
2025/12/19 11:09:43 SliceLit <nil> 1 false
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.141271 [INFO] typesutil/gopinfo.go:215: ==> Type: &{260 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit []string 1 false
2025/12/19 11:09:43 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:43.141301 [INFO] typesutil/gopinfo.go:215: ==> Type: &{267 STRING "b" <nil>} untyped string
2025/12/19 11:09:43 SliceLit <nil> 1 false
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.141336 [INFO] typesutil/gopinfo.go:215: ==> Type: &{260 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit []string 1 false
2025/12/19 11:09:43 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:43.141371 [INFO] typesutil/gopinfo.go:215: ==> Type: &{267 STRING "b" <nil>} untyped string
2025/12/19 11:09:43 SliceLit <nil> 1 false
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.141400 [INFO] typesutil/gopinfo.go:215: ==> Type: &{260 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit []main.Mesher 1 false
2025/12/19 11:09:43 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:43 ==> AssignableConv untyped string main.Mesher false
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.141464 [INFO] typesutil/gopinfo.go:215: ==> Type: &{260 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit []main.Mesher 1 false
2025/12/19 11:09:43 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:43 ==> AssignableConv untyped string main.Mesher false
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.141531 [INFO] typesutil/gopinfo.go:215: ==> Type: &{260 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit []string 1 false
2025/12/19 11:09:43 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:43.141560 [INFO] typesutil/gopinfo.go:215: ==> Type: &{267 STRING "b" <nil>} untyped string
2025/12/19 11:09:43 SliceLit []string 1 false
2025/12/19 11:09:43.141582 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:43 NewClosure func(key string)
2025/12/19 11:09:43.141604 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:43.141620 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0003c5440 {
.  var key string
}

2025/12/19 11:09:43 End // Func
2025/12/19 11:09:43 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchType []string, []string
2025/12/19 11:09:43 ==> MatchType []string, []string
2025/12/19 11:09:43 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:43.141867 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__6(a []string, b []string, fn func(key string))
2025/12/19 11:09:43.141883 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a []string, b []string, fn func(key string))
2025/12/19 11:09:43.141904 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc0002a4de0 0xc0002a4e40 0xc0002bfa40] 0 [] 0 283} ()
2025/12/19 11:09:43 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.141928 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.141937 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/12/19 11:09:43.141950 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.141975 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit <nil> 1 false
2025/12/19 11:09:43 Val m1 *main.Mesh
2025/12/19 11:09:43.142002 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:43.142013 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:43 Val m2 *main.Mesh
2025/12/19 11:09:43.142042 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:43.142054 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:43 SliceLit <nil> 2 false
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.142087 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit <nil> 1 false
2025/12/19 11:09:43 Val m1 *main.Mesh
2025/12/19 11:09:43.142113 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:43.142124 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:43 Val m2 *main.Mesh
2025/12/19 11:09:43.142144 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:43.142155 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:43 SliceLit <nil> 2 false
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.142187 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit []string 1 false
2025/12/19 11:09:43 Val m1 *main.Mesh
2025/12/19 11:09:43.142216 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:43.142226 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:43 Val m2 *main.Mesh
2025/12/19 11:09:43.142246 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:43.142256 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:43 SliceLit <nil> 2 false
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.142286 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit []string 1 false
2025/12/19 11:09:43 Val m1 *main.Mesh
2025/12/19 11:09:43.142334 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:43.142345 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:43 Val m2 *main.Mesh
2025/12/19 11:09:43.142363 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:43.142373 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:43 SliceLit <nil> 2 false
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.142408 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit []main.Mesher 1 false
2025/12/19 11:09:43 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:43 ==> AssignableConv untyped string main.Mesher false
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.142462 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit []main.Mesher 1 false
2025/12/19 11:09:43 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:43 ==> AssignableConv untyped string main.Mesher false
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.142526 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit []string 1 false
2025/12/19 11:09:43 Val m1 *main.Mesh
2025/12/19 11:09:43.142555 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:43.142565 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:43 Val m2 *main.Mesh
2025/12/19 11:09:43.142584 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:43.142594 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:43 SliceLit []string 2 false
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.142631 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit []string 1 false
2025/12/19 11:09:43 Val m1 *main.Mesh
2025/12/19 11:09:43.142659 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:43.142669 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:43 Val m2 *main.Mesh
2025/12/19 11:09:43.142704 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:43.142715 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:43 SliceLit []main.Mesher 2 false
2025/12/19 11:09:43 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:43 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:43.142754 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:43 NewClosure func(key string)
2025/12/19 11:09:43.142776 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:43.142792 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0003c5620 {
.  var key string
}

2025/12/19 11:09:43 End // Func
2025/12/19 11:09:43 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchType []string, []string
2025/12/19 11:09:43 ==> MatchType []main.Mesher, []string
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchType []string, []string
2025/12/19 11:09:43 ==> MatchType []main.Mesher, []main.Mesher
2025/12/19 11:09:43 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:43.143074 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__7(a []string, b []main.Mesher, fn func(key string))
2025/12/19 11:09:43.143089 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a []string, b []main.Mesher, fn func(key string))
2025/12/19 11:09:43.143110 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc0002a4f30 0xc0002a4f60 0xc0002bfac0] 0 [] 0 317} ()
2025/12/19 11:09:43 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.143132 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.143141 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/12/19 11:09:43.143154 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.143180 [INFO] typesutil/gopinfo.go:215: ==> Type: &{325 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit <nil> 1 false
2025/12/19 11:09:43 Val nil untyped nil
2025/12/19 11:09:43.143207 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/12/19 11:09:43.143217 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.143242 [INFO] typesutil/gopinfo.go:215: ==> Type: &{325 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit <nil> 1 false
2025/12/19 11:09:43 Val nil untyped nil
2025/12/19 11:09:43.143264 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/12/19 11:09:43.143276 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.143300 [INFO] typesutil/gopinfo.go:215: ==> Type: &{325 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit []string 1 false
2025/12/19 11:09:43 Val nil untyped nil
2025/12/19 11:09:43.143328 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/12/19 11:09:43.143338 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.143362 [INFO] typesutil/gopinfo.go:215: ==> Type: &{325 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit []string 1 false
2025/12/19 11:09:43 Val nil untyped nil
2025/12/19 11:09:43.143404 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/12/19 11:09:43.143414 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.143438 [INFO] typesutil/gopinfo.go:215: ==> Type: &{325 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit []main.Mesher 1 false
2025/12/19 11:09:43 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:43 ==> AssignableConv untyped string main.Mesher false
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.143502 [INFO] typesutil/gopinfo.go:215: ==> Type: &{325 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit []main.Mesher 1 false
2025/12/19 11:09:43 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:43 ==> AssignableConv untyped string main.Mesher false
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.143556 [INFO] typesutil/gopinfo.go:215: ==> Type: &{325 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 SliceLit []string 1 false
2025/12/19 11:09:43 Val nil untyped nil
2025/12/19 11:09:43.143582 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/12/19 11:09:43.143592 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/12/19 11:09:43.143604 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:43 NewClosure func(key string)
2025/12/19 11:09:43.143626 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:43.143641 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0003c5800 {
.  var key string
}

2025/12/19 11:09:43 End // Func
2025/12/19 11:09:43 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:43 ==> MatchType []string, []string
2025/12/19 11:09:43 ==> MatchType untyped nil, []string
2025/12/19 11:09:43 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:43.143865 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__6(a []string, b []string, fn func(key string))
2025/12/19 11:09:43.143879 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a []string, b []string, fn func(key string))
2025/12/19 11:09:43.143913 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc0002a5020 nil 0xc0002bfb40] 0 [] 0 346} ()
2025/12/19 11:09:43 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.144998 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.145044 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/12/19 11:09:43.145072 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:43.145210 [INFO] typesutil/gopinfo.go:215: ==> Type: &{353 INT 100 <nil>} untyped int
2025/12/19 11:09:43 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:43.145268 [INFO] typesutil/gopinfo.go:215: ==> Type: &{358 INT 200 <nil>} untyped int
2025/12/19 11:09:43 NewClosure func() int
2025/12/19 11:09:43 End // Func
2025/12/19 11:09:43 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped int (100), string
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped int (100), string
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped int (100), []string
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped int (100), []string
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped int (100), []main.Mesher
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped int (100), []main.Mesher
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped int (100), int
2025/12/19 11:09:43 ==> MatchType func() int, int
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped int (100), string
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, b string, v ...int) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped int (100), string
2025/12/19 11:09:43 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:43.146435 [INFO] typesutil/gopinfo.go:215: ==> Type: &{353 INT 100 <nil>} untyped int
2025/12/19 11:09:43 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:43.146466 [INFO] typesutil/gopinfo.go:215: ==> Type: &{358 INT 200 <nil>} untyped int
2025/12/19 11:09:43 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped int (100), string
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped int (100), string
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped int (100), []string
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped int (100), []string
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped int (100), []main.Mesher
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped int (100), []main.Mesher
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped int (100), int
2025/12/19 11:09:43 ==> MatchType untyped int (200), int
2025/12/19 11:09:43.146681 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__8(x int, y int)
2025/12/19 11:09:43.146695 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(x int, y int)
2025/12/19 11:09:43.146718 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc0002a50e0 0xc0002a5110] 0 [] 0 361} ()
2025/12/19 11:09:43 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.146747 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.146758 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/12/19 11:09:43.146771 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.146797 [INFO] typesutil/gopinfo.go:215: ==> Type: &{368 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:43.146820 [INFO] typesutil/gopinfo.go:215: ==> Type: &{373 STRING "b" <nil>} untyped string
2025/12/19 11:09:43 NewClosure func() string
2025/12/19 11:09:43 End // Func
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.146868 [INFO] typesutil/gopinfo.go:215: ==> Type: &{368 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:43.146890 [INFO] typesutil/gopinfo.go:215: ==> Type: &{373 STRING "b" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.146913 [INFO] typesutil/gopinfo.go:215: ==> Type: &{368 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:43.146936 [INFO] typesutil/gopinfo.go:215: ==> Type: &{373 STRING "b" <nil>} untyped string
2025/12/19 11:09:43 NewClosure func() string
2025/12/19 11:09:43 End // Func
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.146978 [INFO] typesutil/gopinfo.go:215: ==> Type: &{368 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:43.146998 [INFO] typesutil/gopinfo.go:215: ==> Type: &{373 STRING "b" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.147021 [INFO] typesutil/gopinfo.go:215: ==> Type: &{368 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:43.147040 [INFO] typesutil/gopinfo.go:215: ==> Type: &{373 STRING "b" <nil>} untyped string
2025/12/19 11:09:43 NewClosure func() string
2025/12/19 11:09:43 End // Func
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.147154 [INFO] typesutil/gopinfo.go:215: ==> Type: &{368 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:43.147176 [INFO] typesutil/gopinfo.go:215: ==> Type: &{373 STRING "b" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.147199 [INFO] typesutil/gopinfo.go:215: ==> Type: &{368 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:43.147219 [INFO] typesutil/gopinfo.go:215: ==> Type: &{373 STRING "b" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.147254 [INFO] typesutil/gopinfo.go:215: ==> Type: &{368 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:43.147274 [INFO] typesutil/gopinfo.go:215: ==> Type: &{373 STRING "b" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.147302 [INFO] typesutil/gopinfo.go:215: ==> Type: &{368 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:43.147325 [INFO] typesutil/gopinfo.go:215: ==> Type: &{373 STRING "b" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.147349 [INFO] typesutil/gopinfo.go:215: ==> Type: &{368 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:43.147372 [INFO] typesutil/gopinfo.go:215: ==> Type: &{373 STRING "b" <nil>} untyped string
2025/12/19 11:09:43.147386 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:09:43 NewClosure func(x int) int
2025/12/19 11:09:43.147415 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:09:43 Val x int
2025/12/19 11:09:43.147436 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:09:43.147448 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:09:43 Val x int
2025/12/19 11:09:43.147469 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:09:43.147481 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:09:43 BinaryOp *
2025/12/19 11:09:43 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:43 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:09:43.147571 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 385 * x} int
2025/12/19 11:09:43.147593 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0003c53e0 {
.  var x int
}

2025/12/19 11:09:43 Return 1
2025/12/19 11:09:43 ==> MatchType int, int
2025/12/19 11:09:43 End // Func
2025/12/19 11:09:43.147633 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:09:43 NewClosure func(x int) int
2025/12/19 11:09:43.147672 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:09:43 Val x int
2025/12/19 11:09:43.147694 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:09:43.147716 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:09:43 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:43.147751 [INFO] typesutil/gopinfo.go:215: ==> Type: &{409 INT 2 <nil>} untyped int
2025/12/19 11:09:43 BinaryOp *
2025/12/19 11:09:43 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:09:43 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:43 ==> MatchType untyped int (2), unboundFuncParam{typ: int}
2025/12/19 11:09:43.147824 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 407 * 0xc0002a5200} int
2025/12/19 11:09:43 Return 1
2025/12/19 11:09:43 ==> MatchType int, int
2025/12/19 11:09:43.147857 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0003c5860 {
.  var x int
}

2025/12/19 11:09:43 End // Func
2025/12/19 11:09:43 Call 4 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 ==> MatchFuncCall TyOverloadFunc args: 4 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func()) args: 4 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func(key string)) args: 4 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func()) args: 4 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func(key string)) args: 4 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 4 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 4 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 4 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 4 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(x int, y int) args: 4 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 4 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped string ("a"), string
2025/12/19 11:09:43 ==> MatchType untyped string ("b"), string
2025/12/19 11:09:43 ==> MatchType func(x int) int, func(x int) int
2025/12/19 11:09:43 ==> MatchType func(x int) int, func(x int) int
2025/12/19 11:09:43.148194 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__9(a string, b string, fn ...func(x int) int)
2025/12/19 11:09:43.148213 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a string, b string, fn ...func(x int) int)
2025/12/19 11:09:43.148240 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc0002a5140 0xc0002a5170 0xc0000ff6d0 0xc0002bfc00] 0 [] 0 412} ()
2025/12/19 11:09:43 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.148267 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.148279 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/12/19 11:09:43.148292 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.148322 [INFO] typesutil/gopinfo.go:215: ==> Type: &{419 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:43.148346 [INFO] typesutil/gopinfo.go:215: ==> Type: &{424 STRING "b" <nil>} untyped string
2025/12/19 11:09:43 NewClosure func() string
2025/12/19 11:09:43 End // Func
2025/12/19 11:09:43 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:43.148389 [INFO] typesutil/gopinfo.go:215: ==> Type: &{429 INT 1 <nil>} untyped int
2025/12/19 11:09:43 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:43.148409 [INFO] typesutil/gopinfo.go:215: ==> Type: &{432 INT 2 <nil>} untyped int
2025/12/19 11:09:43 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:43.148430 [INFO] typesutil/gopinfo.go:215: ==> Type: &{435 INT 3 <nil>} untyped int
2025/12/19 11:09:43 Call 5 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 ==> MatchFuncCall TyOverloadFunc args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func()) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func(key string)) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func()) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func(key string)) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(x int, y int) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped string ("a"), string
2025/12/19 11:09:43 ==> MatchType func() string, string
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, b string, v ...int) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped string ("a"), string
2025/12/19 11:09:43 ==> MatchType func() string, string
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.148815 [INFO] typesutil/gopinfo.go:215: ==> Type: &{419 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:43.148840 [INFO] typesutil/gopinfo.go:215: ==> Type: &{424 STRING "b" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:43.148862 [INFO] typesutil/gopinfo.go:215: ==> Type: &{429 INT 1 <nil>} untyped int
2025/12/19 11:09:43 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:43.148884 [INFO] typesutil/gopinfo.go:215: ==> Type: &{432 INT 2 <nil>} untyped int
2025/12/19 11:09:43 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:43.148905 [INFO] typesutil/gopinfo.go:215: ==> Type: &{435 INT 3 <nil>} untyped int
2025/12/19 11:09:43 Call 5 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 ==> MatchFuncCall TyOverloadFunc args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func()) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func(key string)) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func()) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func(key string)) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(x int, y int) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped string ("a"), string
2025/12/19 11:09:43 ==> MatchType untyped string ("b"), string
2025/12/19 11:09:43 ==> MatchType untyped int (1), func(x int) int
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, b string, v ...int) args: 5 flags: 0
2025/12/19 11:09:43 ==> MatchType untyped string ("a"), string
2025/12/19 11:09:43 ==> MatchType untyped string ("b"), string
2025/12/19 11:09:43 ==> MatchType untyped int (1), int
2025/12/19 11:09:43 ==> MatchType untyped int (2), int
2025/12/19 11:09:43 ==> MatchType untyped int (3), int
2025/12/19 11:09:43.149284 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__a(a string, b string, v ...int)
2025/12/19 11:09:43.149299 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a string, b string, v ...int)
2025/12/19 11:09:43.149324 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 0 [0xc0002a5290 0xc0002a52f0 0xc0002a5320 0xc0002a5350 0xc0002a5380] 0 [] 0 436} ()
2025/12/19 11:09:43 Val OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.149349 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43.149369 [INFO] typesutil/gopinfo.go:274: ==> Overloads: OnKey TyOverloadFunc
2025/12/19 11:09:43.149383 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.149408 [INFO] typesutil/gopinfo.go:215: ==> Type: &{443 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:43.149433 [INFO] typesutil/gopinfo.go:215: ==> Type: &{448 STRING "b" <nil>} untyped string
2025/12/19 11:09:43 NewClosure func() string
2025/12/19 11:09:43 End // Func
2025/12/19 11:09:43 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:43.149478 [INFO] typesutil/gopinfo.go:215: ==> Type: &{454 INT 1 <nil>} untyped int
2025/12/19 11:09:43 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:43.149502 [INFO] typesutil/gopinfo.go:215: ==> Type: &{457 INT 2 <nil>} untyped int
2025/12/19 11:09:43 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:43.149525 [INFO] typesutil/gopinfo.go:215: ==> Type: &{460 INT 3 <nil>} untyped int
2025/12/19 11:09:43 SliceLit <nil> 3 false
2025/12/19 11:09:43 Call 3 1 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchFuncCall func(x int, y int) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchType untyped string ("a"), string
2025/12/19 11:09:43 ==> MatchType func() string, string
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, b string, v ...int) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchType untyped string ("a"), string
2025/12/19 11:09:43 ==> MatchType func() string, string
2025/12/19 11:09:43 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:43.149739 [INFO] typesutil/gopinfo.go:215: ==> Type: &{443 STRING "a" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:43.149763 [INFO] typesutil/gopinfo.go:215: ==> Type: &{448 STRING "b" <nil>} untyped string
2025/12/19 11:09:43 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:43.149785 [INFO] typesutil/gopinfo.go:215: ==> Type: &{454 INT 1 <nil>} untyped int
2025/12/19 11:09:43 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:43.149806 [INFO] typesutil/gopinfo.go:215: ==> Type: &{457 INT 2 <nil>} untyped int
2025/12/19 11:09:43 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:09:43.149827 [INFO] typesutil/gopinfo.go:215: ==> Type: &{460 INT 3 <nil>} untyped int
2025/12/19 11:09:43 SliceLit <nil> 3 false
2025/12/19 11:09:43 Call 3 1 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:43 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchFuncCall func(x int, y int) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, b string, fn ...func(x int) int) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchType untyped string ("a"), string
2025/12/19 11:09:43 ==> MatchType untyped string ("b"), string
2025/12/19 11:09:43 ==> MatchType []int, []func(x int) int
2025/12/19 11:09:43 ==> MatchFuncCall func(a string, b string, v ...int) args: 3 flags: 1
2025/12/19 11:09:43 ==> MatchType untyped string ("a"), string
2025/12/19 11:09:43 ==> MatchType untyped string ("b"), string
2025/12/19 11:09:43 ==> MatchType []int, []int
2025/12/19 11:09:43.150044 [INFO] typesutil/gopinfo.go:265: ==> Use: OnKey func main.OnKey__a(a string, b string, v ...int)
2025/12/19 11:09:43.150059 [INFO] typesutil/gopinfo.go:215: ==> Type: OnKey func(a string, b string, v ...int)
2025/12/19 11:09:43.150079 [INFO] typesutil/gopinfo.go:215: ==> Type: &{OnKey 442 [0xc0002a53b0 0xc0002a53e0 0xc0002a54a0] 462 [] 465 0} ()
2025/12/19 11:09:43.150095 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0003c4960 {
}

2025/12/19 11:09:43 End // Func
2025/12/19 11:09:43 NewFunc Name (*main.Mesh) func() string
2025/12/19 11:09:43 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:43.150147 [INFO] typesutil/gopinfo.go:215: ==> Type: &{63 STRING "hello" <nil>} untyped string
2025/12/19 11:09:43 Return 1
2025/12/19 11:09:43 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:43.150186 [INFO] typesutil/gopinfo.go:332: ==> Scope: func Name scope 0xc0003c5e00 {
.  var p *main.Mesh
}

2025/12/19 11:09:43 End // Func
    info_test.go:190: == types ==
        000:  2:11 | struct {
        }          *ast.StructType                | type    : struct{} | type
        001:  5:10 | Mesh                *ast.Ident                     | type    : main.Mesh | type
        002:  5:23 | string              *ast.Ident                     | type    : string | type
        003:  6: 9 | "hello"             *ast.BasicLit                  | value   : untyped string = "hello" | constant
        004: 10: 7 | &Mesh{}             *ast.UnaryExpr                 | value   : *main.Mesh | value
        005: 10: 8 | Mesh                *ast.Ident                     | type    : main.Mesh | type
        006: 10: 8 | Mesh{}              *ast.CompositeLit              | value   : main.Mesh | value
        007: 11: 7 | &Mesh{}             *ast.UnaryExpr                 | value   : *main.Mesh | value
        008: 11: 8 | Mesh                *ast.Ident                     | type    : main.Mesh | type
        009: 11: 8 | Mesh{}              *ast.CompositeLit              | value   : main.Mesh | value
        010: 14: 1 | OnKey               *ast.Ident                     | value   : func(a string, fn func()) | value
        011: 14: 1 | OnKey "hello", => {
        } *ast.CallExpr                  | void    : () | no value
        012: 14: 7 | "hello"             *ast.BasicLit                  | value   : untyped string = "hello" | constant
        013: 16: 1 | OnKey               *ast.Ident                     | value   : func(a string, fn func(key string)) | value
        014: 16: 1 | OnKey "hello", key => {
        } *ast.CallExpr                  | void    : () | no value
        015: 16: 7 | "hello"             *ast.BasicLit                  | value   : untyped string = "hello" | constant
        016: 18: 1 | OnKey               *ast.Ident                     | value   : func(a []string, fn func()) | value
        017: 18: 1 | OnKey ["1"], => {
        } *ast.CallExpr                  | void    : () | no value
        018: 18: 8 | "1"                 *ast.BasicLit                  | value   : untyped string = "1" | constant
        019: 20: 1 | OnKey               *ast.Ident                     | value   : func(a []string, fn func(key string)) | value
        020: 20: 1 | OnKey ["2"], key => {
        } *ast.CallExpr                  | void    : () | no value
        021: 20: 8 | "2"                 *ast.BasicLit                  | value   : untyped string = "2" | constant
        022: 22: 1 | OnKey               *ast.Ident                     | value   : func(a []main.Mesher, fn func()) | value
        023: 22: 1 | OnKey [m1, m2], => {
        } *ast.CallExpr                  | void    : () | no value
        024: 22: 8 | m1                  *ast.Ident                     | var     : *main.Mesh | variable
        025: 22:12 | m2                  *ast.Ident                     | var     : *main.Mesh | variable
        026: 24: 1 | OnKey               *ast.Ident                     | value   : func(a []main.Mesher, fn func(key main.Mesher)) | value
        027: 24: 1 | OnKey [m1, m2], key => {
        } *ast.CallExpr                  | void    : () | no value
        028: 24: 8 | m1                  *ast.Ident                     | var     : *main.Mesh | variable
        029: 24:12 | m2                  *ast.Ident                     | var     : *main.Mesh | variable
        030: 26: 1 | OnKey               *ast.Ident                     | value   : func(a []string, b []string, fn func(key string)) | value
        031: 26: 1 | OnKey ["a"], ["b"], key => {
        } *ast.CallExpr                  | void    : () | no value
        032: 26: 8 | "a"                 *ast.BasicLit                  | value   : untyped string = "a" | constant
        033: 26:15 | "b"                 *ast.BasicLit                  | value   : untyped string = "b" | constant
        034: 28: 1 | OnKey               *ast.Ident                     | value   : func(a []string, b []main.Mesher, fn func(key string)) | value
        035: 28: 1 | OnKey ["a"], [m1, m2], key => {
        } *ast.CallExpr                  | void    : () | no value
        036: 28: 8 | "a"                 *ast.BasicLit                  | value   : untyped string = "a" | constant
        037: 28:15 | m1                  *ast.Ident                     | var     : *main.Mesh | variable
        038: 28:19 | m2                  *ast.Ident                     | var     : *main.Mesh | variable
        039: 30: 1 | OnKey               *ast.Ident                     | value   : func(a []string, b []string, fn func(key string)) | value
        040: 30: 1 | OnKey ["a"], nil, key => {
        } *ast.CallExpr                  | void    : () | no value
        041: 30: 8 | "a"                 *ast.BasicLit                  | value   : untyped string = "a" | constant
        042: 30:14 | nil                 *ast.Ident                     | nil     : untyped nil | value
        043: 32: 1 | OnKey               *ast.Ident                     | value   : func(x int, y int) | value
        044: 32: 1 | OnKey 100, 200      *ast.CallExpr                  | void    : () | no value
        045: 32: 7 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        046: 32:12 | 200                 *ast.BasicLit                  | value   : untyped int = 200 | constant
        047: 33: 1 | OnKey               *ast.Ident                     | value   : func(a string, b string, fn ...func(x int) int) | value
        048: 33: 1 | OnKey "a", "b", x => x * x, x => {
        	return x * 2
        } *ast.CallExpr                  | void    : () | no value
        049: 33: 7 | "a"                 *ast.BasicLit                  | value   : untyped string = "a" | constant
        050: 33:12 | "b"                 *ast.BasicLit                  | value   : untyped string = "b" | constant
        051: 33:22 | x                   *ast.Ident                     | var     : int | variable
        052: 33:22 | x * x               *ast.BinaryExpr                | value   : int | value
        053: 33:26 | x                   *ast.Ident                     | var     : int | variable
        054: 34: 9 | x                   *ast.Ident                     | var     : int | variable
        055: 34: 9 | x * 2               *ast.BinaryExpr                | value   : int | value
        056: 34:13 | 2                   *ast.BasicLit                  | value   : untyped int = 2 | constant
        057: 36: 1 | OnKey               *ast.Ident                     | value   : func(a string, b string, v ...int) | value
        058: 36: 1 | OnKey "a", "b", 1, 2, 3 *ast.CallExpr                  | void    : () | no value
        059: 36: 7 | "a"                 *ast.BasicLit                  | value   : untyped string = "a" | constant
        060: 36:12 | "b"                 *ast.BasicLit                  | value   : untyped string = "b" | constant
        061: 36:17 | 1                   *ast.BasicLit                  | value   : untyped int = 1 | constant
        062: 36:20 | 2                   *ast.BasicLit                  | value   : untyped int = 2 | constant
        063: 36:23 | 3                   *ast.BasicLit                  | value   : untyped int = 3 | constant
        064: 37: 1 | OnKey               *ast.Ident                     | value   : func(a string, b string, v ...int) | value
        065: 37: 1 | OnKey("a", "b", [1, 2, 3]...) *ast.CallExpr                  | void    : () | no value
        066: 37: 7 | "a"                 *ast.BasicLit                  | value   : untyped string = "a" | constant
        067: 37:12 | "b"                 *ast.BasicLit                  | value   : untyped string = "b" | constant
        068: 37:18 | 1                   *ast.BasicLit                  | value   : untyped int = 1 | constant
        069: 37:21 | 2                   *ast.BasicLit                  | value   : untyped int = 2 | constant
        070: 37:24 | 3                   *ast.BasicLit                  | value   : untyped int = 3 | constant
        == defs ==
        000:  2: 6 | Mesh                | type main.Mesh struct{}
        001:  5: 7 | p                   | var p *main.Mesh
        002:  5:16 | Name                | func (*main.Mesh).Name() string
        003: 10: 2 | m1                  | var main.m1 *main.Mesh
        004: 11: 2 | m2                  | var main.m2 *main.Mesh
        005: 14: 1 | main                | func main.main()
        006: 16:16 | key                 | var key string
        007: 20:14 | key                 | var key string
        008: 24:17 | key                 | var key main.Mesher
        009: 26:21 | key                 | var key string
        010: 28:24 | key                 | var key string
        011: 30:19 | key                 | var key string
        012: 33:17 | x                   | var x int
        013: 33:29 | x                   | var x int
        == uses ==
        000:  5:10 | Mesh                | type main.Mesh struct{}
        001:  5:23 | string              | type string
        002: 10: 8 | Mesh                | type main.Mesh struct{}
        003: 11: 8 | Mesh                | type main.Mesh struct{}
        004: 14: 1 | OnKey               | func main.OnKey__0(a string, fn func())
        005: 16: 1 | OnKey               | func main.OnKey__1(a string, fn func(key string))
        006: 18: 1 | OnKey               | func main.OnKey__2(a []string, fn func())
        007: 20: 1 | OnKey               | func main.OnKey__3(a []string, fn func(key string))
        008: 22: 1 | OnKey               | func main.OnKey__4(a []main.Mesher, fn func())
        009: 22: 8 | m1                  | var main.m1 *main.Mesh
        010: 22:12 | m2                  | var main.m2 *main.Mesh
        011: 24: 1 | OnKey               | func main.OnKey__5(a []main.Mesher, fn func(key main.Mesher))
        012: 24: 8 | m1                  | var main.m1 *main.Mesh
        013: 24:12 | m2                  | var main.m2 *main.Mesh
        014: 26: 1 | OnKey               | func main.OnKey__6(a []string, b []string, fn func(key string))
        015: 28: 1 | OnKey               | func main.OnKey__7(a []string, b []main.Mesher, fn func(key string))
        016: 28:15 | m1                  | var main.m1 *main.Mesh
        017: 28:19 | m2                  | var main.m2 *main.Mesh
        018: 30: 1 | OnKey               | func main.OnKey__6(a []string, b []string, fn func(key string))
        019: 30:14 | nil                 | nil
        020: 32: 1 | OnKey               | func main.OnKey__8(x int, y int)
        021: 33: 1 | OnKey               | func main.OnKey__9(a string, b string, fn ...func(x int) int)
        022: 33:22 | x                   | var x int
        023: 33:26 | x                   | var x int
        024: 34: 9 | x                   | var x int
        025: 36: 1 | OnKey               | func main.OnKey__a(a string, b string, v ...int)
        026: 37: 1 | OnKey               | func main.OnKey__a(a string, b string, v ...int)
        == overloads ==
        000: 14: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        001: 16: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        002: 18: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        003: 20: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        004: 22: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        005: 24: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        006: 26: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        007: 28: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        008: 30: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        009: 32: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        010: 33: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        011: 36: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
        012: 37: 1 | OnKey               | func main.OnKey(__xgo_overload_args__ interface{_()})
--- PASS: TestMixedOverload1 (1.02s)
=== RUN   TestMixedOverload2
2025/12/19 11:09:43.153871 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 1
2025/12/19 11:09:43 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:43 ==> NewOverloadFunc NewRange
2025/12/19 11:09:43 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:43 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:43 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:43 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:43 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:43 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:43 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:43 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:43 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:43 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:43 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:43 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:43 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:43 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:43 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:43 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:43 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:43 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:43 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:43 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:43 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:43 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:43 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:43 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:43 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:43 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:43 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:43 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:43 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:43 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:43 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:43 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:43 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:43 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:43 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:43 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:43 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:43 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:43 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:43 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:43 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:43 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:44.252971 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0007314a0 {
}

2025/12/19 11:09:44 ==> Preload type Mesh
2025/12/19 11:09:44 ==> Preload method Mesh.Name
2025/12/19 11:09:44 ==> Preload var [m1]
2025/12/19 11:09:44 ==> Preload var [m2]
2025/12/19 11:09:44 ==> Preload func main
2025/12/19 11:09:44 ==> Preload type Mesher
2025/12/19 11:09:44 ==> Preload type N
2025/12/19 11:09:44 ==> Preload method N.OnKey__0
2025/12/19 11:09:44 ==> Preload method N.OnKey__1
2025/12/19 11:09:44 ==> Preload method N.OnKey__2
2025/12/19 11:09:44 ==> Preload method N.OnKey__3
2025/12/19 11:09:44 ==> Preload method N.OnKey__4
2025/12/19 11:09:44 ==> Preload method N.OnKey__5
2025/12/19 11:09:44 ==> Preload method N.OnKey__6
2025/12/19 11:09:44 ==> Preload method N.OnKey__7
2025/12/19 11:09:44 ==> Preload method N.OnKey__8
2025/12/19 11:09:44 ==> Preload func OnKey__0
2025/12/19 11:09:44 ==> Preload func OnKey__1
2025/12/19 11:09:44 ==> Preload func OnKey__2
2025/12/19 11:09:44 ==> Preload func OnKey__3
2025/12/19 11:09:44 ==> Preload func OnKey__4
2025/12/19 11:09:44 ==> Preload func OnKey__5
2025/12/19 11:09:44 ==> Preload func OnKey__6
2025/12/19 11:09:44 ==> Preload func OnKey__7
2025/12/19 11:09:44 ==> Preload func OnKey__8
2025/12/19 11:09:44 ==> Preload func OnKey__9
2025/12/19 11:09:44 ==> Preload func OnKey__a
2025/12/19 11:09:44 ==> Load func OnKey__1
2025/12/19 11:09:44 ==> Load func OnKey__2
2025/12/19 11:09:44 ==> Load func OnKey__7
2025/12/19 11:09:44 ==> Load > NewType Mesher
2025/12/19 11:09:44 ==> Lookup (LoadSymbol) Mesher => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:44 ==> Load > InitType Mesher
2025/12/19 11:09:44 ==> Load func OnKey__9
2025/12/19 11:09:44 ==> Load func OnKey__8
2025/12/19 11:09:44 ==> Load > NewType N
2025/12/19 11:09:44 ==> Load > InitType N
2025/12/19 11:09:44 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:44 ==> Load method *main.N.OnKey__0
2025/12/19 11:09:44 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:44 ==> Load method *main.N.OnKey__1
2025/12/19 11:09:44 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:44 ==> Load method *main.N.OnKey__2
2025/12/19 11:09:44 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:44 ==> Load method *main.N.OnKey__3
2025/12/19 11:09:44 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:44 ==> Load method *main.N.OnKey__4
2025/12/19 11:09:44 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/12/19 11:09:44 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:44 ==> Load method *main.N.OnKey__5
2025/12/19 11:09:44 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/12/19 11:09:44 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/12/19 11:09:44 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:44 ==> Load method *main.N.OnKey__6
2025/12/19 11:09:44 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:44 ==> Load method *main.N.OnKey__7
2025/12/19 11:09:44 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/12/19 11:09:44 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:44 ==> Load method *main.N.OnKey__8
2025/12/19 11:09:44 ==> Load func OnKey__4
2025/12/19 11:09:44 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/12/19 11:09:44 ==> Load func OnKey__5
2025/12/19 11:09:44 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/12/19 11:09:44 ==> LookupParent Mesher => type main.Mesher interface{Name() string}
2025/12/19 11:09:44 ==> Load func OnKey__6
2025/12/19 11:09:44 ==> Load func OnKey__0
2025/12/19 11:09:44 ==> Load func OnKey__3
2025/12/19 11:09:44 ==> Load func OnKey__a
2025/12/19 11:09:44 ==> NewOverloadMethod N OnKey
2025/12/19 11:09:44 ==> NewOverloadFunc OnKey
2025/12/19 11:09:44 ==> Load > NewType Mesh
2025/12/19 11:09:44 NewType Mesh
2025/12/19 11:09:44 ==> Load > InitType Mesh
2025/12/19 11:09:44.254042 [INFO] typesutil/gopinfo.go:215: ==> Type: &{12 0xc000503230 false} struct{}
2025/12/19 11:09:44 InitType Mesh struct{}
2025/12/19 11:09:44.254075 [INFO] typesutil/gopinfo.go:251: ==> Def: Mesh type main.Mesh struct{}
2025/12/19 11:09:44 ==> LookupParent Mesh => type main.Mesh struct{}
2025/12/19 11:09:44.254100 [INFO] typesutil/gopinfo.go:265: ==> Use: Mesh type main.Mesh struct{}
2025/12/19 11:09:44.254116 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/12/19 11:09:44.254132 [INFO] typesutil/gopinfo.go:251: ==> Def: p var p *main.Mesh
2025/12/19 11:09:44 ==> Load method *main.Mesh.Name
2025/12/19 11:09:44.254157 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/12/19 11:09:44.254171 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:44.254183 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:44.254200 [INFO] typesutil/gopinfo.go:251: ==> Def: Name func (*main.Mesh).Name() string
2025/12/19 11:09:44 ==> Load var <nil> [m1]
2025/12/19 11:09:44 NewVarDefs
2025/12/19 11:09:44 NewVar [m1]
2025/12/19 11:09:44 ==> LookupParent Mesh => type main.Mesh struct{}
2025/12/19 11:09:44.254254 [INFO] typesutil/gopinfo.go:265: ==> Use: Mesh type main.Mesh struct{}
2025/12/19 11:09:44.254265 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/12/19 11:09:44.254277 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/12/19 11:09:44 StructLit main.Mesh 0 false
2025/12/19 11:09:44.254305 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/12/19 11:09:44.254326 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Mesh 91 [] 92 false} main.Mesh
2025/12/19 11:09:44 UnaryOp & flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:44.254370 [INFO] typesutil/gopinfo.go:215: ==> Type: &{86 & 0xc000688640} *main.Mesh
2025/12/19 11:09:44 EndInit 1
2025/12/19 11:09:44.254396 [INFO] typesutil/gopinfo.go:251: ==> Def: m1 var main.m1 *main.Mesh
2025/12/19 11:09:44 ==> Load var <nil> [m2]
2025/12/19 11:09:44 NewVarDefs
2025/12/19 11:09:44 NewVar [m2]
2025/12/19 11:09:44 ==> LookupParent Mesh => type main.Mesh struct{}
2025/12/19 11:09:44.254445 [INFO] typesutil/gopinfo.go:265: ==> Use: Mesh type main.Mesh struct{}
2025/12/19 11:09:44.254457 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/12/19 11:09:44.254472 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/12/19 11:09:44 StructLit main.Mesh 0 false
2025/12/19 11:09:44.254492 [INFO] typesutil/gopinfo.go:215: ==> Type: Mesh main.Mesh
2025/12/19 11:09:44.254511 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Mesh 105 [] 106 false} main.Mesh
2025/12/19 11:09:44 UnaryOp & flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:44.254549 [INFO] typesutil/gopinfo.go:215: ==> Type: &{100 & 0xc000688680} *main.Mesh
2025/12/19 11:09:44 EndInit 1
2025/12/19 11:09:44.254574 [INFO] typesutil/gopinfo.go:251: ==> Def: m2 var main.m2 *main.Mesh
2025/12/19 11:09:44 ==> Load func main
2025/12/19 11:09:44.254598 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:09:44 NewFunc main func()
2025/12/19 11:09:44 DefineVarStart [n]
2025/12/19 11:09:44 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:44.254647 [INFO] typesutil/gopinfo.go:265: ==> Use: N type main.N struct{}
2025/12/19 11:09:44.254659 [INFO] typesutil/gopinfo.go:215: ==> Type: N main.N
2025/12/19 11:09:44.254671 [INFO] typesutil/gopinfo.go:215: ==> Type: N main.N
2025/12/19 11:09:44 StructLit main.N 0 false
2025/12/19 11:09:44.254696 [INFO] typesutil/gopinfo.go:215: ==> Type: N main.N
2025/12/19 11:09:44.254713 [INFO] typesutil/gopinfo.go:215: ==> Type: &{N 118 [] 119 false} main.N
2025/12/19 11:09:44 UnaryOp & flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:44.254750 [INFO] typesutil/gopinfo.go:215: ==> Type: &{116 & 0xc000688740} *main.N
2025/12/19 11:09:44 EndInit 1
2025/12/19 11:09:44.254769 [INFO] typesutil/gopinfo.go:251: ==> Def: n var n *main.N
2025/12/19 11:09:44 Val n *main.N
2025/12/19 11:09:44.254798 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n *main.N
2025/12/19 11:09:44.254813 [INFO] typesutil/gopinfo.go:215: ==> Type: n *main.N
2025/12/19 11:09:44 Member onKey 1 // *main.N
2025/12/19 11:09:44.254844 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (main.N).OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44.254856 [INFO] typesutil/gopinfo.go:274: ==> Overloads: onKey TyOverloadMethod
2025/12/19 11:09:44.254879 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:44.254930 [INFO] typesutil/gopinfo.go:215: ==> Type: &{129 STRING "hello" <nil>} untyped string
2025/12/19 11:09:44 NewClosure func()
2025/12/19 11:09:44.254959 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0007a2a20 {
}

2025/12/19 11:09:44 End // Func
2025/12/19 11:09:44 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:44 ==> MatchType func(), func()
2025/12/19 11:09:44.255057 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (*main.N).OnKey__0(a string, fn func())
2025/12/19 11:09:44.255075 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(a string, fn func())
2025/12/19 11:09:44.255101 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0005c3b78 0 [0xc000503440 0xc0006887c0] 0 [] 0 144} ()
2025/12/19 11:09:44 Val n *main.N
2025/12/19 11:09:44.255129 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n *main.N
2025/12/19 11:09:44.255146 [INFO] typesutil/gopinfo.go:215: ==> Type: n *main.N
2025/12/19 11:09:44 Member onKey 1 // *main.N
2025/12/19 11:09:44.255171 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (main.N).OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44.255185 [INFO] typesutil/gopinfo.go:274: ==> Overloads: onKey TyOverloadMethod
2025/12/19 11:09:44.255201 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:44.255231 [INFO] typesutil/gopinfo.go:215: ==> Type: &{153 STRING "hello" <nil>} untyped string
2025/12/19 11:09:44 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:44.255263 [INFO] typesutil/gopinfo.go:215: ==> Type: &{153 STRING "hello" <nil>} untyped string
2025/12/19 11:09:44.255278 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:44 NewClosure func(key string)
2025/12/19 11:09:44.255303 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:44.255323 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0007a2ba0 {
.  var key string
}

2025/12/19 11:09:44 End // Func
2025/12/19 11:09:44 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:44 ==> MatchType func(key string), func()
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:44 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:44.255443 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (*main.N).OnKey__1(a string, fn func(key string))
2025/12/19 11:09:44.255461 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(a string, fn func(key string))
2025/12/19 11:09:44.255485 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0005c3b90 0 [0xc0005034d0 0xc000688800] 0 [] 0 172} ()
2025/12/19 11:09:44 Val n *main.N
2025/12/19 11:09:44.255511 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n *main.N
2025/12/19 11:09:44.255527 [INFO] typesutil/gopinfo.go:215: ==> Type: n *main.N
2025/12/19 11:09:44 Member onKey 1 // *main.N
2025/12/19 11:09:44.255551 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (main.N).OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44.255563 [INFO] typesutil/gopinfo.go:274: ==> Overloads: onKey TyOverloadMethod
2025/12/19 11:09:44.255578 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:09:44.255608 [INFO] typesutil/gopinfo.go:215: ==> Type: &{182 STRING "1" <nil>} untyped string
2025/12/19 11:09:44 SliceLit <nil> 1 false
2025/12/19 11:09:44 NewClosure func()
2025/12/19 11:09:44.255640 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0007a2cc0 {
}

2025/12/19 11:09:44 End // Func
2025/12/19 11:09:44 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []string, string
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []string, string
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []string, []string
2025/12/19 11:09:44 ==> MatchType func(), func()
2025/12/19 11:09:44.255757 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (*main.N).OnKey__2(a []string, fn func())
2025/12/19 11:09:44.255775 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(a []string, fn func())
2025/12/19 11:09:44.255796 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0005c3ba8 0 [0xc000503590 0xc000688880] 0 [] 0 194} ()
2025/12/19 11:09:44 Val n *main.N
2025/12/19 11:09:44.255821 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n *main.N
2025/12/19 11:09:44.255835 [INFO] typesutil/gopinfo.go:215: ==> Type: n *main.N
2025/12/19 11:09:44 Member onKey 1 // *main.N
2025/12/19 11:09:44.255859 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (main.N).OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44.255871 [INFO] typesutil/gopinfo.go:274: ==> Overloads: onKey TyOverloadMethod
2025/12/19 11:09:44.255886 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 Val &{0 STRING "2"} *ast.BasicLit
2025/12/19 11:09:44.255920 [INFO] typesutil/gopinfo.go:215: ==> Type: &{204 STRING "2" <nil>} untyped string
2025/12/19 11:09:44 SliceLit <nil> 1 false
2025/12/19 11:09:44 Val &{0 STRING "2"} *ast.BasicLit
2025/12/19 11:09:44.255966 [INFO] typesutil/gopinfo.go:215: ==> Type: &{204 STRING "2" <nil>} untyped string
2025/12/19 11:09:44 SliceLit <nil> 1 false
2025/12/19 11:09:44.255988 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:44 NewClosure func(key string)
2025/12/19 11:09:44.256017 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:44.256037 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0007a2e40 {
.  var key string
}

2025/12/19 11:09:44 End // Func
2025/12/19 11:09:44 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []string, string
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []string, string
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []string, []string
2025/12/19 11:09:44 ==> MatchType func(key string), func()
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []string, []string
2025/12/19 11:09:44 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:44.256200 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (*main.N).OnKey__3(a []string, fn func(key string))
2025/12/19 11:09:44.256219 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(a []string, fn func(key string))
2025/12/19 11:09:44.256241 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0005c3bc0 0 [0xc000503650 0xc000688900] 0 [] 0 220} ()
2025/12/19 11:09:44 Val n *main.N
2025/12/19 11:09:44.256267 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n *main.N
2025/12/19 11:09:44.256283 [INFO] typesutil/gopinfo.go:215: ==> Type: n *main.N
2025/12/19 11:09:44 Member onKey 1 // *main.N
2025/12/19 11:09:44.256313 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (main.N).OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44.256326 [INFO] typesutil/gopinfo.go:274: ==> Overloads: onKey TyOverloadMethod
2025/12/19 11:09:44.256341 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 Val m1 *main.Mesh
2025/12/19 11:09:44.256370 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:44.256384 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:44 Val m2 *main.Mesh
2025/12/19 11:09:44.256406 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:44.256417 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:44 SliceLit <nil> 2 false
2025/12/19 11:09:44 NewClosure func()
2025/12/19 11:09:44.256451 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0007a2f60 {
}

2025/12/19 11:09:44 End // Func
2025/12/19 11:09:44 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []*main.Mesh, string
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []*main.Mesh, string
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []*main.Mesh, []string
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []*main.Mesh, []string
2025/12/19 11:09:44 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []*main.Mesh, []main.Mesher
2025/12/19 11:09:44 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []*main.Mesh, []main.Mesher
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []*main.Mesh, int
2025/12/19 11:09:44 Val m1 *main.Mesh
2025/12/19 11:09:44.256710 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:44.256725 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:44 Val m2 *main.Mesh
2025/12/19 11:09:44.256745 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:44.256756 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:44 SliceLit <nil> 2 false
2025/12/19 11:09:44 Val m1 *main.Mesh
2025/12/19 11:09:44.256792 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:44.256807 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:44 Val m2 *main.Mesh
2025/12/19 11:09:44.256829 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:44.256842 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:44 SliceLit []string 2 false
2025/12/19 11:09:44 Val m1 *main.Mesh
2025/12/19 11:09:44.256890 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:44.256902 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:44 Val m2 *main.Mesh
2025/12/19 11:09:44.256925 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:44.256938 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:44 SliceLit []string 2 false
2025/12/19 11:09:44 Val m1 *main.Mesh
2025/12/19 11:09:44.256977 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:44.256989 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:44 Val m2 *main.Mesh
2025/12/19 11:09:44.257008 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:44.257019 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:44 SliceLit []main.Mesher 2 false
2025/12/19 11:09:44 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:44 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:44 NewClosure func()
2025/12/19 11:09:44.257104 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0007a3020 {
}

2025/12/19 11:09:44 End // Func
2025/12/19 11:09:44 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []main.Mesher, string
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []main.Mesher, string
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []main.Mesher, []string
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []main.Mesher, []string
2025/12/19 11:09:44 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []main.Mesher, []main.Mesher
2025/12/19 11:09:44 ==> MatchType func(), func()
2025/12/19 11:09:44.257263 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (*main.N).OnKey__4(a []main.Mesher, fn func())
2025/12/19 11:09:44.257361 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(a []main.Mesher, fn func())
2025/12/19 11:09:44.257391 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0005c3bd8 0 [0xc0005036e0 0xc000688940] 0 [] 0 245} ()
2025/12/19 11:09:44 Val n *main.N
2025/12/19 11:09:44.257418 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n *main.N
2025/12/19 11:09:44.257437 [INFO] typesutil/gopinfo.go:215: ==> Type: n *main.N
2025/12/19 11:09:44 Member onKey 1 // *main.N
2025/12/19 11:09:44.257464 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (main.N).OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44.257476 [INFO] typesutil/gopinfo.go:274: ==> Overloads: onKey TyOverloadMethod
2025/12/19 11:09:44.257492 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 Val m1 *main.Mesh
2025/12/19 11:09:44.257518 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:44.257533 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:44 Val m2 *main.Mesh
2025/12/19 11:09:44.257554 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:44.257568 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:44 SliceLit <nil> 2 false
2025/12/19 11:09:44 Val m1 *main.Mesh
2025/12/19 11:09:44.257606 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:44.257617 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:44 Val m2 *main.Mesh
2025/12/19 11:09:44.257637 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:44.257661 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:44 SliceLit <nil> 2 false
2025/12/19 11:09:44.257671 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:44 NewClosure func(key string)
2025/12/19 11:09:44.257682 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:44.257690 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0007a31a0 {
.  var key string
}

2025/12/19 11:09:44 End // Func
2025/12/19 11:09:44 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []*main.Mesh, string
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []*main.Mesh, string
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []*main.Mesh, []string
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []*main.Mesh, []string
2025/12/19 11:09:44 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []*main.Mesh, []main.Mesher
2025/12/19 11:09:44 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []*main.Mesh, []main.Mesher
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []*main.Mesh, int
2025/12/19 11:09:44 Val m1 *main.Mesh
2025/12/19 11:09:44.257818 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:44.257824 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:44 Val m2 *main.Mesh
2025/12/19 11:09:44.257834 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:44.257840 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:44 SliceLit []string 2 false
2025/12/19 11:09:44 Val m1 *main.Mesh
2025/12/19 11:09:44.257862 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:44.257867 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:44 Val m2 *main.Mesh
2025/12/19 11:09:44.257877 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:44.257882 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:44 SliceLit []string 2 false
2025/12/19 11:09:44 Val m1 *main.Mesh
2025/12/19 11:09:44.257902 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:44.257908 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:44 Val m2 *main.Mesh
2025/12/19 11:09:44.257916 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:44.257921 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:44 SliceLit []main.Mesher 2 false
2025/12/19 11:09:44 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:44 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:44 Val m1 *main.Mesh
2025/12/19 11:09:44.257948 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:44.257954 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:44 Val m2 *main.Mesh
2025/12/19 11:09:44.257963 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:44.257968 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:44 SliceLit []main.Mesher 2 false
2025/12/19 11:09:44 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:44 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:44.257988 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key main.Mesher
2025/12/19 11:09:44 NewClosure func(key main.Mesher)
2025/12/19 11:09:44.257999 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key main.Mesher
2025/12/19 11:09:44.258007 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0007a33e0 {
.  var key main.Mesher
}

2025/12/19 11:09:44 End // Func
2025/12/19 11:09:44 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []main.Mesher, string
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []main.Mesher, string
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []main.Mesher, []string
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []main.Mesher, []string
2025/12/19 11:09:44 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []main.Mesher, []main.Mesher
2025/12/19 11:09:44 ==> MatchType func(key main.Mesher), func()
2025/12/19 11:09:44 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType []main.Mesher, []main.Mesher
2025/12/19 11:09:44 ==> MatchType func(key main.Mesher), func(key main.Mesher)
2025/12/19 11:09:44.258095 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (*main.N).OnKey__5(a []main.Mesher, fn func(key main.Mesher))
2025/12/19 11:09:44.258103 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(a []main.Mesher, fn func(key main.Mesher))
2025/12/19 11:09:44.258115 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0005c3bf0 0 [0xc000503770 0xc000688980] 0 [] 0 274} ()
2025/12/19 11:09:44 Val n *main.N
2025/12/19 11:09:44.258126 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n *main.N
2025/12/19 11:09:44.258132 [INFO] typesutil/gopinfo.go:215: ==> Type: n *main.N
2025/12/19 11:09:44 Member onKey 1 // *main.N
2025/12/19 11:09:44.258146 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (main.N).OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44.258152 [INFO] typesutil/gopinfo.go:274: ==> Overloads: onKey TyOverloadMethod
2025/12/19 11:09:44.258158 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.258176 [INFO] typesutil/gopinfo.go:215: ==> Type: &{284 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit <nil> 1 false
2025/12/19 11:09:44 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:44.258190 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "b" <nil>} untyped string
2025/12/19 11:09:44 SliceLit <nil> 1 false
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.258207 [INFO] typesutil/gopinfo.go:215: ==> Type: &{284 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit <nil> 1 false
2025/12/19 11:09:44 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:44.258219 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "b" <nil>} untyped string
2025/12/19 11:09:44 SliceLit <nil> 1 false
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.258232 [INFO] typesutil/gopinfo.go:215: ==> Type: &{284 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit []string 1 false
2025/12/19 11:09:44 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:44.258248 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "b" <nil>} untyped string
2025/12/19 11:09:44 SliceLit <nil> 1 false
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.258265 [INFO] typesutil/gopinfo.go:215: ==> Type: &{284 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit []string 1 false
2025/12/19 11:09:44 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:44.258281 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "b" <nil>} untyped string
2025/12/19 11:09:44 SliceLit <nil> 1 false
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.258294 [INFO] typesutil/gopinfo.go:215: ==> Type: &{284 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit []main.Mesher 1 false
2025/12/19 11:09:44 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:44 ==> AssignableConv untyped string main.Mesher false
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.258321 [INFO] typesutil/gopinfo.go:215: ==> Type: &{284 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit []main.Mesher 1 false
2025/12/19 11:09:44 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:44 ==> AssignableConv untyped string main.Mesher false
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.258349 [INFO] typesutil/gopinfo.go:215: ==> Type: &{284 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit []string 1 false
2025/12/19 11:09:44 Val &{0 STRING "b"} *ast.BasicLit
2025/12/19 11:09:44.258393 [INFO] typesutil/gopinfo.go:215: ==> Type: &{291 STRING "b" <nil>} untyped string
2025/12/19 11:09:44 SliceLit []string 1 false
2025/12/19 11:09:44.258403 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:44 NewClosure func(key string)
2025/12/19 11:09:44.258416 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:44.258424 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0002d4060 {
.  var key string
}

2025/12/19 11:09:44 End // Func
2025/12/19 11:09:44 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 ==> MatchFuncCall TyOverloadMethod args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchType []string, []string
2025/12/19 11:09:44 ==> MatchType []string, []string
2025/12/19 11:09:44 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:44.258534 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (*main.N).OnKey__6(a []string, b []string, fn func(key string))
2025/12/19 11:09:44.258542 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(a []string, b []string, fn func(key string))
2025/12/19 11:09:44.258553 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0005c3c08 0 [0xc000503830 0xc000503890 0xc0006889c0] 0 [] 0 307} ()
2025/12/19 11:09:44 Val n *main.N
2025/12/19 11:09:44.258567 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n *main.N
2025/12/19 11:09:44.258573 [INFO] typesutil/gopinfo.go:215: ==> Type: n *main.N
2025/12/19 11:09:44 Member onKey 1 // *main.N
2025/12/19 11:09:44.258586 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (main.N).OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44.258593 [INFO] typesutil/gopinfo.go:274: ==> Overloads: onKey TyOverloadMethod
2025/12/19 11:09:44.258601 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.258613 [INFO] typesutil/gopinfo.go:215: ==> Type: &{317 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit <nil> 1 false
2025/12/19 11:09:44 Val m1 *main.Mesh
2025/12/19 11:09:44.258629 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:44.258636 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:44 Val m2 *main.Mesh
2025/12/19 11:09:44.258646 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:44.258654 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:44 SliceLit <nil> 2 false
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.258670 [INFO] typesutil/gopinfo.go:215: ==> Type: &{317 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit <nil> 1 false
2025/12/19 11:09:44 Val m1 *main.Mesh
2025/12/19 11:09:44.258686 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:44.258692 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:44 Val m2 *main.Mesh
2025/12/19 11:09:44.258702 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:44.258707 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:44 SliceLit <nil> 2 false
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.258722 [INFO] typesutil/gopinfo.go:215: ==> Type: &{317 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit []string 1 false
2025/12/19 11:09:44 Val m1 *main.Mesh
2025/12/19 11:09:44.258736 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:44.258741 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:44 Val m2 *main.Mesh
2025/12/19 11:09:44.258750 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:44.258755 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:44 SliceLit <nil> 2 false
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.258771 [INFO] typesutil/gopinfo.go:215: ==> Type: &{317 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit []string 1 false
2025/12/19 11:09:44 Val m1 *main.Mesh
2025/12/19 11:09:44.258787 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:44.258793 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:44 Val m2 *main.Mesh
2025/12/19 11:09:44.258803 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:44.258808 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:44 SliceLit <nil> 2 false
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.258823 [INFO] typesutil/gopinfo.go:215: ==> Type: &{317 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit []main.Mesher 1 false
2025/12/19 11:09:44 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:44 ==> AssignableConv untyped string main.Mesher false
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.258851 [INFO] typesutil/gopinfo.go:215: ==> Type: &{317 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit []main.Mesher 1 false
2025/12/19 11:09:44 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:44 ==> AssignableConv untyped string main.Mesher false
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.258876 [INFO] typesutil/gopinfo.go:215: ==> Type: &{317 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit []string 1 false
2025/12/19 11:09:44 Val m1 *main.Mesh
2025/12/19 11:09:44.258890 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:44.258895 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:44 Val m2 *main.Mesh
2025/12/19 11:09:44.258904 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:44.258909 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:44 SliceLit []string 2 false
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.258928 [INFO] typesutil/gopinfo.go:215: ==> Type: &{317 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit []string 1 false
2025/12/19 11:09:44 Val m1 *main.Mesh
2025/12/19 11:09:44.258944 [INFO] typesutil/gopinfo.go:265: ==> Use: m1 var main.m1 *main.Mesh
2025/12/19 11:09:44.258949 [INFO] typesutil/gopinfo.go:215: ==> Type: m1 *main.Mesh
2025/12/19 11:09:44 Val m2 *main.Mesh
2025/12/19 11:09:44.258959 [INFO] typesutil/gopinfo.go:265: ==> Use: m2 var main.m2 *main.Mesh
2025/12/19 11:09:44.258965 [INFO] typesutil/gopinfo.go:215: ==> Type: m2 *main.Mesh
2025/12/19 11:09:44 SliceLit []main.Mesher 2 false
2025/12/19 11:09:44 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:44 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:44.258984 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:44 NewClosure func(key string)
2025/12/19 11:09:44.258994 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:44.259003 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0002d4240 {
.  var key string
}

2025/12/19 11:09:44 End // Func
2025/12/19 11:09:44 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 ==> MatchFuncCall TyOverloadMethod args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchType []string, []string
2025/12/19 11:09:44 ==> MatchType []main.Mesher, []string
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchType []string, []string
2025/12/19 11:09:44 ==> MatchType []main.Mesher, []main.Mesher
2025/12/19 11:09:44 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:44.259123 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (*main.N).OnKey__7(a []string, b []main.Mesher, fn func(key string))
2025/12/19 11:09:44.259131 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(a []string, b []main.Mesher, fn func(key string))
2025/12/19 11:09:44.259142 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0005c3c20 0 [0xc000503980 0xc0005039b0 0xc000688a40] 0 [] 0 343} ()
2025/12/19 11:09:44 Val n *main.N
2025/12/19 11:09:44.259155 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n *main.N
2025/12/19 11:09:44.259160 [INFO] typesutil/gopinfo.go:215: ==> Type: n *main.N
2025/12/19 11:09:44 Member onKey 1 // *main.N
2025/12/19 11:09:44.259172 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (main.N).OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44.259178 [INFO] typesutil/gopinfo.go:274: ==> Overloads: onKey TyOverloadMethod
2025/12/19 11:09:44.259185 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.259199 [INFO] typesutil/gopinfo.go:215: ==> Type: &{353 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit <nil> 1 false
2025/12/19 11:09:44 Val nil untyped nil
2025/12/19 11:09:44.259214 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/12/19 11:09:44.259228 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.259249 [INFO] typesutil/gopinfo.go:215: ==> Type: &{353 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit <nil> 1 false
2025/12/19 11:09:44 Val nil untyped nil
2025/12/19 11:09:44.259264 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/12/19 11:09:44.259269 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.259285 [INFO] typesutil/gopinfo.go:215: ==> Type: &{353 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit []string 1 false
2025/12/19 11:09:44 Val nil untyped nil
2025/12/19 11:09:44.259299 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/12/19 11:09:44.259304 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.259319 [INFO] typesutil/gopinfo.go:215: ==> Type: &{353 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit []string 1 false
2025/12/19 11:09:44 Val nil untyped nil
2025/12/19 11:09:44.259333 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/12/19 11:09:44.259338 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.259350 [INFO] typesutil/gopinfo.go:215: ==> Type: &{353 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit []main.Mesher 1 false
2025/12/19 11:09:44 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:44 ==> AssignableConv untyped string main.Mesher false
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.259382 [INFO] typesutil/gopinfo.go:215: ==> Type: &{353 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit []main.Mesher 1 false
2025/12/19 11:09:44 ==> EnsureLoaded main.Mesher
2025/12/19 11:09:44 ==> AssignableConv untyped string main.Mesher false
2025/12/19 11:09:44 Val &{0 STRING "a"} *ast.BasicLit
2025/12/19 11:09:44.259406 [INFO] typesutil/gopinfo.go:215: ==> Type: &{353 STRING "a" <nil>} untyped string
2025/12/19 11:09:44 SliceLit []string 1 false
2025/12/19 11:09:44 Val nil untyped nil
2025/12/19 11:09:44.259419 [INFO] typesutil/gopinfo.go:265: ==> Use: nil nil
2025/12/19 11:09:44.259423 [INFO] typesutil/gopinfo.go:215: ==> Type: nil untyped nil
2025/12/19 11:09:44.259429 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:44 NewClosure func(key string)
2025/12/19 11:09:44.259439 [INFO] typesutil/gopinfo.go:251: ==> Def: key var key string
2025/12/19 11:09:44.259446 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0002d4420 {
.  var key string
}

2025/12/19 11:09:44 End // Func
2025/12/19 11:09:44 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 ==> MatchFuncCall TyOverloadMethod args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func()) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, fn func()) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 3 flags: 0
2025/12/19 11:09:44 ==> MatchType []string, []string
2025/12/19 11:09:44 ==> MatchType untyped nil, []string
2025/12/19 11:09:44 ==> MatchType func(key string), func(key string)
2025/12/19 11:09:44.259559 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (*main.N).OnKey__6(a []string, b []string, fn func(key string))
2025/12/19 11:09:44.259567 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(a []string, b []string, fn func(key string))
2025/12/19 11:09:44.259575 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0005c3c38 0 [0xc000503aa0 nil 0xc000688ac0] 0 [] 0 374} ()
2025/12/19 11:09:44 Val n *main.N
2025/12/19 11:09:44.259589 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n *main.N
2025/12/19 11:09:44.259594 [INFO] typesutil/gopinfo.go:215: ==> Type: n *main.N
2025/12/19 11:09:44 Member onKey 1 // *main.N
2025/12/19 11:09:44.259607 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (main.N).OnKey(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44.259612 [INFO] typesutil/gopinfo.go:274: ==> Overloads: onKey TyOverloadMethod
2025/12/19 11:09:44.259618 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:44.259631 [INFO] typesutil/gopinfo.go:215: ==> Type: &{383 INT 100 <nil>} untyped int
2025/12/19 11:09:44 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:44.259643 [INFO] typesutil/gopinfo.go:215: ==> Type: &{388 INT 200 <nil>} untyped int
2025/12/19 11:09:44 NewClosure func() int
2025/12/19 11:09:44 End // Func
2025/12/19 11:09:44 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType untyped int (100), string
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType untyped int (100), string
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType untyped int (100), []string
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType untyped int (100), []string
2025/12/19 11:09:44 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType untyped int (100), []main.Mesher
2025/12/19 11:09:44 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType untyped int (100), []main.Mesher
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType untyped int (100), int
2025/12/19 11:09:44 ==> MatchType func() int, int
2025/12/19 11:09:44 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:44.259772 [INFO] typesutil/gopinfo.go:215: ==> Type: &{383 INT 100 <nil>} untyped int
2025/12/19 11:09:44 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:09:44.259785 [INFO] typesutil/gopinfo.go:215: ==> Type: &{388 INT 200 <nil>} untyped int
2025/12/19 11:09:44 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:44 ==> MatchFuncCall TyOverloadMethod args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType untyped int (100), string
2025/12/19 11:09:44 ==> MatchFuncCall func(a string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType untyped int (100), string
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType untyped int (100), []string
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType untyped int (100), []string
2025/12/19 11:09:44 ==> MatchFuncCall func(a []main.Mesher, fn func()) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType untyped int (100), []main.Mesher
2025/12/19 11:09:44 ==> MatchFuncCall func(a []main.Mesher, fn func(key main.Mesher)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType untyped int (100), []main.Mesher
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, b []string, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(a []string, b []main.Mesher, fn func(key string)) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchFuncCall func(x int, y int) args: 2 flags: 0
2025/12/19 11:09:44 ==> MatchType untyped int (100), int
2025/12/19 11:09:44 ==> MatchType untyped int (200), int
2025/12/19 11:09:44.259889 [INFO] typesutil/gopinfo.go:265: ==> Use: onKey func (*main.N).OnKey__8(x int, y int)
2025/12/19 11:09:44.259896 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n onKey} func(x int, y int)
2025/12/19 11:09:44.259904 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0005c3c50 0 [0xc000503b30 0xc000503b60] 0 [] 0 391} ()
2025/12/19 11:09:44.259912 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0007a2900 {
.  var n *main.N
}

2025/12/19 11:09:44 End // Func
2025/12/19 11:09:44 NewFunc Name (*main.Mesh) func() string
2025/12/19 11:09:44 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:09:44.259938 [INFO] typesutil/gopinfo.go:215: ==> Type: &{63 STRING "hello" <nil>} untyped string
2025/12/19 11:09:44 Return 1
2025/12/19 11:09:44 ==> MatchType untyped string ("hello"), string
2025/12/19 11:09:44.259956 [INFO] typesutil/gopinfo.go:332: ==> Scope: func Name scope 0xc0002d46c0 {
.  var p *main.Mesh
}

2025/12/19 11:09:44 End // Func
    info_test.go:190: == types ==
        000:  2:11 | struct {
        }          *ast.StructType                | type    : struct{} | type
        001:  5:10 | Mesh                *ast.Ident                     | type    : main.Mesh | type
        002:  5:23 | string              *ast.Ident                     | type    : string | type
        003:  6: 9 | "hello"             *ast.BasicLit                  | value   : untyped string = "hello" | constant
        004: 10: 7 | &Mesh{}             *ast.UnaryExpr                 | value   : *main.Mesh | value
        005: 10: 8 | Mesh                *ast.Ident                     | type    : main.Mesh | type
        006: 10: 8 | Mesh{}              *ast.CompositeLit              | value   : main.Mesh | value
        007: 11: 7 | &Mesh{}             *ast.UnaryExpr                 | value   : *main.Mesh | value
        008: 11: 8 | Mesh                *ast.Ident                     | type    : main.Mesh | type
        009: 11: 8 | Mesh{}              *ast.CompositeLit              | value   : main.Mesh | value
        010: 14: 6 | &N{}                *ast.UnaryExpr                 | value   : *main.N | value
        011: 14: 7 | N                   *ast.Ident                     | type    : main.N | type
        012: 14: 7 | N{}                 *ast.CompositeLit              | value   : main.N | value
        013: 15: 1 | n                   *ast.Ident                     | var     : *main.N | variable
        014: 15: 1 | n.onKey             *ast.SelectorExpr              | value   : func(a string, fn func()) | value
        015: 15: 1 | n.onKey "hello", => {
        } *ast.CallExpr                  | void    : () | no value
        016: 15: 9 | "hello"             *ast.BasicLit                  | value   : untyped string = "hello" | constant
        017: 17: 1 | n                   *ast.Ident                     | var     : *main.N | variable
        018: 17: 1 | n.onKey             *ast.SelectorExpr              | value   : func(a string, fn func(key string)) | value
        019: 17: 1 | n.onKey "hello", key => {
        } *ast.CallExpr                  | void    : () | no value
        020: 17: 9 | "hello"             *ast.BasicLit                  | value   : untyped string = "hello" | constant
        021: 19: 1 | n                   *ast.Ident                     | var     : *main.N | variable
        022: 19: 1 | n.onKey             *ast.SelectorExpr              | value   : func(a []string, fn func()) | value
        023: 19: 1 | n.onKey ["1"], => {
        } *ast.CallExpr                  | void    : () | no value
        024: 19:10 | "1"                 *ast.BasicLit                  | value   : untyped string = "1" | constant
        025: 21: 1 | n                   *ast.Ident                     | var     : *main.N | variable
        026: 21: 1 | n.onKey             *ast.SelectorExpr              | value   : func(a []string, fn func(key string)) | value
        027: 21: 1 | n.onKey ["2"], key => {
        } *ast.CallExpr                  | void    : () | no value
        028: 21:10 | "2"                 *ast.BasicLit                  | value   : untyped string = "2" | constant
        029: 23: 1 | n                   *ast.Ident                     | var     : *main.N | variable
        030: 23: 1 | n.onKey             *ast.SelectorExpr              | value   : func(a []main.Mesher, fn func()) | value
        031: 23: 1 | n.onKey [m1, m2], => {
        } *ast.CallExpr                  | void    : () | no value
        032: 23:10 | m1                  *ast.Ident                     | var     : *main.Mesh | variable
        033: 23:14 | m2                  *ast.Ident                     | var     : *main.Mesh | variable
        034: 25: 1 | n                   *ast.Ident                     | var     : *main.N | variable
        035: 25: 1 | n.onKey             *ast.SelectorExpr              | value   : func(a []main.Mesher, fn func(key main.Mesher)) | value
        036: 25: 1 | n.onKey [m1, m2], key => {
        } *ast.CallExpr                  | void    : () | no value
        037: 25:10 | m1                  *ast.Ident                     | var     : *main.Mesh | variable
        038: 25:14 | m2                  *ast.Ident                     | var     : *main.Mesh | variable
        039: 27: 1 | n                   *ast.Ident                     | var     : *main.N | variable
        040: 27: 1 | n.onKey             *ast.SelectorExpr              | value   : func(a []string, b []string, fn func(key string)) | value
        041: 27: 1 | n.onKey ["a"], ["b"], key => {
        } *ast.CallExpr                  | void    : () | no value
        042: 27:10 | "a"                 *ast.BasicLit                  | value   : untyped string = "a" | constant
        043: 27:17 | "b"                 *ast.BasicLit                  | value   : untyped string = "b" | constant
        044: 29: 1 | n                   *ast.Ident                     | var     : *main.N | variable
        045: 29: 1 | n.onKey             *ast.SelectorExpr              | value   : func(a []string, b []main.Mesher, fn func(key string)) | value
        046: 29: 1 | n.onKey ["a"], [m1, m2], key => {
        } *ast.CallExpr                  | void    : () | no value
        047: 29:10 | "a"                 *ast.BasicLit                  | value   : untyped string = "a" | constant
        048: 29:17 | m1                  *ast.Ident                     | var     : *main.Mesh | variable
        049: 29:21 | m2                  *ast.Ident                     | var     : *main.Mesh | variable
        050: 31: 1 | n                   *ast.Ident                     | var     : *main.N | variable
        051: 31: 1 | n.onKey             *ast.SelectorExpr              | value   : func(a []string, b []string, fn func(key string)) | value
        052: 31: 1 | n.onKey ["a"], nil, key => {
        } *ast.CallExpr                  | void    : () | no value
        053: 31:10 | "a"                 *ast.BasicLit                  | value   : untyped string = "a" | constant
        054: 31:16 | nil                 *ast.Ident                     | nil     : untyped nil | value
        055: 33: 1 | n                   *ast.Ident                     | var     : *main.N | variable
        056: 33: 1 | n.onKey             *ast.SelectorExpr              | value   : func(x int, y int) | value
        057: 33: 1 | n.onKey 100, 200    *ast.CallExpr                  | void    : () | no value
        058: 33: 9 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        059: 33:14 | 200                 *ast.BasicLit                  | value   : untyped int = 200 | constant
        == defs ==
        000:  2: 6 | Mesh                | type main.Mesh struct{}
        001:  5: 7 | p                   | var p *main.Mesh
        002:  5:16 | Name                | func (*main.Mesh).Name() string
        003: 10: 2 | m1                  | var main.m1 *main.Mesh
        004: 11: 2 | m2                  | var main.m2 *main.Mesh
        005: 14: 1 | main                | func main.main()
        006: 14: 1 | n                   | var n *main.N
        007: 17:18 | key                 | var key string
        008: 21:16 | key                 | var key string
        009: 25:19 | key                 | var key main.Mesher
        010: 27:23 | key                 | var key string
        011: 29:26 | key                 | var key string
        012: 31:21 | key                 | var key string
        == uses ==
        000:  5:10 | Mesh                | type main.Mesh struct{}
        001:  5:23 | string              | type string
        002: 10: 8 | Mesh                | type main.Mesh struct{}
        003: 11: 8 | Mesh                | type main.Mesh struct{}
        004: 14: 7 | N                   | type main.N struct{}
        005: 15: 1 | n                   | var n *main.N
        006: 15: 3 | onKey               | func (*main.N).OnKey__0(a string, fn func())
        007: 17: 1 | n                   | var n *main.N
        008: 17: 3 | onKey               | func (*main.N).OnKey__1(a string, fn func(key string))
        009: 19: 1 | n                   | var n *main.N
        010: 19: 3 | onKey               | func (*main.N).OnKey__2(a []string, fn func())
        011: 21: 1 | n                   | var n *main.N
        012: 21: 3 | onKey               | func (*main.N).OnKey__3(a []string, fn func(key string))
        013: 23: 1 | n                   | var n *main.N
        014: 23: 3 | onKey               | func (*main.N).OnKey__4(a []main.Mesher, fn func())
        015: 23:10 | m1                  | var main.m1 *main.Mesh
        016: 23:14 | m2                  | var main.m2 *main.Mesh
        017: 25: 1 | n                   | var n *main.N
        018: 25: 3 | onKey               | func (*main.N).OnKey__5(a []main.Mesher, fn func(key main.Mesher))
        019: 25:10 | m1                  | var main.m1 *main.Mesh
        020: 25:14 | m2                  | var main.m2 *main.Mesh
        021: 27: 1 | n                   | var n *main.N
        022: 27: 3 | onKey               | func (*main.N).OnKey__6(a []string, b []string, fn func(key string))
        023: 29: 1 | n                   | var n *main.N
        024: 29: 3 | onKey               | func (*main.N).OnKey__7(a []string, b []main.Mesher, fn func(key string))
        025: 29:17 | m1                  | var main.m1 *main.Mesh
        026: 29:21 | m2                  | var main.m2 *main.Mesh
        027: 31: 1 | n                   | var n *main.N
        028: 31: 3 | onKey               | func (*main.N).OnKey__6(a []string, b []string, fn func(key string))
        029: 31:16 | nil                 | nil
        030: 33: 1 | n                   | var n *main.N
        031: 33: 3 | onKey               | func (*main.N).OnKey__8(x int, y int)
        == overloads ==
        000: 15: 3 | onKey               | func (main.N).OnKey(__xgo_overload_args__ interface{_()})
        001: 17: 3 | onKey               | func (main.N).OnKey(__xgo_overload_args__ interface{_()})
        002: 19: 3 | onKey               | func (main.N).OnKey(__xgo_overload_args__ interface{_()})
        003: 21: 3 | onKey               | func (main.N).OnKey(__xgo_overload_args__ interface{_()})
        004: 23: 3 | onKey               | func (main.N).OnKey(__xgo_overload_args__ interface{_()})
        005: 25: 3 | onKey               | func (main.N).OnKey(__xgo_overload_args__ interface{_()})
        006: 27: 3 | onKey               | func (main.N).OnKey(__xgo_overload_args__ interface{_()})
        007: 29: 3 | onKey               | func (main.N).OnKey(__xgo_overload_args__ interface{_()})
        008: 31: 3 | onKey               | func (main.N).OnKey(__xgo_overload_args__ interface{_()})
        009: 33: 3 | onKey               | func (main.N).OnKey(__xgo_overload_args__ interface{_()})
--- PASS: TestMixedOverload2 (1.11s)
=== RUN   TestMixedOverload3
2025/12/19 11:09:44.264956 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 1
2025/12/19 11:09:44 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:44 ==> NewOverloadFunc NewRange
2025/12/19 11:09:45 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:45 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:45 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:45 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:45 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:45 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:45 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:45 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:45 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:45 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:45 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:45 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:45 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:45 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:45 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:45 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:45 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:45 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:45 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:45 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:45 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:45 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:45 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:45 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:45 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:45 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:45 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:45 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:45 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:45 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:45 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:45 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:45 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:45 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:45 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:45 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:45 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:45 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:45 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:45 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:45 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:45 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:45.361592 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0004bf2c0 {
}

2025/12/19 11:09:45 ==> Preload func main
2025/12/19 11:09:45 ==> Preload func Test__0
2025/12/19 11:09:45 ==> Preload func Test__1
2025/12/19 11:09:45 ==> Preload type N
2025/12/19 11:09:45 ==> Preload method N.Test__0
2025/12/19 11:09:45 ==> Preload method N.Test__1
2025/12/19 11:09:45 ==> Load func Test__0
2025/12/19 11:09:45 ==> Load func Test__1
2025/12/19 11:09:45 ==> Load > NewType N
2025/12/19 11:09:45 ==> Load > InitType N
2025/12/19 11:09:45 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:45 ==> Load method *main.N.Test__0
2025/12/19 11:09:45 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:45 ==> Load method *main.N.Test__1
2025/12/19 11:09:45 ==> NewOverloadMethod N Test
2025/12/19 11:09:45 ==> NewOverloadFunc Test
2025/12/19 11:09:45 ==> Load func main
2025/12/19 11:09:45.361753 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:09:45 NewFunc main func()
2025/12/19 11:09:45 Val Test func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:45.361784 [INFO] typesutil/gopinfo.go:265: ==> Use: Test func main.Test(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:45.361792 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Test TyOverloadFunc
2025/12/19 11:09:45.361801 [INFO] typesutil/gopinfo.go:215: ==> Type: Test func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:45 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:45 ==> MatchFuncCall TyOverloadFunc args: 0 flags: 0
2025/12/19 11:09:45 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:45.361831 [INFO] typesutil/gopinfo.go:265: ==> Use: Test func main.Test__0()
2025/12/19 11:09:45.361840 [INFO] typesutil/gopinfo.go:215: ==> Type: Test func()
2025/12/19 11:09:45 Val Test func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:45.361856 [INFO] typesutil/gopinfo.go:265: ==> Use: Test func main.Test(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:45.361862 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Test TyOverloadFunc
2025/12/19 11:09:45.361869 [INFO] typesutil/gopinfo.go:215: ==> Type: Test func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:45 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:45.361897 [INFO] typesutil/gopinfo.go:215: ==> Type: &{12 INT 100 <nil>} untyped int
2025/12/19 11:09:45 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:45 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:09:45 ==> MatchFuncCall func() args: 1 flags: 0
2025/12/19 11:09:45 ==> MatchFuncCall func(n int) args: 1 flags: 0
2025/12/19 11:09:45 ==> MatchType untyped int (100), int
2025/12/19 11:09:45.361946 [INFO] typesutil/gopinfo.go:265: ==> Use: Test func main.Test__1(n int)
2025/12/19 11:09:45.361953 [INFO] typesutil/gopinfo.go:215: ==> Type: Test func(n int)
2025/12/19 11:09:45.361966 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Test 0 [0xc000504c60] 0 [] 0 15} ()
2025/12/19 11:09:45 ==> LookupParent N => type main.N struct{}
2025/12/19 11:09:45.361981 [INFO] typesutil/gopinfo.go:265: ==> Use: N type main.N struct{}
2025/12/19 11:09:45.361989 [INFO] typesutil/gopinfo.go:215: ==> Type: N main.N
2025/12/19 11:09:45.361996 [INFO] typesutil/gopinfo.go:215: ==> Type: N main.N
2025/12/19 11:09:45 ==> Load var main.N [n]
2025/12/19 11:09:45 NewVarDefs
2025/12/19 11:09:45 NewVar [n]
2025/12/19 11:09:45.362026 [INFO] typesutil/gopinfo.go:251: ==> Def: n var n main.N
2025/12/19 11:09:45 Val n main.N
2025/12/19 11:09:45.362042 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n main.N
2025/12/19 11:09:45.362049 [INFO] typesutil/gopinfo.go:215: ==> Type: n main.N
2025/12/19 11:09:45 Member test 1 // main.N
2025/12/19 11:09:45.362068 [INFO] typesutil/gopinfo.go:265: ==> Use: test func (main.N).Test(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:45.362074 [INFO] typesutil/gopinfo.go:274: ==> Overloads: test TyOverloadMethod
2025/12/19 11:09:45.362084 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n test} func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:45 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:45 ==> MatchFuncCall TyOverloadMethod args: 0 flags: 0
2025/12/19 11:09:45 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:45.362106 [INFO] typesutil/gopinfo.go:265: ==> Use: test func (*main.N).Test__0()
2025/12/19 11:09:45.362114 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n test} func()
2025/12/19 11:09:45 Val n main.N
2025/12/19 11:09:45.362128 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n main.N
2025/12/19 11:09:45.362135 [INFO] typesutil/gopinfo.go:215: ==> Type: n main.N
2025/12/19 11:09:45 Member test 1 // main.N
2025/12/19 11:09:45.362147 [INFO] typesutil/gopinfo.go:265: ==> Use: test func (main.N).Test(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:45.362154 [INFO] typesutil/gopinfo.go:274: ==> Overloads: test TyOverloadMethod
2025/12/19 11:09:45.362173 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n test} func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:45 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:09:45.362192 [INFO] typesutil/gopinfo.go:215: ==> Type: &{38 INT 100 <nil>} untyped int
2025/12/19 11:09:45 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:45 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/12/19 11:09:45 ==> MatchFuncCall func() args: 1 flags: 0
2025/12/19 11:09:45 ==> MatchFuncCall func(n int) args: 1 flags: 0
2025/12/19 11:09:45 ==> MatchType untyped int (100), int
2025/12/19 11:09:45.362229 [INFO] typesutil/gopinfo.go:265: ==> Use: test func (*main.N).Test__1(n int)
2025/12/19 11:09:45.362237 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n test} func(n int)
2025/12/19 11:09:45.362247 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00033d458 0 [0xc000504c90] 0 [] 0 41} ()
2025/12/19 11:09:45.362258 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0004bf9e0 {
.  var n main.N
}

2025/12/19 11:09:45 End // Func
    info_test.go:190: == types ==
        000:  2: 1 | Test                *ast.Ident                     | value   : func() | value
        001:  3: 1 | Test                *ast.Ident                     | value   : func(n int) | value
        002:  3: 1 | Test 100            *ast.CallExpr                  | void    : () | no value
        003:  3: 6 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        004:  4: 7 | N                   *ast.Ident                     | type    : main.N | type
        005:  5: 1 | n                   *ast.Ident                     | var     : main.N | variable
        006:  5: 1 | n.test              *ast.SelectorExpr              | value   : func() | value
        007:  6: 1 | n                   *ast.Ident                     | var     : main.N | variable
        008:  6: 1 | n.test              *ast.SelectorExpr              | value   : func(n int) | value
        009:  6: 1 | n.test 100          *ast.CallExpr                  | void    : () | no value
        010:  6: 8 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        == defs ==
        000:  2: 1 | main                | func main.main()
        001:  4: 5 | n                   | var n main.N
        == uses ==
        000:  2: 1 | Test                | func main.Test__0()
        001:  3: 1 | Test                | func main.Test__1(n int)
        002:  4: 7 | N                   | type main.N struct{}
        003:  5: 1 | n                   | var n main.N
        004:  5: 3 | test                | func (*main.N).Test__0()
        005:  6: 1 | n                   | var n main.N
        006:  6: 3 | test                | func (*main.N).Test__1(n int)
        == overloads ==
        000:  2: 1 | Test                | func main.Test(__xgo_overload_args__ interface{_()})
        001:  3: 1 | Test                | func main.Test(__xgo_overload_args__ interface{_()})
        002:  5: 3 | test                | func (main.N).Test(__xgo_overload_args__ interface{_()})
        003:  6: 3 | test                | func (main.N).Test(__xgo_overload_args__ interface{_()})
--- PASS: TestMixedOverload3 (1.10s)
=== RUN   TestOverloadNamed
2025/12/19 11:09:45.363001 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:09:45 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:45 ==> NewOverloadFunc NewRange
2025/12/19 11:09:46 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:46 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:46 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:46 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:46 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:46 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:46 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:46 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:46 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:46 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:46 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:46 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:46 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:46 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:46 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:46 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:46 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:46 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:46 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:46 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:46 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:46 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:46 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:46 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:46 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:46 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:46 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:46 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:46 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:46 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:46 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:46 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:46 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:46 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:46 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:46 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:46 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:46 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:46 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:46 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:46 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:46 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:46.402449 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0002c0e40 {
}

2025/12/19 11:09:46 ==> Import github.com/goplus/xgo/cl/internal/overload/bar
2025/12/19 11:09:46 ==> NewOverloadFunc Gopt_Player_Gopx_OnCmd
2025/12/19 11:09:46 ==> NewTemplateRecvMethod Player Gopx_OnCmd
2025/12/19 11:09:46 ==> AliasMethod github.com/goplus/xgo/cl/internal/overload/bar.Player Gopx_OnCmd => OnCmd
2025/12/19 11:09:46 ==> NewOverloadFunc Gopx_Var_Cast
2025/12/19 11:09:46 ==> AliasFunc Gopx_Var_Cast => Var_Cast
2025/12/19 11:09:46 ==> NewOverloadNamed Var
2025/12/19 11:09:46.423775 [INFO] typesutil/gopinfo.go:292: ==> Implicit: package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
2025/12/19 11:09:46 ==> Preload var [a]
2025/12/19 11:09:46 ==> Preload var [b]
2025/12/19 11:09:46 ==> Preload func main
2025/12/19 11:09:46.423847 [INFO] typesutil/gopinfo.go:265: ==> Use: bar package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
2025/12/19 11:09:46.423876 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:46.423894 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Var TyOverloadNamed{github.com/goplus/xgo/cl/internal/overload/bar.Var}
2025/12/19 11:09:46.423918 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar Var} func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:46.423939 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:46.423955 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:46.423969 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:46.424006 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar Var} github.com/goplus/xgo/cl/internal/overload/bar.Var__0[int]
2025/12/19 11:09:46.424032 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T github.com/goplus/xgo/cl/internal/overload/bar.basetype] struct{val T}
2025/12/19 11:09:46.424055 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000378ed0 72 int 76} github.com/goplus/xgo/cl/internal/overload/bar.Var__0[int]
2025/12/19 11:09:46 ==> Load var github.com/goplus/xgo/cl/internal/overload/bar.Var__0[int] [a]
2025/12/19 11:09:46 NewVarDefs
2025/12/19 11:09:46 NewVar [a]
2025/12/19 11:09:46.424104 [INFO] typesutil/gopinfo.go:251: ==> Def: a var main.a github.com/goplus/xgo/cl/internal/overload/bar.Var__0[int]
2025/12/19 11:09:46.424124 [INFO] typesutil/gopinfo.go:265: ==> Use: bar package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
2025/12/19 11:09:46.424139 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:46.424151 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Var TyOverloadNamed{github.com/goplus/xgo/cl/internal/overload/bar.Var}
2025/12/19 11:09:46.424168 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar Var} func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:46.424183 [INFO] typesutil/gopinfo.go:265: ==> Use: bar package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
2025/12/19 11:09:46.424198 [INFO] typesutil/gopinfo.go:265: ==> Use: M type github.com/goplus/xgo/cl/internal/overload/bar.M = map[string]any
2025/12/19 11:09:46.424215 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar M} map[string]any
2025/12/19 11:09:46.424316 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar Var} github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any]
2025/12/19 11:09:46.424340 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type github.com/goplus/xgo/cl/internal/overload/bar.Var__1[T map[string]any] struct{val T}
2025/12/19 11:09:46.424360 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000378ee8 91 0xc000378f00 97} github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any]
2025/12/19 11:09:46 ==> Load var github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any] [b]
2025/12/19 11:09:46 NewVarDefs
2025/12/19 11:09:46 NewVar [b]
2025/12/19 11:09:46.424409 [INFO] typesutil/gopinfo.go:251: ==> Def: b var main.b github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any]
2025/12/19 11:09:46 ==> Load func main
2025/12/19 11:09:46.424437 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:09:46 NewFunc main func()
2025/12/19 11:09:46 DefineVarStart [c]
2025/12/19 11:09:46.424485 [INFO] typesutil/gopinfo.go:265: ==> Use: bar package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
2025/12/19 11:09:46.424503 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:46.424520 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Var TyOverloadNamed{github.com/goplus/xgo/cl/internal/overload/bar.Var}
2025/12/19 11:09:46 Val Var func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:46 Val type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()}) => Typ func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:46 Val string string
2025/12/19 11:09:46 Val type string => Typ string
2025/12/19 11:09:46.424598 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/12/19 11:09:46.424611 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:46 Call 1 0 // TypeType{typ: func(__xgo_overload_args__ interface{_()})}
2025/12/19 11:09:46 ==> MatchFuncCall TypeType{typ: func(__xgo_overload_args__ interface{_()})} args: 1 flags: 0
2025/12/19 11:09:46 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 8
2025/12/19 11:09:46 ==> MatchFuncCall func[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T] args: 1 flags: 8
2025/12/19 11:09:46 boundTypeParams: bar.Gopx_Var_Cast__0 sig: func[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T] args: 1 flags: 8
2025/12/19 11:09:46.424773 [INFO] typesutil/gopinfo.go:265: ==> Use: Var func github.com/goplus/xgo/cl/internal/overload/bar.Gopx_Var_Cast__0[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T]
2025/12/19 11:09:46.424807 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar Var} func[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T]
2025/12/19 11:09:46.424843 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000378f30 111 [string] 0 [] 118 0} *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[string]
2025/12/19 11:09:46 EndInit 1
2025/12/19 11:09:46.424875 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[string]
2025/12/19 11:09:46 DefineVarStart [d]
2025/12/19 11:09:46.424904 [INFO] typesutil/gopinfo.go:265: ==> Use: bar package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
2025/12/19 11:09:46.424920 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:46.424933 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Var TyOverloadNamed{github.com/goplus/xgo/cl/internal/overload/bar.Var}
2025/12/19 11:09:46 Val Var func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:46 Val type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()}) => Typ func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:46.424978 [INFO] typesutil/gopinfo.go:265: ==> Use: bar package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
2025/12/19 11:09:46.424994 [INFO] typesutil/gopinfo.go:265: ==> Use: M type github.com/goplus/xgo/cl/internal/overload/bar.M = map[string]any
2025/12/19 11:09:46 Val M map[string]any
2025/12/19 11:09:46 Val type github.com/goplus/xgo/cl/internal/overload/bar.M = map[string]any => Typ map[string]any
2025/12/19 11:09:46.425039 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar M} map[string]any
2025/12/19 11:09:46 Call 1 0 // TypeType{typ: func(__xgo_overload_args__ interface{_()})}
2025/12/19 11:09:46 ==> MatchFuncCall TypeType{typ: func(__xgo_overload_args__ interface{_()})} args: 1 flags: 0
2025/12/19 11:09:46 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 8
2025/12/19 11:09:46 ==> MatchFuncCall func[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T] args: 1 flags: 8
2025/12/19 11:09:46 boundTypeParams: bar.Gopx_Var_Cast__0 sig: func[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T] args: 1 flags: 8
2025/12/19 11:09:46 ==> MatchFuncCall func[T map[string]any]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[T] args: 1 flags: 8
2025/12/19 11:09:46 boundTypeParams: bar.Gopx_Var_Cast__1 sig: func[T map[string]any]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[T] args: 1 flags: 8
2025/12/19 11:09:46.425270 [INFO] typesutil/gopinfo.go:265: ==> Use: Var func github.com/goplus/xgo/cl/internal/overload/bar.Gopx_Var_Cast__1[T map[string]any]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[T]
2025/12/19 11:09:46.425295 [INFO] typesutil/gopinfo.go:215: ==> Type: &{bar Var} func[T map[string]any]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[T]
2025/12/19 11:09:46.425320 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000378f48 132 [0xc000378f60] 0 [] 138 0} *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any]
2025/12/19 11:09:46 EndInit 1
2025/12/19 11:09:46.425343 [INFO] typesutil/gopinfo.go:251: ==> Def: d var d *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any]
2025/12/19 11:09:46.425380 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0002f0cc0 {
.  var c *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[string]
.  var d *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any]
}

2025/12/19 11:09:46 End // Func
    info_test.go:190: == types ==
        000:  4: 7 | bar.Var             *ast.SelectorExpr              | type    : github.com/goplus/xgo/cl/internal/overload/bar.Var__0[int] | type
        001:  4: 7 | bar.Var[int]        *ast.IndexExpr                 | type    : github.com/goplus/xgo/cl/internal/overload/bar.Var__0[int] | type
        002:  4:15 | int                 *ast.Ident                     | type    : int | type
        003:  5: 7 | bar.Var             *ast.SelectorExpr              | type    : github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any] | type
        004:  5: 7 | bar.Var[bar.M]      *ast.IndexExpr                 | type    : github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any] | type
        005:  5:15 | bar.M               *ast.SelectorExpr              | type    : map[string]any | type
        006:  6: 6 | bar.Var             *ast.SelectorExpr              | value   : func[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T] | value
        007:  6: 6 | bar.Var(string)     *ast.CallExpr                  | value   : *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[string] | value
        008:  6:14 | string              *ast.Ident                     | type    : string | type
        009:  7: 6 | bar.Var             *ast.SelectorExpr              | value   : func[T map[string]any]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[T] | value
        010:  7: 6 | bar.Var(bar.M)      *ast.CallExpr                  | value   : *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any] | value
        011:  7:14 | bar.M               *ast.SelectorExpr              | var     : map[string]any | variable
        == defs ==
        000:  4: 5 | a                   | var main.a github.com/goplus/xgo/cl/internal/overload/bar.Var__0[int]
        001:  5: 5 | b                   | var main.b github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any]
        002:  6: 1 | c                   | var c *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[string]
        003:  6: 1 | main                | func main.main()
        004:  7: 1 | d                   | var d *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[map[string]any]
        == uses ==
        000:  4: 7 | bar                 | package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
        001:  4:11 | Var                 | type github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T github.com/goplus/xgo/cl/internal/overload/bar.basetype] struct{val T}
        002:  4:15 | int                 | type int
        003:  5: 7 | bar                 | package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
        004:  5:11 | Var                 | type github.com/goplus/xgo/cl/internal/overload/bar.Var__1[T map[string]any] struct{val T}
        005:  5:15 | bar                 | package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
        006:  5:19 | M                   | type github.com/goplus/xgo/cl/internal/overload/bar.M = map[string]any
        007:  6: 6 | bar                 | package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
        008:  6:10 | Var                 | func github.com/goplus/xgo/cl/internal/overload/bar.Gopx_Var_Cast__0[T github.com/goplus/xgo/cl/internal/overload/bar.basetype]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__0[T]
        009:  6:14 | string              | type string
        010:  7: 6 | bar                 | package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
        011:  7:10 | Var                 | func github.com/goplus/xgo/cl/internal/overload/bar.Gopx_Var_Cast__1[T map[string]any]() *github.com/goplus/xgo/cl/internal/overload/bar.Var__1[T]
        012:  7:14 | bar                 | package bar ("github.com/goplus/xgo/cl/internal/overload/bar")
        013:  7:18 | M                   | type github.com/goplus/xgo/cl/internal/overload/bar.M = map[string]any
        == overloads ==
        000:  4:11 | Var                 | type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()})
        001:  5:11 | Var                 | type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()})
        002:  6:10 | Var                 | type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()})
        003:  7:10 | Var                 | type github.com/goplus/xgo/cl/internal/overload/bar.Var = func(__xgo_overload_args__ interface{_()})
--- PASS: TestOverloadNamed (1.06s)
=== RUN   TestMixedOverloadNamed
2025/12/19 11:09:46.426875 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 1
2025/12/19 11:09:47 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:47 ==> NewOverloadFunc NewRange
2025/12/19 11:09:47 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:47 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:47 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:47 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:47 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:47 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:47 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:47 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:47 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:47 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:47 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:47 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:47 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:47 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:47 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:47 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:47 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:47 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:47 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:47 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:47 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:47 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:47 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:47 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:47 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:47 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:47 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:47 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:47 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:47 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:47 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:47 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:47 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:47 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:47 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:47 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:47 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:47 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:47 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:47 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:47 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:47 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:47.587703 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc000296480 {
}

2025/12/19 11:09:47 ==> Preload var [a]
2025/12/19 11:09:47 ==> Preload var [b]
2025/12/19 11:09:47 ==> Preload func main
2025/12/19 11:09:47 ==> Preload type M
2025/12/19 11:09:47 ==> Preload type basetype
2025/12/19 11:09:47 ==> Preload type Var__0
2025/12/19 11:09:47 ==> Preload type Var__1
2025/12/19 11:09:47 ==> Preload func Gopx_Var_Cast__0
2025/12/19 11:09:47 ==> Preload func Gopx_Var_Cast__1
2025/12/19 11:09:47 ==> Load > AliasType M
2025/12/19 11:09:47 ==> Load > NewType Var__0
2025/12/19 11:09:47 ==> Load > InitType Var__0
2025/12/19 11:09:47 ==> Load > NewType basetype
2025/12/19 11:09:47 ==> Lookup (LoadSymbol) basetype => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:47 ==> Load > InitType basetype
2025/12/19 11:09:47 ==> Load > NewType Var__1
2025/12/19 11:09:47 ==> Load > InitType Var__1
2025/12/19 11:09:47 ==> Load func Gopx_Var_Cast__1
2025/12/19 11:09:47 ==> LookupParent Var__1 => type main.Var__1[T map[string]interface{}] struct{val T}
2025/12/19 11:09:47 ==> EnsureLoaded main.Var__1[T map[string]interface{}]
2025/12/19 11:09:47 ==> Load func Gopx_Var_Cast__0
2025/12/19 11:09:47 ==> LookupParent basetype => type main.basetype interface{interface{string | int | bool | float64}}
2025/12/19 11:09:47 ==> LookupParent Var__0 => type main.Var__0[T main.basetype] struct{val T}
2025/12/19 11:09:47 ==> EnsureLoaded main.Var__0[T main.basetype]
2025/12/19 11:09:47 ==> NewOverloadFunc Gopx_Var_Cast
2025/12/19 11:09:47 ==> AliasFunc Gopx_Var_Cast => Var_Cast
2025/12/19 11:09:47 ==> NewOverloadNamed Var
2025/12/19 11:09:47 ==> LookupParent Var => type main.Var = func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:47.588058 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type main.Var = func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:47.588074 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Var TyOverloadNamed{main.Var}
2025/12/19 11:09:47.588086 [INFO] typesutil/gopinfo.go:215: ==> Type: Var func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:47.588096 [INFO] typesutil/gopinfo.go:215: ==> Type: Var func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:47.588104 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:47.588111 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:47.588118 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:47.588135 [INFO] typesutil/gopinfo.go:215: ==> Type: Var main.Var__0[int]
2025/12/19 11:09:47.588147 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type main.Var__0[T main.basetype] struct{val T}
2025/12/19 11:09:47.588162 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Var 11 int 15} main.Var__0[int]
2025/12/19 11:09:47 ==> Load var main.Var__0[int] [a]
2025/12/19 11:09:47 NewVarDefs
2025/12/19 11:09:47 NewVar [a]
2025/12/19 11:09:47.588190 [INFO] typesutil/gopinfo.go:251: ==> Def: a var main.a main.Var__0[int]
2025/12/19 11:09:47 ==> LookupParent Var => type main.Var = func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:47.588208 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type main.Var = func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:47.588217 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Var TyOverloadNamed{main.Var}
2025/12/19 11:09:47.588225 [INFO] typesutil/gopinfo.go:215: ==> Type: Var func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:47.588233 [INFO] typesutil/gopinfo.go:215: ==> Type: Var func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:47 ==> LookupParent M => type main.M = map[string]interface{}
2025/12/19 11:09:47.588249 [INFO] typesutil/gopinfo.go:265: ==> Use: M type main.M = map[string]interface{}
2025/12/19 11:09:47.588256 [INFO] typesutil/gopinfo.go:215: ==> Type: M map[string]interface{}
2025/12/19 11:09:47.588264 [INFO] typesutil/gopinfo.go:215: ==> Type: M map[string]interface{}
2025/12/19 11:09:47.588306 [INFO] typesutil/gopinfo.go:215: ==> Type: Var main.Var__1[map[string]interface{}]
2025/12/19 11:09:47.588324 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type main.Var__1[T map[string]interface{}] struct{val T}
2025/12/19 11:09:47.588336 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Var 26 M 28} main.Var__1[map[string]interface{}]
2025/12/19 11:09:47 ==> Load var main.Var__1[map[string]interface{}] [b]
2025/12/19 11:09:47 NewVarDefs
2025/12/19 11:09:47 NewVar [b]
2025/12/19 11:09:47.588368 [INFO] typesutil/gopinfo.go:251: ==> Def: b var main.b main.Var__1[map[string]interface{}]
2025/12/19 11:09:47 ==> Load func main
2025/12/19 11:09:47.588382 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:09:47 NewFunc main func()
2025/12/19 11:09:47 DefineVarStart [c]
2025/12/19 11:09:47 Val Var func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:47 Val type main.Var = func(__xgo_overload_args__ interface{_()}) => Typ func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:47.588432 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type main.Var = func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:47.588440 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Var TyOverloadNamed{main.Var}
2025/12/19 11:09:47.588448 [INFO] typesutil/gopinfo.go:215: ==> Type: Var func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:47 Val string string
2025/12/19 11:09:47 Val type string => Typ string
2025/12/19 11:09:47.588468 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/12/19 11:09:47.588476 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:47 Call 1 0 // TypeType{typ: func(__xgo_overload_args__ interface{_()})}
2025/12/19 11:09:47 ==> MatchFuncCall TypeType{typ: func(__xgo_overload_args__ interface{_()})} args: 1 flags: 0
2025/12/19 11:09:47 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 8
2025/12/19 11:09:47 ==> MatchFuncCall func[T main.basetype]() *main.Var__0[T] args: 1 flags: 8
2025/12/19 11:09:47 boundTypeParams: Gopx_Var_Cast__0 sig: func[T main.basetype]() *main.Var__0[T] args: 1 flags: 8
2025/12/19 11:09:47.588562 [INFO] typesutil/gopinfo.go:265: ==> Use: Var func main.Gopx_Var_Cast__0[T main.basetype]() *main.Var__0[T]
2025/12/19 11:09:47.588576 [INFO] typesutil/gopinfo.go:215: ==> Type: Var func[T main.basetype]() *main.Var__0[T]
2025/12/19 11:09:47.588594 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Var 38 [string] 0 [] 45 0} *main.Var__0[string]
2025/12/19 11:09:47 EndInit 1
2025/12/19 11:09:47.588610 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c *main.Var__0[string]
2025/12/19 11:09:47 DefineVarStart [d]
2025/12/19 11:09:47 Val Var func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:47 Val type main.Var = func(__xgo_overload_args__ interface{_()}) => Typ func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:47.588641 [INFO] typesutil/gopinfo.go:265: ==> Use: Var type main.Var = func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:47.588649 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Var TyOverloadNamed{main.Var}
2025/12/19 11:09:47.588657 [INFO] typesutil/gopinfo.go:215: ==> Type: Var func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:47 Val M map[string]interface{}
2025/12/19 11:09:47 Val type main.M = map[string]interface{} => Typ map[string]interface{}
2025/12/19 11:09:47.588680 [INFO] typesutil/gopinfo.go:265: ==> Use: M type main.M = map[string]interface{}
2025/12/19 11:09:47.588687 [INFO] typesutil/gopinfo.go:215: ==> Type: M map[string]interface{}
2025/12/19 11:09:47 Call 1 0 // TypeType{typ: func(__xgo_overload_args__ interface{_()})}
2025/12/19 11:09:47 ==> MatchFuncCall TypeType{typ: func(__xgo_overload_args__ interface{_()})} args: 1 flags: 0
2025/12/19 11:09:47 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 8
2025/12/19 11:09:47 ==> MatchFuncCall func[T main.basetype]() *main.Var__0[T] args: 1 flags: 8
2025/12/19 11:09:47 boundTypeParams: Gopx_Var_Cast__0 sig: func[T main.basetype]() *main.Var__0[T] args: 1 flags: 8
2025/12/19 11:09:47 ==> MatchFuncCall func[T map[string]interface{}]() *main.Var__1[T] args: 1 flags: 8
2025/12/19 11:09:47 boundTypeParams: Gopx_Var_Cast__1 sig: func[T map[string]interface{}]() *main.Var__1[T] args: 1 flags: 8
2025/12/19 11:09:47.588789 [INFO] typesutil/gopinfo.go:265: ==> Use: Var func main.Gopx_Var_Cast__1[T map[string]interface{}]() *main.Var__1[T]
2025/12/19 11:09:47.588800 [INFO] typesutil/gopinfo.go:215: ==> Type: Var func[T map[string]interface{}]() *main.Var__1[T]
2025/12/19 11:09:47.588813 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Var 55 [M] 0 [] 57 0} *main.Var__1[map[string]interface{}]
2025/12/19 11:09:47 EndInit 1
2025/12/19 11:09:47.588828 [INFO] typesutil/gopinfo.go:251: ==> Def: d var d *main.Var__1[map[string]interface{}]
2025/12/19 11:09:47.588845 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc000296d20 {
.  var c *main.Var__0[string]
.  var d *main.Var__1[map[string]interface{}]
}

2025/12/19 11:09:47 End // Func
    info_test.go:190: == types ==
        000:  2: 7 | Var                 *ast.Ident                     | type    : main.Var__0[int] | type
        001:  2: 7 | Var[int]            *ast.IndexExpr                 | type    : main.Var__0[int] | type
        002:  2:11 | int                 *ast.Ident                     | type    : int | type
        003:  3: 7 | Var                 *ast.Ident                     | type    : main.Var__1[map[string]interface{}] | type
        004:  3: 7 | Var[M]              *ast.IndexExpr                 | type    : main.Var__1[map[string]interface{}] | type
        005:  3:11 | M                   *ast.Ident                     | type    : map[string]interface{} | type
        006:  4: 6 | Var                 *ast.Ident                     | value   : func[T main.basetype]() *main.Var__0[T] | value
        007:  4: 6 | Var(string)         *ast.CallExpr                  | value   : *main.Var__0[string] | value
        008:  4:10 | string              *ast.Ident                     | type    : string | type
        009:  5: 6 | Var                 *ast.Ident                     | value   : func[T map[string]interface{}]() *main.Var__1[T] | value
        010:  5: 6 | Var(M)              *ast.CallExpr                  | value   : *main.Var__1[map[string]interface{}] | value
        011:  5:10 | M                   *ast.Ident                     | type    : map[string]interface{} | type
        == defs ==
        000:  2: 5 | a                   | var main.a main.Var__0[int]
        001:  3: 5 | b                   | var main.b main.Var__1[map[string]interface{}]
        002:  4: 1 | c                   | var c *main.Var__0[string]
        003:  4: 1 | main                | func main.main()
        004:  5: 1 | d                   | var d *main.Var__1[map[string]interface{}]
        == uses ==
        000:  2: 7 | Var                 | type main.Var__0[T main.basetype] struct{val T}
        001:  2:11 | int                 | type int
        002:  3: 7 | Var                 | type main.Var__1[T map[string]any] struct{val T}
        003:  3:11 | M                   | type main.M = map[string]any
        004:  4: 6 | Var                 | func main.Gopx_Var_Cast__0[T main.basetype]() *main.Var__0[T]
        005:  4:10 | string              | type string
        006:  5: 6 | Var                 | func main.Gopx_Var_Cast__1[T map[string]any]() *main.Var__1[T]
        007:  5:10 | M                   | type main.M = map[string]any
        == overloads ==
        000:  2: 7 | Var                 | type main.Var = func(__xgo_overload_args__ interface{_()})
        001:  3: 7 | Var                 | type main.Var = func(__xgo_overload_args__ interface{_()})
        002:  4: 6 | Var                 | type main.Var = func(__xgo_overload_args__ interface{_()})
        003:  5: 6 | Var                 | type main.Var = func(__xgo_overload_args__ interface{_()})
--- PASS: TestMixedOverloadNamed (1.16s)
=== RUN   TestMixedRawNamed
2025/12/19 11:09:47.590057 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 1
2025/12/19 11:09:48 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:48 ==> NewOverloadFunc NewRange
2025/12/19 11:09:48 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:48 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:48 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:48 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:48 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:48 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:48 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:48 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:48 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:48 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:48 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:48 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:48 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:48 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:48 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:48 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:48 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:48 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:48 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:48 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:48 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:48 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:48 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:48 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:48 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:48 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:48 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:48 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:48 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:48 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:48 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:48 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:48 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:48 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:48 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:48 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:48 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:48 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:48 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:48 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:48 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:48 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:48.737864 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc000360a80 {
}

2025/12/19 11:09:48 ==> Preload var [a]
2025/12/19 11:09:48 ==> Preload var [b]
2025/12/19 11:09:48 ==> Preload func main
2025/12/19 11:09:48 ==> Preload type M
2025/12/19 11:09:48 ==> Preload type basetype
2025/12/19 11:09:48 ==> Preload type Var__0
2025/12/19 11:09:48 ==> Preload type Var__1
2025/12/19 11:09:48 ==> Preload func Gopx_Var_Cast__0
2025/12/19 11:09:48 ==> Preload func Gopx_Var_Cast__1
2025/12/19 11:09:48 ==> Load > AliasType M
2025/12/19 11:09:48 ==> Load > NewType basetype
2025/12/19 11:09:48 ==> Load > InitType basetype
2025/12/19 11:09:48 ==> Load > NewType Var__0
2025/12/19 11:09:48 ==> Load > InitType Var__0
2025/12/19 11:09:48 ==> LookupParent basetype => type main.basetype interface{interface{string | int | bool | float64}}
2025/12/19 11:09:48 ==> Load > NewType Var__1
2025/12/19 11:09:48 ==> Load > InitType Var__1
2025/12/19 11:09:48 ==> Load func Gopx_Var_Cast__0
2025/12/19 11:09:48 ==> LookupParent basetype => type main.basetype interface{interface{string | int | bool | float64}}
2025/12/19 11:09:48 ==> LookupParent Var__0 => type main.Var__0[T main.basetype] struct{val T}
2025/12/19 11:09:48 ==> EnsureLoaded main.Var__0[T main.basetype]
2025/12/19 11:09:48 ==> Load func Gopx_Var_Cast__1
2025/12/19 11:09:48 ==> LookupParent Var__1 => type main.Var__1[T map[string]interface{}] struct{val T}
2025/12/19 11:09:48 ==> EnsureLoaded main.Var__1[T map[string]interface{}]
2025/12/19 11:09:48 ==> NewOverloadFunc Gopx_Var_Cast
2025/12/19 11:09:48 ==> AliasFunc Gopx_Var_Cast => Var_Cast
2025/12/19 11:09:48 ==> NewOverloadNamed Var
2025/12/19 11:09:48 ==> LookupParent Var__0 => type main.Var__0[T main.basetype] struct{val T}
2025/12/19 11:09:48.738401 [INFO] typesutil/gopinfo.go:265: ==> Use: Var__0 type main.Var__0[T main.basetype] struct{val T}
2025/12/19 11:09:48.738423 [INFO] typesutil/gopinfo.go:215: ==> Type: Var__0 main.Var__0[T main.basetype]
2025/12/19 11:09:48.738442 [INFO] typesutil/gopinfo.go:215: ==> Type: Var__0 main.Var__0[T main.basetype]
2025/12/19 11:09:48.738457 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:48.738470 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:48.738482 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:48 ==> EnsureLoaded main.Var__0[T main.basetype]
2025/12/19 11:09:48.738517 [INFO] typesutil/gopinfo.go:215: ==> Type: Var__0 main.Var__0[int]
2025/12/19 11:09:48.738536 [INFO] typesutil/gopinfo.go:265: ==> Use: Var__0 type main.Var__0[T main.basetype] struct{val T}
2025/12/19 11:09:48.738560 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Var__0 14 int 18} main.Var__0[int]
2025/12/19 11:09:48 ==> Load var main.Var__0[int] [a]
2025/12/19 11:09:48 NewVarDefs
2025/12/19 11:09:48 NewVar [a]
2025/12/19 11:09:48.738618 [INFO] typesutil/gopinfo.go:251: ==> Def: a var main.a main.Var__0[int]
2025/12/19 11:09:48 ==> LookupParent Var__1 => type main.Var__1[T map[string]interface{}] struct{val T}
2025/12/19 11:09:48.738656 [INFO] typesutil/gopinfo.go:265: ==> Use: Var__1 type main.Var__1[T map[string]interface{}] struct{val T}
2025/12/19 11:09:48.738673 [INFO] typesutil/gopinfo.go:215: ==> Type: Var__1 main.Var__1[T map[string]interface{}]
2025/12/19 11:09:48.738689 [INFO] typesutil/gopinfo.go:215: ==> Type: Var__1 main.Var__1[T map[string]interface{}]
2025/12/19 11:09:48 ==> LookupParent M => type main.M = map[string]interface{}
2025/12/19 11:09:48.738714 [INFO] typesutil/gopinfo.go:265: ==> Use: M type main.M = map[string]interface{}
2025/12/19 11:09:48.738728 [INFO] typesutil/gopinfo.go:215: ==> Type: M map[string]interface{}
2025/12/19 11:09:48.738741 [INFO] typesutil/gopinfo.go:215: ==> Type: M map[string]interface{}
2025/12/19 11:09:48 ==> EnsureLoaded main.Var__1[T map[string]interface{}]
2025/12/19 11:09:48.738780 [INFO] typesutil/gopinfo.go:215: ==> Type: Var__1 main.Var__1[map[string]interface{}]
2025/12/19 11:09:48.738797 [INFO] typesutil/gopinfo.go:265: ==> Use: Var__1 type main.Var__1[T map[string]interface{}] struct{val T}
2025/12/19 11:09:48.738816 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Var__1 32 M 34} main.Var__1[map[string]interface{}]
2025/12/19 11:09:48 ==> Load var main.Var__1[map[string]interface{}] [b]
2025/12/19 11:09:48 NewVarDefs
2025/12/19 11:09:48 NewVar [b]
2025/12/19 11:09:48.738857 [INFO] typesutil/gopinfo.go:251: ==> Def: b var main.b main.Var__1[map[string]interface{}]
2025/12/19 11:09:48 ==> Load func main
2025/12/19 11:09:48.738882 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:09:48 NewFunc main func()
2025/12/19 11:09:48 DefineVarStart [c]
2025/12/19 11:09:48 Val Gopx_Var_Cast__0 func[T main.basetype]() *main.Var__0[T]
2025/12/19 11:09:48.738947 [INFO] typesutil/gopinfo.go:265: ==> Use: Gopx_Var_Cast__0 func main.Gopx_Var_Cast__0[T main.basetype]() *main.Var__0[T]
2025/12/19 11:09:48.738965 [INFO] typesutil/gopinfo.go:215: ==> Type: Gopx_Var_Cast__0 func[T main.basetype]() *main.Var__0[T]
2025/12/19 11:09:48 Val string string
2025/12/19 11:09:48 Val type string => Typ string
2025/12/19 11:09:48.739000 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/12/19 11:09:48.739013 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:09:48 Index 1 false
2025/12/19 11:09:48 ==> InferType func() *main.Var__0[string]
2025/12/19 11:09:48.739095 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Gopx_Var_Cast__0 57 string 64} func() *main.Var__0[string]
2025/12/19 11:09:48 EndInit 1
2025/12/19 11:09:48.739123 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c func() *main.Var__0[string]
2025/12/19 11:09:48 DefineVarStart [d]
2025/12/19 11:09:48 Val Gopx_Var_Cast__1 func[T map[string]interface{}]() *main.Var__1[T]
2025/12/19 11:09:48.739171 [INFO] typesutil/gopinfo.go:265: ==> Use: Gopx_Var_Cast__1 func main.Gopx_Var_Cast__1[T map[string]interface{}]() *main.Var__1[T]
2025/12/19 11:09:48.739190 [INFO] typesutil/gopinfo.go:215: ==> Type: Gopx_Var_Cast__1 func[T map[string]interface{}]() *main.Var__1[T]
2025/12/19 11:09:48 Val M map[string]interface{}
2025/12/19 11:09:48 Val type main.M = map[string]interface{} => Typ map[string]interface{}
2025/12/19 11:09:48.739230 [INFO] typesutil/gopinfo.go:265: ==> Use: M type main.M = map[string]interface{}
2025/12/19 11:09:48.739245 [INFO] typesutil/gopinfo.go:215: ==> Type: M map[string]interface{}
2025/12/19 11:09:48 Index 1 false
2025/12/19 11:09:48 ==> InferType func() *main.Var__1[map[string]interface{}]
2025/12/19 11:09:48.739321 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Gopx_Var_Cast__1 87 M 89} func() *main.Var__1[map[string]interface{}]
2025/12/19 11:09:48 EndInit 1
2025/12/19 11:09:48.739346 [INFO] typesutil/gopinfo.go:251: ==> Def: d var d func() *main.Var__1[map[string]interface{}]
2025/12/19 11:09:48.739379 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc000361320 {
.  var c func() *main.Var__0[string]
.  var d func() *main.Var__1[map[string]interface{}]
}

2025/12/19 11:09:48 End // Func
    info_test.go:190: == types ==
        000:  2: 7 | Var__0              *ast.Ident                     | type    : main.Var__0[int] | type
        001:  2: 7 | Var__0[int]         *ast.IndexExpr                 | type    : main.Var__0[int] | type
        002:  2:14 | int                 *ast.Ident                     | type    : int | type
        003:  3: 7 | Var__1              *ast.Ident                     | type    : main.Var__1[map[string]interface{}] | type
        004:  3: 7 | Var__1[M]           *ast.IndexExpr                 | type    : main.Var__1[map[string]interface{}] | type
        005:  3:14 | M                   *ast.Ident                     | type    : map[string]interface{} | type
        006:  4: 6 | Gopx_Var_Cast__0    *ast.Ident                     | value   : func[T main.basetype]() *main.Var__0[T] | value
        007:  4: 6 | Gopx_Var_Cast__0[string] *ast.IndexExpr                 | var     : func() *main.Var__0[string] | variable
        008:  4:23 | string              *ast.Ident                     | type    : string | type
        009:  5: 6 | Gopx_Var_Cast__1    *ast.Ident                     | value   : func[T map[string]interface{}]() *main.Var__1[T] | value
        010:  5: 6 | Gopx_Var_Cast__1[M] *ast.IndexExpr                 | var     : func() *main.Var__1[map[string]interface{}] | variable
        011:  5:23 | M                   *ast.Ident                     | type    : map[string]interface{} | type
        == defs ==
        000:  2: 5 | a                   | var main.a main.Var__0[int]
        001:  3: 5 | b                   | var main.b main.Var__1[map[string]interface{}]
        002:  4: 1 | c                   | var c func() *main.Var__0[string]
        003:  4: 1 | main                | func main.main()
        004:  5: 1 | d                   | var d func() *main.Var__1[map[string]interface{}]
        == uses ==
        000:  2: 7 | Var__0              | type main.Var__0[T main.basetype] struct{val T}
        001:  2:14 | int                 | type int
        002:  3: 7 | Var__1              | type main.Var__1[T map[string]any] struct{val T}
        003:  3:14 | M                   | type main.M = map[string]any
        004:  4: 6 | Gopx_Var_Cast__0    | func main.Gopx_Var_Cast__0[T main.basetype]() *main.Var__0[T]
        005:  4:23 | string              | type string
        006:  5: 6 | Gopx_Var_Cast__1    | func main.Gopx_Var_Cast__1[T map[string]any]() *main.Var__1[T]
        007:  5:23 | M                   | type main.M = map[string]any
--- PASS: TestMixedRawNamed (1.15s)
=== RUN   TestSpxInfo
2025/12/19 11:09:48.742390 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:09:49 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:49 ==> NewOverloadFunc NewRange
2025/12/19 11:09:49 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:49 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:49 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:49 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:49 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:49 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:49 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:49 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:49 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:49 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:49 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:49 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:49 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:49 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:49 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:49 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:49 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:49 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:49 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:49 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:49 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:49 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:49 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:49 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:49 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:49 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:49 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:49 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:49 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:49 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:49 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:49 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:49 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:49 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:49 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:49 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:49 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:49 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:49 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:49 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:49 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:49 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:49 ==> ClassFile Kai.tspx
2025/12/19 11:09:49 ==> Import github.com/goplus/xgo/cl/internal/spx
2025/12/19 11:09:49 ==> NewTemplateRecvMethod MyGame Main
2025/12/19 11:09:49 ==> NewTemplateRecvMethod MyGame Run
2025/12/19 11:09:49 ==> NewTemplateRecvMethod Sprite OnKey2
2025/12/19 11:09:49 ==> NewOverloadFunc Gopt_Sprite_Clone
2025/12/19 11:09:49 ==> NewTemplateRecvMethod Sprite Clone
2025/12/19 11:09:49 ==> NewOverloadFunc Gopt_Sprite_OnKey
2025/12/19 11:09:49 ==> NewTemplateRecvMethod Sprite OnKey
2025/12/19 11:09:49 ==> NewOverloadMethod MyGame Broadcast
2025/12/19 11:09:49 ==> NewOverloadFunc Rand
2025/12/19 11:09:49 ==> Import github.com/goplus/xgo/cl/internal/spx/pkg
2025/12/19 11:09:49 ==> NewOverloadMethod Vector Add
2025/12/19 11:09:50 ==> InitClass Kai isProj: false
2025/12/19 11:09:50.008644 [INFO] typesutil/gopinfo.go:332: ==> Scope: Kai.tspx scope 0xc0009179e0 {
}

2025/12/19 11:09:50 ==> Preload type Kai
2025/12/19 11:09:50 ==> Preload type info
2025/12/19 11:09:50 ==> Preload method Kai.onInit
2025/12/19 11:09:50 ==> Preload method Kai.onCloned
2025/12/19 11:09:50 ==> Preload method Kai.Main
2025/12/19 11:09:50 ==> Load > NewType Kai
2025/12/19 11:09:50 NewType Kai
2025/12/19 11:09:50 ==> Load > NewType info
2025/12/19 11:09:50 NewType info
2025/12/19 11:09:50 ==> Load > InitType info
2025/12/19 11:09:50.008777 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:50.008799 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:50.008812 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:50.008825 [INFO] typesutil/gopinfo.go:251: ==> Def: x field x int
2025/12/19 11:09:50.008837 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:50.008847 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:50.008858 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:50.008870 [INFO] typesutil/gopinfo.go:251: ==> Def: y field y int
2025/12/19 11:09:50.008894 [INFO] typesutil/gopinfo.go:215: ==> Type: &{28 0xc0003fe1b0 false} struct{x int; y int}
2025/12/19 11:09:50 InitType info struct{x int; y int}
2025/12/19 11:09:50.008918 [INFO] typesutil/gopinfo.go:251: ==> Def: info type main.info struct{x int; y int}
2025/12/19 11:09:50 ==> Load > InitType Kai
2025/12/19 11:09:50 ==> Load > NewType MyGame
2025/12/19 11:09:50 NewType MyGame
2025/12/19 11:09:50 ==> Lookup (LoadSymbol) MyGame => %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:50.008971 [INFO] typesutil/gopinfo.go:265: ==> Use: MyGame %!v(PANIC=String method: nil underlying)
2025/12/19 11:09:50.008984 [INFO] typesutil/gopinfo.go:215: ==> Type: MyGame main.MyGame
2025/12/19 11:09:50.008995 [INFO] typesutil/gopinfo.go:215: ==> Type: MyGame main.MyGame
2025/12/19 11:09:50 ==> Load > InitType MyGame
2025/12/19 11:09:50 InitType MyGame struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:50.009033 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:50.009055 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:50.009067 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:50.009127 [INFO] typesutil/gopinfo.go:251: ==> Def: a field a int
2025/12/19 11:09:50 InitType Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *main.MyGame; a int}
2025/12/19 11:09:50 ==> LookupParent Kai => type main.Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *main.MyGame; a int}
2025/12/19 11:09:50.009227 [INFO] typesutil/gopinfo.go:265: ==> Use: Kai type main.Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *main.MyGame; a int}
2025/12/19 11:09:50.009239 [INFO] typesutil/gopinfo.go:215: ==> Type: Kai main.Kai
2025/12/19 11:09:50.009251 [INFO] typesutil/gopinfo.go:251: ==> Def: this var this *main.Kai
2025/12/19 11:09:50 ==> Load method *main.Kai.onInit
2025/12/19 11:09:50.009278 [INFO] typesutil/gopinfo.go:251: ==> Def: onInit func (*main.Kai).onInit()
2025/12/19 11:09:50 ==> LookupParent Kai => type main.Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *main.MyGame; a int}
2025/12/19 11:09:50.009306 [INFO] typesutil/gopinfo.go:265: ==> Use: Kai type main.Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *main.MyGame; a int}
2025/12/19 11:09:50.009316 [INFO] typesutil/gopinfo.go:215: ==> Type: Kai main.Kai
2025/12/19 11:09:50.009328 [INFO] typesutil/gopinfo.go:251: ==> Def: this var this *main.Kai
2025/12/19 11:09:50 ==> Load method *main.Kai.onCloned
2025/12/19 11:09:50.009350 [INFO] typesutil/gopinfo.go:251: ==> Def: onCloned func (*main.Kai).onCloned()
2025/12/19 11:09:50 ==> LookupParent Kai => type main.Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *main.MyGame; a int}
2025/12/19 11:09:50.009374 [INFO] typesutil/gopinfo.go:265: ==> Use: Kai type main.Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *main.MyGame; a int}
2025/12/19 11:09:50.009384 [INFO] typesutil/gopinfo.go:215: ==> Type: Kai main.Kai
2025/12/19 11:09:50.009396 [INFO] typesutil/gopinfo.go:251: ==> Def: this var this *main.Kai
2025/12/19 11:09:50 ==> Load method *main.Kai.Main
2025/12/19 11:09:50.009417 [INFO] typesutil/gopinfo.go:251: ==> Def: Main func (*main.Kai).Main()
2025/12/19 11:09:50 NewFunc Main (*main.MyGame) func()
2025/12/19 11:09:50 Typ github.com/goplus/xgo/cl/internal/spx.MyGame
2025/12/19 11:09:50 Member Main 0 // TypeType{typ: github.com/goplus/xgo/cl/internal/spx.MyGame}
2025/12/19 11:09:50 Val this *main.MyGame
2025/12/19 11:09:50 Call 1 0 // func(game any)
2025/12/19 11:09:50 ==> MatchFuncCall func(game any) args: 1 flags: 0
2025/12/19 11:09:50 ==> MatchType *main.MyGame, any
2025/12/19 11:09:50 End // Func
2025/12/19 11:09:50 NewFunc onInit (*main.Kai) func()
2025/12/19 11:09:50 Val this *main.Kai
2025/12/19 11:09:50 Member a -1 // *main.Kai
2025/12/19 11:09:50.009567 [INFO] typesutil/gopinfo.go:265: ==> Use: a field a int
2025/12/19 11:09:50.009578 [INFO] typesutil/gopinfo.go:215: ==> Type: a int
2025/12/19 11:09:50 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:50.009610 [INFO] typesutil/gopinfo.go:215: ==> Type: &{75 INT 1 <nil>} untyped int
2025/12/19 11:09:50 Assign 1 1
2025/12/19 11:09:50 ==> MatchType untyped int (1), int
2025/12/19 11:09:50 Val this *main.Kai
2025/12/19 11:09:50 Member clone 1 // *main.Kai
2025/12/19 11:09:50.009672 [INFO] typesutil/gopinfo.go:265: ==> Use: clone func (github.com/goplus/xgo/cl/internal/spx.Sprite).Clone(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:50.009688 [INFO] typesutil/gopinfo.go:274: ==> Overloads: clone TyTemplateRecvMethod
2025/12/19 11:09:50.009704 [INFO] typesutil/gopinfo.go:215: ==> Type: clone func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:50 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:50 ==> MatchFuncCall TyTemplateRecvMethod args: 0 flags: 0
2025/12/19 11:09:50 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 16
2025/12/19 11:09:50 ==> MatchFuncCall func(sprite any) args: 1 flags: 16
2025/12/19 11:09:50 ==> MatchType *main.Kai, any
2025/12/19 11:09:50.009765 [INFO] typesutil/gopinfo.go:265: ==> Use: clone func github.com/goplus/xgo/cl/internal/spx.Gopt_Sprite_Clone__0(sprite any)
2025/12/19 11:09:50.009777 [INFO] typesutil/gopinfo.go:215: ==> Type: clone func(sprite any)
2025/12/19 11:09:50 Val this *main.Kai
2025/12/19 11:09:50 Member clone 1 // *main.Kai
2025/12/19 11:09:50.009810 [INFO] typesutil/gopinfo.go:265: ==> Use: clone func (github.com/goplus/xgo/cl/internal/spx.Sprite).Clone(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:50.009819 [INFO] typesutil/gopinfo.go:274: ==> Overloads: clone TyTemplateRecvMethod
2025/12/19 11:09:50.009832 [INFO] typesutil/gopinfo.go:215: ==> Type: clone func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:50 ==> LookupParent info => type main.info struct{x int; y int}
2025/12/19 11:09:50.009857 [INFO] typesutil/gopinfo.go:265: ==> Use: info type main.info struct{x int; y int}
2025/12/19 11:09:50.009870 [INFO] typesutil/gopinfo.go:215: ==> Type: info main.info
2025/12/19 11:09:50.009881 [INFO] typesutil/gopinfo.go:215: ==> Type: info main.info
2025/12/19 11:09:50 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:50.009904 [INFO] typesutil/gopinfo.go:215: ==> Type: &{96 INT 1 <nil>} untyped int
2025/12/19 11:09:50 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:50.009924 [INFO] typesutil/gopinfo.go:215: ==> Type: &{98 INT 2 <nil>} untyped int
2025/12/19 11:09:50 StructLit main.info 2 false
2025/12/19 11:09:50.009945 [INFO] typesutil/gopinfo.go:215: ==> Type: info main.info
2025/12/19 11:09:50.009968 [INFO] typesutil/gopinfo.go:215: ==> Type: &{info 95 [0xc0003fe2a0 0xc0003fe2d0] 99 false} main.info
2025/12/19 11:09:50 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:50 ==> MatchFuncCall TyTemplateRecvMethod args: 1 flags: 0
2025/12/19 11:09:50 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 16
2025/12/19 11:09:50 ==> MatchFuncCall func(sprite any) args: 2 flags: 16
2025/12/19 11:09:50 ==> MatchFuncCall func(sprite any, data any) args: 2 flags: 16
2025/12/19 11:09:50 ==> MatchType *main.Kai, any
2025/12/19 11:09:50 ==> MatchType main.info, any
2025/12/19 11:09:50 ==> EnsureLoaded main.info
2025/12/19 11:09:50.010069 [INFO] typesutil/gopinfo.go:265: ==> Use: clone func github.com/goplus/xgo/cl/internal/spx.Gopt_Sprite_Clone__1(sprite any, data any)
2025/12/19 11:09:50.010082 [INFO] typesutil/gopinfo.go:215: ==> Type: clone func(sprite any, data any)
2025/12/19 11:09:50.010102 [INFO] typesutil/gopinfo.go:215: ==> Type: &{clone 0 [0xc0003a0380] 0 [] 0 100} ()
2025/12/19 11:09:50 Val this *main.Kai
2025/12/19 11:09:50 Member clone 1 // *main.Kai
2025/12/19 11:09:50.010134 [INFO] typesutil/gopinfo.go:265: ==> Use: clone func (github.com/goplus/xgo/cl/internal/spx.Sprite).Clone(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:50.010143 [INFO] typesutil/gopinfo.go:274: ==> Overloads: clone TyTemplateRecvMethod
2025/12/19 11:09:50.010154 [INFO] typesutil/gopinfo.go:215: ==> Type: clone func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:50 ==> LookupParent info => type main.info struct{x int; y int}
2025/12/19 11:09:50.010176 [INFO] typesutil/gopinfo.go:265: ==> Use: info type main.info struct{x int; y int}
2025/12/19 11:09:50.010187 [INFO] typesutil/gopinfo.go:215: ==> Type: info main.info
2025/12/19 11:09:50.010197 [INFO] typesutil/gopinfo.go:215: ==> Type: info main.info
2025/12/19 11:09:50 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:50.010219 [INFO] typesutil/gopinfo.go:215: ==> Type: &{114 INT 1 <nil>} untyped int
2025/12/19 11:09:50 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:50.010240 [INFO] typesutil/gopinfo.go:215: ==> Type: &{116 INT 2 <nil>} untyped int
2025/12/19 11:09:50 StructLit main.info 2 false
2025/12/19 11:09:50.010257 [INFO] typesutil/gopinfo.go:215: ==> Type: info main.info
2025/12/19 11:09:50.010271 [INFO] typesutil/gopinfo.go:215: ==> Type: &{info 113 [0xc0003fe300 0xc0003fe330] 117 false} main.info
2025/12/19 11:09:50 UnaryOp & flags: 0
2025/12/19 11:09:50 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:09:50.010304 [INFO] typesutil/gopinfo.go:215: ==> Type: &{108 & 0xc0003a0400} *main.info
2025/12/19 11:09:50 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:09:50 ==> MatchFuncCall TyTemplateRecvMethod args: 1 flags: 0
2025/12/19 11:09:50 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 16
2025/12/19 11:09:50 ==> MatchFuncCall func(sprite any) args: 2 flags: 16
2025/12/19 11:09:50 ==> MatchFuncCall func(sprite any, data any) args: 2 flags: 16
2025/12/19 11:09:50 ==> MatchType *main.Kai, any
2025/12/19 11:09:50 ==> MatchType *main.info, any
2025/12/19 11:09:50 ==> EnsureLoaded main.info
2025/12/19 11:09:50.010403 [INFO] typesutil/gopinfo.go:265: ==> Use: clone func github.com/goplus/xgo/cl/internal/spx.Gopt_Sprite_Clone__1(sprite any, data any)
2025/12/19 11:09:50.010416 [INFO] typesutil/gopinfo.go:215: ==> Type: clone func(sprite any, data any)
2025/12/19 11:09:50.010436 [INFO] typesutil/gopinfo.go:215: ==> Type: &{clone 0 [0xc0000fdea0] 0 [] 0 118} ()
2025/12/19 11:09:50.010455 [INFO] typesutil/gopinfo.go:332: ==> Scope: func onInit scope 0xc00059f440 {
.  var this *main.Kai
}

2025/12/19 11:09:50 End // Func
2025/12/19 11:09:50 NewFunc onCloned (*main.Kai) func()
2025/12/19 11:09:50 Val this *main.Kai
2025/12/19 11:09:50 Member say 1 // *main.Kai
2025/12/19 11:09:50.010516 [INFO] typesutil/gopinfo.go:265: ==> Use: say func (*github.com/goplus/xgo/cl/internal/spx.Sprite).Say(msg string, secs ...float64)
2025/12/19 11:09:50.010529 [INFO] typesutil/gopinfo.go:215: ==> Type: say func(msg string, secs ...float64)
2025/12/19 11:09:50 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:09:50.010551 [INFO] typesutil/gopinfo.go:215: ==> Type: &{145 STRING "Hi" <nil>} untyped string
2025/12/19 11:09:50 Call 1 0 // func(msg string, secs ...float64)
2025/12/19 11:09:50 ==> MatchFuncCall func(msg string, secs ...float64) args: 1 flags: 0
2025/12/19 11:09:50 ==> MatchType untyped string ("Hi"), string
2025/12/19 11:09:50.010598 [INFO] typesutil/gopinfo.go:215: ==> Type: &{say 144 [0xc0003fe450] 0 [] 149 0} ()
2025/12/19 11:09:50.010616 [INFO] typesutil/gopinfo.go:332: ==> Scope: func onCloned scope 0xc00059f560 {
.  var this *main.Kai
}

2025/12/19 11:09:50 End // Func
2025/12/19 11:09:50 NewFunc Main (*main.Kai) func()
2025/12/19 11:09:50.010651 [INFO] typesutil/gopinfo.go:332: ==> Scope: func Main scope 0xc00059f620 {
.  var this *main.Kai
}

2025/12/19 11:09:50 End // Func
2025/12/19 11:09:50 NewFunc main func()
2025/12/19 11:09:50 Val new TyInstruction{gogen.newInstr}
2025/12/19 11:09:50 Val MyGame main.MyGame
2025/12/19 11:09:50 Val type main.MyGame struct{*github.com/goplus/xgo/cl/internal/spx.MyGame} => Typ main.MyGame
2025/12/19 11:09:50 Call 1 0 // TyInstruction{gogen.newInstr}
2025/12/19 11:09:50 ==> MatchFuncCall TyInstruction{gogen.newInstr} args: 1 flags: 0
2025/12/19 11:09:50 Member Main 0 // *main.MyGame
2025/12/19 11:09:50 Call 0 0 // func()
2025/12/19 11:09:50 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:09:50 End // Func
    info_test.go:190: == types ==
        000:  0: 0 | Kai                 *ast.Ident                     | type    : main.Kai | type
        001:  0: 0 | MyGame              *ast.Ident                     | type    : main.MyGame | type
        002:  3: 4 | int                 *ast.Ident                     | type    : int | type
        003:  6:11 | struct {
        	x int
        	y int
        } *ast.StructType                | type    : struct{x int; y int} | type
        004:  7: 4 | int                 *ast.Ident                     | type    : int | type
        005:  8: 4 | int                 *ast.Ident                     | type    : int | type
        006: 12: 2 | a                   *ast.Ident                     | var     : int | variable
        007: 12: 6 | 1                   *ast.BasicLit                  | value   : untyped int = 1 | constant
        008: 13: 2 | clone               *ast.Ident                     | value   : func(sprite any) | value
        009: 14: 2 | clone               *ast.Ident                     | value   : func(sprite any, data any) | value
        010: 14: 2 | clone info{1, 2}    *ast.CallExpr                  | void    : () | no value
        011: 14: 8 | info                *ast.Ident                     | type    : main.info | type
        012: 14: 8 | info{1, 2}          *ast.CompositeLit              | value   : main.info | value
        013: 14:13 | 1                   *ast.BasicLit                  | value   : untyped int = 1 | constant
        014: 14:15 | 2                   *ast.BasicLit                  | value   : untyped int = 2 | constant
        015: 15: 2 | clone               *ast.Ident                     | value   : func(sprite any, data any) | value
        016: 15: 2 | clone &info{1, 2}   *ast.CallExpr                  | void    : () | no value
        017: 15: 8 | &info{1, 2}         *ast.UnaryExpr                 | value   : *main.info | value
        018: 15: 9 | info                *ast.Ident                     | type    : main.info | type
        019: 15: 9 | info{1, 2}          *ast.CompositeLit              | value   : main.info | value
        020: 15:14 | 1                   *ast.BasicLit                  | value   : untyped int = 1 | constant
        021: 15:16 | 2                   *ast.BasicLit                  | value   : untyped int = 2 | constant
        022: 19: 2 | say                 *ast.Ident                     | value   : func(msg string, secs ...float64) | value
        023: 19: 2 | say("Hi")           *ast.CallExpr                  | void    : () | no value
        024: 19: 6 | "Hi"                *ast.BasicLit                  | value   : untyped string = "Hi" | constant
        == defs ==
        000:  0: 0 | Main                | func (*main.Kai).Main()
        001:  0: 0 | this                | var this *main.Kai
        002:  3: 2 | a                   | field a int
        003:  6: 6 | info                | type main.info struct{x int; y int}
        004:  7: 2 | x                   | field x int
        005:  8: 2 | y                   | field y int
        006: 11: 6 | onInit              | func (*main.Kai).onInit()
        007: 18: 6 | onCloned            | func (*main.Kai).onCloned()
        == uses ==
        000:  0: 0 | Kai                 | type main.Kai struct{github.com/goplus/xgo/cl/internal/spx.Sprite; *main.MyGame; a int}
        001:  0: 0 | MyGame              | type main.MyGame struct{*github.com/goplus/xgo/cl/internal/spx.MyGame}
        002:  3: 4 | int                 | type int
        003:  7: 4 | int                 | type int
        004:  8: 4 | int                 | type int
        005: 12: 2 | a                   | field a int
        006: 13: 2 | clone               | func github.com/goplus/xgo/cl/internal/spx.Gopt_Sprite_Clone__0(sprite any)
        007: 14: 2 | clone               | func github.com/goplus/xgo/cl/internal/spx.Gopt_Sprite_Clone__1(sprite any, data any)
        008: 14: 8 | info                | type main.info struct{x int; y int}
        009: 15: 2 | clone               | func github.com/goplus/xgo/cl/internal/spx.Gopt_Sprite_Clone__1(sprite any, data any)
        010: 15: 9 | info                | type main.info struct{x int; y int}
        011: 19: 2 | say                 | func (*github.com/goplus/xgo/cl/internal/spx.Sprite).Say(msg string, secs ...float64)
        == overloads ==
        000: 13: 2 | clone               | func (github.com/goplus/xgo/cl/internal/spx.Sprite).Clone(__xgo_overload_args__ interface{_()})
        001: 14: 2 | clone               | func (github.com/goplus/xgo/cl/internal/spx.Sprite).Clone(__xgo_overload_args__ interface{_()})
        002: 15: 2 | clone               | func (github.com/goplus/xgo/cl/internal/spx.Sprite).Clone(__xgo_overload_args__ interface{_()})
--- PASS: TestSpxInfo (1.27s)
=== RUN   TestScopesInfo
2025/12/19 11:09:50.011511 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:09:50 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:50 ==> NewOverloadFunc NewRange
2025/12/19 11:09:50 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:50 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:50 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:50 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:50 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:50 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:50 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:50 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:50 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:50 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:50 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:50 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:50 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:50 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:50 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:50 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:50 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:50 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:50 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:50 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:50 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:50 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:50 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:50 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:50 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:50 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:50 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:50 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:50 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:50 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:50 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:50 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:50 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:50 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:50 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:50 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:50 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:50 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:50 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:50 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:50 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:50 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:51.135178 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0003672c0 {
}

2025/12/19 11:09:51.135400 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:09:51 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:51 ==> NewOverloadFunc NewRange
2025/12/19 11:09:51 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:51 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:51 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:51 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:51 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:51 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:51 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:51 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:51 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:51 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:51 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:51 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:51 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:51 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:51 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:51 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:51 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:51 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:51 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:51 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:51 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:51 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:51 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:51 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:51 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:51 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:51 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:51 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:51 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:51 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:51 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:51 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:51 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:51 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:51 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:51 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:51 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:51 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:51 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:51 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:51 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:51 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:52.195163 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0003d5b00 {
}

2025/12/19 11:09:52.195210 [INFO] typesutil/gopinfo.go:292: ==> Implicit: package fmt
2025/12/19 11:09:52.234173 [INFO] typesutil/gopinfo.go:251: ==> Def: m package m ("math")
2025/12/19 11:09:52.234225 [INFO] typesutil/gopinfo.go:251: ==> Def: _ package _ ("os")
2025/12/19 11:09:52 ==> Preload var [_]
2025/12/19 11:09:52 ==> Preload var [_]
2025/12/19 11:09:52 ==> Load var <nil> [_]
2025/12/19 11:09:52 NewVarDefs
2025/12/19 11:09:52 NewVar [_]
2025/12/19 11:09:52.234324 [INFO] typesutil/gopinfo.go:265: ==> Use: fmt package fmt
2025/12/19 11:09:52.234357 [INFO] typesutil/gopinfo.go:265: ==> Use: Println func fmt.Println(a ...any) (n int, err error)
2025/12/19 11:09:52 Val Println func(a ...any) (n int, err error)
2025/12/19 11:09:52.234402 [INFO] typesutil/gopinfo.go:215: ==> Type: &{fmt Println} func(a ...any) (n int, err error)
2025/12/19 11:09:52 EndInit 1
2025/12/19 11:09:52 ==> Load var <nil> [_]
2025/12/19 11:09:52 NewVarDefs
2025/12/19 11:09:52 NewVar [_]
2025/12/19 11:09:52.234446 [INFO] typesutil/gopinfo.go:265: ==> Use: m package m ("math")
2025/12/19 11:09:52.234464 [INFO] typesutil/gopinfo.go:265: ==> Use: Pi const math.Pi untyped float
2025/12/19 11:09:52 Val Pi untyped float
2025/12/19 11:09:52.234492 [INFO] typesutil/gopinfo.go:215: ==> Type: &{m Pi} untyped float
2025/12/19 11:09:52 EndInit 1
2025/12/19 11:09:52.234608 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:09:52 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:52 ==> NewOverloadFunc NewRange
2025/12/19 11:09:52 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:52 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:52 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:52 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:52 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:52 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:52 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:52 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:52 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:52 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:52 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:52 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:52 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:52 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:52 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:52 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:52 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:52 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:52 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:52 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:52 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:52 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:52 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:52 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:52 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:52 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:52 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:52 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:52 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:52 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:52 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:52 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:52 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:52 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:52 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:52 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:52 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:52 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:52 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:52 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:52 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:52 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:53.220595 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc00037bce0 {
}

2025/12/19 11:09:53 ==> Preload func _
2025/12/19 11:09:53 ==> Load func _
2025/12/19 11:09:53.220650 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:09:53 NewFunc _ func()
2025/12/19 11:09:53.220669 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc00037bda0 {
}

2025/12/19 11:09:53 End // Func
2025/12/19 11:09:53.220972 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:09:53 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:53 ==> NewOverloadFunc NewRange
2025/12/19 11:09:53 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:53 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:53 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:53 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:53 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:53 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:53 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:53 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:53 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:53 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:53 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:53 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:53 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:53 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:53 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:53 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:53 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:53 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:53 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:53 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:53 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:53 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:53 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:53 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:53 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:53 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:53 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:53 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:53 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:53 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:53 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:53 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:53 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:53 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:53 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:53 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:53 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:53 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:53 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:53 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:53 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:53 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:54.236678 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0004acd80 {
}

2025/12/19 11:09:54 ==> Preload func _
2025/12/19 11:09:54 ==> Load func _
2025/12/19 11:09:54.236770 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:54.236803 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:54.236820 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:54.236837 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:09:54.236852 [INFO] typesutil/gopinfo.go:251: ==> Def: y var y int
2025/12/19 11:09:54.236872 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(x int, y int)
2025/12/19 11:09:54 NewFunc _ func(x int, y int)
2025/12/19 11:09:54.236916 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0004acf00 {
.  var x int
.  var y int
}

2025/12/19 11:09:54 End // Func
2025/12/19 11:09:54.237136 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:09:54 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:54 ==> NewOverloadFunc NewRange
2025/12/19 11:09:54 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:54 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:54 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:54 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:54 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:54 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:54 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:54 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:54 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:54 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:54 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:54 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:54 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:54 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:54 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:54 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:54 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:54 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:54 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:54 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:54 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:54 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:54 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:54 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:54 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:54 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:54 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:54 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:54 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:54 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:54 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:54 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:54 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:54 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:54 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:54 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:54 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:54 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:54 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:54 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:54 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:54 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:55.322723 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0004be000 {
}

2025/12/19 11:09:55 ==> Preload func _
2025/12/19 11:09:55 ==> Load func _
2025/12/19 11:09:55.322783 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:55.322801 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:55.322813 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:55.322826 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:09:55.322837 [INFO] typesutil/gopinfo.go:251: ==> Def: y var y int
2025/12/19 11:09:55.322853 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(x int, y int)
2025/12/19 11:09:55 NewFunc _ func(x int, y int)
2025/12/19 11:09:55 DefineVarStart [x z]
2025/12/19 11:09:55 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:09:55.322915 [INFO] typesutil/gopinfo.go:215: ==> Type: &{40 INT 1 <nil>} untyped int
2025/12/19 11:09:55 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:09:55.322939 [INFO] typesutil/gopinfo.go:215: ==> Type: &{43 INT 2 <nil>} untyped int
2025/12/19 11:09:55 EndInit 2
2025/12/19 11:09:55 ==> MatchType untyped int (1), int
2025/12/19 11:09:55.322973 [INFO] typesutil/gopinfo.go:251: ==> Def: z var z int
2025/12/19 11:09:55 VarRef _
2025/12/19 11:09:55 Val z int
2025/12/19 11:09:55.323000 [INFO] typesutil/gopinfo.go:265: ==> Use: z var z int
2025/12/19 11:09:55.323009 [INFO] typesutil/gopinfo.go:215: ==> Type: z int
2025/12/19 11:09:55 Assign 1 1
2025/12/19 11:09:55.323037 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0004be180 {
.  var x int
.  var y int
.  var z int
}

2025/12/19 11:09:55 End // Func
2025/12/19 11:09:55.323175 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:09:55 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:55 ==> NewOverloadFunc NewRange
2025/12/19 11:09:56 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:56 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:56 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:56 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:56 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:56 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:56 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:56 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:56 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:56 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:56 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:56 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:56 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:56 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:56 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:56 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:56 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:56 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:56 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:56 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:56 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:56 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:56 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:56 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:56 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:56 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:56 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:56 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:56 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:56 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:56 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:56 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:56 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:56 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:56 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:56 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:56 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:56 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:56 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:56 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:56 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:56 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:56.422053 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc000376900 {
}

2025/12/19 11:09:56 ==> Preload func _
2025/12/19 11:09:56 ==> Load func _
2025/12/19 11:09:56.422109 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:56.422124 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:56.422133 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:56.422143 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:09:56.422152 [INFO] typesutil/gopinfo.go:251: ==> Def: y var y int
2025/12/19 11:09:56.422159 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:56.422166 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:56.422173 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:56.422181 [INFO] typesutil/gopinfo.go:251: ==> Def: u var u int
2025/12/19 11:09:56.422189 [INFO] typesutil/gopinfo.go:251: ==> Def: _ var _ int
2025/12/19 11:09:56.422202 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(x int, y int) (u int, _ int)
2025/12/19 11:09:56 NewFunc _ func(x int, y int) (u int, _ int)
2025/12/19 11:09:56 Return 0
2025/12/19 11:09:56.422243 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000376b40 {
.  var u int
.  var x int
.  var y int
}

2025/12/19 11:09:56 End // Func
2025/12/19 11:09:56.422353 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:09:57 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:57 ==> NewOverloadFunc NewRange
2025/12/19 11:09:57 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:57 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:57 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:57 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:57 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:57 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:57 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:57 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:57 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:57 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:57 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:57 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:57 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:57 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:57 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:57 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:57 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:57 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:57 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:57 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:57 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:57 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:57 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:57 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:57 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:57 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:57 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:57 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:57 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:57 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:57 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:57 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:57 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:57 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:57 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:57 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:57 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:57 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:57 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:57 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:57 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:57 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:57.514760 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc000297920 {
}

2025/12/19 11:09:57 ==> Preload func _
2025/12/19 11:09:57 ==> Load func _
2025/12/19 11:09:57.514848 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:09:57 NewFunc _ func()
2025/12/19 11:09:57 Block
2025/12/19 11:09:57.514890 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:09:57.514907 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:57.514919 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:09:57 ==> Load var int [x]
2025/12/19 11:09:57 NewVarDefs
2025/12/19 11:09:57 NewVar [x]
2025/12/19 11:09:57.514962 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:09:57 VarRef _
2025/12/19 11:09:57 Val x int
2025/12/19 11:09:57.514997 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:09:57.515010 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:09:57 Assign 1 1
2025/12/19 11:09:57.515039 [INFO] typesutil/gopinfo.go:332: ==> Scope: block statement scope 0xc000297a40 {
.  var x int
}

2025/12/19 11:09:57 End // Block
2025/12/19 11:09:57.515062 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0002979e0 {
}

2025/12/19 11:09:57 End // Func
2025/12/19 11:09:57.515190 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:09:58 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:58 ==> NewOverloadFunc NewRange
2025/12/19 11:09:58 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:58 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:58 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:58 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:58 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:58 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:58 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:58 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:58 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:58 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:58 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:58 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:58 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:58 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:58 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:58 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:58 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:58 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:58 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:58 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:58 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:58 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:58 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:58 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:58 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:58 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:58 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:58 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:58 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:58 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:58 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:58 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:58 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:58 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:58 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:58 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:58 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:58 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:58 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:58 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:58 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:58 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:58.553544 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0002c7560 {
}

2025/12/19 11:09:58 ==> Preload func _
2025/12/19 11:09:58 ==> Load func _
2025/12/19 11:09:58.553632 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:09:58 NewFunc _ func()
2025/12/19 11:09:58 If
2025/12/19 11:09:58 Val true untyped bool
2025/12/19 11:09:58.553672 [INFO] typesutil/gopinfo.go:265: ==> Use: true const true untyped bool
2025/12/19 11:09:58.553681 [INFO] typesutil/gopinfo.go:215: ==> Type: true untyped bool
2025/12/19 11:09:58.553692 [INFO] typesutil/gopinfo.go:332: ==> Scope: if statement scope 0xc0002c7680 {
}

2025/12/19 11:09:58 Then
2025/12/19 11:09:58.553708 [INFO] typesutil/gopinfo.go:332: ==> Scope: if body scope 0xc0002c76e0 {
}

2025/12/19 11:09:58 End // If
2025/12/19 11:09:58.553723 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0002c7620 {
}

2025/12/19 11:09:58 End // Func
2025/12/19 11:09:58.553832 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:09:59 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:09:59 ==> NewOverloadFunc NewRange
2025/12/19 11:09:59 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:09:59 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:09:59 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:09:59 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:09:59 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:09:59 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:09:59 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:09:59 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:09:59 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:09:59 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:09:59 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:09:59 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:09:59 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:09:59 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:09:59 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:09:59 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:09:59 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:09:59 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:09:59 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:09:59 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:09:59 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:09:59 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:09:59 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:09:59 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:09:59 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:09:59 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:09:59 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:09:59 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:09:59 ==> NewOverloadFunc Int128_Init
2025/12/19 11:09:59 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:09:59 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:09:59 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:09:59 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:09:59 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:09:59 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:09:59 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:09:59 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:09:59 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:09:59 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:09:59 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:09:59 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:09:59 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:09:59.595046 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0003e7920 {
}

2025/12/19 11:09:59 ==> Preload func _
2025/12/19 11:09:59 ==> Load func _
2025/12/19 11:09:59.595136 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:09:59 NewFunc _ func()
2025/12/19 11:09:59 If
2025/12/19 11:09:59 DefineVarStart [x]
2025/12/19 11:09:59 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:59.595229 [INFO] typesutil/gopinfo.go:215: ==> Type: &{32 INT 0 <nil>} untyped int
2025/12/19 11:09:59 EndInit 1
2025/12/19 11:09:59.595260 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:09:59 Val x int
2025/12/19 11:09:59.595288 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:09:59.595304 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:09:59 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:09:59.595330 [INFO] typesutil/gopinfo.go:215: ==> Type: &{39 INT 0 <nil>} untyped int
2025/12/19 11:09:59 BinaryOp <
2025/12/19 11:09:59 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:09:59 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:09:59 ==> MatchType untyped int (0), unboundFuncParam{typ: int}
2025/12/19 11:09:59.595464 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 37 < 0xc000719650} untyped bool
2025/12/19 11:09:59.595485 [INFO] typesutil/gopinfo.go:332: ==> Scope: if statement scope 0xc0003e7a40 {
.  var x int
}

2025/12/19 11:09:59 Then
2025/12/19 11:09:59 DefineVarStart [y]
2025/12/19 11:09:59 Val x int
2025/12/19 11:09:59.595530 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:09:59.595542 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:09:59 EndInit 1
2025/12/19 11:09:59.595562 [INFO] typesutil/gopinfo.go:251: ==> Def: y var y int
2025/12/19 11:09:59 VarRef _
2025/12/19 11:09:59 Val y int
2025/12/19 11:09:59.595593 [INFO] typesutil/gopinfo.go:265: ==> Use: y var y int
2025/12/19 11:09:59.595604 [INFO] typesutil/gopinfo.go:215: ==> Type: y int
2025/12/19 11:09:59 Assign 1 1
2025/12/19 11:09:59.595631 [INFO] typesutil/gopinfo.go:332: ==> Scope: if body scope 0xc0003e7bc0 {
.  var y int
}

2025/12/19 11:09:59 End // If
2025/12/19 11:09:59.595656 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0003e79e0 {
}

2025/12/19 11:09:59 End // Func
2025/12/19 11:09:59.595805 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:00 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:00 ==> NewOverloadFunc NewRange
2025/12/19 11:10:00 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:00 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:00 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:00 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:00 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:00 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:00 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:00 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:00 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:00 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:00 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:00 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:00 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:00 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:00 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:00 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:00 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:00 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:00 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:00 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:00 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:00 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:00 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:00 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:00 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:00 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:00 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:00 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:00 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:00 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:00 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:00 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:00 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:00 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:00 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:00 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:00 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:00 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:00 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:00 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:00 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:00 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:00.720825 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc000275c20 {
}

2025/12/19 11:10:00 ==> Preload func _
2025/12/19 11:10:00 ==> Load func _
2025/12/19 11:10:00.720899 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:00 NewFunc _ func()
2025/12/19 11:10:00 Switch
2025/12/19 11:10:00 DefineVarStart [x]
2025/12/19 11:10:00 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:10:00.720976 [INFO] typesutil/gopinfo.go:215: ==> Type: &{36 INT 0 <nil>} untyped int
2025/12/19 11:10:00 EndInit 1
2025/12/19 11:10:00.720999 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:10:00 Val x int
2025/12/19 11:10:00.721023 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:10:00.721034 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:10:00.721053 [INFO] typesutil/gopinfo.go:332: ==> Scope: switch statement scope 0xc00027c300 {
.  var x int
}

2025/12/19 11:10:00 Then
2025/12/19 11:10:00 End // Switch
2025/12/19 11:10:00.721129 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000275f20 {
}

2025/12/19 11:10:00 End // Func
2025/12/19 11:10:00.721293 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:01 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:01 ==> NewOverloadFunc NewRange
2025/12/19 11:10:01 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:01 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:01 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:01 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:01 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:01 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:01 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:01 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:01 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:01 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:01 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:01 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:01 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:01 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:01 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:01 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:01 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:01 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:01 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:01 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:01 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:01 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:01 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:01 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:01 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:01 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:01 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:01 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:01 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:01 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:01 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:01 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:01 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:01 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:01 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:01 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:01 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:01 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:01 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:01 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:01 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:01 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:01.829495 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0002be240 {
}

2025/12/19 11:10:01 ==> Preload func _
2025/12/19 11:10:01 ==> Load func _
2025/12/19 11:10:01.829561 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:01 NewFunc _ func()
2025/12/19 11:10:01 Switch
2025/12/19 11:10:01 DefineVarStart [x]
2025/12/19 11:10:01 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:10:01.829628 [INFO] typesutil/gopinfo.go:215: ==> Type: &{37 INT 0 <nil>} untyped int
2025/12/19 11:10:01 EndInit 1
2025/12/19 11:10:01.829650 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:10:01 Val x int
2025/12/19 11:10:01.829671 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:10:01.829681 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:10:01.829698 [INFO] typesutil/gopinfo.go:332: ==> Scope: switch statement scope 0xc0002be3c0 {
.  var x int
}

2025/12/19 11:10:01 Then
2025/12/19 11:10:01 Case
2025/12/19 11:10:01 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:10:01.829730 [INFO] typesutil/gopinfo.go:215: ==> Type: &{49 INT 1 <nil>} untyped int
2025/12/19 11:10:01 Then
2025/12/19 11:10:01 DefineVarStart [y]
2025/12/19 11:10:01 Val x int
2025/12/19 11:10:01.829762 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:10:01.829772 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:10:01 EndInit 1
2025/12/19 11:10:01.829785 [INFO] typesutil/gopinfo.go:251: ==> Def: y var y int
2025/12/19 11:10:01 VarRef _
2025/12/19 11:10:01 Val y int
2025/12/19 11:10:01.829807 [INFO] typesutil/gopinfo.go:265: ==> Use: y var y int
2025/12/19 11:10:01.829815 [INFO] typesutil/gopinfo.go:215: ==> Type: y int
2025/12/19 11:10:01 Assign 1 1
2025/12/19 11:10:01.829835 [INFO] typesutil/gopinfo.go:332: ==> Scope: case statement scope 0xc0002be480 {
.  var y int
}

2025/12/19 11:10:01 End // Case
2025/12/19 11:10:01 Case
2025/12/19 11:10:01 Then
2025/12/19 11:10:01.829859 [INFO] typesutil/gopinfo.go:332: ==> Scope: case statement scope 0xc0002be540 {
}

2025/12/19 11:10:01 End // Case
2025/12/19 11:10:01 End // Switch
2025/12/19 11:10:01.829878 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0002be300 {
}

2025/12/19 11:10:01 End // Func
2025/12/19 11:10:01.829997 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:02 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:02 ==> NewOverloadFunc NewRange
2025/12/19 11:10:02 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:02 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:02 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:02 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:02 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:02 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:02 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:02 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:02 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:02 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:02 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:02 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:02 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:02 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:02 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:02 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:02 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:02 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:02 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:02 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:02 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:02 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:02 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:02 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:02 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:02 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:02 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:02 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:02 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:02 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:02 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:02 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:02 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:02 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:02 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:02 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:02 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:02 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:02 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:02 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:02 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:02 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:03.004683 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0003bf920 {
}

2025/12/19 11:10:03 ==> Preload func _
2025/12/19 11:10:03 ==> Load func _
2025/12/19 11:10:03.004783 [INFO] typesutil/gopinfo.go:215: ==> Type: &{23 0xc00049f710 false} interface{}
2025/12/19 11:10:03.004804 [INFO] typesutil/gopinfo.go:251: ==> Def: t var t interface{}
2025/12/19 11:10:03.004829 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(t interface{})
2025/12/19 11:10:03 NewFunc _ func(t interface{})
2025/12/19 11:10:03 TypeSwitch
2025/12/19 11:10:03.004874 [INFO] typesutil/gopinfo.go:332: ==> Scope: type switch statement scope 0xc0003bfaa0 {
}

2025/12/19 11:10:03 Val t interface{}
2025/12/19 11:10:03.004903 [INFO] typesutil/gopinfo.go:265: ==> Use: t var t interface{}
2025/12/19 11:10:03.004917 [INFO] typesutil/gopinfo.go:215: ==> Type: t interface{}
2025/12/19 11:10:03 TypeAssertThen
2025/12/19 11:10:03 End // TypeSwitch
2025/12/19 11:10:03.004958 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0003bfa40 {
.  var t interface{}
}

2025/12/19 11:10:03 End // Func
2025/12/19 11:10:03.005172 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:03 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:03 ==> NewOverloadFunc NewRange
2025/12/19 11:10:03 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:03 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:03 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:03 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:03 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:03 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:03 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:03 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:03 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:03 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:03 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:03 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:03 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:03 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:03 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:03 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:03 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:03 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:03 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:03 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:03 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:03 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:03 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:03 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:03 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:03 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:03 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:03 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:03 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:03 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:03 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:03 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:03 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:03 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:03 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:03 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:03 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:03 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:03 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:03 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:03 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:03 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:04.094111 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0009104e0 {
}

2025/12/19 11:10:04 ==> Preload func _
2025/12/19 11:10:04 ==> Load func _
2025/12/19 11:10:04.094196 [INFO] typesutil/gopinfo.go:215: ==> Type: &{23 0xc000302bd0 false} interface{}
2025/12/19 11:10:04.094216 [INFO] typesutil/gopinfo.go:251: ==> Def: t var t interface{}
2025/12/19 11:10:04.094237 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(t interface{})
2025/12/19 11:10:04 NewFunc _ func(t interface{})
2025/12/19 11:10:04 TypeSwitch
2025/12/19 11:10:04.094274 [INFO] typesutil/gopinfo.go:332: ==> Scope: type switch statement scope 0xc000910840 {
}

2025/12/19 11:10:04 DefineVarStart [t]
2025/12/19 11:10:04 Val t interface{}
2025/12/19 11:10:04.094312 [INFO] typesutil/gopinfo.go:265: ==> Use: t var t interface{}
2025/12/19 11:10:04.094325 [INFO] typesutil/gopinfo.go:215: ==> Type: t interface{}
2025/12/19 11:10:04 EndInit 1
2025/12/19 11:10:04.094347 [INFO] typesutil/gopinfo.go:251: ==> Def: t var t interface{}
2025/12/19 11:10:04 Val t interface{}
2025/12/19 11:10:04.094367 [INFO] typesutil/gopinfo.go:265: ==> Use: t var t interface{}
2025/12/19 11:10:04.094379 [INFO] typesutil/gopinfo.go:215: ==> Type: t interface{}
2025/12/19 11:10:04 TypeAssertThen
2025/12/19 11:10:04 End // TypeSwitch
2025/12/19 11:10:04.094415 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0009106c0 {
.  var t interface{}
}

2025/12/19 11:10:04 End // Func
2025/12/19 11:10:04.094592 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:04 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:04 ==> NewOverloadFunc NewRange
2025/12/19 11:10:04 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:04 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:04 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:04 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:04 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:04 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:04 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:04 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:04 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:04 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:04 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:04 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:04 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:04 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:04 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:04 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:04 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:04 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:04 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:04 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:04 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:04 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:04 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:04 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:04 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:04 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:04 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:04 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:04 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:04 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:04 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:04 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:04 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:04 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:04 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:04 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:04 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:04 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:04 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:04 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:04 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:04 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:05.066676 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0001fd380 {
}

2025/12/19 11:10:05 ==> Preload func _
2025/12/19 11:10:05 ==> Load func _
2025/12/19 11:10:05.066767 [INFO] typesutil/gopinfo.go:215: ==> Type: &{23 0xc0002a4d50 false} interface{}
2025/12/19 11:10:05.066788 [INFO] typesutil/gopinfo.go:251: ==> Def: t var t interface{}
2025/12/19 11:10:05.066811 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(t interface{})
2025/12/19 11:10:05 NewFunc _ func(t interface{})
2025/12/19 11:10:05 TypeSwitch
2025/12/19 11:10:05.066849 [INFO] typesutil/gopinfo.go:332: ==> Scope: type switch statement scope 0xc0001fd500 {
}

2025/12/19 11:10:05 Val t interface{}
2025/12/19 11:10:05.066878 [INFO] typesutil/gopinfo.go:265: ==> Use: t var t interface{}
2025/12/19 11:10:05.066893 [INFO] typesutil/gopinfo.go:215: ==> Type: t interface{}
2025/12/19 11:10:05 TypeAssertThen
2025/12/19 11:10:05 TypeCase
2025/12/19 11:10:05 Val int int
2025/12/19 11:10:05 Val type int => Typ int
2025/12/19 11:10:05.066950 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:05.066964 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:05 Then
2025/12/19 11:10:05 VarRef _
2025/12/19 11:10:05 Val x int
2025/12/19 11:10:05.067023 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:10:05.067035 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:10:05 Assign 1 1
2025/12/19 11:10:05.067066 [INFO] typesutil/gopinfo.go:332: ==> Scope: type case statement scope 0xc0001fd560 {
.  var x int
}

2025/12/19 11:10:05 End // TypeCase
2025/12/19 11:10:05 End // TypeSwitch
2025/12/19 11:10:05.067119 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0001fd4a0 {
.  var t interface{}
}

2025/12/19 11:10:05 End // Func
2025/12/19 11:10:05.067257 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:05 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:05 ==> NewOverloadFunc NewRange
2025/12/19 11:10:05 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:05 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:05 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:05 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:05 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:05 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:05 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:05 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:05 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:05 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:05 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:05 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:05 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:05 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:05 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:05 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:05 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:05 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:05 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:05 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:05 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:05 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:05 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:05 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:05 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:05 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:05 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:05 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:05 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:05 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:05 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:05 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:05 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:05 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:05 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:05 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:05 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:05 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:05 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:05 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:05 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:05 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:06.194322 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0003df380 {
}

2025/12/19 11:10:06 ==> Preload func _
2025/12/19 11:10:06 ==> Load func _
2025/12/19 11:10:06.194400 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:06 NewFunc _ func()
2025/12/19 11:10:06 Select
2025/12/19 11:10:06 End // Select
2025/12/19 11:10:06.194443 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0003df440 {
}

2025/12/19 11:10:06 End // Func
2025/12/19 11:10:06.194549 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:06 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:06 ==> NewOverloadFunc NewRange
2025/12/19 11:10:06 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:06 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:06 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:06 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:06 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:06 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:06 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:06 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:06 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:06 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:06 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:06 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:06 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:06 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:06 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:06 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:06 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:06 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:06 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:06 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:06 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:06 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:06 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:06 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:06 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:06 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:06 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:06 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:06 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:06 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:06 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:06 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:06 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:06 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:06 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:06 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:06 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:06 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:06 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:06 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:06 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:06 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:07.302995 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0004adce0 {
}

2025/12/19 11:10:07 ==> Preload func _
2025/12/19 11:10:07 ==> Load func _
2025/12/19 11:10:07.303088 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:07.303110 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:07.303126 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:07.303152 [INFO] typesutil/gopinfo.go:215: ==> Type: &{23 0 3 int} chan int
2025/12/19 11:10:07.303170 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c chan int
2025/12/19 11:10:07.303193 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(c chan int)
2025/12/19 11:10:07 NewFunc _ func(c chan int)
2025/12/19 11:10:07 Select
2025/12/19 11:10:07 CommCase
2025/12/19 11:10:07 Val c chan int
2025/12/19 11:10:07.303255 [INFO] typesutil/gopinfo.go:265: ==> Use: c var c chan int
2025/12/19 11:10:07.303268 [INFO] typesutil/gopinfo.go:215: ==> Type: c chan int
2025/12/19 11:10:07 UnaryOp <- flags: 0
2025/12/19 11:10:07 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 0
2025/12/19 11:10:07.303325 [INFO] typesutil/gopinfo.go:215: ==> Type: &{48 <- c} int
2025/12/19 11:10:07 Then
2025/12/19 11:10:07.303349 [INFO] typesutil/gopinfo.go:332: ==> Scope: comm case statement scope 0xc0004adf20 {
}

2025/12/19 11:10:07 End // CommCase
2025/12/19 11:10:07 End // Select
2025/12/19 11:10:07.303390 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0004ade00 {
.  var c chan int
}

2025/12/19 11:10:07 End // Func
2025/12/19 11:10:07.303599 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:07 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:07 ==> NewOverloadFunc NewRange
2025/12/19 11:10:08 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:08 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:08 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:08 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:08 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:08 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:08 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:08 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:08 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:08 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:08 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:08 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:08 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:08 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:08 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:08 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:08 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:08 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:08 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:08 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:08 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:08 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:08 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:08 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:08 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:08 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:08 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:08 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:08 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:08 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:08 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:08 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:08 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:08 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:08 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:08 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:08 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:08 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:08 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:08 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:08 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:08 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:08.393801 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc000488360 {
}

2025/12/19 11:10:08 ==> Preload func _
2025/12/19 11:10:08 ==> Load func _
2025/12/19 11:10:08.393889 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:08.393911 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:08.393928 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:08.393955 [INFO] typesutil/gopinfo.go:215: ==> Type: &{23 0 3 int} chan int
2025/12/19 11:10:08.393972 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c chan int
2025/12/19 11:10:08.393994 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(c chan int)
2025/12/19 11:10:08 NewFunc _ func(c chan int)
2025/12/19 11:10:08 Select
2025/12/19 11:10:08 CommCase
2025/12/19 11:10:08 DefineVarStart [i]
2025/12/19 11:10:08 Val c chan int
2025/12/19 11:10:08.394073 [INFO] typesutil/gopinfo.go:265: ==> Use: c var c chan int
2025/12/19 11:10:08.394087 [INFO] typesutil/gopinfo.go:215: ==> Type: c chan int
2025/12/19 11:10:08 UnaryOp <- flags: 0
2025/12/19 11:10:08 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 0
2025/12/19 11:10:08.394134 [INFO] typesutil/gopinfo.go:215: ==> Type: &{53 <- c} int
2025/12/19 11:10:08 EndInit 1
2025/12/19 11:10:08.394161 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/12/19 11:10:08 Then
2025/12/19 11:10:08 DefineVarStart [x]
2025/12/19 11:10:08 Val i int
2025/12/19 11:10:08.394199 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/12/19 11:10:08.394212 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/12/19 11:10:08 EndInit 1
2025/12/19 11:10:08.394232 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:10:08 VarRef _
2025/12/19 11:10:08 Val x int
2025/12/19 11:10:08.394260 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:10:08.394271 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:10:08 Assign 1 1
2025/12/19 11:10:08.394306 [INFO] typesutil/gopinfo.go:332: ==> Scope: comm case statement scope 0xc0004885a0 {
.  var i int
.  var x int
}

2025/12/19 11:10:08 End // CommCase
2025/12/19 11:10:08 End // Select
2025/12/19 11:10:08.394357 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000488480 {
.  var c chan int
}

2025/12/19 11:10:08 End // Func
2025/12/19 11:10:08.394489 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:08 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:08 ==> NewOverloadFunc NewRange
2025/12/19 11:10:09 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:09 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:09 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:09 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:09 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:09 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:09 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:09 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:09 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:09 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:09 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:09 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:09 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:09 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:09 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:09 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:09 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:09 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:09 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:09 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:09 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:09 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:09 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:09 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:09 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:09 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:09 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:09 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:09 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:09 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:09 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:09 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:09 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:09 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:09 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:09 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:09 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:09 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:09 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:09 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:09 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:09 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:09.456507 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc00039a060 {
}

2025/12/19 11:10:09 ==> Preload func _
2025/12/19 11:10:09 ==> Load func _
2025/12/19 11:10:09.456621 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:09 NewFunc _ func()
2025/12/19 11:10:09 For
2025/12/19 11:10:09.456666 [INFO] typesutil/gopinfo.go:332: ==> Scope: for statement scope 0xc00039a180 {
}

2025/12/19 11:10:09 None
2025/12/19 11:10:09 Then
2025/12/19 11:10:09.456692 [INFO] typesutil/gopinfo.go:332: ==> Scope: for body scope 0xc00039a1e0 {
}

2025/12/19 11:10:09 End // For
2025/12/19 11:10:09.456718 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc00039a120 {
}

2025/12/19 11:10:09 End // Func
2025/12/19 11:10:09.456902 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:09 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:09 ==> NewOverloadFunc NewRange
2025/12/19 11:10:10 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:10 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:10 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:10 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:10 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:10 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:10 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:10 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:10 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:10 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:10 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:10 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:10 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:10 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:10 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:10 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:10 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:10 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:10 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:10 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:10 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:10 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:10 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:10 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:10 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:10 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:10 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:10 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:10 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:10 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:10 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:10 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:10 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:10 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:10 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:10 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:10 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:10 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:10 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:10 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:10 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:10 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:10.464511 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0003639e0 {
}

2025/12/19 11:10:10 ==> Preload func _
2025/12/19 11:10:10 ==> Load func _
2025/12/19 11:10:10.464589 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:10.464606 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:10.464616 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:10.464627 [INFO] typesutil/gopinfo.go:251: ==> Def: n var n int
2025/12/19 11:10:10.464642 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(n int)
2025/12/19 11:10:10 NewFunc _ func(n int)
2025/12/19 11:10:10 For
2025/12/19 11:10:10.464676 [INFO] typesutil/gopinfo.go:332: ==> Scope: for statement scope 0xc000363b60 {
}

2025/12/19 11:10:10 DefineVarStart [i]
2025/12/19 11:10:10 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:10:10.464718 [INFO] typesutil/gopinfo.go:215: ==> Type: &{39 INT 0 <nil>} untyped int
2025/12/19 11:10:10 EndInit 1
2025/12/19 11:10:10.464742 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/12/19 11:10:10 Val i int
2025/12/19 11:10:10.464763 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/12/19 11:10:10.464772 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/12/19 11:10:10 Val n int
2025/12/19 11:10:10.464790 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n int
2025/12/19 11:10:10.464799 [INFO] typesutil/gopinfo.go:215: ==> Type: n int
2025/12/19 11:10:10 BinaryOp <
2025/12/19 11:10:10 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:10:10 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:10 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:10:10.464878 [INFO] typesutil/gopinfo.go:215: ==> Type: &{i 44 < n} untyped bool
2025/12/19 11:10:10 Then
2025/12/19 11:10:10.464895 [INFO] typesutil/gopinfo.go:332: ==> Scope: for body scope 0xc000363ce0 {
}

2025/12/19 11:10:10 VarRef _
2025/12/19 11:10:10 Val i int
2025/12/19 11:10:10.464917 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/12/19 11:10:10.464926 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/12/19 11:10:10 Assign 1 1
2025/12/19 11:10:10 Post
2025/12/19 11:10:10 VarRef i int
2025/12/19 11:10:10.464950 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/12/19 11:10:10.464959 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/12/19 11:10:10 IncDec ++
2025/12/19 11:10:10 End // For
2025/12/19 11:10:10.464988 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000363b00 {
.  var n int
}

2025/12/19 11:10:10 End // Func
2025/12/19 11:10:10.465141 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:11 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:11 ==> NewOverloadFunc NewRange
2025/12/19 11:10:11 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:11 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:11 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:11 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:11 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:11 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:11 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:11 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:11 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:11 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:11 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:11 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:11 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:11 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:11 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:11 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:11 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:11 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:11 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:11 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:11 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:11 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:11 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:11 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:11 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:11 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:11 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:11 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:11 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:11 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:11 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:11 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:11 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:11 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:11 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:11 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:11 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:11 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:11 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:11 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:11 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:11 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:11.506978 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0004d9da0 {
}

2025/12/19 11:10:11 ==> Preload func _
2025/12/19 11:10:11 ==> Load func _
2025/12/19 11:10:11.507048 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:11.507066 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:11.507078 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:11.507097 [INFO] typesutil/gopinfo.go:215: ==> Type: &{23 <nil> int} []int
2025/12/19 11:10:11.507109 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a []int
2025/12/19 11:10:11.507123 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(a []int)
2025/12/19 11:10:11 NewFunc _ func(a []int)
2025/12/19 11:10:11 ForRange [i]
2025/12/19 11:10:11 Val a []int
2025/12/19 11:10:11.507165 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a []int
2025/12/19 11:10:11.507177 [INFO] typesutil/gopinfo.go:215: ==> Type: a []int
2025/12/19 11:10:11 RangeAssignThen
2025/12/19 11:10:11.507194 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/12/19 11:10:11.507211 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc0004d9f20 {
.  var i int
}

2025/12/19 11:10:11 VBlock
2025/12/19 11:10:11 VarRef _
2025/12/19 11:10:11 Val i int
2025/12/19 11:10:11.507237 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/12/19 11:10:11.507246 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/12/19 11:10:11 Assign 1 1
2025/12/19 11:10:11.507261 [INFO] typesutil/gopinfo.go:332: ==> Scope: vblock statement scope 0xc0004de0c0 {
}

2025/12/19 11:10:11 End // Vblock
2025/12/19 11:10:11 End // ForRange
2025/12/19 11:10:11.507286 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0004d9ec0 {
.  var a []int
}

2025/12/19 11:10:11 End // Func
2025/12/19 11:10:11.507433 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:12 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:12 ==> NewOverloadFunc NewRange
2025/12/19 11:10:12 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:12 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:12 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:12 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:12 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:12 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:12 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:12 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:12 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:12 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:12 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:12 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:12 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:12 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:12 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:12 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:12 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:12 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:12 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:12 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:12 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:12 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:12 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:12 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:12 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:12 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:12 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:12 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:12 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:12 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:12 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:12 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:12 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:12 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:12 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:12 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:12 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:12 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:12 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:12 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:12 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:12 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:12.574608 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc000355800 {
}

2025/12/19 11:10:12 ==> Preload var [s]
2025/12/19 11:10:12 ==> Preload func _
2025/12/19 11:10:12.574685 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:12.574704 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:12.574716 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:12 ==> Load var int [s]
2025/12/19 11:10:12 NewVarDefs
2025/12/19 11:10:12 NewVar [s]
2025/12/19 11:10:12.574753 [INFO] typesutil/gopinfo.go:251: ==> Def: s var s int
2025/12/19 11:10:12 ==> Load func _
2025/12/19 11:10:12.574772 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:12.574782 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:12.574791 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:12.574810 [INFO] typesutil/gopinfo.go:215: ==> Type: &{34 <nil> int} []int
2025/12/19 11:10:12.574823 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a []int
2025/12/19 11:10:12.574840 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(a []int)
2025/12/19 11:10:12 NewFunc _ func(a []int)
2025/12/19 11:10:12 ForRange [i x]
2025/12/19 11:10:12 Val a []int
2025/12/19 11:10:12.574883 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a []int
2025/12/19 11:10:12.574895 [INFO] typesutil/gopinfo.go:215: ==> Type: a []int
2025/12/19 11:10:12 RangeAssignThen
2025/12/19 11:10:12.574913 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/12/19 11:10:12.574922 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:10:12.574943 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc0003559e0 {
.  var i int
.  var x int
}

2025/12/19 11:10:12 VBlock
2025/12/19 11:10:12 VarRef s int
2025/12/19 11:10:12.574979 [INFO] typesutil/gopinfo.go:265: ==> Use: s var s int
2025/12/19 11:10:12.574989 [INFO] typesutil/gopinfo.go:215: ==> Type: s int
2025/12/19 11:10:12 Val x int
2025/12/19 11:10:12.575004 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:10:12.575013 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:10:12 AssignOp += Gop_AddAssign
2025/12/19 11:10:12 ==> MatchFuncCall TemplateSignature{func(a unboundProxyParam{typ: *TemplateParamType{name: T}}, b TemplateParamType{name: T})} args: 2 flags: 0
2025/12/19 11:10:12 ==> MatchType refType{typ: int}, unboundProxyParam{typ: *unboundFuncParam{typ: <nil>}}
2025/12/19 11:10:12 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:10:12 VarRef _
2025/12/19 11:10:12 Val i int
2025/12/19 11:10:12.575117 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/12/19 11:10:12.575126 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/12/19 11:10:12 Assign 1 1
2025/12/19 11:10:12.575142 [INFO] typesutil/gopinfo.go:332: ==> Scope: vblock statement scope 0xc000355b60 {
}

2025/12/19 11:10:12 End // Vblock
2025/12/19 11:10:12 End // ForRange
2025/12/19 11:10:12.575171 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000355980 {
.  var a []int
}

2025/12/19 11:10:12 End // Func
2025/12/19 11:10:12.575341 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:13 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:13 ==> NewOverloadFunc NewRange
2025/12/19 11:10:13 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:13 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:13 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:13 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:13 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:13 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:13 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:13 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:13 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:13 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:13 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:13 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:13 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:13 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:13 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:13 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:13 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:13 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:13 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:13 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:13 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:13 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:13 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:13 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:13 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:13 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:13 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:13 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:13 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:13 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:13 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:13 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:13 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:13 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:13 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:13 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:13 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:13 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:13 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:13 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:13 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:13 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:13.731613 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc000531320 {
}

2025/12/19 11:10:13 ==> Preload var [s]
2025/12/19 11:10:13 ==> Preload func _
2025/12/19 11:10:13.731714 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:13.731737 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:13.731751 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:13 ==> Load var int [s]
2025/12/19 11:10:13 NewVarDefs
2025/12/19 11:10:13 NewVar [s]
2025/12/19 11:10:13.731795 [INFO] typesutil/gopinfo.go:251: ==> Def: s var s int
2025/12/19 11:10:13 ==> Load func _
2025/12/19 11:10:13.731816 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:13.731828 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:13.731839 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:13.731859 [INFO] typesutil/gopinfo.go:215: ==> Type: &{34 <nil> int} []int
2025/12/19 11:10:13.731873 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a []int
2025/12/19 11:10:13.731892 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(a []int)
2025/12/19 11:10:13 NewFunc _ func(a []int)
2025/12/19 11:10:13 ForRange [i x]
2025/12/19 11:10:13 Val a []int
2025/12/19 11:10:13.731945 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a []int
2025/12/19 11:10:13.731959 [INFO] typesutil/gopinfo.go:215: ==> Type: a []int
2025/12/19 11:10:13 RangeAssignThen
2025/12/19 11:10:13.731978 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/12/19 11:10:13.731989 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:10:13.732017 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc000531500 {
.  var i int
.  var x int
}

2025/12/19 11:10:13 VBlock
2025/12/19 11:10:13 DefineVarStart [c]
2025/12/19 11:10:13 Val i int
2025/12/19 11:10:13.732063 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/12/19 11:10:13.732075 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/12/19 11:10:13 EndInit 1
2025/12/19 11:10:13.732096 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c int
2025/12/19 11:10:13 Val println func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:13.732128 [INFO] typesutil/gopinfo.go:265: ==> Use: println builtin println
2025/12/19 11:10:13.732143 [INFO] typesutil/gopinfo.go:215: ==> Type: println invalid type
2025/12/19 11:10:13 Val c int
2025/12/19 11:10:13.732164 [INFO] typesutil/gopinfo.go:265: ==> Use: c var c int
2025/12/19 11:10:13.732175 [INFO] typesutil/gopinfo.go:215: ==> Type: c int
2025/12/19 11:10:13 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:13 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:10:13 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:10:13 ==> MatchType int, any
2025/12/19 11:10:13.732240 [INFO] typesutil/gopinfo.go:265: ==> Use: println func fmt.Println(a ...any) (n int, err error)
2025/12/19 11:10:13.732254 [INFO] typesutil/gopinfo.go:215: ==> Type: println func(a ...any) (n int, err error)
2025/12/19 11:10:13.732278 [INFO] typesutil/gopinfo.go:215: ==> Type: &{println 80 [c] 0 [] 82 0} (n int, err error)
2025/12/19 11:10:13.732300 [INFO] typesutil/gopinfo.go:332: ==> Scope: vblock statement scope 0xc000531680 {
.  var c int
}

2025/12/19 11:10:13 End // Vblock
2025/12/19 11:10:13 End // ForRange
2025/12/19 11:10:13.732335 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0005314a0 {
.  var a []int
}

2025/12/19 11:10:13 End // Func
2025/12/19 11:10:13.732548 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:14 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:14 ==> NewOverloadFunc NewRange
2025/12/19 11:10:14 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:14 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:14 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:14 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:14 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:14 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:14 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:14 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:14 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:14 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:14 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:14 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:14 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:14 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:14 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:14 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:14 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:14 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:14 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:14 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:14 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:14 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:14 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:14 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:14 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:14 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:14 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:14 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:14 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:14 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:14 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:14 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:14 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:14 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:14 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:14 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:14 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:14 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:14 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:14 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:14 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:14 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:14.871115 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0003852c0 {
}

2025/12/19 11:10:14 ==> Preload func _
2025/12/19 11:10:14 ==> Load func _
2025/12/19 11:10:14.871193 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:14 NewFunc _ func()
2025/12/19 11:10:14 DefineVarStart [sum]
2025/12/19 11:10:14 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:10:14.871271 [INFO] typesutil/gopinfo.go:215: ==> Type: &{31 INT 0 <nil>} untyped int
2025/12/19 11:10:14 EndInit 1
2025/12/19 11:10:14.871301 [INFO] typesutil/gopinfo.go:251: ==> Def: sum var sum int
2025/12/19 11:10:14 ForRange [_ x]
2025/12/19 11:10:14 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:10:14.871342 [INFO] typesutil/gopinfo.go:215: ==> Type: &{44 INT 1 <nil>} untyped int
2025/12/19 11:10:14 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:10:14.871368 [INFO] typesutil/gopinfo.go:215: ==> Type: &{47 INT 3 <nil>} untyped int
2025/12/19 11:10:14 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:10:14.871392 [INFO] typesutil/gopinfo.go:215: ==> Type: &{50 INT 5 <nil>} untyped int
2025/12/19 11:10:14 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:10:14.871416 [INFO] typesutil/gopinfo.go:215: ==> Type: &{53 INT 7 <nil>} untyped int
2025/12/19 11:10:14 Val &{0 INT 11} *ast.BasicLit
2025/12/19 11:10:14.871442 [INFO] typesutil/gopinfo.go:215: ==> Type: &{56 INT 11 <nil>} untyped int
2025/12/19 11:10:14 Val &{0 INT 13} *ast.BasicLit
2025/12/19 11:10:14.871464 [INFO] typesutil/gopinfo.go:215: ==> Type: &{60 INT 13 <nil>} untyped int
2025/12/19 11:10:14 Val &{0 INT 17} *ast.BasicLit
2025/12/19 11:10:14.871487 [INFO] typesutil/gopinfo.go:215: ==> Type: &{64 INT 17 <nil>} untyped int
2025/12/19 11:10:14 SliceLit <nil> 7 false
2025/12/19 11:10:14 RangeAssignThen
2025/12/19 11:10:14.871520 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:10:14.871542 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc000385440 {
.  var x int
}

2025/12/19 11:10:14 If
2025/12/19 11:10:14 Val x int
2025/12/19 11:10:14.871576 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:10:14.871595 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:10:14 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:10:14.871623 [INFO] typesutil/gopinfo.go:215: ==> Type: &{73 INT 3 <nil>} untyped int
2025/12/19 11:10:14 BinaryOp >
2025/12/19 11:10:14 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:10:14 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:14 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/12/19 11:10:14.871725 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 71 > 0xc000302780} untyped bool
2025/12/19 11:10:14 Then
2025/12/19 11:10:14 VarRef sum int
2025/12/19 11:10:14.871759 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/12/19 11:10:14.871773 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/12/19 11:10:14 Val sum int
2025/12/19 11:10:14.871798 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/12/19 11:10:14.871811 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/12/19 11:10:14 Val x int
2025/12/19 11:10:14.871833 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:10:14.871850 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:10:14 BinaryOp +
2025/12/19 11:10:14 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:10:14 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:14 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:10:14.871944 [INFO] typesutil/gopinfo.go:215: ==> Type: &{sum 87 + x} int
2025/12/19 11:10:14 Assign 1 1
2025/12/19 11:10:14 ==> MatchType int, int
2025/12/19 11:10:14 DefineVarStart [c]
2025/12/19 11:10:14 Val sum int
2025/12/19 11:10:14.872053 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/12/19 11:10:14.872066 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/12/19 11:10:14 EndInit 1
2025/12/19 11:10:14.872087 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c int
2025/12/19 11:10:14 VarRef _
2025/12/19 11:10:14 Val c int
2025/12/19 11:10:14.872114 [INFO] typesutil/gopinfo.go:265: ==> Use: c var c int
2025/12/19 11:10:14.872126 [INFO] typesutil/gopinfo.go:215: ==> Type: c int
2025/12/19 11:10:14 Assign 1 1
2025/12/19 11:10:14.872153 [INFO] typesutil/gopinfo.go:332: ==> Scope: if body scope 0xc000385680 {
.  var c int
}

2025/12/19 11:10:14 End // If
2025/12/19 11:10:14 End // ForRange
2025/12/19 11:10:14.872194 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000385380 {
.  var sum int
}

2025/12/19 11:10:14 End // Func
2025/12/19 11:10:14.872416 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:15 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:15 ==> NewOverloadFunc NewRange
2025/12/19 11:10:15 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:15 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:15 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:15 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:15 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:15 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:15 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:15 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:15 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:15 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:15 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:15 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:15 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:15 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:15 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:15 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:15 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:15 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:15 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:15 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:15 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:15 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:15 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:15 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:15 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:15 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:15 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:15 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:15 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:15 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:15 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:15 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:15 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:15 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:15 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:15 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:15 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:15 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:15 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:15 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:15 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:15 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:15.959883 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0002b2000 {
}

2025/12/19 11:10:15 ==> Preload func _
2025/12/19 11:10:15 ==> Load func _
2025/12/19 11:10:15.959964 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:15 NewFunc _ func()
2025/12/19 11:10:15 DefineVarStart [sum]
2025/12/19 11:10:15 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:10:15.960029 [INFO] typesutil/gopinfo.go:215: ==> Type: &{31 INT 0 <nil>} untyped int
2025/12/19 11:10:15 EndInit 1
2025/12/19 11:10:15.960052 [INFO] typesutil/gopinfo.go:251: ==> Def: sum var sum int
2025/12/19 11:10:15 ForRange [_ x]
2025/12/19 11:10:15 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:10:15.960085 [INFO] typesutil/gopinfo.go:215: ==> Type: &{44 INT 1 <nil>} untyped int
2025/12/19 11:10:15 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:10:15.960108 [INFO] typesutil/gopinfo.go:215: ==> Type: &{47 INT 3 <nil>} untyped int
2025/12/19 11:10:15 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:10:15.960127 [INFO] typesutil/gopinfo.go:215: ==> Type: &{50 INT 5 <nil>} untyped int
2025/12/19 11:10:15 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:10:15.960144 [INFO] typesutil/gopinfo.go:215: ==> Type: &{53 INT 7 <nil>} untyped int
2025/12/19 11:10:15 Val &{0 INT 11} *ast.BasicLit
2025/12/19 11:10:15.960163 [INFO] typesutil/gopinfo.go:215: ==> Type: &{56 INT 11 <nil>} untyped int
2025/12/19 11:10:15 Val &{0 INT 13} *ast.BasicLit
2025/12/19 11:10:15.960180 [INFO] typesutil/gopinfo.go:215: ==> Type: &{60 INT 13 <nil>} untyped int
2025/12/19 11:10:15 Val &{0 INT 17} *ast.BasicLit
2025/12/19 11:10:15.960199 [INFO] typesutil/gopinfo.go:215: ==> Type: &{64 INT 17 <nil>} untyped int
2025/12/19 11:10:15 SliceLit <nil> 7 false
2025/12/19 11:10:15 RangeAssignThen
2025/12/19 11:10:15.960223 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:10:15.960240 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc0002b2180 {
.  var x int
}

2025/12/19 11:10:15 VBlock
2025/12/19 11:10:15 VarRef sum int
2025/12/19 11:10:15.960267 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/12/19 11:10:15.960280 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/12/19 11:10:15 Val sum int
2025/12/19 11:10:15.960299 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/12/19 11:10:15.960308 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/12/19 11:10:15 Val x int
2025/12/19 11:10:15.960327 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:10:15.960335 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:10:15 BinaryOp +
2025/12/19 11:10:15 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:10:15 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:15 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:10:15.960418 [INFO] typesutil/gopinfo.go:215: ==> Type: &{sum 80 + x} int
2025/12/19 11:10:15 Assign 1 1
2025/12/19 11:10:15 ==> MatchType int, int
2025/12/19 11:10:15 DefineVarStart [c]
2025/12/19 11:10:15 Val sum int
2025/12/19 11:10:15.960461 [INFO] typesutil/gopinfo.go:265: ==> Use: sum var sum int
2025/12/19 11:10:15.960470 [INFO] typesutil/gopinfo.go:215: ==> Type: sum int
2025/12/19 11:10:15 EndInit 1
2025/12/19 11:10:15.960486 [INFO] typesutil/gopinfo.go:251: ==> Def: c var c int
2025/12/19 11:10:15 VarRef _
2025/12/19 11:10:15 Val c int
2025/12/19 11:10:15.960506 [INFO] typesutil/gopinfo.go:265: ==> Use: c var c int
2025/12/19 11:10:15.960520 [INFO] typesutil/gopinfo.go:215: ==> Type: c int
2025/12/19 11:10:15 Assign 1 1
2025/12/19 11:10:15.960542 [INFO] typesutil/gopinfo.go:332: ==> Scope: vblock statement scope 0xc0002b22a0 {
.  var c int
}

2025/12/19 11:10:15 End // Vblock
2025/12/19 11:10:15 End // ForRange
2025/12/19 11:10:15.960568 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0002b20c0 {
.  var sum int
}

2025/12/19 11:10:15 End // Func
2025/12/19 11:10:15.960740 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:16 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:16 ==> NewOverloadFunc NewRange
2025/12/19 11:10:16 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:16 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:16 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:16 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:16 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:16 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:16 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:16 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:16 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:16 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:16 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:16 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:16 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:16 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:16 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:16 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:16 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:16 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:16 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:16 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:16 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:16 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:16 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:16 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:16 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:16 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:16 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:16 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:16 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:16 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:16 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:16 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:16 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:16 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:16 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:16 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:16 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:16 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:16 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:16 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:16 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:16 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:17.018937 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0002da420 {
}

2025/12/19 11:10:17 ==> Preload func test
2025/12/19 11:10:17 ==> Preload func _
2025/12/19 11:10:17 ==> Load func test
2025/12/19 11:10:17.019041 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:17.019066 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:17.019081 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:17.019095 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:17.019108 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:17.019119 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:17.019148 [INFO] typesutil/gopinfo.go:215: ==> Type: &{27 <nil> 0xc00049e240 0xc00049e270} func(int) int
2025/12/19 11:10:17.019182 [INFO] typesutil/gopinfo.go:251: ==> Def: fn var fn func(int) int
2025/12/19 11:10:17.019205 [INFO] typesutil/gopinfo.go:251: ==> Def: test func test(fn func(int) int)
2025/12/19 11:10:17 NewFunc test func(fn func(int) int)
2025/12/19 11:10:17.019250 [INFO] typesutil/gopinfo.go:332: ==> Scope: func test scope 0xc0002da600 {
.  var fn func(int) int
}

2025/12/19 11:10:17 End // Func
2025/12/19 11:10:17 ==> Load func _
2025/12/19 11:10:17.019296 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:17 NewFunc _ func()
2025/12/19 11:10:17 Val test func(fn func(int) int)
2025/12/19 11:10:17.019336 [INFO] typesutil/gopinfo.go:265: ==> Use: test func test(fn func(int) int)
2025/12/19 11:10:17.019354 [INFO] typesutil/gopinfo.go:215: ==> Type: test func(fn func(int) int)
2025/12/19 11:10:17.019369 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:17.019382 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:17.019394 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:17.019409 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:10:17.019421 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:17.019434 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:17.019446 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:17.019466 [INFO] typesutil/gopinfo.go:215: ==> Type: &{57 <nil> 0xc00049e420 0xc00049e450} func(x int) int
2025/12/19 11:10:17.019493 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000483420 0xc00049e510} func(x int) int
2025/12/19 11:10:17 NewClosure func(x int) int
2025/12/19 11:10:17 DefineVarStart [y]
2025/12/19 11:10:17 Val x int
2025/12/19 11:10:17.019543 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:10:17.019561 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:10:17 Val x int
2025/12/19 11:10:17.019584 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:10:17.019597 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:10:17 BinaryOp *
2025/12/19 11:10:17 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:10:17 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:17 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:10:17.019694 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 81 * x} int
2025/12/19 11:10:17 EndInit 1
2025/12/19 11:10:17.019721 [INFO] typesutil/gopinfo.go:251: ==> Def: y var y int
2025/12/19 11:10:17 Val y int
2025/12/19 11:10:17.019744 [INFO] typesutil/gopinfo.go:265: ==> Use: y var y int
2025/12/19 11:10:17.019756 [INFO] typesutil/gopinfo.go:215: ==> Type: y int
2025/12/19 11:10:17 Return 1
2025/12/19 11:10:17 ==> MatchType int, int
2025/12/19 11:10:17.019798 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0002da840 {
.  var x int
.  var y int
}

2025/12/19 11:10:17 End // Func
2025/12/19 11:10:17 Call 1 0 // func(fn func(int) int)
2025/12/19 11:10:17 ==> MatchFuncCall func(fn func(int) int) args: 1 flags: 0
2025/12/19 11:10:17 ==> MatchType func(x int) int, func(int) int
2025/12/19 11:10:17.019872 [INFO] typesutil/gopinfo.go:215: ==> Type: &{test 56 [0xc0005bfe40] 0 [] 96 0} ()
2025/12/19 11:10:17.019888 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0002da6c0 {
}

2025/12/19 11:10:17 End // Func
2025/12/19 11:10:17.020079 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:17 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:17 ==> NewOverloadFunc NewRange
2025/12/19 11:10:17 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:17 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:17 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:17 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:17 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:17 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:17 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:17 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:17 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:17 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:17 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:17 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:17 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:17 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:17 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:17 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:17 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:17 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:17 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:17 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:17 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:17 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:17 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:17 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:17 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:17 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:17 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:17 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:17 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:17 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:17 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:17 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:17 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:17 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:17 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:17 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:17 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:17 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:17 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:17 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:17 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:17 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:18.030593 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0004f3ce0 {
}

2025/12/19 11:10:18 ==> Preload func test
2025/12/19 11:10:18 ==> Preload func _
2025/12/19 11:10:18 ==> Load func test
2025/12/19 11:10:18.030747 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:18.030777 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:18.030798 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:18.030818 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:18.030837 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:18.030856 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:18.030898 [INFO] typesutil/gopinfo.go:215: ==> Type: &{27 <nil> 0xc0008291d0 0xc000829200} func(int) int
2025/12/19 11:10:18.030930 [INFO] typesutil/gopinfo.go:251: ==> Def: fn var fn func(int) int
2025/12/19 11:10:18.030964 [INFO] typesutil/gopinfo.go:251: ==> Def: test func test(fn func(int) int)
2025/12/19 11:10:18 NewFunc test func(fn func(int) int)
2025/12/19 11:10:18.031042 [INFO] typesutil/gopinfo.go:332: ==> Scope: func test scope 0xc0004f3ec0 {
.  var fn func(int) int
}

2025/12/19 11:10:18 End // Func
2025/12/19 11:10:18 ==> Load func _
2025/12/19 11:10:18.031113 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:18 NewFunc _ func()
2025/12/19 11:10:18 Val test func(fn func(int) int)
2025/12/19 11:10:18.031193 [INFO] typesutil/gopinfo.go:265: ==> Use: test func test(fn func(int) int)
2025/12/19 11:10:18.031216 [INFO] typesutil/gopinfo.go:215: ==> Type: test func(fn func(int) int)
2025/12/19 11:10:18.031241 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:10:18 NewClosure func(x int) int
2025/12/19 11:10:18.031293 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:10:18 Val x int
2025/12/19 11:10:18.031328 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:10:18.031346 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:10:18 Val x int
2025/12/19 11:10:18.031376 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:10:18.031394 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:10:18 BinaryOp *
2025/12/19 11:10:18 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:10:18 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:18 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:10:18.031528 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 64 * x} int
2025/12/19 11:10:18.031564 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc000518180 {
.  var x int
}

2025/12/19 11:10:18 Return 1
2025/12/19 11:10:18 ==> MatchType int, int
2025/12/19 11:10:18 End // Func
2025/12/19 11:10:18 Call 1 0 // func(fn func(int) int)
2025/12/19 11:10:18 ==> MatchFuncCall func(fn func(int) int) args: 1 flags: 0
2025/12/19 11:10:18 ==> MatchType func(x int) int, func(int) int
2025/12/19 11:10:18.031714 [INFO] typesutil/gopinfo.go:215: ==> Type: &{test 56 [0xc0004c9450] 0 [] 67 0} ()
2025/12/19 11:10:18.031742 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000518000 {
}

2025/12/19 11:10:18 End // Func
2025/12/19 11:10:18.032005 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:18 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:18 ==> NewOverloadFunc NewRange
2025/12/19 11:10:18 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:18 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:18 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:18 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:18 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:18 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:18 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:18 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:18 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:18 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:18 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:18 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:18 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:18 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:18 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:18 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:18 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:18 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:18 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:18 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:18 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:18 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:18 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:18 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:18 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:18 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:18 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:18 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:18 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:18 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:18 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:18 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:18 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:18 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:18 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:18 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:18 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:18 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:18 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:18 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:18 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:18 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:19.187459 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0003be9c0 {
}

2025/12/19 11:10:19 ==> Preload func test
2025/12/19 11:10:19 ==> Preload func _
2025/12/19 11:10:19 ==> Load func test
2025/12/19 11:10:19.187553 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:19.187578 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:19.187592 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:19.187608 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:19.187620 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:19.187631 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:19.187659 [INFO] typesutil/gopinfo.go:215: ==> Type: &{27 <nil> 0xc0002a5da0 0xc0002a5dd0} func(int) int
2025/12/19 11:10:19.187675 [INFO] typesutil/gopinfo.go:251: ==> Def: fn var fn func(int) int
2025/12/19 11:10:19.187699 [INFO] typesutil/gopinfo.go:251: ==> Def: test func test(fn func(int) int)
2025/12/19 11:10:19 NewFunc test func(fn func(int) int)
2025/12/19 11:10:19.187740 [INFO] typesutil/gopinfo.go:332: ==> Scope: func test scope 0xc0003beba0 {
.  var fn func(int) int
}

2025/12/19 11:10:19 End // Func
2025/12/19 11:10:19 ==> Load func _
2025/12/19 11:10:19.187791 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:19 NewFunc _ func()
2025/12/19 11:10:19 Val test func(fn func(int) int)
2025/12/19 11:10:19.187831 [INFO] typesutil/gopinfo.go:265: ==> Use: test func test(fn func(int) int)
2025/12/19 11:10:19.187847 [INFO] typesutil/gopinfo.go:215: ==> Type: test func(fn func(int) int)
2025/12/19 11:10:19.187864 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:10:19 NewClosure func(x int) int
2025/12/19 11:10:19.187893 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:10:19 DefineVarStart [y]
2025/12/19 11:10:19 Val x int
2025/12/19 11:10:19.187929 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:10:19.187942 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:10:19 Val x int
2025/12/19 11:10:19.187963 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:10:19.187975 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:10:19 BinaryOp *
2025/12/19 11:10:19 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:10:19 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:19 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:10:19.188075 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 71 * x} int
2025/12/19 11:10:19 EndInit 1
2025/12/19 11:10:19.188097 [INFO] typesutil/gopinfo.go:251: ==> Def: y var y int
2025/12/19 11:10:19 Val y int
2025/12/19 11:10:19.188121 [INFO] typesutil/gopinfo.go:265: ==> Use: y var y int
2025/12/19 11:10:19.188133 [INFO] typesutil/gopinfo.go:215: ==> Type: y int
2025/12/19 11:10:19 Return 1
2025/12/19 11:10:19 ==> MatchType int, int
2025/12/19 11:10:19.188170 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0003bede0 {
.  var x int
.  var y int
}

2025/12/19 11:10:19 End // Func
2025/12/19 11:10:19 Call 1 0 // func(fn func(int) int)
2025/12/19 11:10:19 ==> MatchFuncCall func(fn func(int) int) args: 1 flags: 0
2025/12/19 11:10:19 ==> MatchType func(x int) int, func(int) int
2025/12/19 11:10:19.188255 [INFO] typesutil/gopinfo.go:215: ==> Type: &{test 56 [0xc0004f5980] 0 [] 86 0} ()
2025/12/19 11:10:19.188278 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0003bec60 {
}

2025/12/19 11:10:19 End // Func
2025/12/19 11:10:19.188465 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:19 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:19 ==> NewOverloadFunc NewRange
2025/12/19 11:10:19 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:19 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:19 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:19 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:19 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:19 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:19 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:19 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:19 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:19 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:19 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:19 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:19 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:19 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:19 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:19 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:19 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:19 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:19 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:19 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:19 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:19 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:19 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:19 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:19 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:19 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:19 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:19 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:19 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:19 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:19 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:19 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:19 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:19 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:19 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:19 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:19 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:19 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:19 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:19 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:19 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:19 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:20.332409 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc00038f4a0 {
}

2025/12/19 11:10:20 ==> Preload func _
2025/12/19 11:10:20 ==> Load func _
2025/12/19 11:10:20.332499 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:20 NewFunc _ func()
2025/12/19 11:10:20 DefineVarStart [b]
2025/12/19 11:10:20 NewClosure func() (_xgo_ok bool)
2025/12/19 11:10:20 ForRange [_ x]
2025/12/19 11:10:20 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:10:20.332615 [INFO] typesutil/gopinfo.go:215: ==> Type: &{40 STRING "1" <nil>} untyped string
2025/12/19 11:10:20 Val &{0 STRING "3"} *ast.BasicLit
2025/12/19 11:10:20.332645 [INFO] typesutil/gopinfo.go:215: ==> Type: &{45 STRING "3" <nil>} untyped string
2025/12/19 11:10:20 Val &{0 STRING "5"} *ast.BasicLit
2025/12/19 11:10:20.332667 [INFO] typesutil/gopinfo.go:215: ==> Type: &{50 STRING "5" <nil>} untyped string
2025/12/19 11:10:20 Val &{0 STRING "7"} *ast.BasicLit
2025/12/19 11:10:20.332689 [INFO] typesutil/gopinfo.go:215: ==> Type: &{55 STRING "7" <nil>} untyped string
2025/12/19 11:10:20 Val &{0 STRING "11"} *ast.BasicLit
2025/12/19 11:10:20.332725 [INFO] typesutil/gopinfo.go:215: ==> Type: &{60 STRING "11" <nil>} untyped string
2025/12/19 11:10:20 SliceLit <nil> 5 false
2025/12/19 11:10:20 RangeAssignThen
2025/12/19 11:10:20.332761 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x string
2025/12/19 11:10:20.332787 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc00038f6e0 {
.  var x string
}

2025/12/19 11:10:20 If
2025/12/19 11:10:20 Val x string
2025/12/19 11:10:20.332824 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x string
2025/12/19 11:10:20.332837 [INFO] typesutil/gopinfo.go:215: ==> Type: x string
2025/12/19 11:10:20 Val &{0 STRING "5"} *ast.BasicLit
2025/12/19 11:10:20.332862 [INFO] typesutil/gopinfo.go:215: ==> Type: &{72 STRING "5" <nil>} untyped string
2025/12/19 11:10:20 BinaryOp ==
2025/12/19 11:10:20.332892 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 69 == 0xc000302a80} untyped bool
2025/12/19 11:10:20 Then
2025/12/19 11:10:20 Val true bool
2025/12/19 11:10:20 Return 1
2025/12/19 11:10:20 ==> MatchType untyped bool (true), bool
2025/12/19 11:10:20 End // If
2025/12/19 11:10:20 End // ForRange
2025/12/19 11:10:20 Return 0
2025/12/19 11:10:20 End // Func
2025/12/19 11:10:20 Call 0 0 // func() (_xgo_ok bool)
2025/12/19 11:10:20 ==> MatchFuncCall func() (_xgo_ok bool) args: 0 flags: 0
2025/12/19 11:10:20 EndInit 1
2025/12/19 11:10:20.333045 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b bool
2025/12/19 11:10:20 VarRef _
2025/12/19 11:10:20 Val b bool
2025/12/19 11:10:20.333096 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b bool
2025/12/19 11:10:20.333123 [INFO] typesutil/gopinfo.go:215: ==> Type: b bool
2025/12/19 11:10:20 Assign 1 1
2025/12/19 11:10:20.333157 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc00038f560 {
.  var b bool
}

2025/12/19 11:10:20 End // Func
2025/12/19 11:10:20.333349 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:20 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:20 ==> NewOverloadFunc NewRange
2025/12/19 11:10:21 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:21 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:21 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:21 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:21 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:21 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:21 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:21 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:21 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:21 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:21 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:21 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:21 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:21 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:21 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:21 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:21 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:21 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:21 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:21 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:21 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:21 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:21 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:21 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:21 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:21 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:21 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:21 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:21 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:21 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:21 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:21 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:21 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:21 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:21 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:21 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:21 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:21 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:21 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:21 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:21 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:21 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:21.419265 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0003d1500 {
}

2025/12/19 11:10:21 ==> Preload func _
2025/12/19 11:10:21 ==> Load func _
2025/12/19 11:10:21.419361 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:21 NewFunc _ func()
2025/12/19 11:10:21 DefineVarStart [b ok]
2025/12/19 11:10:21 NewClosure func() (_xgo_ret unboundType{typ: <nil>}, _xgo_ok bool)
2025/12/19 11:10:21 ForRange [i x]
2025/12/19 11:10:21 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:10:21.419474 [INFO] typesutil/gopinfo.go:215: ==> Type: &{49 STRING "1" <nil>} untyped string
2025/12/19 11:10:21 Val &{0 STRING "3"} *ast.BasicLit
2025/12/19 11:10:21.419504 [INFO] typesutil/gopinfo.go:215: ==> Type: &{54 STRING "3" <nil>} untyped string
2025/12/19 11:10:21 Val &{0 STRING "5"} *ast.BasicLit
2025/12/19 11:10:21.419530 [INFO] typesutil/gopinfo.go:215: ==> Type: &{59 STRING "5" <nil>} untyped string
2025/12/19 11:10:21 Val &{0 STRING "7"} *ast.BasicLit
2025/12/19 11:10:21.419555 [INFO] typesutil/gopinfo.go:215: ==> Type: &{64 STRING "7" <nil>} untyped string
2025/12/19 11:10:21 Val &{0 STRING "11"} *ast.BasicLit
2025/12/19 11:10:21.419580 [INFO] typesutil/gopinfo.go:215: ==> Type: &{69 STRING "11" <nil>} untyped string
2025/12/19 11:10:21 SliceLit <nil> 5 false
2025/12/19 11:10:21 RangeAssignThen
2025/12/19 11:10:21.419614 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/12/19 11:10:21.419627 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x string
2025/12/19 11:10:21.419652 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc0003d17a0 {
.  var i int
.  var x string
}

2025/12/19 11:10:21 If
2025/12/19 11:10:21 Val x string
2025/12/19 11:10:21.419683 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x string
2025/12/19 11:10:21.419697 [INFO] typesutil/gopinfo.go:215: ==> Type: x string
2025/12/19 11:10:21 Val &{0 STRING "5"} *ast.BasicLit
2025/12/19 11:10:21.419724 [INFO] typesutil/gopinfo.go:215: ==> Type: &{81 STRING "5" <nil>} untyped string
2025/12/19 11:10:21 BinaryOp ==
2025/12/19 11:10:21.419752 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 78 == 0xc0003ff0b0} untyped bool
2025/12/19 11:10:21 Then
2025/12/19 11:10:21 Val i int
2025/12/19 11:10:21.419781 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/12/19 11:10:21.419796 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/12/19 11:10:21 Val true bool
2025/12/19 11:10:21 Return 2
2025/12/19 11:10:21 ==> MatchType int, unboundType{typ: <nil>}
2025/12/19 11:10:21 ==> MatchType untyped bool (true), bool
2025/12/19 11:10:21 End // If
2025/12/19 11:10:21 End // ForRange
2025/12/19 11:10:21 Return 0
2025/12/19 11:10:21 End // Func
2025/12/19 11:10:21 Call 0 0 // func() (_xgo_ret int, _xgo_ok bool)
2025/12/19 11:10:21 ==> MatchFuncCall func() (_xgo_ret int, _xgo_ok bool) args: 0 flags: 0
2025/12/19 11:10:21 EndInit 1
2025/12/19 11:10:21.419930 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b int
2025/12/19 11:10:21.419943 [INFO] typesutil/gopinfo.go:251: ==> Def: ok var ok bool
2025/12/19 11:10:21 VarRef _
2025/12/19 11:10:21 Val b int
2025/12/19 11:10:21.419969 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b int
2025/12/19 11:10:21.419981 [INFO] typesutil/gopinfo.go:215: ==> Type: b int
2025/12/19 11:10:21 Assign 1 1
2025/12/19 11:10:21 VarRef _
2025/12/19 11:10:21 Val ok bool
2025/12/19 11:10:21.420014 [INFO] typesutil/gopinfo.go:265: ==> Use: ok var ok bool
2025/12/19 11:10:21.420026 [INFO] typesutil/gopinfo.go:215: ==> Type: ok bool
2025/12/19 11:10:21 Assign 1 1
2025/12/19 11:10:21.420053 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0003d15c0 {
.  var b int
.  var ok bool
}

2025/12/19 11:10:21 End // Func
2025/12/19 11:10:21.420241 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:21 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:21 ==> NewOverloadFunc NewRange
2025/12/19 11:10:22 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:22 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:22 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:22 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:22 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:22 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:22 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:22 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:22 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:22 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:22 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:22 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:22 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:22 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:22 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:22 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:22 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:22 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:22 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:22 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:22 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:22 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:22 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:22 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:22 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:22 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:22 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:22 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:22 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:22 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:22 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:22 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:22 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:22 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:22 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:22 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:22 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:22 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:22 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:22 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:22 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:22 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:22.485482 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0002d5920 {
}

2025/12/19 11:10:22 ==> Preload func _
2025/12/19 11:10:22 ==> Load func _
2025/12/19 11:10:22.485546 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:22 NewFunc _ func()
2025/12/19 11:10:22 DefineVarStart [a]
2025/12/19 11:10:22 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:10:22 ForRange [_ x]
2025/12/19 11:10:22 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:10:22.485627 [INFO] typesutil/gopinfo.go:215: ==> Type: &{44 INT 1 <nil>} untyped int
2025/12/19 11:10:22 Val &{0 FLOAT 3.4} *ast.BasicLit
2025/12/19 11:10:22.485661 [INFO] typesutil/gopinfo.go:215: ==> Type: &{47 FLOAT 3.4 <nil>} untyped float
2025/12/19 11:10:22 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:10:22.485676 [INFO] typesutil/gopinfo.go:215: ==> Type: &{52 INT 5 <nil>} untyped int
2025/12/19 11:10:22 SliceLit <nil> 3 false
2025/12/19 11:10:22 RangeAssignThen
2025/12/19 11:10:22.485708 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x float64
2025/12/19 11:10:22.485721 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc0002d5b60 {
.  var x float64
}

2025/12/19 11:10:22 If
2025/12/19 11:10:22 Val x float64
2025/12/19 11:10:22.485743 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/12/19 11:10:22.485753 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/12/19 11:10:22 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:10:22.485769 [INFO] typesutil/gopinfo.go:215: ==> Type: &{62 INT 2 <nil>} untyped int
2025/12/19 11:10:22 BinaryOp >
2025/12/19 11:10:22 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:10:22 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:22 ==> MatchType untyped int (2), unboundFuncParam{typ: float64}
2025/12/19 11:10:22.485835 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 60 > 0xc000303440} untyped bool
2025/12/19 11:10:22 Then
2025/12/19 11:10:22 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:10:22 Val append func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:22 Val _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:10:22 Val x float64
2025/12/19 11:10:22.485872 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/12/19 11:10:22.485878 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/12/19 11:10:22 Val x float64
2025/12/19 11:10:22.485894 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x float64
2025/12/19 11:10:22.485900 [INFO] typesutil/gopinfo.go:215: ==> Type: x float64
2025/12/19 11:10:22 BinaryOp *
2025/12/19 11:10:22 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:10:22 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:22 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:10:22.485942 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 31 * x} float64
2025/12/19 11:10:22 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:22 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:10:22 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/12/19 11:10:22 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/12/19 11:10:22 ==> MatchType unboundType{typ: <nil>}, []unboundFuncParam{typ: <nil>}
2025/12/19 11:10:22 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:22 Assign 1 1
2025/12/19 11:10:22 ==> MatchType []float64, unboundType{typ: <nil>}
2025/12/19 11:10:22 End // If
2025/12/19 11:10:22 End // ForRange
2025/12/19 11:10:22 Return 0
2025/12/19 11:10:22 End // Func
2025/12/19 11:10:22 Call 0 0 // func() (_xgo_ret []float64)
2025/12/19 11:10:22 ==> MatchFuncCall func() (_xgo_ret []float64) args: 0 flags: 0
2025/12/19 11:10:22 EndInit 1
2025/12/19 11:10:22.486069 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a []float64
2025/12/19 11:10:22 VarRef _
2025/12/19 11:10:22 Val a []float64
2025/12/19 11:10:22.486089 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a []float64
2025/12/19 11:10:22.486097 [INFO] typesutil/gopinfo.go:215: ==> Type: a []float64
2025/12/19 11:10:22 Assign 1 1
2025/12/19 11:10:22.486111 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0002d59e0 {
.  var a []float64
}

2025/12/19 11:10:22 End // Func
2025/12/19 11:10:22.486256 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:23 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:23 ==> NewOverloadFunc NewRange
2025/12/19 11:10:23 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:23 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:23 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:23 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:23 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:23 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:23 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:23 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:23 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:23 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:23 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:23 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:23 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:23 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:23 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:23 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:23 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:23 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:23 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:23 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:23 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:23 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:23 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:23 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:23 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:23 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:23 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:23 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:23 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:23 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:23 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:23 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:23 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:23 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:23 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:23 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:23 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:23 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:23 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:23 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:23 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:23 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:23.540651 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc00022e300 {
}

2025/12/19 11:10:23 ==> Preload func _
2025/12/19 11:10:23 ==> Load func _
2025/12/19 11:10:23.540750 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:23 NewFunc _ func()
2025/12/19 11:10:23 DefineVarStart [arr]
2025/12/19 11:10:23 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:10:23.540837 [INFO] typesutil/gopinfo.go:215: ==> Type: &{32 INT 1 <nil>} untyped int
2025/12/19 11:10:23 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:10:23.540866 [INFO] typesutil/gopinfo.go:215: ==> Type: &{35 INT 2 <nil>} untyped int
2025/12/19 11:10:23 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:10:23.540893 [INFO] typesutil/gopinfo.go:215: ==> Type: &{38 INT 3 <nil>} untyped int
2025/12/19 11:10:23 Val &{0 FLOAT 4.1} *ast.BasicLit
2025/12/19 11:10:23.540937 [INFO] typesutil/gopinfo.go:215: ==> Type: &{41 FLOAT 4.1 <nil>} untyped float
2025/12/19 11:10:23 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:10:23.540967 [INFO] typesutil/gopinfo.go:215: ==> Type: &{46 INT 5 <nil>} untyped int
2025/12/19 11:10:23 Val &{0 INT 6} *ast.BasicLit
2025/12/19 11:10:23.540989 [INFO] typesutil/gopinfo.go:215: ==> Type: &{49 INT 6 <nil>} untyped int
2025/12/19 11:10:23 SliceLit <nil> 6 false
2025/12/19 11:10:23 EndInit 1
2025/12/19 11:10:23.541035 [INFO] typesutil/gopinfo.go:251: ==> Def: arr var arr []float64
2025/12/19 11:10:23 DefineVarStart [x]
2025/12/19 11:10:23 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:10:23 ForRange [_ b]
2025/12/19 11:10:23 Val arr []float64
2025/12/19 11:10:23.541151 [INFO] typesutil/gopinfo.go:265: ==> Use: arr var arr []float64
2025/12/19 11:10:23.541179 [INFO] typesutil/gopinfo.go:215: ==> Type: arr []float64
2025/12/19 11:10:23 RangeAssignThen
2025/12/19 11:10:23.541201 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b float64
2025/12/19 11:10:23.541222 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc00022e600 {
.  var b float64
}

2025/12/19 11:10:23 If
2025/12/19 11:10:23 Val b float64
2025/12/19 11:10:23.541252 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b float64
2025/12/19 11:10:23.541264 [INFO] typesutil/gopinfo.go:215: ==> Type: b float64
2025/12/19 11:10:23 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:10:23.541295 [INFO] typesutil/gopinfo.go:215: ==> Type: &{103 INT 2 <nil>} untyped int
2025/12/19 11:10:23 BinaryOp >
2025/12/19 11:10:23 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:10:23 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:23 ==> MatchType untyped int (2), unboundFuncParam{typ: float64}
2025/12/19 11:10:23.541409 [INFO] typesutil/gopinfo.go:215: ==> Type: &{b 101 > 0xc00020c8a0} untyped bool
2025/12/19 11:10:23 Then
2025/12/19 11:10:23 ForRange [_ a]
2025/12/19 11:10:23 Val arr []float64
2025/12/19 11:10:23.541455 [INFO] typesutil/gopinfo.go:265: ==> Use: arr var arr []float64
2025/12/19 11:10:23.541469 [INFO] typesutil/gopinfo.go:215: ==> Type: arr []float64
2025/12/19 11:10:23 RangeAssignThen
2025/12/19 11:10:23.541487 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a float64
2025/12/19 11:10:23.541505 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc00022e8a0 {
.  var a float64
}

2025/12/19 11:10:23 If
2025/12/19 11:10:23 Val a float64
2025/12/19 11:10:23.541532 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a float64
2025/12/19 11:10:23.541544 [INFO] typesutil/gopinfo.go:215: ==> Type: a float64
2025/12/19 11:10:23 Val b float64
2025/12/19 11:10:23.541562 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b float64
2025/12/19 11:10:23.541573 [INFO] typesutil/gopinfo.go:215: ==> Type: b float64
2025/12/19 11:10:23 BinaryOp <
2025/12/19 11:10:23 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:10:23 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:23 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:10:23.541655 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 81 < b} untyped bool
2025/12/19 11:10:23 Then
2025/12/19 11:10:23 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:10:23 Val append func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:23 Val _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:10:23 Val a float64
2025/12/19 11:10:23.541715 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a float64
2025/12/19 11:10:23.541727 [INFO] typesutil/gopinfo.go:215: ==> Type: a float64
2025/12/19 11:10:23 Val b float64
2025/12/19 11:10:23.541749 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b float64
2025/12/19 11:10:23.541761 [INFO] typesutil/gopinfo.go:215: ==> Type: b float64
2025/12/19 11:10:23 SliceLit <nil> 2 false
2025/12/19 11:10:23 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:23 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:10:23 ==> MatchFuncCall TyInstruction{gogen.appendStringInstr} args: 2 flags: 0
2025/12/19 11:10:23 ==> MatchFuncCall TemplateSignature{func(slice []TemplateParamType{name: Type}, elems ...TemplateParamType{name: Type}) []TemplateParamType{name: Type}} args: 2 flags: 0
2025/12/19 11:10:23 ==> MatchType unboundType{typ: <nil>}, []unboundFuncParam{typ: <nil>}
2025/12/19 11:10:23 ==> MatchType []float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:23 Assign 1 1
2025/12/19 11:10:23 ==> MatchType [][]float64, unboundType{typ: <nil>}
2025/12/19 11:10:23 End // If
2025/12/19 11:10:23 End // ForRange
2025/12/19 11:10:23 End // If
2025/12/19 11:10:23 End // ForRange
2025/12/19 11:10:23 Return 0
2025/12/19 11:10:23 End // Func
2025/12/19 11:10:23 Call 0 0 // func() (_xgo_ret [][]float64)
2025/12/19 11:10:23 ==> MatchFuncCall func() (_xgo_ret [][]float64) args: 0 flags: 0
2025/12/19 11:10:23 EndInit 1
2025/12/19 11:10:23.541969 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x [][]float64
2025/12/19 11:10:23 VarRef _
2025/12/19 11:10:23 Val x [][]float64
2025/12/19 11:10:23.542001 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x [][]float64
2025/12/19 11:10:23.542016 [INFO] typesutil/gopinfo.go:215: ==> Type: x [][]float64
2025/12/19 11:10:23 Assign 1 1
2025/12/19 11:10:23.542047 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc00022e3c0 {
.  var arr []float64
.  var x [][]float64
}

2025/12/19 11:10:23 End // Func
2025/12/19 11:10:23.542253 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:24 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:24 ==> NewOverloadFunc NewRange
2025/12/19 11:10:24 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:24 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:24 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:24 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:24 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:24 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:24 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:24 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:24 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:24 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:24 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:24 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:24 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:24 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:24 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:24 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:24 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:24 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:24 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:24 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:24 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:24 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:24 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:24 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:24 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:24 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:24 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:24 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:24 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:24 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:24 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:24 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:24 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:24 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:24 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:24 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:24 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:24 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:24 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:24 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:24 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:24 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:24.615426 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0003a6f00 {
}

2025/12/19 11:10:24 ==> Preload func _
2025/12/19 11:10:24 ==> Load func _
2025/12/19 11:10:24.615518 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:24 NewFunc _ func()
2025/12/19 11:10:24 DefineVarStart [y]
2025/12/19 11:10:24 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:10:24 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:10:24 ZeroLit // unboundType{typ: <nil>}
2025/12/19 11:10:24 Assign 1 1
2025/12/19 11:10:24 ==> MatchType unboundType{typ: <nil>}, unboundType{typ: <nil>}
2025/12/19 11:10:24 ForRange [i x]
2025/12/19 11:10:24 Val &{0 STRING "1"} *ast.BasicLit
2025/12/19 11:10:24.615674 [INFO] typesutil/gopinfo.go:215: ==> Type: &{48 STRING "1" <nil>} untyped string
2025/12/19 11:10:24 Val &{0 STRING "3"} *ast.BasicLit
2025/12/19 11:10:24.615708 [INFO] typesutil/gopinfo.go:215: ==> Type: &{53 STRING "3" <nil>} untyped string
2025/12/19 11:10:24 Val &{0 STRING "5"} *ast.BasicLit
2025/12/19 11:10:24.615732 [INFO] typesutil/gopinfo.go:215: ==> Type: &{58 STRING "5" <nil>} untyped string
2025/12/19 11:10:24 Val &{0 STRING "7"} *ast.BasicLit
2025/12/19 11:10:24.615766 [INFO] typesutil/gopinfo.go:215: ==> Type: &{63 STRING "7" <nil>} untyped string
2025/12/19 11:10:24 Val &{0 STRING "11"} *ast.BasicLit
2025/12/19 11:10:24.615794 [INFO] typesutil/gopinfo.go:215: ==> Type: &{68 STRING "11" <nil>} untyped string
2025/12/19 11:10:24 SliceLit <nil> 5 false
2025/12/19 11:10:24 RangeAssignThen
2025/12/19 11:10:24.615833 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/12/19 11:10:24.615851 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x string
2025/12/19 11:10:24.615875 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc0003a7140 {
.  var i int
.  var x string
}

2025/12/19 11:10:24 Val _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:10:24 Val x string
2025/12/19 11:10:24.615914 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x string
2025/12/19 11:10:24.615933 [INFO] typesutil/gopinfo.go:215: ==> Type: x string
2025/12/19 11:10:24 IndexRef 1
2025/12/19 11:10:24 Val i int
2025/12/19 11:10:24.615960 [INFO] typesutil/gopinfo.go:265: ==> Use: i var i int
2025/12/19 11:10:24.615971 [INFO] typesutil/gopinfo.go:215: ==> Type: i int
2025/12/19 11:10:24 Assign 1 1
2025/12/19 11:10:24 ==> MatchType int, unboundMapElemType{key: string}
2025/12/19 11:10:24 End // ForRange
2025/12/19 11:10:24 Return 0
2025/12/19 11:10:24 End // Func
2025/12/19 11:10:24 Call 0 0 // func() (_xgo_ret map[string]int)
2025/12/19 11:10:24 ==> MatchFuncCall func() (_xgo_ret map[string]int) args: 0 flags: 0
2025/12/19 11:10:24 EndInit 1
2025/12/19 11:10:24.616072 [INFO] typesutil/gopinfo.go:251: ==> Def: y var y map[string]int
2025/12/19 11:10:24 VarRef _
2025/12/19 11:10:24 Val y map[string]int
2025/12/19 11:10:24.616107 [INFO] typesutil/gopinfo.go:265: ==> Use: y var y map[string]int
2025/12/19 11:10:24.616120 [INFO] typesutil/gopinfo.go:215: ==> Type: y map[string]int
2025/12/19 11:10:24 Assign 1 1
2025/12/19 11:10:24.616146 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0003a6fc0 {
.  var y map[string]int
}

2025/12/19 11:10:24 End // Func
2025/12/19 11:10:24.616366 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:25 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:25 ==> NewOverloadFunc NewRange
2025/12/19 11:10:25 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:25 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:25 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:25 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:25 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:25 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:25 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:25 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:25 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:25 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:25 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:25 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:25 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:25 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:25 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:25 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:25 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:25 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:25 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:25 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:25 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:25 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:25 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:25 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:25 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:25 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:25 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:25 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:25 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:25 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:25 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:25 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:25 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:25 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:25 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:25 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:25 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:25 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:25 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:25 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:25 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:25 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:25.626905 [INFO] typesutil/gopinfo.go:332: ==> Scope: src.xgo scope 0xc0002f19e0 {
}

2025/12/19 11:10:25 ==> Preload func _
2025/12/19 11:10:25 ==> Load func _
2025/12/19 11:10:25.626979 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:25 NewFunc _ func()
2025/12/19 11:10:25 DefineVarStart [z]
2025/12/19 11:10:25 NewClosure func() (_xgo_ret unboundType{typ: <nil>})
2025/12/19 11:10:25 VarRef _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:10:25 ZeroLit // unboundType{typ: <nil>}
2025/12/19 11:10:25 Assign 1 1
2025/12/19 11:10:25 ==> MatchType unboundType{typ: <nil>}, unboundType{typ: <nil>}
2025/12/19 11:10:25 ForRange [k v]
2025/12/19 11:10:25 Val &{0 STRING "Hello"} *ast.BasicLit
2025/12/19 11:10:25.627131 [INFO] typesutil/gopinfo.go:215: ==> Type: &{48 STRING "Hello" <nil>} untyped string
2025/12/19 11:10:25 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:10:25.627171 [INFO] typesutil/gopinfo.go:215: ==> Type: &{57 INT 1 <nil>} untyped int
2025/12/19 11:10:25 Val &{0 STRING "Hi"} *ast.BasicLit
2025/12/19 11:10:25.627197 [INFO] typesutil/gopinfo.go:215: ==> Type: &{60 STRING "Hi" <nil>} untyped string
2025/12/19 11:10:25 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:10:25.627222 [INFO] typesutil/gopinfo.go:215: ==> Type: &{66 INT 3 <nil>} untyped int
2025/12/19 11:10:25 Val &{0 STRING "xsw"} *ast.BasicLit
2025/12/19 11:10:25.627249 [INFO] typesutil/gopinfo.go:215: ==> Type: &{69 STRING "xsw" <nil>} untyped string
2025/12/19 11:10:25 Val &{0 INT 5} *ast.BasicLit
2025/12/19 11:10:25.627274 [INFO] typesutil/gopinfo.go:215: ==> Type: &{76 INT 5 <nil>} untyped int
2025/12/19 11:10:25 Val &{0 STRING "XGo"} *ast.BasicLit
2025/12/19 11:10:25.627297 [INFO] typesutil/gopinfo.go:215: ==> Type: &{79 STRING "XGo" <nil>} untyped string
2025/12/19 11:10:25 Val &{0 INT 7} *ast.BasicLit
2025/12/19 11:10:25.627322 [INFO] typesutil/gopinfo.go:215: ==> Type: &{86 INT 7 <nil>} untyped int
2025/12/19 11:10:25 MapLit <nil> 8
2025/12/19 11:10:25.627350 [INFO] typesutil/gopinfo.go:215: ==> Type: <nil> <nil>
2025/12/19 11:10:25.627377 [INFO] typesutil/gopinfo.go:215: ==> Type: &{<nil> 47 [0xc000303830 0xc000303950 0xc000303a70 0xc000303bc0] 87 false} <nil>
2025/12/19 11:10:25 RangeAssignThen
2025/12/19 11:10:25.627406 [INFO] typesutil/gopinfo.go:251: ==> Def: k var k string
2025/12/19 11:10:25.627420 [INFO] typesutil/gopinfo.go:251: ==> Def: v var v int
2025/12/19 11:10:25.627446 [INFO] typesutil/gopinfo.go:332: ==> Scope: for range statement scope 0xc0002f1c20 {
.  var k string
.  var v int
}

2025/12/19 11:10:25 If
2025/12/19 11:10:25 Val v int
2025/12/19 11:10:25.627481 [INFO] typesutil/gopinfo.go:265: ==> Use: v var v int
2025/12/19 11:10:25.627496 [INFO] typesutil/gopinfo.go:215: ==> Type: v int
2025/12/19 11:10:25 Val &{0 INT 3} *ast.BasicLit
2025/12/19 11:10:25.627520 [INFO] typesutil/gopinfo.go:215: ==> Type: &{94 INT 3 <nil>} untyped int
2025/12/19 11:10:25 BinaryOp >
2025/12/19 11:10:25 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) untyped bool} args: 2 flags: 0
2025/12/19 11:10:25 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:25 ==> MatchType untyped int (3), unboundFuncParam{typ: int}
2025/12/19 11:10:25.627623 [INFO] typesutil/gopinfo.go:215: ==> Type: &{v 92 > 0xc000303bf0} untyped bool
2025/12/19 11:10:25 Then
2025/12/19 11:10:25 Val _xgo_ret unboundType{typ: <nil>}
2025/12/19 11:10:25 Val v int
2025/12/19 11:10:25.627668 [INFO] typesutil/gopinfo.go:265: ==> Use: v var v int
2025/12/19 11:10:25.627686 [INFO] typesutil/gopinfo.go:215: ==> Type: v int
2025/12/19 11:10:25 IndexRef 1
2025/12/19 11:10:25 Val k string
2025/12/19 11:10:25.627719 [INFO] typesutil/gopinfo.go:265: ==> Use: k var k string
2025/12/19 11:10:25.627731 [INFO] typesutil/gopinfo.go:215: ==> Type: k string
2025/12/19 11:10:25 Assign 1 1
2025/12/19 11:10:25 ==> MatchType string, unboundMapElemType{key: int}
2025/12/19 11:10:25 End // If
2025/12/19 11:10:25 End // ForRange
2025/12/19 11:10:25 Return 0
2025/12/19 11:10:25 End // Func
2025/12/19 11:10:25 Call 0 0 // func() (_xgo_ret map[int]string)
2025/12/19 11:10:25 ==> MatchFuncCall func() (_xgo_ret map[int]string) args: 0 flags: 0
2025/12/19 11:10:25 EndInit 1
2025/12/19 11:10:25.627848 [INFO] typesutil/gopinfo.go:251: ==> Def: z var z map[int]string
2025/12/19 11:10:25 VarRef _
2025/12/19 11:10:25 Val z map[int]string
2025/12/19 11:10:25.627879 [INFO] typesutil/gopinfo.go:265: ==> Use: z var z map[int]string
2025/12/19 11:10:25.627895 [INFO] typesutil/gopinfo.go:215: ==> Type: z map[int]string
2025/12/19 11:10:25 Assign 1 1
2025/12/19 11:10:25.627923 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0002f1aa0 {
.  var z map[int]string
}

2025/12/19 11:10:25 End // Func
--- PASS: TestScopesInfo (35.62s)
=== RUN   TestAddress
2025/12/19 11:10:25.628928 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:26 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:26 ==> NewOverloadFunc NewRange
2025/12/19 11:10:26 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:26 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:26 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:26 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:26 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:26 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:26 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:26 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:26 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:26 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:26 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:26 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:26 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:26 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:26 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:26 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:26 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:26 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:26 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:26 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:26 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:26 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:26 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:26 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:26 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:26 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:26 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:26 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:26 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:26 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:26 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:26 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:26 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:26 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:26 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:26 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:26 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:26 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:26 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:26 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:26 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:26 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:26.729713 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc000330720 {
}

2025/12/19 11:10:26 ==> Preload type foo
2025/12/19 11:10:26 ==> Preload method foo.ptr
2025/12/19 11:10:26 ==> Preload method foo.clone
2025/12/19 11:10:26 ==> Preload type nested
2025/12/19 11:10:26 ==> Preload func _
2025/12/19 11:10:26 ==> Load > NewType foo
2025/12/19 11:10:26 NewType foo
2025/12/19 11:10:26 ==> Load > InitType foo
2025/12/19 11:10:26.729850 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:26.729872 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:26.729887 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:26.729905 [INFO] typesutil/gopinfo.go:251: ==> Def: c field c int
2025/12/19 11:10:26.729920 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:26.729933 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:26.729945 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:26.729969 [INFO] typesutil/gopinfo.go:215: ==> Type: &{44 int} *int
2025/12/19 11:10:26.730002 [INFO] typesutil/gopinfo.go:251: ==> Def: p field p *int
2025/12/19 11:10:26.730027 [INFO] typesutil/gopinfo.go:215: ==> Type: &{27 0xc0002a4d20 false} struct{c int; p *int}
2025/12/19 11:10:26 InitType foo struct{c int; p *int}
2025/12/19 11:10:26.730067 [INFO] typesutil/gopinfo.go:251: ==> Def: foo type foo struct{c int; p *int}
2025/12/19 11:10:26 ==> LookupParent foo => type foo struct{c int; p *int}
2025/12/19 11:10:26.730103 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type foo struct{c int; p *int}
2025/12/19 11:10:26.730119 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/12/19 11:10:26.730132 [INFO] typesutil/gopinfo.go:251: ==> Def: f var f foo
2025/12/19 11:10:26 ==> Load method foo.ptr
2025/12/19 11:10:26 ==> LookupParent foo => type foo struct{c int; p *int}
2025/12/19 11:10:26.730165 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type foo struct{c int; p *int}
2025/12/19 11:10:26.730178 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/12/19 11:10:26.730191 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/12/19 11:10:26.730208 [INFO] typesutil/gopinfo.go:215: ==> Type: &{71 foo} *foo
2025/12/19 11:10:26.730231 [INFO] typesutil/gopinfo.go:251: ==> Def: ptr func (foo).ptr() *foo
2025/12/19 11:10:26 ==> LookupParent foo => type foo struct{c int; p *int}
2025/12/19 11:10:26.730255 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type foo struct{c int; p *int}
2025/12/19 11:10:26.730267 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/12/19 11:10:26.730280 [INFO] typesutil/gopinfo.go:251: ==> Def: f var f foo
2025/12/19 11:10:26 ==> Load method foo.clone
2025/12/19 11:10:26 ==> LookupParent foo => type foo struct{c int; p *int}
2025/12/19 11:10:26.730314 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type foo struct{c int; p *int}
2025/12/19 11:10:26.730330 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/12/19 11:10:26.730344 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/12/19 11:10:26.730361 [INFO] typesutil/gopinfo.go:251: ==> Def: clone func (foo).clone() foo
2025/12/19 11:10:26 ==> Load > NewType nested
2025/12/19 11:10:26 NewType nested
2025/12/19 11:10:26 ==> Load > InitType nested
2025/12/19 11:10:26 ==> LookupParent foo => type foo struct{c int; p *int}
2025/12/19 11:10:26.730405 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type foo struct{c int; p *int}
2025/12/19 11:10:26.730417 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/12/19 11:10:26.730429 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/12/19 11:10:26.730442 [INFO] typesutil/gopinfo.go:251: ==> Def: f field f foo
2025/12/19 11:10:26 ==> LookupParent foo => type foo struct{c int; p *int}
2025/12/19 11:10:26.730465 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type foo struct{c int; p *int}
2025/12/19 11:10:26.730479 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/12/19 11:10:26.730491 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/12/19 11:10:26 Val &{0 INT 2} *ast.BasicLit
2025/12/19 11:10:26.730530 [INFO] typesutil/gopinfo.go:215: ==> Type: &{161 INT 2 <nil>} untyped int
2025/12/19 11:10:26.730559 [INFO] typesutil/gopinfo.go:215: ==> Type: &{160 0xc0002a5020 foo} [2]foo
2025/12/19 11:10:26.730576 [INFO] typesutil/gopinfo.go:251: ==> Def: a field a [2]foo
2025/12/19 11:10:26 ==> LookupParent foo => type foo struct{c int; p *int}
2025/12/19 11:10:26.730602 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type foo struct{c int; p *int}
2025/12/19 11:10:26.730622 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/12/19 11:10:26.730638 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/12/19 11:10:26.730659 [INFO] typesutil/gopinfo.go:215: ==> Type: &{170 <nil> foo} []foo
2025/12/19 11:10:26.730673 [INFO] typesutil/gopinfo.go:251: ==> Def: s field s []foo
2025/12/19 11:10:26.730686 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:26.730697 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:26.730708 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:26 ==> LookupParent foo => type foo struct{c int; p *int}
2025/12/19 11:10:26.730730 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type foo struct{c int; p *int}
2025/12/19 11:10:26.730743 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/12/19 11:10:26.730755 [INFO] typesutil/gopinfo.go:215: ==> Type: foo foo
2025/12/19 11:10:26.730774 [INFO] typesutil/gopinfo.go:215: ==> Type: &{179 int foo} map[int]foo
2025/12/19 11:10:26.730789 [INFO] typesutil/gopinfo.go:251: ==> Def: m field m map[int]foo
2025/12/19 11:10:26.730815 [INFO] typesutil/gopinfo.go:215: ==> Type: &{141 0xc0002a5110 false} struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/12/19 11:10:26 InitType nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/12/19 11:10:26.730854 [INFO] typesutil/gopinfo.go:251: ==> Def: nested type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/12/19 11:10:26 ==> Load func _
2025/12/19 11:10:26.730876 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:26 NewFunc _ func()
2025/12/19 11:10:26 DefineVarStart [getNested]
2025/12/19 11:10:26 ==> LookupParent nested => type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/12/19 11:10:26.730934 [INFO] typesutil/gopinfo.go:265: ==> Use: nested type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/12/19 11:10:26.730947 [INFO] typesutil/gopinfo.go:215: ==> Type: nested nested
2025/12/19 11:10:26.730959 [INFO] typesutil/gopinfo.go:215: ==> Type: nested nested
2025/12/19 11:10:26.730980 [INFO] typesutil/gopinfo.go:215: ==> Type: &{219 <nil> 0xc0002a5200 0xc0002a5230} func() nested
2025/12/19 11:10:26.731009 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0000fc340 0xc0002a52f0} func() nested
2025/12/19 11:10:26 NewClosure func() nested
2025/12/19 11:10:26 ==> LookupParent nested => type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/12/19 11:10:26.731051 [INFO] typesutil/gopinfo.go:265: ==> Use: nested type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/12/19 11:10:26.731064 [INFO] typesutil/gopinfo.go:215: ==> Type: nested nested
2025/12/19 11:10:26.731075 [INFO] typesutil/gopinfo.go:215: ==> Type: nested nested
2025/12/19 11:10:26 StructLit nested 0 false
2025/12/19 11:10:26.731097 [INFO] typesutil/gopinfo.go:215: ==> Type: nested nested
2025/12/19 11:10:26.731116 [INFO] typesutil/gopinfo.go:215: ==> Type: &{nested 248 [] 249 false} nested
2025/12/19 11:10:26 Return 1
2025/12/19 11:10:26 ==> MatchType nested, nested
2025/12/19 11:10:26 ==> EnsureLoaded nested
2025/12/19 11:10:26 ==> EnsureLoaded nested
2025/12/19 11:10:26.731166 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc000330e40 {
}

2025/12/19 11:10:26 End // Func
2025/12/19 11:10:26 EndInit 1
2025/12/19 11:10:26.731205 [INFO] typesutil/gopinfo.go:251: ==> Def: getNested var getNested func() nested
2025/12/19 11:10:26 DefineVarStart [getNestedPtr]
2025/12/19 11:10:26 ==> LookupParent nested => type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/12/19 11:10:26.731255 [INFO] typesutil/gopinfo.go:265: ==> Use: nested type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/12/19 11:10:26.731271 [INFO] typesutil/gopinfo.go:215: ==> Type: nested nested
2025/12/19 11:10:26.731284 [INFO] typesutil/gopinfo.go:215: ==> Type: nested nested
2025/12/19 11:10:26.731301 [INFO] typesutil/gopinfo.go:215: ==> Type: &{277 nested} *nested
2025/12/19 11:10:26.731326 [INFO] typesutil/gopinfo.go:215: ==> Type: &{270 <nil> 0xc0002a5350 0xc0002a5380} func() *nested
2025/12/19 11:10:26.731347 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0000fc440 0xc0002a53e0} func() *nested
2025/12/19 11:10:26 NewClosure func() *nested
2025/12/19 11:10:26 ==> LookupParent nested => type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/12/19 11:10:26.731398 [INFO] typesutil/gopinfo.go:265: ==> Use: nested type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
2025/12/19 11:10:26.731426 [INFO] typesutil/gopinfo.go:215: ==> Type: nested nested
2025/12/19 11:10:26.731440 [INFO] typesutil/gopinfo.go:215: ==> Type: nested nested
2025/12/19 11:10:26 StructLit nested 0 false
2025/12/19 11:10:26.731463 [INFO] typesutil/gopinfo.go:215: ==> Type: nested nested
2025/12/19 11:10:26.731480 [INFO] typesutil/gopinfo.go:215: ==> Type: &{nested 301 [] 302 false} nested
2025/12/19 11:10:26 UnaryOp & flags: 0
2025/12/19 11:10:26 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:10:26.731522 [INFO] typesutil/gopinfo.go:215: ==> Type: &{294 & 0xc000340880} *nested
2025/12/19 11:10:26 Return 1
2025/12/19 11:10:26 ==> MatchType *nested, *nested
2025/12/19 11:10:26 ==> EnsureLoaded nested
2025/12/19 11:10:26 ==> EnsureLoaded nested
2025/12/19 11:10:26.731571 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc000330fc0 {
}

2025/12/19 11:10:26 End // Func
2025/12/19 11:10:26 EndInit 1
2025/12/19 11:10:26.731604 [INFO] typesutil/gopinfo.go:251: ==> Def: getNestedPtr var getNestedPtr func() *nested
2025/12/19 11:10:26 VarRef _
2025/12/19 11:10:26 Val getNested func() nested
2025/12/19 11:10:26.731636 [INFO] typesutil/gopinfo.go:265: ==> Use: getNested var getNested func() nested
2025/12/19 11:10:26.731650 [INFO] typesutil/gopinfo.go:215: ==> Type: getNested func() nested
2025/12/19 11:10:26 Call 0 0 // func() nested
2025/12/19 11:10:26 ==> MatchFuncCall func() nested args: 0 flags: 0
2025/12/19 11:10:26.731692 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNested 321 [] 0 [] 322 0} nested
2025/12/19 11:10:26 Member f 2 // nested
2025/12/19 11:10:26.731720 [INFO] typesutil/gopinfo.go:265: ==> Use: f field f foo
2025/12/19 11:10:26.731748 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003540c0 f} foo
2025/12/19 11:10:26 Member c 2 // foo
2025/12/19 11:10:26.731773 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/12/19 11:10:26.731788 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000300540 c} int
2025/12/19 11:10:26 Assign 1 1
2025/12/19 11:10:26 VarRef _
2025/12/19 11:10:26 Val getNested func() nested
2025/12/19 11:10:26.731822 [INFO] typesutil/gopinfo.go:265: ==> Use: getNested var getNested func() nested
2025/12/19 11:10:26.731835 [INFO] typesutil/gopinfo.go:215: ==> Type: getNested func() nested
2025/12/19 11:10:26 Call 0 0 // func() nested
2025/12/19 11:10:26 ==> MatchFuncCall func() nested args: 0 flags: 0
2025/12/19 11:10:26.731870 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNested 342 [] 0 [] 343 0} nested
2025/12/19 11:10:26 Member a 2 // nested
2025/12/19 11:10:26.731893 [INFO] typesutil/gopinfo.go:265: ==> Use: a field a [2]foo
2025/12/19 11:10:26.731908 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000354120 a} [2]foo
2025/12/19 11:10:26 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:10:26.731936 [INFO] typesutil/gopinfo.go:215: ==> Type: &{347 INT 0 <nil>} untyped int
2025/12/19 11:10:26 Index 1 false
2025/12/19 11:10:26.731961 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000300570 346 0xc0002a5410 348} foo
2025/12/19 11:10:26 Member c 2 // foo
2025/12/19 11:10:26.731985 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/12/19 11:10:26.731999 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002a5440 c} int
2025/12/19 11:10:26 Assign 1 1
2025/12/19 11:10:26 VarRef _
2025/12/19 11:10:26 Val getNested func() nested
2025/12/19 11:10:26.732032 [INFO] typesutil/gopinfo.go:265: ==> Use: getNested var getNested func() nested
2025/12/19 11:10:26.732046 [INFO] typesutil/gopinfo.go:215: ==> Type: getNested func() nested
2025/12/19 11:10:26 Call 0 0 // func() nested
2025/12/19 11:10:26 ==> MatchFuncCall func() nested args: 0 flags: 0
2025/12/19 11:10:26.732079 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNested 366 [] 0 [] 367 0} nested
2025/12/19 11:10:26 Member s 2 // nested
2025/12/19 11:10:26.732101 [INFO] typesutil/gopinfo.go:265: ==> Use: s field s []foo
2025/12/19 11:10:26.732115 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000354180 s} []foo
2025/12/19 11:10:26 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:10:26.732141 [INFO] typesutil/gopinfo.go:215: ==> Type: &{371 INT 0 <nil>} untyped int
2025/12/19 11:10:26 Index 1 false
2025/12/19 11:10:26.732163 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003005a0 370 0xc0002a5470 372} foo
2025/12/19 11:10:26 Member c 2 // foo
2025/12/19 11:10:26.732184 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/12/19 11:10:26.732197 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002a54a0 c} int
2025/12/19 11:10:26 Assign 1 1
2025/12/19 11:10:26 VarRef _
2025/12/19 11:10:26 Val getNested func() nested
2025/12/19 11:10:26.732233 [INFO] typesutil/gopinfo.go:265: ==> Use: getNested var getNested func() nested
2025/12/19 11:10:26.732246 [INFO] typesutil/gopinfo.go:215: ==> Type: getNested func() nested
2025/12/19 11:10:26 Call 0 0 // func() nested
2025/12/19 11:10:26 ==> MatchFuncCall func() nested args: 0 flags: 0
2025/12/19 11:10:26.732278 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNested 390 [] 0 [] 391 0} nested
2025/12/19 11:10:26 Member m 2 // nested
2025/12/19 11:10:26.732303 [INFO] typesutil/gopinfo.go:265: ==> Use: m field m map[int]foo
2025/12/19 11:10:26.732317 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003541e0 m} map[int]foo
2025/12/19 11:10:26 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:10:26.732342 [INFO] typesutil/gopinfo.go:215: ==> Type: &{395 INT 0 <nil>} untyped int
2025/12/19 11:10:26 Index 1 false
2025/12/19 11:10:26.732364 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003005d0 394 0xc0002a54d0 396} foo
2025/12/19 11:10:26 Member c 2 // foo
2025/12/19 11:10:26.732386 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/12/19 11:10:26.732413 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002a5500 c} int
2025/12/19 11:10:26 Assign 1 1
2025/12/19 11:10:26 VarRef _
2025/12/19 11:10:26 Val getNested func() nested
2025/12/19 11:10:26.732455 [INFO] typesutil/gopinfo.go:265: ==> Use: getNested var getNested func() nested
2025/12/19 11:10:26.732471 [INFO] typesutil/gopinfo.go:215: ==> Type: getNested func() nested
2025/12/19 11:10:26 Call 0 0 // func() nested
2025/12/19 11:10:26 ==> MatchFuncCall func() nested args: 0 flags: 0
2025/12/19 11:10:26.732508 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNested 414 [] 0 [] 415 0} nested
2025/12/19 11:10:26 Member f 2 // nested
2025/12/19 11:10:26.732534 [INFO] typesutil/gopinfo.go:265: ==> Use: f field f foo
2025/12/19 11:10:26.732549 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000354240 f} foo
2025/12/19 11:10:26 Member ptr 1 // foo
2025/12/19 11:10:26.732578 [INFO] typesutil/gopinfo.go:265: ==> Use: ptr func (foo).ptr() *foo
2025/12/19 11:10:26.732594 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000300600 ptr} func() *foo
2025/12/19 11:10:26 Call 0 0 // func() *foo
2025/12/19 11:10:26 ==> MatchFuncCall func() *foo args: 0 flags: 0
2025/12/19 11:10:26.732635 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000300618 422 [] 0 [] 423 0} *foo
2025/12/19 11:10:26 Member c 2 // *foo
2025/12/19 11:10:26.732671 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/12/19 11:10:26.732685 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003542a0 c} int
2025/12/19 11:10:26 Assign 1 1
2025/12/19 11:10:26 VarRef _
2025/12/19 11:10:26 Val getNested func() nested
2025/12/19 11:10:26.732718 [INFO] typesutil/gopinfo.go:265: ==> Use: getNested var getNested func() nested
2025/12/19 11:10:26.732731 [INFO] typesutil/gopinfo.go:215: ==> Type: getNested func() nested
2025/12/19 11:10:26 Call 0 0 // func() nested
2025/12/19 11:10:26 ==> MatchFuncCall func() nested args: 0 flags: 0
2025/12/19 11:10:26.732766 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNested 441 [] 0 [] 442 0} nested
2025/12/19 11:10:26 Member f 2 // nested
2025/12/19 11:10:26.732789 [INFO] typesutil/gopinfo.go:265: ==> Use: f field f foo
2025/12/19 11:10:26.732803 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000354300 f} foo
2025/12/19 11:10:26 Member clone 1 // foo
2025/12/19 11:10:26.732829 [INFO] typesutil/gopinfo.go:265: ==> Use: clone func (foo).clone() foo
2025/12/19 11:10:26.732845 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000300648 clone} func() foo
2025/12/19 11:10:26 Call 0 0 // func() foo
2025/12/19 11:10:26 ==> MatchFuncCall func() foo args: 0 flags: 0
2025/12/19 11:10:26.732877 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000300660 451 [] 0 [] 452 0} foo
2025/12/19 11:10:26 Member c 2 // foo
2025/12/19 11:10:26.732901 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/12/19 11:10:26.732917 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000354360 c} int
2025/12/19 11:10:26 Assign 1 1
2025/12/19 11:10:26 VarRef _
2025/12/19 11:10:26 Val getNested func() nested
2025/12/19 11:10:26.732951 [INFO] typesutil/gopinfo.go:265: ==> Use: getNested var getNested func() nested
2025/12/19 11:10:26.732963 [INFO] typesutil/gopinfo.go:215: ==> Type: getNested func() nested
2025/12/19 11:10:26 Call 0 0 // func() nested
2025/12/19 11:10:26 ==> MatchFuncCall func() nested args: 0 flags: 0
2025/12/19 11:10:26.732998 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNested 470 [] 0 [] 471 0} nested
2025/12/19 11:10:26 Member f 2 // nested
2025/12/19 11:10:26.733020 [INFO] typesutil/gopinfo.go:265: ==> Use: f field f foo
2025/12/19 11:10:26.733033 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003543c0 f} foo
2025/12/19 11:10:26 Member clone 1 // foo
2025/12/19 11:10:26.733056 [INFO] typesutil/gopinfo.go:265: ==> Use: clone func (foo).clone() foo
2025/12/19 11:10:26.733071 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000300690 clone} func() foo
2025/12/19 11:10:26 Call 0 0 // func() foo
2025/12/19 11:10:26 ==> MatchFuncCall func() foo args: 0 flags: 0
2025/12/19 11:10:26.733124 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003006a8 480 [] 0 [] 481 0} foo
2025/12/19 11:10:26 Member ptr 1 // foo
2025/12/19 11:10:26.733153 [INFO] typesutil/gopinfo.go:265: ==> Use: ptr func (foo).ptr() *foo
2025/12/19 11:10:26.733168 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000354420 ptr} func() *foo
2025/12/19 11:10:26 Call 0 0 // func() *foo
2025/12/19 11:10:26 ==> MatchFuncCall func() *foo args: 0 flags: 0
2025/12/19 11:10:26.733205 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003006c0 486 [] 0 [] 487 0} *foo
2025/12/19 11:10:26 Member c 2 // *foo
2025/12/19 11:10:26.733230 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/12/19 11:10:26.733244 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000354480 c} int
2025/12/19 11:10:26 Assign 1 1
2025/12/19 11:10:26 VarRef _
2025/12/19 11:10:26 Val getNestedPtr func() *nested
2025/12/19 11:10:26.733282 [INFO] typesutil/gopinfo.go:265: ==> Use: getNestedPtr var getNestedPtr func() *nested
2025/12/19 11:10:26.733295 [INFO] typesutil/gopinfo.go:215: ==> Type: getNestedPtr func() *nested
2025/12/19 11:10:26 Call 0 0 // func() *nested
2025/12/19 11:10:26 ==> MatchFuncCall func() *nested args: 0 flags: 0
2025/12/19 11:10:26.733332 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNestedPtr 509 [] 0 [] 510 0} *nested
2025/12/19 11:10:26 Member f 2 // *nested
2025/12/19 11:10:26.733355 [INFO] typesutil/gopinfo.go:265: ==> Use: f field f foo
2025/12/19 11:10:26.733368 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003544e0 f} foo
2025/12/19 11:10:26 Member c 2 // foo
2025/12/19 11:10:26.733391 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/12/19 11:10:26.733404 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003006f0 c} int
2025/12/19 11:10:26 Assign 1 1
2025/12/19 11:10:26 VarRef _
2025/12/19 11:10:26 Val getNestedPtr func() *nested
2025/12/19 11:10:26.733440 [INFO] typesutil/gopinfo.go:265: ==> Use: getNestedPtr var getNestedPtr func() *nested
2025/12/19 11:10:26.733452 [INFO] typesutil/gopinfo.go:215: ==> Type: getNestedPtr func() *nested
2025/12/19 11:10:26 Call 0 0 // func() *nested
2025/12/19 11:10:26 ==> MatchFuncCall func() *nested args: 0 flags: 0
2025/12/19 11:10:26.733486 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNestedPtr 533 [] 0 [] 534 0} *nested
2025/12/19 11:10:26 Member a 2 // *nested
2025/12/19 11:10:26.733512 [INFO] typesutil/gopinfo.go:265: ==> Use: a field a [2]foo
2025/12/19 11:10:26.733527 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000354540 a} [2]foo
2025/12/19 11:10:26 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:10:26.733565 [INFO] typesutil/gopinfo.go:215: ==> Type: &{538 INT 0 <nil>} untyped int
2025/12/19 11:10:26 Index 1 false
2025/12/19 11:10:26.733576 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000300720 537 0xc0002a5530 539} foo
2025/12/19 11:10:26 Member c 2 // foo
2025/12/19 11:10:26.733589 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/12/19 11:10:26.733596 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002a5560 c} int
2025/12/19 11:10:26 Assign 1 1
2025/12/19 11:10:26 VarRef _
2025/12/19 11:10:26 Val getNestedPtr func() *nested
2025/12/19 11:10:26.733614 [INFO] typesutil/gopinfo.go:265: ==> Use: getNestedPtr var getNestedPtr func() *nested
2025/12/19 11:10:26.733620 [INFO] typesutil/gopinfo.go:215: ==> Type: getNestedPtr func() *nested
2025/12/19 11:10:26 Call 0 0 // func() *nested
2025/12/19 11:10:26 ==> MatchFuncCall func() *nested args: 0 flags: 0
2025/12/19 11:10:26.733639 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNestedPtr 560 [] 0 [] 561 0} *nested
2025/12/19 11:10:26 Member s 2 // *nested
2025/12/19 11:10:26.733651 [INFO] typesutil/gopinfo.go:265: ==> Use: s field s []foo
2025/12/19 11:10:26.733658 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003545a0 s} []foo
2025/12/19 11:10:26 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:10:26.733670 [INFO] typesutil/gopinfo.go:215: ==> Type: &{565 INT 0 <nil>} untyped int
2025/12/19 11:10:26 Index 1 false
2025/12/19 11:10:26.733680 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000300750 564 0xc0002a5590 566} foo
2025/12/19 11:10:26 Member c 2 // foo
2025/12/19 11:10:26.733690 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/12/19 11:10:26.733695 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002a55c0 c} int
2025/12/19 11:10:26 Assign 1 1
2025/12/19 11:10:26 VarRef _
2025/12/19 11:10:26 Val getNestedPtr func() *nested
2025/12/19 11:10:26.733713 [INFO] typesutil/gopinfo.go:265: ==> Use: getNestedPtr var getNestedPtr func() *nested
2025/12/19 11:10:26.733719 [INFO] typesutil/gopinfo.go:215: ==> Type: getNestedPtr func() *nested
2025/12/19 11:10:26 Call 0 0 // func() *nested
2025/12/19 11:10:26 ==> MatchFuncCall func() *nested args: 0 flags: 0
2025/12/19 11:10:26.733735 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNestedPtr 587 [] 0 [] 588 0} *nested
2025/12/19 11:10:26 Member m 2 // *nested
2025/12/19 11:10:26.733746 [INFO] typesutil/gopinfo.go:265: ==> Use: m field m map[int]foo
2025/12/19 11:10:26.733752 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000354600 m} map[int]foo
2025/12/19 11:10:26 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:10:26.733765 [INFO] typesutil/gopinfo.go:215: ==> Type: &{592 INT 0 <nil>} untyped int
2025/12/19 11:10:26 Index 1 false
2025/12/19 11:10:26.733776 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000300780 591 0xc0002a55f0 593} foo
2025/12/19 11:10:26 Member c 2 // foo
2025/12/19 11:10:26.733787 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/12/19 11:10:26.733794 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0002a5620 c} int
2025/12/19 11:10:26 Assign 1 1
2025/12/19 11:10:26 VarRef _
2025/12/19 11:10:26 Val getNestedPtr func() *nested
2025/12/19 11:10:26.733810 [INFO] typesutil/gopinfo.go:265: ==> Use: getNestedPtr var getNestedPtr func() *nested
2025/12/19 11:10:26.733821 [INFO] typesutil/gopinfo.go:215: ==> Type: getNestedPtr func() *nested
2025/12/19 11:10:26 Call 0 0 // func() *nested
2025/12/19 11:10:26 ==> MatchFuncCall func() *nested args: 0 flags: 0
2025/12/19 11:10:26.733835 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNestedPtr 614 [] 0 [] 615 0} *nested
2025/12/19 11:10:26 Member f 2 // *nested
2025/12/19 11:10:26.733846 [INFO] typesutil/gopinfo.go:265: ==> Use: f field f foo
2025/12/19 11:10:26.733853 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000354660 f} foo
2025/12/19 11:10:26 Member ptr 1 // foo
2025/12/19 11:10:26.733863 [INFO] typesutil/gopinfo.go:265: ==> Use: ptr func (foo).ptr() *foo
2025/12/19 11:10:26.733871 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003007b0 ptr} func() *foo
2025/12/19 11:10:26 Call 0 0 // func() *foo
2025/12/19 11:10:26 ==> MatchFuncCall func() *foo args: 0 flags: 0
2025/12/19 11:10:26.733888 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003007c8 622 [] 0 [] 623 0} *foo
2025/12/19 11:10:26 Member c 2 // *foo
2025/12/19 11:10:26.733899 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/12/19 11:10:26.733906 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003546c0 c} int
2025/12/19 11:10:26 Assign 1 1
2025/12/19 11:10:26 VarRef _
2025/12/19 11:10:26 Val getNestedPtr func() *nested
2025/12/19 11:10:26.733923 [INFO] typesutil/gopinfo.go:265: ==> Use: getNestedPtr var getNestedPtr func() *nested
2025/12/19 11:10:26.733929 [INFO] typesutil/gopinfo.go:215: ==> Type: getNestedPtr func() *nested
2025/12/19 11:10:26 Call 0 0 // func() *nested
2025/12/19 11:10:26 ==> MatchFuncCall func() *nested args: 0 flags: 0
2025/12/19 11:10:26.733945 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNestedPtr 644 [] 0 [] 645 0} *nested
2025/12/19 11:10:26 Member f 2 // *nested
2025/12/19 11:10:26.733955 [INFO] typesutil/gopinfo.go:265: ==> Use: f field f foo
2025/12/19 11:10:26.733960 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000354720 f} foo
2025/12/19 11:10:26 Member clone 1 // foo
2025/12/19 11:10:26.733972 [INFO] typesutil/gopinfo.go:265: ==> Use: clone func (foo).clone() foo
2025/12/19 11:10:26.733989 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003007f8 clone} func() foo
2025/12/19 11:10:26 Call 0 0 // func() foo
2025/12/19 11:10:26 ==> MatchFuncCall func() foo args: 0 flags: 0
2025/12/19 11:10:26.734015 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000300810 654 [] 0 [] 655 0} foo
2025/12/19 11:10:26 Member c 2 // foo
2025/12/19 11:10:26.734027 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/12/19 11:10:26.734034 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000354780 c} int
2025/12/19 11:10:26 Assign 1 1
2025/12/19 11:10:26 VarRef _
2025/12/19 11:10:26 Val getNestedPtr func() *nested
2025/12/19 11:10:26.734051 [INFO] typesutil/gopinfo.go:265: ==> Use: getNestedPtr var getNestedPtr func() *nested
2025/12/19 11:10:26.734059 [INFO] typesutil/gopinfo.go:215: ==> Type: getNestedPtr func() *nested
2025/12/19 11:10:26 Call 0 0 // func() *nested
2025/12/19 11:10:26 ==> MatchFuncCall func() *nested args: 0 flags: 0
2025/12/19 11:10:26.734076 [INFO] typesutil/gopinfo.go:215: ==> Type: &{getNestedPtr 676 [] 0 [] 677 0} *nested
2025/12/19 11:10:26 Member f 2 // *nested
2025/12/19 11:10:26.734087 [INFO] typesutil/gopinfo.go:265: ==> Use: f field f foo
2025/12/19 11:10:26.734094 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003547e0 f} foo
2025/12/19 11:10:26 Member clone 1 // foo
2025/12/19 11:10:26.734106 [INFO] typesutil/gopinfo.go:265: ==> Use: clone func (foo).clone() foo
2025/12/19 11:10:26.734113 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000300840 clone} func() foo
2025/12/19 11:10:26 Call 0 0 // func() foo
2025/12/19 11:10:26 ==> MatchFuncCall func() foo args: 0 flags: 0
2025/12/19 11:10:26.734130 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000300858 686 [] 0 [] 687 0} foo
2025/12/19 11:10:26 Member ptr 1 // foo
2025/12/19 11:10:26.734142 [INFO] typesutil/gopinfo.go:265: ==> Use: ptr func (foo).ptr() *foo
2025/12/19 11:10:26.734151 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000354840 ptr} func() *foo
2025/12/19 11:10:26 Call 0 0 // func() *foo
2025/12/19 11:10:26 ==> MatchFuncCall func() *foo args: 0 flags: 0
2025/12/19 11:10:26.734168 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000300870 692 [] 0 [] 693 0} *foo
2025/12/19 11:10:26 Member c 2 // *foo
2025/12/19 11:10:26.734180 [INFO] typesutil/gopinfo.go:265: ==> Use: c field c int
2025/12/19 11:10:26.734187 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0003548a0 c} int
2025/12/19 11:10:26 Assign 1 1
2025/12/19 11:10:26.734205 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000330d20 {
.  var getNested func() nested
.  var getNestedPtr func() *nested
}

2025/12/19 11:10:26 End // Func
2025/12/19 11:10:26 NewFunc ptr (foo) func() *foo
2025/12/19 11:10:26 Val f foo
2025/12/19 11:10:26.734228 [INFO] typesutil/gopinfo.go:265: ==> Use: f var f foo
2025/12/19 11:10:26.734236 [INFO] typesutil/gopinfo.go:215: ==> Type: f foo
2025/12/19 11:10:26 UnaryOp & flags: 0
2025/12/19 11:10:26 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:10:26.734254 [INFO] typesutil/gopinfo.go:215: ==> Type: &{85 & f} *foo
2025/12/19 11:10:26 Return 1
2025/12/19 11:10:26 ==> MatchType *foo, *foo
2025/12/19 11:10:26.734271 [INFO] typesutil/gopinfo.go:332: ==> Scope: func ptr scope 0xc0003318c0 {
.  var f foo
}

2025/12/19 11:10:26 End // Func
2025/12/19 11:10:26 NewFunc clone (foo) func() foo
2025/12/19 11:10:26 Val f foo
2025/12/19 11:10:26.734294 [INFO] typesutil/gopinfo.go:265: ==> Use: f var f foo
2025/12/19 11:10:26.734300 [INFO] typesutil/gopinfo.go:215: ==> Type: f foo
2025/12/19 11:10:26 Return 1
2025/12/19 11:10:26 ==> MatchType foo, foo
2025/12/19 11:10:26.734315 [INFO] typesutil/gopinfo.go:332: ==> Scope: func clone scope 0xc000331920 {
.  var f foo
}

2025/12/19 11:10:26 End // Func
    info_test.go:226: ====== check types pass (count: 118) ======
        000:  3:10 | struct {
        	c int
        	p *int
        } *ast.StructType                | type    : struct{c int; p *int} | type
        001:  3:20 | int                 *ast.Ident                     | type    : int | type
        002:  3:27 | *int                *ast.StarExpr                  | type    : *int | type
        003:  3:28 | int                 *ast.Ident                     | type    : int | type
        004:  5: 9 | foo                 *ast.Ident                     | type    : foo | type
        005:  5:20 | *foo                *ast.StarExpr                  | type    : *foo | type
        006:  5:21 | foo                 *ast.Ident                     | type    : foo | type
        007:  5:34 | &f                  *ast.UnaryExpr                 | value   : *foo | value
        008:  5:35 | f                   *ast.Ident                     | var     : foo | variable
        009:  6: 9 | foo                 *ast.Ident                     | type    : foo | type
        010:  6:22 | foo                 *ast.Ident                     | type    : foo | type
        011:  6:35 | f                   *ast.Ident                     | var     : foo | variable
        012:  8:13 | struct {
        	f foo
        	a [2]foo
        	s []foo
        	m map[int]foo
        } *ast.StructType                | type    : struct{f foo; a [2]foo; s []foo; m map[int]foo} | type
        013:  9: 4 | foo                 *ast.Ident                     | type    : foo | type
        014: 10: 4 | [2]foo              *ast.ArrayType                 | type    : [2]foo | type
        015: 10: 5 | 2                   *ast.BasicLit                  | value   : INT = 2 | constant
        016: 10: 7 | foo                 *ast.Ident                     | type    : foo | type
        017: 11: 4 | []foo               *ast.ArrayType                 | type    : []foo | type
        018: 11: 6 | foo                 *ast.Ident                     | type    : foo | type
        019: 12: 4 | map[int]foo         *ast.MapType                   | type    : map[int]foo | type
        020: 12: 8 | int                 *ast.Ident                     | type    : int | type
        021: 12:12 | foo                 *ast.Ident                     | type    : foo | type
        022: 16:15 | func() nested       *ast.FuncType                  | type    : func() nested | type
        023: 16:15 | func() nested { return nested{} } *ast.FuncLit                   | value   : func() nested | value
        024: 16:22 | nested              *ast.Ident                     | type    : nested | type
        025: 16:38 | nested              *ast.Ident                     | type    : nested | type
        026: 16:38 | nested{}            *ast.CompositeLit              | value   : nested | value
        027: 17:18 | func() *nested      *ast.FuncType                  | type    : func() *nested | type
        028: 17:18 | func() *nested { return &nested{} } *ast.FuncLit                   | value   : func() *nested | value
        029: 17:25 | *nested             *ast.StarExpr                  | type    : *nested | type
        030: 17:26 | nested              *ast.Ident                     | type    : nested | type
        031: 17:42 | &nested{}           *ast.UnaryExpr                 | value   : *nested | value
        032: 17:43 | nested              *ast.Ident                     | type    : nested | type
        033: 17:43 | nested{}            *ast.CompositeLit              | value   : nested | value
        034: 19: 6 | getNested           *ast.Ident                     | var     : func() nested | variable
        035: 19: 6 | getNested()         *ast.CallExpr                  | value   : nested | value
        036: 19: 6 | getNested().f       *ast.SelectorExpr              | value   : foo | value
        037: 19: 6 | getNested().f.c     *ast.SelectorExpr              | value   : int | value
        038: 20: 6 | getNested           *ast.Ident                     | var     : func() nested | variable
        039: 20: 6 | getNested()         *ast.CallExpr                  | value   : nested | value
        040: 20: 6 | getNested().a       *ast.SelectorExpr              | value   : [2]foo | value
        041: 20: 6 | getNested().a[0]    *ast.IndexExpr                 | value   : foo | value
        042: 20: 6 | getNested().a[0].c  *ast.SelectorExpr              | value   : int | value
        043: 20:20 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        044: 21: 6 | getNested           *ast.Ident                     | var     : func() nested | variable
        045: 21: 6 | getNested()         *ast.CallExpr                  | value   : nested | value
        046: 21: 6 | getNested().s       *ast.SelectorExpr              | value   : []foo | value
        047: 21: 6 | getNested().s[0]    *ast.IndexExpr                 | var     : foo | variable
        048: 21: 6 | getNested().s[0].c  *ast.SelectorExpr              | var     : int | variable
        049: 21:20 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        050: 22: 6 | getNested           *ast.Ident                     | var     : func() nested | variable
        051: 22: 6 | getNested()         *ast.CallExpr                  | value   : nested | value
        052: 22: 6 | getNested().m       *ast.SelectorExpr              | value   : map[int]foo | value
        053: 22: 6 | getNested().m[0]    *ast.IndexExpr                 | mapindex : foo | map index expression
        054: 22: 6 | getNested().m[0].c  *ast.SelectorExpr              | value   : int | value
        055: 22:20 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        056: 23: 6 | getNested           *ast.Ident                     | var     : func() nested | variable
        057: 23: 6 | getNested()         *ast.CallExpr                  | value   : nested | value
        058: 23: 6 | getNested().f       *ast.SelectorExpr              | value   : foo | value
        059: 23: 6 | getNested().f.ptr   *ast.SelectorExpr              | value   : func() *foo | value
        060: 23: 6 | getNested().f.ptr() *ast.CallExpr                  | value   : *foo | value
        061: 23: 6 | getNested().f.ptr().c *ast.SelectorExpr              | var     : int | variable
        062: 24: 6 | getNested           *ast.Ident                     | var     : func() nested | variable
        063: 24: 6 | getNested()         *ast.CallExpr                  | value   : nested | value
        064: 24: 6 | getNested().f       *ast.SelectorExpr              | value   : foo | value
        065: 24: 6 | getNested().f.clone *ast.SelectorExpr              | value   : func() foo | value
        066: 24: 6 | getNested().f.clone() *ast.CallExpr                  | value   : foo | value
        067: 24: 6 | getNested().f.clone().c *ast.SelectorExpr              | value   : int | value
        068: 25: 6 | getNested           *ast.Ident                     | var     : func() nested | variable
        069: 25: 6 | getNested()         *ast.CallExpr                  | value   : nested | value
        070: 25: 6 | getNested().f       *ast.SelectorExpr              | value   : foo | value
        071: 25: 6 | getNested().f.clone *ast.SelectorExpr              | value   : func() foo | value
        072: 25: 6 | getNested().f.clone() *ast.CallExpr                  | value   : foo | value
        073: 25: 6 | getNested().f.clone().ptr *ast.SelectorExpr              | value   : func() *foo | value
        074: 25: 6 | getNested().f.clone().ptr() *ast.CallExpr                  | value   : *foo | value
        075: 25: 6 | getNested().f.clone().ptr().c *ast.SelectorExpr              | var     : int | variable
        076: 27: 6 | getNestedPtr        *ast.Ident                     | var     : func() *nested | variable
        077: 27: 6 | getNestedPtr()      *ast.CallExpr                  | value   : *nested | value
        078: 27: 6 | getNestedPtr().f    *ast.SelectorExpr              | var     : foo | variable
        079: 27: 6 | getNestedPtr().f.c  *ast.SelectorExpr              | var     : int | variable
        080: 28: 6 | getNestedPtr        *ast.Ident                     | var     : func() *nested | variable
        081: 28: 6 | getNestedPtr()      *ast.CallExpr                  | value   : *nested | value
        082: 28: 6 | getNestedPtr().a    *ast.SelectorExpr              | var     : [2]foo | variable
        083: 28: 6 | getNestedPtr().a[0] *ast.IndexExpr                 | var     : foo | variable
        084: 28: 6 | getNestedPtr().a[0].c *ast.SelectorExpr              | var     : int | variable
        085: 28:23 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        086: 29: 6 | getNestedPtr        *ast.Ident                     | var     : func() *nested | variable
        087: 29: 6 | getNestedPtr()      *ast.CallExpr                  | value   : *nested | value
        088: 29: 6 | getNestedPtr().s    *ast.SelectorExpr              | var     : []foo | variable
        089: 29: 6 | getNestedPtr().s[0] *ast.IndexExpr                 | var     : foo | variable
        090: 29: 6 | getNestedPtr().s[0].c *ast.SelectorExpr              | var     : int | variable
        091: 29:23 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        092: 30: 6 | getNestedPtr        *ast.Ident                     | var     : func() *nested | variable
        093: 30: 6 | getNestedPtr()      *ast.CallExpr                  | value   : *nested | value
        094: 30: 6 | getNestedPtr().m    *ast.SelectorExpr              | var     : map[int]foo | variable
        095: 30: 6 | getNestedPtr().m[0] *ast.IndexExpr                 | mapindex : foo | map index expression
        096: 30: 6 | getNestedPtr().m[0].c *ast.SelectorExpr              | value   : int | value
        097: 30:23 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        098: 31: 6 | getNestedPtr        *ast.Ident                     | var     : func() *nested | variable
        099: 31: 6 | getNestedPtr()      *ast.CallExpr                  | value   : *nested | value
        100: 31: 6 | getNestedPtr().f    *ast.SelectorExpr              | var     : foo | variable
        101: 31: 6 | getNestedPtr().f.ptr *ast.SelectorExpr              | value   : func() *foo | value
        102: 31: 6 | getNestedPtr().f.ptr() *ast.CallExpr                  | value   : *foo | value
        103: 31: 6 | getNestedPtr().f.ptr().c *ast.SelectorExpr              | var     : int | variable
        104: 32: 6 | getNestedPtr        *ast.Ident                     | var     : func() *nested | variable
        105: 32: 6 | getNestedPtr()      *ast.CallExpr                  | value   : *nested | value
        106: 32: 6 | getNestedPtr().f    *ast.SelectorExpr              | var     : foo | variable
        107: 32: 6 | getNestedPtr().f.clone *ast.SelectorExpr              | value   : func() foo | value
        108: 32: 6 | getNestedPtr().f.clone() *ast.CallExpr                  | value   : foo | value
        109: 32: 6 | getNestedPtr().f.clone().c *ast.SelectorExpr              | value   : int | value
        110: 33: 6 | getNestedPtr        *ast.Ident                     | var     : func() *nested | variable
        111: 33: 6 | getNestedPtr()      *ast.CallExpr                  | value   : *nested | value
        112: 33: 6 | getNestedPtr().f    *ast.SelectorExpr              | var     : foo | variable
        113: 33: 6 | getNestedPtr().f.clone *ast.SelectorExpr              | value   : func() foo | value
        114: 33: 6 | getNestedPtr().f.clone() *ast.CallExpr                  | value   : foo | value
        115: 33: 6 | getNestedPtr().f.clone().ptr *ast.SelectorExpr              | value   : func() *foo | value
        116: 33: 6 | getNestedPtr().f.clone().ptr() *ast.CallExpr                  | value   : *foo | value
        117: 33: 6 | getNestedPtr().f.clone().ptr().c *ast.SelectorExpr              | var     : int | variable
    info_test.go:226: ====== check defs pass (count: 15) ======
        000:  3: 6 | foo                 | type foo struct{c int; p *int}
        001:  3:18 | c                   | field c int
        002:  3:25 | p                   | field p *int
        003:  5: 7 | f                   | var f foo
        004:  5:14 | ptr                 | func (foo).ptr() *foo
        005:  6: 7 | f                   | var f foo
        006:  6:14 | clone               | func (foo).clone() foo
        007:  8: 6 | nested              | type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
        008:  9: 2 | f                   | field f foo
        009: 10: 2 | a                   | field a [2]foo
        010: 11: 2 | s                   | field s []foo
        011: 12: 2 | m                   | field m map[int]foo
        012: 15: 6 | _                   | func _()
        013: 16: 2 | getNested           | var getNested func() nested
        014: 17: 2 | getNestedPtr        | var getNestedPtr func() *nested
    info_test.go:226: ====== check uses pass (count: 67) ======
        000:  3:20 | int                 | type int
        001:  3:28 | int                 | type int
        002:  5: 9 | foo                 | type foo struct{c int; p *int}
        003:  5:21 | foo                 | type foo struct{c int; p *int}
        004:  5:35 | f                   | var f foo
        005:  6: 9 | foo                 | type foo struct{c int; p *int}
        006:  6:22 | foo                 | type foo struct{c int; p *int}
        007:  6:35 | f                   | var f foo
        008:  9: 4 | foo                 | type foo struct{c int; p *int}
        009: 10: 7 | foo                 | type foo struct{c int; p *int}
        010: 11: 6 | foo                 | type foo struct{c int; p *int}
        011: 12: 8 | int                 | type int
        012: 12:12 | foo                 | type foo struct{c int; p *int}
        013: 16:22 | nested              | type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
        014: 16:38 | nested              | type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
        015: 17:26 | nested              | type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
        016: 17:43 | nested              | type nested struct{f foo; a [2]foo; s []foo; m map[int]foo}
        017: 19: 6 | getNested           | var getNested func() nested
        018: 19:18 | f                   | field f foo
        019: 19:20 | c                   | field c int
        020: 20: 6 | getNested           | var getNested func() nested
        021: 20:18 | a                   | field a [2]foo
        022: 20:23 | c                   | field c int
        023: 21: 6 | getNested           | var getNested func() nested
        024: 21:18 | s                   | field s []foo
        025: 21:23 | c                   | field c int
        026: 22: 6 | getNested           | var getNested func() nested
        027: 22:18 | m                   | field m map[int]foo
        028: 22:23 | c                   | field c int
        029: 23: 6 | getNested           | var getNested func() nested
        030: 23:18 | f                   | field f foo
        031: 23:20 | ptr                 | func (foo).ptr() *foo
        032: 23:26 | c                   | field c int
        033: 24: 6 | getNested           | var getNested func() nested
        034: 24:18 | f                   | field f foo
        035: 24:20 | clone               | func (foo).clone() foo
        036: 24:28 | c                   | field c int
        037: 25: 6 | getNested           | var getNested func() nested
        038: 25:18 | f                   | field f foo
        039: 25:20 | clone               | func (foo).clone() foo
        040: 25:28 | ptr                 | func (foo).ptr() *foo
        041: 25:34 | c                   | field c int
        042: 27: 6 | getNestedPtr        | var getNestedPtr func() *nested
        043: 27:21 | f                   | field f foo
        044: 27:23 | c                   | field c int
        045: 28: 6 | getNestedPtr        | var getNestedPtr func() *nested
        046: 28:21 | a                   | field a [2]foo
        047: 28:26 | c                   | field c int
        048: 29: 6 | getNestedPtr        | var getNestedPtr func() *nested
        049: 29:21 | s                   | field s []foo
        050: 29:26 | c                   | field c int
        051: 30: 6 | getNestedPtr        | var getNestedPtr func() *nested
        052: 30:21 | m                   | field m map[int]foo
        053: 30:26 | c                   | field c int
        054: 31: 6 | getNestedPtr        | var getNestedPtr func() *nested
        055: 31:21 | f                   | field f foo
        056: 31:23 | ptr                 | func (foo).ptr() *foo
        057: 31:29 | c                   | field c int
        058: 32: 6 | getNestedPtr        | var getNestedPtr func() *nested
        059: 32:21 | f                   | field f foo
        060: 32:23 | clone               | func (foo).clone() foo
        061: 32:31 | c                   | field c int
        062: 33: 6 | getNestedPtr        | var getNestedPtr func() *nested
        063: 33:21 | f                   | field f foo
        064: 33:23 | clone               | func (foo).clone() foo
        065: 33:31 | ptr                 | func (foo).ptr() *foo
        066: 33:37 | c                   | field c int
--- PASS: TestAddress (1.11s)
=== RUN   TestAddress2
2025/12/19 11:10:26.737976 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:27 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:27 ==> NewOverloadFunc NewRange
2025/12/19 11:10:27 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:27 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:27 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:27 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:27 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:27 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:27 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:27 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:27 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:27 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:27 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:27 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:27 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:27 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:27 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:27 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:27 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:27 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:27 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:27 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:27 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:27 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:27 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:27 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:27 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:27 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:27 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:27 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:27 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:27 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:27 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:27 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:27 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:27 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:27 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:27 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:27 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:27 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:27 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:27 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:27 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:27 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:27.771196 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc00064b260 {
}

2025/12/19 11:10:27.771245 [INFO] typesutil/gopinfo.go:292: ==> Implicit: package os
2025/12/19 11:10:27 ==> Preload func _
2025/12/19 11:10:27 ==> Preload func _
2025/12/19 11:10:27 ==> Preload func _
2025/12/19 11:10:27 ==> Preload func _
2025/12/19 11:10:27 ==> Preload func _
2025/12/19 11:10:27 ==> Preload func _
2025/12/19 11:10:27 ==> Preload func _
2025/12/19 11:10:27 ==> Preload func _
2025/12/19 11:10:27 ==> Preload type T
2025/12/19 11:10:27 ==> Preload method T._
2025/12/19 11:10:27 ==> Preload func _
2025/12/19 11:10:27 ==> Preload func _
2025/12/19 11:10:27 ==> Preload func _
2025/12/19 11:10:27 ==> Preload func f
2025/12/19 11:10:27 ==> Preload func _
2025/12/19 11:10:27 ==> Preload func _
2025/12/19 11:10:27 ==> Load > NewType T
2025/12/19 11:10:27 NewType T
2025/12/19 11:10:27 ==> Load > InitType T
2025/12/19 11:10:27.771352 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:27.771367 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.771377 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27 InitType T int
2025/12/19 11:10:27.771395 [INFO] typesutil/gopinfo.go:251: ==> Def: T type T int
2025/12/19 11:10:27 ==> LookupParent T => type T int
2025/12/19 11:10:27.771409 [INFO] typesutil/gopinfo.go:265: ==> Use: T type T int
2025/12/19 11:10:27.771418 [INFO] typesutil/gopinfo.go:215: ==> Type: T T
2025/12/19 11:10:27.771428 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x T
2025/12/19 11:10:27 ==> Load method T._
2025/12/19 11:10:27.771449 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func (T)._()
2025/12/19 11:10:27 ==> Load func f
2025/12/19 11:10:27.771466 [INFO] typesutil/gopinfo.go:251: ==> Def: f func f()
2025/12/19 11:10:27 NewFunc f func()
2025/12/19 11:10:27 VarRef _
2025/12/19 11:10:27 Val f func()
2025/12/19 11:10:27.771497 [INFO] typesutil/gopinfo.go:265: ==> Use: f func f()
2025/12/19 11:10:27.771505 [INFO] typesutil/gopinfo.go:215: ==> Type: f func()
2025/12/19 11:10:27 Assign 1 1
2025/12/19 11:10:27.771520 [INFO] typesutil/gopinfo.go:332: ==> Scope: func f scope 0xc00064bd40 {
}

2025/12/19 11:10:27 End // Func
2025/12/19 11:10:27 ==> Load func _
2025/12/19 11:10:27.771541 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:27 NewFunc _ func()
2025/12/19 11:10:27 VarRef _
2025/12/19 11:10:27.771562 [INFO] typesutil/gopinfo.go:265: ==> Use: os package os
2025/12/19 11:10:27.771574 [INFO] typesutil/gopinfo.go:265: ==> Use: Stdout var os.Stdout *os.File
2025/12/19 11:10:27 Val Stdout *os.File
2025/12/19 11:10:27.771598 [INFO] typesutil/gopinfo.go:215: ==> Type: &{os Stdout} *os.File
2025/12/19 11:10:27 Assign 1 1
2025/12/19 11:10:27.771611 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000366240 {
}

2025/12/19 11:10:27 End // Func
2025/12/19 11:10:27 ==> Load func _
2025/12/19 11:10:27.771626 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:27 NewFunc _ func()
2025/12/19 11:10:27.771642 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:27.771649 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.771656 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27 ==> Load var int [a]
2025/12/19 11:10:27 NewVarDefs
2025/12/19 11:10:27 NewVar [a]
2025/12/19 11:10:27.771681 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a int
2025/12/19 11:10:27 VarRef _
2025/12/19 11:10:27 Val a int
2025/12/19 11:10:27.771698 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a int
2025/12/19 11:10:27.771705 [INFO] typesutil/gopinfo.go:215: ==> Type: a int
2025/12/19 11:10:27 Assign 1 1
2025/12/19 11:10:27.771719 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000366540 {
.  var a int
}

2025/12/19 11:10:27 End // Func
2025/12/19 11:10:27 ==> Load func _
2025/12/19 11:10:27.771735 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:27 NewFunc _ func()
2025/12/19 11:10:27.771753 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:27.771761 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.771769 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.771781 [INFO] typesutil/gopinfo.go:215: ==> Type: &{103 int} *int
2025/12/19 11:10:27 ==> Load var *int [p]
2025/12/19 11:10:27 NewVarDefs
2025/12/19 11:10:27 NewVar [p]
2025/12/19 11:10:27.771804 [INFO] typesutil/gopinfo.go:251: ==> Def: p var p *int
2025/12/19 11:10:27 VarRef _
2025/12/19 11:10:27 Val p *int
2025/12/19 11:10:27.771824 [INFO] typesutil/gopinfo.go:265: ==> Use: p var p *int
2025/12/19 11:10:27.771835 [INFO] typesutil/gopinfo.go:215: ==> Type: p *int
2025/12/19 11:10:27 Star
2025/12/19 11:10:27.771849 [INFO] typesutil/gopinfo.go:215: ==> Type: &{113 p} int
2025/12/19 11:10:27 Assign 1 1
2025/12/19 11:10:27.771865 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000366660 {
.  var p *int
}

2025/12/19 11:10:27 End // Func
2025/12/19 11:10:27 ==> Load func _
2025/12/19 11:10:27.771880 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:27 NewFunc _ func()
2025/12/19 11:10:27.771895 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:27.771903 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.771909 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.771921 [INFO] typesutil/gopinfo.go:215: ==> Type: &{136 <nil> int} []int
2025/12/19 11:10:27 ==> Load var []int [s]
2025/12/19 11:10:27 NewVarDefs
2025/12/19 11:10:27 NewVar [s]
2025/12/19 11:10:27.771943 [INFO] typesutil/gopinfo.go:251: ==> Def: s var s []int
2025/12/19 11:10:27 VarRef _
2025/12/19 11:10:27 Val s []int
2025/12/19 11:10:27.771959 [INFO] typesutil/gopinfo.go:265: ==> Use: s var s []int
2025/12/19 11:10:27.771967 [INFO] typesutil/gopinfo.go:215: ==> Type: s []int
2025/12/19 11:10:27 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:10:27.771992 [INFO] typesutil/gopinfo.go:215: ==> Type: &{149 INT 0 <nil>} untyped int
2025/12/19 11:10:27 Index 1 false
2025/12/19 11:10:27.772012 [INFO] typesutil/gopinfo.go:215: ==> Type: &{s 148 0xc0005d7dd0 150} int
2025/12/19 11:10:27 Assign 1 1
2025/12/19 11:10:27.772026 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000366780 {
.  var s []int
}

2025/12/19 11:10:27 End // Func
2025/12/19 11:10:27 ==> Load func _
2025/12/19 11:10:27.772042 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:27 NewFunc _ func()
2025/12/19 11:10:27.772056 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:27.772064 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.772071 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.772079 [INFO] typesutil/gopinfo.go:251: ==> Def: f field f int
2025/12/19 11:10:27.772095 [INFO] typesutil/gopinfo.go:215: ==> Type: &{172 0xc0005d7f20 false} struct{f int}
2025/12/19 11:10:27 ==> Load var struct{f int} [s]
2025/12/19 11:10:27 NewVarDefs
2025/12/19 11:10:27 NewVar [s]
2025/12/19 11:10:27.772120 [INFO] typesutil/gopinfo.go:251: ==> Def: s var s struct{f int}
2025/12/19 11:10:27 VarRef _
2025/12/19 11:10:27 Val s struct{f int}
2025/12/19 11:10:27.772140 [INFO] typesutil/gopinfo.go:265: ==> Use: s var s struct{f int}
2025/12/19 11:10:27.772148 [INFO] typesutil/gopinfo.go:215: ==> Type: s struct{f int}
2025/12/19 11:10:27 Member f 2 // struct{f int}
2025/12/19 11:10:27.772164 [INFO] typesutil/gopinfo.go:265: ==> Use: f field f int
2025/12/19 11:10:27.772175 [INFO] typesutil/gopinfo.go:215: ==> Type: &{s f} int
2025/12/19 11:10:27 Assign 1 1
2025/12/19 11:10:27.772190 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0003668a0 {
.  var s struct{f int}
}

2025/12/19 11:10:27 End // Func
2025/12/19 11:10:27 ==> Load func _
2025/12/19 11:10:27.772207 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:27 NewFunc _ func()
2025/12/19 11:10:27.772221 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:27.772228 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.772235 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27 Val &{0 INT 10} *ast.BasicLit
2025/12/19 11:10:27.772252 [INFO] typesutil/gopinfo.go:215: ==> Type: &{216 INT 10 <nil>} untyped int
2025/12/19 11:10:27.772265 [INFO] typesutil/gopinfo.go:215: ==> Type: &{215 0xc0006280c0 int} [10]int
2025/12/19 11:10:27 ==> Load var [10]int [a]
2025/12/19 11:10:27 NewVarDefs
2025/12/19 11:10:27 NewVar [a]
2025/12/19 11:10:27.772287 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a [10]int
2025/12/19 11:10:27 VarRef _
2025/12/19 11:10:27 Val a [10]int
2025/12/19 11:10:27.772305 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a [10]int
2025/12/19 11:10:27.772312 [INFO] typesutil/gopinfo.go:215: ==> Type: a [10]int
2025/12/19 11:10:27 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:10:27.772327 [INFO] typesutil/gopinfo.go:215: ==> Type: &{230 INT 0 <nil>} untyped int
2025/12/19 11:10:27 Index 1 false
2025/12/19 11:10:27.772341 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 229 0xc000628120 231} int
2025/12/19 11:10:27 Assign 1 1
2025/12/19 11:10:27.772356 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000366a20 {
.  var a [10]int
}

2025/12/19 11:10:27 End // Func
2025/12/19 11:10:27 ==> Load func _
2025/12/19 11:10:27.772372 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:27.772381 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.772387 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.772396 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:10:27.772405 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _(x int)
2025/12/19 11:10:27 NewFunc _ func(x int)
2025/12/19 11:10:27 VarRef _
2025/12/19 11:10:27 Val x int
2025/12/19 11:10:27.772426 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:10:27.772438 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:10:27 Assign 1 1
2025/12/19 11:10:27.772455 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000366ba0 {
.  var x int
}

2025/12/19 11:10:27 End // Func
2025/12/19 11:10:27 ==> Load func _
2025/12/19 11:10:27.772472 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:27.772482 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.772489 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.772498 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:10:27.772506 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _() (x int)
2025/12/19 11:10:27 NewFunc _ func() (x int)
2025/12/19 11:10:27 VarRef _
2025/12/19 11:10:27 Val x int
2025/12/19 11:10:27.772527 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:10:27.772534 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:10:27 Assign 1 1
2025/12/19 11:10:27 Return 0
2025/12/19 11:10:27.772551 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000366cc0 {
.  var x int
}

2025/12/19 11:10:27 End // Func
2025/12/19 11:10:27 ==> Load func _
2025/12/19 11:10:27.772566 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:27 NewFunc _ func()
2025/12/19 11:10:27.772581 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:27.772588 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.772595 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27 ==> Load var int [a b]
2025/12/19 11:10:27 NewVarDefs
2025/12/19 11:10:27 NewVar [a b]
2025/12/19 11:10:27.772617 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a int
2025/12/19 11:10:27.772624 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b int
2025/12/19 11:10:27 VarRef _
2025/12/19 11:10:27 Val a int
2025/12/19 11:10:27.772642 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a int
2025/12/19 11:10:27.772650 [INFO] typesutil/gopinfo.go:215: ==> Type: a int
2025/12/19 11:10:27 Val b int
2025/12/19 11:10:27.772660 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b int
2025/12/19 11:10:27.772667 [INFO] typesutil/gopinfo.go:215: ==> Type: b int
2025/12/19 11:10:27 BinaryOp +
2025/12/19 11:10:27 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:10:27 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:27 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:10:27.772728 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 365 + b} int
2025/12/19 11:10:27 Assign 1 1
2025/12/19 11:10:27.772745 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000366d80 {
.  var a int
.  var b int
}

2025/12/19 11:10:27 End // Func
2025/12/19 11:10:27 ==> Load func _
2025/12/19 11:10:27.772762 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:27 NewFunc _ func()
2025/12/19 11:10:27 VarRef _
2025/12/19 11:10:27.772780 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:27.772788 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.772795 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.772805 [INFO] typesutil/gopinfo.go:215: ==> Type: &{388 <nil> int} []int
2025/12/19 11:10:27 Val &{0 INT 1} *ast.BasicLit
2025/12/19 11:10:27.772822 [INFO] typesutil/gopinfo.go:215: ==> Type: &{394 INT 1 <nil>} untyped int
2025/12/19 11:10:27 SliceLit []int 1 false
2025/12/19 11:10:27.772843 [INFO] typesutil/gopinfo.go:215: ==> Type: &{388 <nil> int} []int
2025/12/19 11:10:27.772861 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0006286f0 393 [0xc000628720] 395 false} []int
2025/12/19 11:10:27 UnaryOp & flags: 0
2025/12/19 11:10:27 ==> MatchFuncCall TyInstruction{gogen.addrInstr} args: 1 flags: 0
2025/12/19 11:10:27.772887 [INFO] typesutil/gopinfo.go:215: ==> Type: &{387 & 0xc0003d5800} *[]int
2025/12/19 11:10:27 Assign 1 1
2025/12/19 11:10:27.772898 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000367020 {
}

2025/12/19 11:10:27 End // Func
2025/12/19 11:10:27 ==> Load func _
2025/12/19 11:10:27.772913 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:27 NewFunc _ func()
2025/12/19 11:10:27 VarRef _
2025/12/19 11:10:27.772935 [INFO] typesutil/gopinfo.go:215: ==> Type: &{415 <nil> 0xc000628870 <nil>} func()
2025/12/19 11:10:27.772947 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0005cb680 0xc000628900} func()
2025/12/19 11:10:27 NewClosure func()
2025/12/19 11:10:27.772962 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc0003671a0 {
}

2025/12/19 11:10:27 End // Func
2025/12/19 11:10:27 Assign 1 1
2025/12/19 11:10:27.772978 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0003670e0 {
}

2025/12/19 11:10:27 End // Func
2025/12/19 11:10:27 ==> Load func _
2025/12/19 11:10:27.772995 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:27 NewFunc _ func()
2025/12/19 11:10:27.773009 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:27.773017 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.773024 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.773030 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:27.773037 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.773043 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.773054 [INFO] typesutil/gopinfo.go:215: ==> Type: &{463 int int} map[int]int
2025/12/19 11:10:27 ==> Load var map[int]int [m]
2025/12/19 11:10:27 NewVarDefs
2025/12/19 11:10:27 NewVar [m]
2025/12/19 11:10:27.773093 [INFO] typesutil/gopinfo.go:251: ==> Def: m var m map[int]int
2025/12/19 11:10:27 VarRef _
2025/12/19 11:10:27 Val m map[int]int
2025/12/19 11:10:27.773116 [INFO] typesutil/gopinfo.go:265: ==> Use: m var m map[int]int
2025/12/19 11:10:27.773126 [INFO] typesutil/gopinfo.go:215: ==> Type: m map[int]int
2025/12/19 11:10:27 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:10:27.773143 [INFO] typesutil/gopinfo.go:215: ==> Type: &{482 INT 0 <nil>} untyped int
2025/12/19 11:10:27 Index 1 false
2025/12/19 11:10:27.773156 [INFO] typesutil/gopinfo.go:215: ==> Type: &{m 481 0xc000628b40 483} int
2025/12/19 11:10:27 Assign 1 1
2025/12/19 11:10:27 VarRef _
2025/12/19 11:10:27 VarRef _
2025/12/19 11:10:27 Val m map[int]int
2025/12/19 11:10:27.773182 [INFO] typesutil/gopinfo.go:265: ==> Use: m var m map[int]int
2025/12/19 11:10:27.773189 [INFO] typesutil/gopinfo.go:215: ==> Type: m map[int]int
2025/12/19 11:10:27 Val &{0 INT 0} *ast.BasicLit
2025/12/19 11:10:27.773203 [INFO] typesutil/gopinfo.go:215: ==> Type: &{495 INT 0 <nil>} untyped int
2025/12/19 11:10:27 Index 1 true
2025/12/19 11:10:27.773218 [INFO] typesutil/gopinfo.go:215: ==> Type: &{m 494 0xc000628ba0 496} (int, bool)
2025/12/19 11:10:27 Assign 2 1
2025/12/19 11:10:27.773235 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000367380 {
.  var m map[int]int
}

2025/12/19 11:10:27 End // Func
2025/12/19 11:10:27 ==> Load func _
2025/12/19 11:10:27.773251 [INFO] typesutil/gopinfo.go:251: ==> Def: _ func _()
2025/12/19 11:10:27 NewFunc _ func()
2025/12/19 11:10:27.773265 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:27.773273 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.773280 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:27.773292 [INFO] typesutil/gopinfo.go:215: ==> Type: &{519 0 3 int} chan int
2025/12/19 11:10:27 ==> Load var chan int [ch]
2025/12/19 11:10:27 NewVarDefs
2025/12/19 11:10:27 NewVar [ch]
2025/12/19 11:10:27.773314 [INFO] typesutil/gopinfo.go:251: ==> Def: ch var ch chan int
2025/12/19 11:10:27 VarRef _
2025/12/19 11:10:27 Val ch chan int
2025/12/19 11:10:27.773332 [INFO] typesutil/gopinfo.go:265: ==> Use: ch var ch chan int
2025/12/19 11:10:27.773341 [INFO] typesutil/gopinfo.go:215: ==> Type: ch chan int
2025/12/19 11:10:27 UnaryOp <- flags: 0
2025/12/19 11:10:27 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 0
2025/12/19 11:10:27.773367 [INFO] typesutil/gopinfo.go:215: ==> Type: &{533 <- ch} int
2025/12/19 11:10:27 Assign 1 1
2025/12/19 11:10:27 VarRef _
2025/12/19 11:10:27 VarRef _
2025/12/19 11:10:27 Val ch chan int
2025/12/19 11:10:27.773399 [INFO] typesutil/gopinfo.go:265: ==> Use: ch var ch chan int
2025/12/19 11:10:27.773409 [INFO] typesutil/gopinfo.go:215: ==> Type: ch chan int
2025/12/19 11:10:27 UnaryOp <- flags: 2
2025/12/19 11:10:27 ==> MatchFuncCall TyInstruction{gogen.recvInstr} args: 1 flags: 2
2025/12/19 11:10:27.773432 [INFO] typesutil/gopinfo.go:215: ==> Type: &{546 <- ch} (int, bool)
2025/12/19 11:10:27 Assign 2 1
2025/12/19 11:10:27.773448 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc000220060 {
.  var ch chan int
}

2025/12/19 11:10:27 End // Func
2025/12/19 11:10:27 NewFunc _ (T) func()
2025/12/19 11:10:27 VarRef _
2025/12/19 11:10:27 Val x T
2025/12/19 11:10:27.773480 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x T
2025/12/19 11:10:27.773488 [INFO] typesutil/gopinfo.go:215: ==> Type: x T
2025/12/19 11:10:27 Assign 1 1
2025/12/19 11:10:27.773503 [INFO] typesutil/gopinfo.go:332: ==> Scope: func _ scope 0xc0002201e0 {
.  var x T
}

2025/12/19 11:10:27 End // Func
    info_test.go:226: ====== check types pass (count: 56) ======
        000:  4:16 | os.Stdout           *ast.SelectorExpr              | var     : *os.File | variable
        001:  6: 8 | int                 *ast.Ident                     | type    : int | type
        002:  7: 6 | a                   *ast.Ident                     | var     : int | variable
        003: 10: 8 | *int                *ast.StarExpr                  | type    : *int | type
        004: 10: 9 | int                 *ast.Ident                     | type    : int | type
        005: 11: 6 | *p                  *ast.StarExpr                  | var     : int | variable
        006: 11: 7 | p                   *ast.Ident                     | var     : *int | variable
        007: 14: 8 | []int               *ast.ArrayType                 | type    : []int | type
        008: 14:10 | int                 *ast.Ident                     | type    : int | type
        009: 15: 6 | s                   *ast.Ident                     | var     : []int | variable
        010: 15: 6 | s[0]                *ast.IndexExpr                 | var     : int | variable
        011: 15: 8 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        012: 18: 8 | struct{ f int }     *ast.StructType                | type    : struct{f int} | type
        013: 18:17 | int                 *ast.Ident                     | type    : int | type
        014: 19: 6 | s                   *ast.Ident                     | var     : struct{f int} | variable
        015: 19: 6 | s.f                 *ast.SelectorExpr              | var     : int | variable
        016: 22: 8 | [10]int             *ast.ArrayType                 | type    : [10]int | type
        017: 22: 9 | 10                  *ast.BasicLit                  | value   : INT = 10 | constant
        018: 22:12 | int                 *ast.Ident                     | type    : int | type
        019: 23: 6 | a                   *ast.Ident                     | var     : [10]int | variable
        020: 23: 6 | a[0]                *ast.IndexExpr                 | var     : int | variable
        021: 23: 8 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        022: 25:10 | int                 *ast.Ident                     | type    : int | type
        023: 26: 6 | x                   *ast.Ident                     | var     : int | variable
        024: 28:12 | int                 *ast.Ident                     | type    : int | type
        025: 29: 6 | x                   *ast.Ident                     | var     : int | variable
        026: 32: 8 | int                 *ast.Ident                     | type    : int | type
        027: 33: 9 | T                   *ast.Ident                     | type    : T | type
        028: 34: 6 | x                   *ast.Ident                     | var     : T | variable
        029: 38:11 | int                 *ast.Ident                     | type    : int | type
        030: 39: 6 | a                   *ast.Ident                     | var     : int | variable
        031: 39: 6 | a + b               *ast.BinaryExpr                | value   : int | value
        032: 39:10 | b                   *ast.Ident                     | var     : int | variable
        033: 42: 6 | &[]int{1}           *ast.UnaryExpr                 | value   : *[]int | value
        034: 42: 7 | []int               *ast.ArrayType                 | type    : []int | type
        035: 42: 7 | []int{1}            *ast.CompositeLit              | value   : []int | value
        036: 42: 9 | int                 *ast.Ident                     | type    : int | type
        037: 42:13 | 1                   *ast.BasicLit                  | value   : INT = 1 | constant
        038: 45: 6 | func()              *ast.FuncType                  | type    : func() | type
        039: 45: 6 | func() {}           *ast.FuncLit                   | value   : func() | value
        040: 47:16 | f                   *ast.Ident                     | value   : func() | value
        041: 49: 8 | map[int]int         *ast.MapType                   | type    : map[int]int | type
        042: 49:12 | int                 *ast.Ident                     | type    : int | type
        043: 49:16 | int                 *ast.Ident                     | type    : int | type
        044: 50: 6 | m                   *ast.Ident                     | var     : map[int]int | variable
        045: 50: 6 | m[0]                *ast.IndexExpr                 | mapindex : int | map index expression
        046: 50: 8 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        047: 51: 9 | m                   *ast.Ident                     | var     : map[int]int | variable
        048: 51: 9 | m[0]                *ast.IndexExpr                 | mapindex : (int, bool) | map index expression
        049: 51:11 | 0                   *ast.BasicLit                  | value   : INT = 0 | constant
        050: 54: 9 | chan int            *ast.ChanType                  | type    : chan int | type
        051: 54:14 | int                 *ast.Ident                     | type    : int | type
        052: 55: 6 | <-ch                *ast.UnaryExpr                 | value   : int | comma, ok expression
        053: 55: 8 | ch                  *ast.Ident                     | var     : chan int | variable
        054: 56: 9 | <-ch                *ast.UnaryExpr                 | value   : (int, bool) | comma, ok expression
        055: 56:11 | ch                  *ast.Ident                     | var     : chan int | variable
    info_test.go:226: ====== check defs pass (count: 29) ======
        000:  4: 6 | _                   | func _()
        001:  5: 6 | _                   | func _()
        002:  6: 6 | a                   | var a int
        003:  9: 6 | _                   | func _()
        004: 10: 6 | p                   | var p *int
        005: 13: 6 | _                   | func _()
        006: 14: 6 | s                   | var s []int
        007: 17: 6 | _                   | func _()
        008: 18: 6 | s                   | var s struct{f int}
        009: 18:15 | f                   | field f int
        010: 21: 6 | _                   | func _()
        011: 22: 6 | a                   | var a [10]int
        012: 25: 6 | _                   | func _(x int)
        013: 25: 8 | x                   | var x int
        014: 28: 6 | _                   | func _() (x int)
        015: 28:10 | x                   | var x int
        016: 32: 6 | T                   | type T int
        017: 33: 7 | x                   | var x T
        018: 33:12 | _                   | func (T)._()
        019: 37: 6 | _                   | func _()
        020: 38: 6 | a                   | var a int
        021: 38: 9 | b                   | var b int
        022: 41: 6 | _                   | func _()
        023: 44: 6 | _                   | func _()
        024: 47: 6 | f                   | func f()
        025: 48: 6 | _                   | func _()
        026: 49: 6 | m                   | var m map[int]int
        027: 53: 6 | _                   | func _()
        028: 54: 6 | ch                  | var ch chan int
    info_test.go:226: ====== check uses pass (count: 32) ======
        000:  4:16 | os                  | package os
        001:  4:19 | Stdout              | var os.Stdout *os.File
        002:  6: 8 | int                 | type int
        003:  7: 6 | a                   | var a int
        004: 10: 9 | int                 | type int
        005: 11: 7 | p                   | var p *int
        006: 14:10 | int                 | type int
        007: 15: 6 | s                   | var s []int
        008: 18:17 | int                 | type int
        009: 19: 6 | s                   | var s struct{f int}
        010: 19: 8 | f                   | field f int
        011: 22:12 | int                 | type int
        012: 23: 6 | a                   | var a [10]int
        013: 25:10 | int                 | type int
        014: 26: 6 | x                   | var x int
        015: 28:12 | int                 | type int
        016: 29: 6 | x                   | var x int
        017: 32: 8 | int                 | type int
        018: 33: 9 | T                   | type T int
        019: 34: 6 | x                   | var x T
        020: 38:11 | int                 | type int
        021: 39: 6 | a                   | var a int
        022: 39:10 | b                   | var b int
        023: 42: 9 | int                 | type int
        024: 47:16 | f                   | func f()
        025: 49:12 | int                 | type int
        026: 49:16 | int                 | type int
        027: 50: 6 | m                   | var m map[int]int
        028: 51: 9 | m                   | var m map[int]int
        029: 54:14 | int                 | type int
        030: 55: 8 | ch                  | var ch chan int
        031: 56:11 | ch                  | var ch chan int
--- PASS: TestAddress2 (1.04s)
=== RUN   TestMixedPackage
2025/12/19 11:10:27.778957 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 1
2025/12/19 11:10:28 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:28 ==> NewOverloadFunc NewRange
2025/12/19 11:10:28 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:28 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:28 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:28 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:28 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:28 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:28 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:28 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:28 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:28 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:28 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:28 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:28 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:28 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:28 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:28 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:28 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:28 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:28 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:28 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:28 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:28 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:28 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:28 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:28 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:28 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:28 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:28 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:28 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:28 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:28 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:28 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:28 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:28 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:28 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:28 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:28 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:28 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:28 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:28 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:28 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:28 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:28.861718 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc000288d20 {
}

2025/12/19 11:10:28 ==> Preload func main
2025/12/19 11:10:28 ==> Preload func Test__0
2025/12/19 11:10:28 ==> Preload func Test__1
2025/12/19 11:10:28 ==> Preload type N
2025/12/19 11:10:28 ==> Preload method N.Test__0
2025/12/19 11:10:28 ==> Preload method N.Test__1
2025/12/19 11:10:28 ==> Load > NewType N
2025/12/19 11:10:28 ==> Load > InitType N
2025/12/19 11:10:28 ==> LookupParent N => type main.N struct{}
2025/12/19 11:10:28 ==> Load method *main.N.Test__0
2025/12/19 11:10:28 ==> LookupParent N => type main.N struct{}
2025/12/19 11:10:28 ==> Load method *main.N.Test__1
2025/12/19 11:10:28 ==> Load func Test__0
2025/12/19 11:10:28 ==> Load func Test__1
2025/12/19 11:10:28 ==> NewOverloadMethod N Test
2025/12/19 11:10:28 ==> NewOverloadFunc Test
2025/12/19 11:10:28 ==> Load func main
2025/12/19 11:10:28.862021 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:10:28 NewFunc main func()
2025/12/19 11:10:28 Val Test func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:28.862090 [INFO] typesutil/gopinfo.go:265: ==> Use: Test func main.Test(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:28.862104 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Test TyOverloadFunc
2025/12/19 11:10:28.862120 [INFO] typesutil/gopinfo.go:215: ==> Type: Test func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:28 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:28 ==> MatchFuncCall TyOverloadFunc args: 0 flags: 0
2025/12/19 11:10:28 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:10:28.862165 [INFO] typesutil/gopinfo.go:265: ==> Use: Test func main.Test__0()
2025/12/19 11:10:28.862185 [INFO] typesutil/gopinfo.go:215: ==> Type: Test func()
2025/12/19 11:10:28 Val Test func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:28.862212 [INFO] typesutil/gopinfo.go:265: ==> Use: Test func main.Test(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:28.862223 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Test TyOverloadFunc
2025/12/19 11:10:28.862236 [INFO] typesutil/gopinfo.go:215: ==> Type: Test func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:28 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:10:28.862285 [INFO] typesutil/gopinfo.go:215: ==> Type: &{12 INT 100 <nil>} untyped int
2025/12/19 11:10:28 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:28 ==> MatchFuncCall TyOverloadFunc args: 1 flags: 0
2025/12/19 11:10:28 ==> MatchFuncCall func() args: 1 flags: 0
2025/12/19 11:10:28 ==> MatchFuncCall func(n int) args: 1 flags: 0
2025/12/19 11:10:28 ==> MatchType untyped int (100), int
2025/12/19 11:10:28.862381 [INFO] typesutil/gopinfo.go:265: ==> Use: Test func main.Test__1(n int)
2025/12/19 11:10:28.862395 [INFO] typesutil/gopinfo.go:215: ==> Type: Test func(n int)
2025/12/19 11:10:28.862421 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Test 0 [0xc0002cbe60] 0 [] 0 15} ()
2025/12/19 11:10:28 ==> LookupParent N => type main.N struct{}
2025/12/19 11:10:28.862456 [INFO] typesutil/gopinfo.go:265: ==> Use: N type main.N struct{}
2025/12/19 11:10:28.862469 [INFO] typesutil/gopinfo.go:215: ==> Type: N main.N
2025/12/19 11:10:28.862487 [INFO] typesutil/gopinfo.go:215: ==> Type: N main.N
2025/12/19 11:10:28 ==> Load var main.N [n]
2025/12/19 11:10:28 NewVarDefs
2025/12/19 11:10:28 NewVar [n]
2025/12/19 11:10:28.862530 [INFO] typesutil/gopinfo.go:251: ==> Def: n var n main.N
2025/12/19 11:10:28 Val n main.N
2025/12/19 11:10:28.862563 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n main.N
2025/12/19 11:10:28.862577 [INFO] typesutil/gopinfo.go:215: ==> Type: n main.N
2025/12/19 11:10:28 Member test 1 // main.N
2025/12/19 11:10:28.862608 [INFO] typesutil/gopinfo.go:265: ==> Use: test func (main.N).Test(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:28.862620 [INFO] typesutil/gopinfo.go:274: ==> Overloads: test TyOverloadMethod
2025/12/19 11:10:28.862637 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n test} func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:28 Call 0 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:28 ==> MatchFuncCall TyOverloadMethod args: 0 flags: 0
2025/12/19 11:10:28 ==> MatchFuncCall func() args: 0 flags: 0
2025/12/19 11:10:28.862677 [INFO] typesutil/gopinfo.go:265: ==> Use: test func (*main.N).Test__0()
2025/12/19 11:10:28.862701 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n test} func()
2025/12/19 11:10:28 Val n main.N
2025/12/19 11:10:28.862725 [INFO] typesutil/gopinfo.go:265: ==> Use: n var n main.N
2025/12/19 11:10:28.862738 [INFO] typesutil/gopinfo.go:215: ==> Type: n main.N
2025/12/19 11:10:28 Member test 1 // main.N
2025/12/19 11:10:28.862764 [INFO] typesutil/gopinfo.go:265: ==> Use: test func (main.N).Test(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:28.862774 [INFO] typesutil/gopinfo.go:274: ==> Overloads: test TyOverloadMethod
2025/12/19 11:10:28.862795 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n test} func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:28 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:10:28.862835 [INFO] typesutil/gopinfo.go:215: ==> Type: &{38 INT 100 <nil>} untyped int
2025/12/19 11:10:28 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:28 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/12/19 11:10:28 ==> MatchFuncCall func() args: 1 flags: 0
2025/12/19 11:10:28 ==> MatchFuncCall func(n int) args: 1 flags: 0
2025/12/19 11:10:28 ==> MatchType untyped int (100), int
2025/12/19 11:10:28.862920 [INFO] typesutil/gopinfo.go:265: ==> Use: test func (*main.N).Test__1(n int)
2025/12/19 11:10:28.862937 [INFO] typesutil/gopinfo.go:215: ==> Type: &{n test} func(n int)
2025/12/19 11:10:28.862958 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00059f8a8 0 [0xc0002cbe90] 0 [] 0 41} ()
2025/12/19 11:10:28.862988 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc000289440 {
.  var n main.N
}

2025/12/19 11:10:28 End // Func
2025/12/19 11:10:28 ==> NewOverloadFunc Test
2025/12/19 11:10:28 ==> NewOverloadMethod N Test
--- PASS: TestMixedPackage (1.08s)
=== RUN   TestGopOverloadUses
2025/12/19 11:10:28.864128 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:10:29 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:29 ==> NewOverloadFunc NewRange
2025/12/19 11:10:29 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:29 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:29 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:29 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:29 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:29 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:29 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:29 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:29 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:29 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:29 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:29 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:29 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:29 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:29 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:29 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:29 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:29 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:29 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:29 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:29 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:29 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:29 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:29 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:29 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:29 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:29 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:29 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:29 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:29 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:29 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:29 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:29 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:29 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:29 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:29 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:29 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:29 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:29 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:29 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:29 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:29 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:29.992733 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0005084e0 {
}

2025/12/19 11:10:29 ==> Preload func MulInt
2025/12/19 11:10:29 ==> Preload func MulFloat
2025/12/19 11:10:29 ==> Preload func Mul__2
2025/12/19 11:10:29 NewConstDefs
2025/12/19 11:10:29 ==> Preload const [Gopo_Mul]
2025/12/19 11:10:29 ==> Preload func main
2025/12/19 11:10:29 ==> Load func MulInt
2025/12/19 11:10:29.992873 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:29.992895 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:29.992909 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:29.992924 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a int
2025/12/19 11:10:29.992937 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b int
2025/12/19 11:10:29.992949 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:29.992960 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:29.992971 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:29.992993 [INFO] typesutil/gopinfo.go:251: ==> Def: MulInt func main.MulInt(a int, b int) int
2025/12/19 11:10:29 NewFunc MulInt func(a int, b int) int
2025/12/19 11:10:29 Val a int
2025/12/19 11:10:29.993045 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a int
2025/12/19 11:10:29.993057 [INFO] typesutil/gopinfo.go:215: ==> Type: a int
2025/12/19 11:10:29 Val b int
2025/12/19 11:10:29.993107 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b int
2025/12/19 11:10:29.993125 [INFO] typesutil/gopinfo.go:215: ==> Type: b int
2025/12/19 11:10:29 BinaryOp *
2025/12/19 11:10:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:10:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:29 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:10:29.993225 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 40 * b} int
2025/12/19 11:10:29 Return 1
2025/12/19 11:10:29 ==> MatchType int, int
2025/12/19 11:10:29.993271 [INFO] typesutil/gopinfo.go:332: ==> Scope: func MulInt scope 0xc000508900 {
.  var a int
.  var b int
}

2025/12/19 11:10:29 End // Func
2025/12/19 11:10:29 ==> Load func MulFloat
2025/12/19 11:10:29.993310 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/12/19 11:10:29.993322 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:10:29.993332 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:10:29.993345 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a float64
2025/12/19 11:10:29.993357 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b float64
2025/12/19 11:10:29.993369 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/12/19 11:10:29.993380 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:10:29.993392 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:10:29.993410 [INFO] typesutil/gopinfo.go:251: ==> Def: MulFloat func main.MulFloat(a float64, b float64) float64
2025/12/19 11:10:29 NewFunc MulFloat func(a float64, b float64) float64
2025/12/19 11:10:29 Val a float64
2025/12/19 11:10:29.993443 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a float64
2025/12/19 11:10:29.993453 [INFO] typesutil/gopinfo.go:215: ==> Type: a float64
2025/12/19 11:10:29 Val b float64
2025/12/19 11:10:29.993469 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b float64
2025/12/19 11:10:29.993483 [INFO] typesutil/gopinfo.go:215: ==> Type: b float64
2025/12/19 11:10:29 BinaryOp *
2025/12/19 11:10:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:10:29 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:29 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:10:29.993544 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 95 * b} float64
2025/12/19 11:10:29 Return 1
2025/12/19 11:10:29 ==> MatchType float64, float64
2025/12/19 11:10:29.993576 [INFO] typesutil/gopinfo.go:332: ==> Scope: func MulFloat scope 0xc000508c00 {
.  var a float64
.  var b float64
}

2025/12/19 11:10:29 End // Func
2025/12/19 11:10:29 ==> Load func Mul__2
2025/12/19 11:10:29.993606 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:29.993623 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:29.993634 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:29.993646 [INFO] typesutil/gopinfo.go:251: ==> Def: x var x int
2025/12/19 11:10:29.993657 [INFO] typesutil/gopinfo.go:251: ==> Def: y var y int
2025/12/19 11:10:29.993668 [INFO] typesutil/gopinfo.go:251: ==> Def: z var z int
2025/12/19 11:10:29.993683 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:29.993694 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:29.993705 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:29.993723 [INFO] typesutil/gopinfo.go:251: ==> Def: Mul__2 func main.Mul__2(x int, y int, z int) int
2025/12/19 11:10:29 NewFunc Mul__2 func(x int, y int, z int) int
2025/12/19 11:10:29 Val x int
2025/12/19 11:10:29.993760 [INFO] typesutil/gopinfo.go:265: ==> Use: x var x int
2025/12/19 11:10:29.993772 [INFO] typesutil/gopinfo.go:215: ==> Type: x int
2025/12/19 11:10:29 Val y int
2025/12/19 11:10:29.993790 [INFO] typesutil/gopinfo.go:265: ==> Use: y var y int
2025/12/19 11:10:29.993806 [INFO] typesutil/gopinfo.go:215: ==> Type: y int
2025/12/19 11:10:29 BinaryOp *
2025/12/19 11:10:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:10:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:29 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:10:29.993865 [INFO] typesutil/gopinfo.go:215: ==> Type: &{x 169 * y} int
2025/12/19 11:10:29 Val z int
2025/12/19 11:10:29.993891 [INFO] typesutil/gopinfo.go:265: ==> Use: z var z int
2025/12/19 11:10:29.993903 [INFO] typesutil/gopinfo.go:215: ==> Type: z int
2025/12/19 11:10:29 BinaryOp *
2025/12/19 11:10:29 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:10:29 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:29 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:10:29.993959 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc00020d920 173 * z} int
2025/12/19 11:10:29 Return 1
2025/12/19 11:10:29 ==> MatchType int, int
2025/12/19 11:10:29.994005 [INFO] typesutil/gopinfo.go:332: ==> Scope: func Mul__2 scope 0xc000508f60 {
.  var x int
.  var y int
.  var z int
}

2025/12/19 11:10:29 End // Func
2025/12/19 11:10:29 ==> Load const [Gopo_Mul] <nil>
2025/12/19 11:10:29 NewConst [Gopo_Mul] 0
2025/12/19 11:10:29 Val &{0 STRING "MulInt,MulFloat,"} *ast.BasicLit
2025/12/19 11:10:29.994070 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0 STRING "MulInt,MulFloat," <nil>} untyped string
2025/12/19 11:10:29 EndInit 1
2025/12/19 11:10:29.994098 [INFO] typesutil/gopinfo.go:251: ==> Def: Gopo_Mul const main.Gopo_Mul untyped string
2025/12/19 11:10:29 ==> NewOverloadFunc Mul
2025/12/19 11:10:29 ==> Load func main
2025/12/19 11:10:29.994145 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main.main()
2025/12/19 11:10:29 NewFunc main func()
2025/12/19 11:10:29 Val Mul func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:29.994185 [INFO] typesutil/gopinfo.go:265: ==> Use: Mul func main.Mul(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:29.994198 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Mul TyOverloadFunc
2025/12/19 11:10:29.994212 [INFO] typesutil/gopinfo.go:215: ==> Type: Mul func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:29 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:10:29.994244 [INFO] typesutil/gopinfo.go:215: ==> Type: &{187 INT 100 <nil>} untyped int
2025/12/19 11:10:29 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:10:29.994264 [INFO] typesutil/gopinfo.go:215: ==> Type: &{191 INT 200 <nil>} untyped int
2025/12/19 11:10:29 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:29 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:10:29 ==> MatchFuncCall func(a int, b int) int args: 2 flags: 0
2025/12/19 11:10:29 ==> MatchType untyped int (100), int
2025/12/19 11:10:29 ==> MatchType untyped int (200), int
2025/12/19 11:10:29.994330 [INFO] typesutil/gopinfo.go:265: ==> Use: Mul func main.MulInt(a int, b int) int
2025/12/19 11:10:29.994350 [INFO] typesutil/gopinfo.go:215: ==> Type: Mul func(a int, b int) int
2025/12/19 11:10:29.994372 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Mul 0 [0xc00020da10 0xc00020da40] 0 [] 0 194} int
2025/12/19 11:10:29 Val Mul func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:29.994404 [INFO] typesutil/gopinfo.go:265: ==> Use: Mul func main.Mul(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:29.994414 [INFO] typesutil/gopinfo.go:274: ==> Overloads: Mul TyOverloadFunc
2025/12/19 11:10:29.994427 [INFO] typesutil/gopinfo.go:215: ==> Type: Mul func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:29 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:10:29.994450 [INFO] typesutil/gopinfo.go:215: ==> Type: &{199 INT 100 <nil>} untyped int
2025/12/19 11:10:29 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:10:29.994470 [INFO] typesutil/gopinfo.go:215: ==> Type: &{203 INT 200 <nil>} untyped int
2025/12/19 11:10:29 Val &{0 INT 300} *ast.BasicLit
2025/12/19 11:10:29.994491 [INFO] typesutil/gopinfo.go:215: ==> Type: &{207 INT 300 <nil>} untyped int
2025/12/19 11:10:29 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:29 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/12/19 11:10:29 ==> MatchFuncCall func(a int, b int) int args: 3 flags: 0
2025/12/19 11:10:29 ==> MatchFuncCall func(a float64, b float64) float64 args: 3 flags: 0
2025/12/19 11:10:29 ==> MatchFuncCall func(x int, y int, z int) int args: 3 flags: 0
2025/12/19 11:10:29 ==> MatchType untyped int (100), int
2025/12/19 11:10:29 ==> MatchType untyped int (200), int
2025/12/19 11:10:29 ==> MatchType untyped int (300), int
2025/12/19 11:10:29.994608 [INFO] typesutil/gopinfo.go:265: ==> Use: Mul func main.Mul__2(x int, y int, z int) int
2025/12/19 11:10:29.994621 [INFO] typesutil/gopinfo.go:215: ==> Type: Mul func(x int, y int, z int) int
2025/12/19 11:10:29.994646 [INFO] typesutil/gopinfo.go:215: ==> Type: &{Mul 0 [0xc00020da70 0xc00020daa0 0xc00020dad0] 0 [] 0 210} int
2025/12/19 11:10:29.994670 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc000509440 {
}

2025/12/19 11:10:29 End // Func
2025/12/19 11:10:29.994691 [INFO] typesutil/gopinfo.go:251: ==> Def: Mul func main.Mul(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:29.994719 [INFO] typesutil/gopinfo.go:215: ==> Type: &{134 <nil> 0xc00020d890 0xc00020d8c0} func(x int, y int, z int) int
2025/12/19 11:10:29.994744 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0001d5340 0xc00020d980} func(x int, y int, z int) int
2025/12/19 11:10:29.994757 [INFO] typesutil/gopinfo.go:292: ==> Implicit: func main.Mul__2(x int, y int, z int) int
2025/12/19 11:10:29.994771 [INFO] typesutil/gopinfo.go:265: ==> Use: MulInt func main.MulInt(a int, b int) int
2025/12/19 11:10:29.994784 [INFO] typesutil/gopinfo.go:265: ==> Use: MulFloat func main.MulFloat(a float64, b float64) float64
    info_test.go:190: == types ==
        000:  0: 0 | "MulInt,MulFloat,"  *ast.BasicLit                  | value   : untyped string = "MulInt,MulFloat," | constant
        001:  2:18 | int                 *ast.Ident                     | type    : int | type
        002:  2:23 | int                 *ast.Ident                     | type    : int | type
        003:  3: 9 | a                   *ast.Ident                     | var     : int | variable
        004:  3: 9 | a * b               *ast.BinaryExpr                | value   : int | value
        005:  3:13 | b                   *ast.Ident                     | var     : int | variable
        006:  6:20 | float64             *ast.Ident                     | type    : float64 | type
        007:  6:29 | float64             *ast.Ident                     | type    : float64 | type
        008:  7: 9 | a                   *ast.Ident                     | var     : float64 | variable
        009:  7: 9 | a * b               *ast.BinaryExpr                | value   : float64 | value
        010:  7:13 | b                   *ast.Ident                     | var     : float64 | variable
        011: 13: 2 | func(x, y, z int) int *ast.FuncType                  | type    : func(x int, y int, z int) int | type
        012: 13: 2 | func(x, y, z int) int {
        	return x * y * z
        } *ast.FuncLit                   | value   : func(x int, y int, z int) int | value
        013: 13:15 | int                 *ast.Ident                     | type    : int | type
        014: 13:20 | int                 *ast.Ident                     | type    : int | type
        015: 14:10 | x                   *ast.Ident                     | var     : int | variable
        016: 14:10 | x * y               *ast.BinaryExpr                | value   : int | value
        017: 14:10 | x * y * z           *ast.BinaryExpr                | value   : int | value
        018: 14:14 | y                   *ast.Ident                     | var     : int | variable
        019: 14:18 | z                   *ast.Ident                     | var     : int | variable
        020: 18: 1 | Mul                 *ast.Ident                     | value   : func(a int, b int) int | value
        021: 18: 1 | Mul 100, 200        *ast.CallExpr                  | value   : int | value
        022: 18: 5 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        023: 18: 9 | 200                 *ast.BasicLit                  | value   : untyped int = 200 | constant
        024: 19: 1 | Mul                 *ast.Ident                     | value   : func(x int, y int, z int) int | value
        025: 19: 1 | Mul 100, 200, 300   *ast.CallExpr                  | value   : int | value
        026: 19: 5 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        027: 19: 9 | 200                 *ast.BasicLit                  | value   : untyped int = 200 | constant
        028: 19:13 | 300                 *ast.BasicLit                  | value   : untyped int = 300 | constant
        == defs ==
        000:  0: 0 | Gopo_Mul            | const main.Gopo_Mul untyped string
        001:  2: 6 | MulInt              | func main.MulInt(a int, b int) int
        002:  2:13 | a                   | var a int
        003:  2:16 | b                   | var b int
        004:  6: 6 | MulFloat            | func main.MulFloat(a float64, b float64) float64
        005:  6:15 | a                   | var a float64
        006:  6:18 | b                   | var b float64
        007: 10: 6 | Mul                 | func main.Mul(__xgo_overload_args__ interface{_()})
        008: 13: 2 | Mul__2              | func main.Mul__2(x int, y int, z int) int
        009: 13: 7 | x                   | var x int
        010: 13:10 | y                   | var y int
        011: 13:13 | z                   | var z int
        012: 18: 1 | main                | func main.main()
        == uses ==
        000:  2:18 | int                 | type int
        001:  2:23 | int                 | type int
        002:  3: 9 | a                   | var a int
        003:  3:13 | b                   | var b int
        004:  6:20 | float64             | type float64
        005:  6:29 | float64             | type float64
        006:  7: 9 | a                   | var a float64
        007:  7:13 | b                   | var b float64
        008: 11: 2 | MulInt              | func main.MulInt(a int, b int) int
        009: 12: 2 | MulFloat            | func main.MulFloat(a float64, b float64) float64
        010: 13:15 | int                 | type int
        011: 13:20 | int                 | type int
        012: 14:10 | x                   | var x int
        013: 14:14 | y                   | var y int
        014: 14:18 | z                   | var z int
        015: 18: 1 | Mul                 | func main.MulInt(a int, b int) int
        016: 19: 1 | Mul                 | func main.Mul__2(x int, y int, z int) int
        == overloads ==
        000: 18: 1 | Mul                 | func main.Mul(__xgo_overload_args__ interface{_()})
        001: 19: 1 | Mul                 | func main.Mul(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:29.996195 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:10:30 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:30 ==> NewOverloadFunc NewRange
2025/12/19 11:10:30 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:30 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:30 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:30 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:30 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:30 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:30 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:30 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:30 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:30 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:30 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:30 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:30 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:30 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:30 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:30 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:30 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:30 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:30 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:30 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:30 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:30 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:30 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:30 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:30 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:30 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:30 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:30 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:30 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:30 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:30 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:30 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:30 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:30 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:30 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:30 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:30 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:30 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:30 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:30 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:30 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:30 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:30.997491 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0004fe4e0 {
}

2025/12/19 11:10:30 ==> Preload type foo
2025/12/19 11:10:30 ==> Preload method foo.mulInt
2025/12/19 11:10:30 ==> Preload method foo.mulFoo
2025/12/19 11:10:30 NewConstDefs
2025/12/19 11:10:30 ==> Preload const [Gopo_foo_mul]
2025/12/19 11:10:30 ==> Preload var [a b]
2025/12/19 11:10:30 ==> Preload var [c]
2025/12/19 11:10:30 ==> Preload var [d]
2025/12/19 11:10:30 ==> Load > NewType foo
2025/12/19 11:10:30 NewType foo
2025/12/19 11:10:30 ==> Load > InitType foo
2025/12/19 11:10:30.997702 [INFO] typesutil/gopinfo.go:215: ==> Type: &{11 0xc00039e5a0 false} struct{}
2025/12/19 11:10:30 InitType foo struct{}
2025/12/19 11:10:30.997750 [INFO] typesutil/gopinfo.go:251: ==> Def: foo type main.foo struct{}
2025/12/19 11:10:30 ==> LookupParent foo => type main.foo struct{}
2025/12/19 11:10:30.997787 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/12/19 11:10:30.997805 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/12/19 11:10:30.997823 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a *main.foo
2025/12/19 11:10:30 ==> Load method *main.foo.mulInt
2025/12/19 11:10:30.997855 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:30.997870 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:30.997883 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:30.997897 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b int
2025/12/19 11:10:30 ==> LookupParent foo => type main.foo struct{}
2025/12/19 11:10:30.997925 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/12/19 11:10:30.997938 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/12/19 11:10:30.997953 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/12/19 11:10:30.997973 [INFO] typesutil/gopinfo.go:215: ==> Type: &{51 foo} *main.foo
2025/12/19 11:10:30.997999 [INFO] typesutil/gopinfo.go:251: ==> Def: mulInt func (*main.foo).mulInt(b int) *main.foo
2025/12/19 11:10:30 ==> LookupParent foo => type main.foo struct{}
2025/12/19 11:10:30.998024 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/12/19 11:10:30.998036 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/12/19 11:10:30.998050 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a *main.foo
2025/12/19 11:10:30 ==> Load method *main.foo.mulFoo
2025/12/19 11:10:30 ==> LookupParent foo => type main.foo struct{}
2025/12/19 11:10:30.998083 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/12/19 11:10:30.998097 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/12/19 11:10:30.998109 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/12/19 11:10:30.998126 [INFO] typesutil/gopinfo.go:215: ==> Type: &{94 foo} *main.foo
2025/12/19 11:10:30.998140 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b *main.foo
2025/12/19 11:10:30 ==> LookupParent foo => type main.foo struct{}
2025/12/19 11:10:30.998164 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/12/19 11:10:30.998186 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/12/19 11:10:30.998202 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/12/19 11:10:30.998217 [INFO] typesutil/gopinfo.go:215: ==> Type: &{100 foo} *main.foo
2025/12/19 11:10:30.998238 [INFO] typesutil/gopinfo.go:251: ==> Def: mulFoo func (*main.foo).mulFoo(b *main.foo) *main.foo
2025/12/19 11:10:30 ==> Load const [Gopo_foo_mul] <nil>
2025/12/19 11:10:30 NewConst [Gopo_foo_mul] 0
2025/12/19 11:10:30 Val &{0 STRING ".mulInt,.mulFoo"} *ast.BasicLit
2025/12/19 11:10:30.998303 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0 STRING ".mulInt,.mulFoo" <nil>} untyped string
2025/12/19 11:10:30 EndInit 1
2025/12/19 11:10:30.998335 [INFO] typesutil/gopinfo.go:251: ==> Def: Gopo_foo_mul const main.Gopo_foo_mul untyped string
2025/12/19 11:10:30 ==> NewOverloadMethod foo mul
2025/12/19 11:10:30 ==> LookupParent foo => type main.foo struct{}
2025/12/19 11:10:30.998385 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/12/19 11:10:30.998401 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/12/19 11:10:30.998416 [INFO] typesutil/gopinfo.go:215: ==> Type: foo main.foo
2025/12/19 11:10:30.998432 [INFO] typesutil/gopinfo.go:215: ==> Type: &{179 foo} *main.foo
2025/12/19 11:10:30 ==> Load var *main.foo [a b]
2025/12/19 11:10:30 NewVarDefs
2025/12/19 11:10:30 NewVar [a b]
2025/12/19 11:10:30.998484 [INFO] typesutil/gopinfo.go:251: ==> Def: a var main.a *main.foo
2025/12/19 11:10:30.998501 [INFO] typesutil/gopinfo.go:251: ==> Def: b var main.b *main.foo
2025/12/19 11:10:30 ==> Load var <nil> [c]
2025/12/19 11:10:30 NewVarDefs
2025/12/19 11:10:30 NewVar [c]
2025/12/19 11:10:30 Val a *main.foo
2025/12/19 11:10:30.998573 [INFO] typesutil/gopinfo.go:265: ==> Use: a var main.a *main.foo
2025/12/19 11:10:30.998594 [INFO] typesutil/gopinfo.go:215: ==> Type: a *main.foo
2025/12/19 11:10:30 Member mul 1 // *main.foo
2025/12/19 11:10:30.998654 [INFO] typesutil/gopinfo.go:265: ==> Use: mul func (main.foo).mul(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:30.998668 [INFO] typesutil/gopinfo.go:274: ==> Overloads: mul TyOverloadMethod
2025/12/19 11:10:30.998691 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a mul} func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:30 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:10:30.998736 [INFO] typesutil/gopinfo.go:215: ==> Type: &{198 INT 100 <nil>} untyped int
2025/12/19 11:10:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:30 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/12/19 11:10:30 ==> MatchFuncCall func(b int) *main.foo args: 1 flags: 0
2025/12/19 11:10:30 ==> MatchType untyped int (100), int
2025/12/19 11:10:30.998812 [INFO] typesutil/gopinfo.go:265: ==> Use: mul func (*main.foo).mulInt(b int) *main.foo
2025/12/19 11:10:30.998835 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a mul} func(b int) *main.foo
2025/12/19 11:10:30.998862 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0005c8b88 197 [0xc00039e8d0] 0 [] 201 0} *main.foo
2025/12/19 11:10:30 EndInit 1
2025/12/19 11:10:30.998890 [INFO] typesutil/gopinfo.go:251: ==> Def: c var main.c *main.foo
2025/12/19 11:10:30 ==> Load var <nil> [d]
2025/12/19 11:10:30 NewVarDefs
2025/12/19 11:10:30 NewVar [d]
2025/12/19 11:10:30 Val a *main.foo
2025/12/19 11:10:30.998937 [INFO] typesutil/gopinfo.go:265: ==> Use: a var main.a *main.foo
2025/12/19 11:10:30.998950 [INFO] typesutil/gopinfo.go:215: ==> Type: a *main.foo
2025/12/19 11:10:30 Member mul 1 // *main.foo
2025/12/19 11:10:30.998979 [INFO] typesutil/gopinfo.go:265: ==> Use: mul func (main.foo).mul(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:30.998991 [INFO] typesutil/gopinfo.go:274: ==> Overloads: mul TyOverloadMethod
2025/12/19 11:10:30.999006 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a mul} func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:30 Val c *main.foo
2025/12/19 11:10:30.999042 [INFO] typesutil/gopinfo.go:265: ==> Use: c var main.c *main.foo
2025/12/19 11:10:30.999060 [INFO] typesutil/gopinfo.go:215: ==> Type: c *main.foo
2025/12/19 11:10:30 Call 1 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:30 ==> MatchFuncCall TyOverloadMethod args: 1 flags: 0
2025/12/19 11:10:30 ==> MatchFuncCall func(b int) *main.foo args: 1 flags: 0
2025/12/19 11:10:30 ==> MatchType *main.foo, int
2025/12/19 11:10:30 ==> MatchFuncCall func(b *main.foo) *main.foo args: 1 flags: 0
2025/12/19 11:10:30 ==> MatchType *main.foo, *main.foo
2025/12/19 11:10:30.999147 [INFO] typesutil/gopinfo.go:265: ==> Use: mul func (*main.foo).mulFoo(b *main.foo) *main.foo
2025/12/19 11:10:30.999165 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a mul} func(b *main.foo) *main.foo
2025/12/19 11:10:30.999187 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0005c8ba0 216 [c] 0 [] 218 0} *main.foo
2025/12/19 11:10:30 EndInit 1
2025/12/19 11:10:30.999216 [INFO] typesutil/gopinfo.go:251: ==> Def: d var main.d *main.foo
2025/12/19 11:10:30 NewFunc mulInt (*main.foo) func(b int) *main.foo
2025/12/19 11:10:30 Val a *main.foo
2025/12/19 11:10:30.999263 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a *main.foo
2025/12/19 11:10:30.999278 [INFO] typesutil/gopinfo.go:215: ==> Type: a *main.foo
2025/12/19 11:10:30 Return 1
2025/12/19 11:10:30 ==> MatchType *main.foo, *main.foo
2025/12/19 11:10:30.999325 [INFO] typesutil/gopinfo.go:332: ==> Scope: func mulInt scope 0xc0004fed80 {
.  var a *main.foo
.  var b int
}

2025/12/19 11:10:30 End // Func
2025/12/19 11:10:30 NewFunc mulFoo (*main.foo) func(b *main.foo) *main.foo
2025/12/19 11:10:30 Val a *main.foo
2025/12/19 11:10:30.999393 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a *main.foo
2025/12/19 11:10:30.999410 [INFO] typesutil/gopinfo.go:215: ==> Type: a *main.foo
2025/12/19 11:10:30 Return 1
2025/12/19 11:10:30 ==> MatchType *main.foo, *main.foo
2025/12/19 11:10:30.999475 [INFO] typesutil/gopinfo.go:332: ==> Scope: func mulFoo scope 0xc0004fede0 {
.  var a *main.foo
.  var b *main.foo
}

2025/12/19 11:10:30 End // Func
2025/12/19 11:10:30.999507 [INFO] typesutil/gopinfo.go:251: ==> Def: mul func (main.foo).mul(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:30.999529 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/12/19 11:10:30.999546 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/12/19 11:10:30.999559 [INFO] typesutil/gopinfo.go:265: ==> Use: foo type main.foo struct{}
2025/12/19 11:10:30.999576 [INFO] typesutil/gopinfo.go:265: ==> Use: mulInt func (*main.foo).mulInt(b int) *main.foo
2025/12/19 11:10:30.999591 [INFO] typesutil/gopinfo.go:265: ==> Use: mulFoo func (*main.foo).mulFoo(b *main.foo) *main.foo
    info_test.go:190: == types ==
        000:  0: 0 | ".mulInt,.mulFoo"   *ast.BasicLit                  | value   : untyped string = ".mulInt,.mulFoo" | constant
        001:  2:10 | struct {
        }          *ast.StructType                | type    : struct{} | type
        002:  5:10 | foo                 *ast.Ident                     | type    : main.foo | type
        003:  5:24 | int                 *ast.Ident                     | type    : int | type
        004:  5:29 | *foo                *ast.StarExpr                  | type    : *main.foo | type
        005:  5:30 | foo                 *ast.Ident                     | type    : main.foo | type
        006:  6: 9 | a                   *ast.Ident                     | var     : *main.foo | variable
        007:  9:10 | foo                 *ast.Ident                     | type    : main.foo | type
        008:  9:24 | *foo                *ast.StarExpr                  | type    : *main.foo | type
        009:  9:25 | foo                 *ast.Ident                     | type    : main.foo | type
        010:  9:30 | *foo                *ast.StarExpr                  | type    : *main.foo | type
        011:  9:31 | foo                 *ast.Ident                     | type    : main.foo | type
        012: 10: 9 | a                   *ast.Ident                     | var     : *main.foo | variable
        013: 18:10 | *foo                *ast.StarExpr                  | type    : *main.foo | type
        014: 18:11 | foo                 *ast.Ident                     | type    : main.foo | type
        015: 19: 9 | a                   *ast.Ident                     | var     : *main.foo | variable
        016: 19: 9 | a.mul               *ast.SelectorExpr              | value   : func(b int) *main.foo | value
        017: 19: 9 | a.mul(100)          *ast.CallExpr                  | value   : *main.foo | value
        018: 19:15 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        019: 20: 9 | a                   *ast.Ident                     | var     : *main.foo | variable
        020: 20: 9 | a.mul               *ast.SelectorExpr              | value   : func(b *main.foo) *main.foo | value
        021: 20: 9 | a.mul(c)            *ast.CallExpr                  | value   : *main.foo | value
        022: 20:15 | c                   *ast.Ident                     | var     : *main.foo | variable
        == defs ==
        000:  0: 0 | Gopo_foo_mul        | const main.Gopo_foo_mul untyped string
        001:  2: 6 | foo                 | type main.foo struct{}
        002:  5: 7 | a                   | var a *main.foo
        003:  5:15 | mulInt              | func (*main.foo).mulInt(b int) *main.foo
        004:  5:22 | b                   | var b int
        005:  9: 7 | a                   | var a *main.foo
        006:  9:15 | mulFoo              | func (*main.foo).mulFoo(b *main.foo) *main.foo
        007:  9:22 | b                   | var b *main.foo
        008: 13:12 | mul                 | func (main.foo).mul(__xgo_overload_args__ interface{_()})
        009: 18: 5 | a                   | var main.a *main.foo
        010: 18: 8 | b                   | var main.b *main.foo
        011: 19: 5 | c                   | var main.c *main.foo
        012: 20: 5 | d                   | var main.d *main.foo
        == uses ==
        000:  5:10 | foo                 | type main.foo struct{}
        001:  5:24 | int                 | type int
        002:  5:30 | foo                 | type main.foo struct{}
        003:  6: 9 | a                   | var a *main.foo
        004:  9:10 | foo                 | type main.foo struct{}
        005:  9:25 | foo                 | type main.foo struct{}
        006:  9:31 | foo                 | type main.foo struct{}
        007: 10: 9 | a                   | var a *main.foo
        008: 13: 7 | foo                 | type main.foo struct{}
        009: 14: 3 | foo                 | type main.foo struct{}
        010: 14: 8 | mulInt              | func (*main.foo).mulInt(b int) *main.foo
        011: 15: 3 | foo                 | type main.foo struct{}
        012: 15: 8 | mulFoo              | func (*main.foo).mulFoo(b *main.foo) *main.foo
        013: 18:11 | foo                 | type main.foo struct{}
        014: 19: 9 | a                   | var main.a *main.foo
        015: 19:11 | mul                 | func (*main.foo).mulInt(b int) *main.foo
        016: 20: 9 | a                   | var main.a *main.foo
        017: 20:11 | mul                 | func (*main.foo).mulFoo(b *main.foo) *main.foo
        018: 20:15 | c                   | var main.c *main.foo
        == overloads ==
        000: 19:11 | mul                 | func (main.foo).mul(__xgo_overload_args__ interface{_()})
        001: 20:11 | mul                 | func (main.foo).mul(__xgo_overload_args__ interface{_()})
--- PASS: TestGopOverloadUses (2.14s)
=== RUN   TestGopOverloadDecl
2025/12/19 11:10:31.002093 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:10:31 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:31 ==> NewOverloadFunc NewRange
2025/12/19 11:10:31 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:31 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:31 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:31 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:31 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:31 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:31 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:31 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:31 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:31 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:31 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:31 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:31 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:31 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:31 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:31 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:31 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:31 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:31 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:31 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:31 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:31 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:31 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:31 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:31 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:31 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:31 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:31 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:31 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:31 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:31 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:31 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:31 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:31 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:31 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:31 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:31 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:31 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:31 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:31 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:31 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:31 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:32.086072 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0002794a0 {
}

2025/12/19 11:10:32 ==> Preload func addInt0
2025/12/19 11:10:32 ==> Preload func addInt1
2025/12/19 11:10:32 ==> Preload func addInt2
2025/12/19 11:10:32 ==> Preload var [addInt3]
2025/12/19 11:10:32 ==> Preload func add__4
2025/12/19 11:10:32 NewConstDefs
2025/12/19 11:10:32 ==> Preload const [Gopo_add]
2025/12/19 11:10:32 ==> Preload func init
2025/12/19 11:10:32 ==> Load func addInt0
2025/12/19 11:10:32.086215 [INFO] typesutil/gopinfo.go:251: ==> Def: addInt0 func main.addInt0()
2025/12/19 11:10:32 NewFunc addInt0 func()
2025/12/19 11:10:32.086253 [INFO] typesutil/gopinfo.go:332: ==> Scope: func addInt0 scope 0xc0002795c0 {
}

2025/12/19 11:10:32 End // Func
2025/12/19 11:10:32 ==> Load func addInt1
2025/12/19 11:10:32.086293 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:32.086312 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:32.086325 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:32.086341 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/12/19 11:10:32.086359 [INFO] typesutil/gopinfo.go:251: ==> Def: addInt1 func main.addInt1(i int)
2025/12/19 11:10:32 NewFunc addInt1 func(i int)
2025/12/19 11:10:32.086390 [INFO] typesutil/gopinfo.go:332: ==> Scope: func addInt1 scope 0xc0002796e0 {
.  var i int
}

2025/12/19 11:10:32 End // Func
2025/12/19 11:10:32 ==> Load func addInt2
2025/12/19 11:10:32.086422 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:32.086434 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:32.086445 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:32.086461 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/12/19 11:10:32.086474 [INFO] typesutil/gopinfo.go:251: ==> Def: j var j int
2025/12/19 11:10:32.086490 [INFO] typesutil/gopinfo.go:251: ==> Def: addInt2 func main.addInt2(i int, j int)
2025/12/19 11:10:32 NewFunc addInt2 func(i int, j int)
2025/12/19 11:10:32.086522 [INFO] typesutil/gopinfo.go:332: ==> Scope: func addInt2 scope 0xc000279860 {
.  var i int
.  var j int
}

2025/12/19 11:10:32 End // Func
2025/12/19 11:10:32 ==> Load var <nil> [addInt3]
2025/12/19 11:10:32 NewVarDefs
2025/12/19 11:10:32 NewVar [addInt3]
2025/12/19 11:10:32.086586 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:32.086598 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:32.086609 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:32.086622 [INFO] typesutil/gopinfo.go:251: ==> Def: i var i int
2025/12/19 11:10:32.086634 [INFO] typesutil/gopinfo.go:251: ==> Def: j var j int
2025/12/19 11:10:32.086648 [INFO] typesutil/gopinfo.go:251: ==> Def: k var k int
2025/12/19 11:10:32.086673 [INFO] typesutil/gopinfo.go:215: ==> Type: &{89 <nil> 0xc00020dc20 <nil>} func(i int, j int, k int)
2025/12/19 11:10:32.086692 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000552260 0xc00020dc80} func(i int, j int, k int)
2025/12/19 11:10:32 NewClosure func(i int, j int, k int)
2025/12/19 11:10:32.086730 [INFO] typesutil/gopinfo.go:332: ==> Scope: func  scope 0xc000279a40 {
.  var i int
.  var j int
.  var k int
}

2025/12/19 11:10:32 End // Func
2025/12/19 11:10:32 EndInit 1
2025/12/19 11:10:32.086772 [INFO] typesutil/gopinfo.go:251: ==> Def: addInt3 var main.addInt3 func(i int, j int, k int)
2025/12/19 11:10:32 ==> Load func add__4
2025/12/19 11:10:32.086791 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/12/19 11:10:32.086805 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:10:32.086816 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:10:32.086828 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a string
2025/12/19 11:10:32.086840 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b string
2025/12/19 11:10:32.086851 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/12/19 11:10:32.086861 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:10:32.086873 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:10:32.086890 [INFO] typesutil/gopinfo.go:251: ==> Def: add__4 func main.add__4(a string, b string) string
2025/12/19 11:10:32 NewFunc add__4 func(a string, b string) string
2025/12/19 11:10:32 Val a string
2025/12/19 11:10:32.086929 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a string
2025/12/19 11:10:32.086941 [INFO] typesutil/gopinfo.go:215: ==> Type: a string
2025/12/19 11:10:32 Val b string
2025/12/19 11:10:32.086964 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b string
2025/12/19 11:10:32.086980 [INFO] typesutil/gopinfo.go:215: ==> Type: b string
2025/12/19 11:10:32 BinaryOp +
2025/12/19 11:10:32 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:10:32 ==> MatchType string, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:32 ==> MatchType string, unboundFuncParam{typ: string}
2025/12/19 11:10:32.087075 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 200 + b} string
2025/12/19 11:10:32 Return 1
2025/12/19 11:10:32 ==> MatchType string, string
2025/12/19 11:10:32.087118 [INFO] typesutil/gopinfo.go:332: ==> Scope: func add__4 scope 0xc000279c80 {
.  var a string
.  var b string
}

2025/12/19 11:10:32 End // Func
2025/12/19 11:10:32 ==> Load const [Gopo_add] <nil>
2025/12/19 11:10:32 NewConst [Gopo_add] 0
2025/12/19 11:10:32 Val &{0 STRING "addInt0,addInt1,addInt2,addInt3,"} *ast.BasicLit
2025/12/19 11:10:32.087192 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0 STRING "addInt0,addInt1,addInt2,addInt3," <nil>} untyped string
2025/12/19 11:10:32 EndInit 1
2025/12/19 11:10:32.087219 [INFO] typesutil/gopinfo.go:251: ==> Def: Gopo_add const main.Gopo_add untyped string
2025/12/19 11:10:32 ==> NewOverloadFunc add
2025/12/19 11:10:32 ==> Load func init
2025/12/19 11:10:32.087270 [INFO] typesutil/gopinfo.go:251: ==> Def: init func main.init()
2025/12/19 11:10:32 NewFunc init func()
2025/12/19 11:10:32 Val add func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:32.087313 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:32.087323 [INFO] typesutil/gopinfo.go:274: ==> Overloads: add TyOverloadFunc
2025/12/19 11:10:32.087337 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:32 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:10:32.087368 [INFO] typesutil/gopinfo.go:215: ==> Type: &{229 INT 100 <nil>} untyped int
2025/12/19 11:10:32 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:10:32.087398 [INFO] typesutil/gopinfo.go:215: ==> Type: &{234 INT 200 <nil>} untyped int
2025/12/19 11:10:32 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:32 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:10:32 ==> MatchFuncCall func() args: 2 flags: 0
2025/12/19 11:10:32 ==> MatchFuncCall func(i int) args: 2 flags: 0
2025/12/19 11:10:32 ==> MatchFuncCall func(i int, j int) args: 2 flags: 0
2025/12/19 11:10:32 ==> MatchType untyped int (100), int
2025/12/19 11:10:32 ==> MatchType untyped int (200), int
2025/12/19 11:10:32.087518 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.addInt2(i int, j int)
2025/12/19 11:10:32.087533 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(i int, j int)
2025/12/19 11:10:32.087558 [INFO] typesutil/gopinfo.go:215: ==> Type: &{add 0 [0xc00020de90 0xc00020dec0] 0 [] 0 237} ()
2025/12/19 11:10:32 Val add func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:32.087587 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:32.087598 [INFO] typesutil/gopinfo.go:274: ==> Overloads: add TyOverloadFunc
2025/12/19 11:10:32.087611 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:32 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:10:32.087641 [INFO] typesutil/gopinfo.go:215: ==> Type: &{243 INT 100 <nil>} untyped int
2025/12/19 11:10:32 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:10:32.087666 [INFO] typesutil/gopinfo.go:215: ==> Type: &{248 INT 200 <nil>} untyped int
2025/12/19 11:10:32 Val &{0 INT 300} *ast.BasicLit
2025/12/19 11:10:32.087687 [INFO] typesutil/gopinfo.go:215: ==> Type: &{253 INT 300 <nil>} untyped int
2025/12/19 11:10:32 Call 3 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:32 ==> MatchFuncCall TyOverloadFunc args: 3 flags: 0
2025/12/19 11:10:32 ==> MatchFuncCall func() args: 3 flags: 0
2025/12/19 11:10:32 ==> MatchFuncCall func(i int) args: 3 flags: 0
2025/12/19 11:10:32 ==> MatchFuncCall func(i int, j int) args: 3 flags: 0
2025/12/19 11:10:32 ==> MatchFuncCall func(i int, j int, k int) args: 3 flags: 0
2025/12/19 11:10:32 ==> MatchType untyped int (100), int
2025/12/19 11:10:32 ==> MatchType untyped int (200), int
2025/12/19 11:10:32 ==> MatchType untyped int (300), int
2025/12/19 11:10:32.087810 [INFO] typesutil/gopinfo.go:265: ==> Use: add var main.addInt3 func(i int, j int, k int)
2025/12/19 11:10:32.087824 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(i int, j int, k int)
2025/12/19 11:10:32.087845 [INFO] typesutil/gopinfo.go:215: ==> Type: &{add 0 [0xc00020def0 0xc00020df20 0xc00020df50] 0 [] 0 256} ()
2025/12/19 11:10:32 Val add func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:32.087869 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:32.087877 [INFO] typesutil/gopinfo.go:274: ==> Overloads: add TyOverloadFunc
2025/12/19 11:10:32.087889 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:32 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:10:32.087913 [INFO] typesutil/gopinfo.go:215: ==> Type: &{262 STRING "hello" <nil>} untyped string
2025/12/19 11:10:32 Val &{0 STRING "world"} *ast.BasicLit
2025/12/19 11:10:32.087938 [INFO] typesutil/gopinfo.go:215: ==> Type: &{271 STRING "world" <nil>} untyped string
2025/12/19 11:10:32 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:32 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:10:32 ==> MatchFuncCall func() args: 2 flags: 0
2025/12/19 11:10:32 ==> MatchFuncCall func(i int) args: 2 flags: 0
2025/12/19 11:10:32 ==> MatchFuncCall func(i int, j int) args: 2 flags: 0
2025/12/19 11:10:32 ==> MatchType untyped string ("hello"), int
2025/12/19 11:10:32 ==> MatchFuncCall func(i int, j int, k int) args: 2 flags: 0
2025/12/19 11:10:32 ==> MatchFuncCall func(a string, b string) string args: 2 flags: 0
2025/12/19 11:10:32 ==> MatchType untyped string ("hello"), string
2025/12/19 11:10:32 ==> MatchType untyped string ("world"), string
2025/12/19 11:10:32.088077 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add__4(a string, b string) string
2025/12/19 11:10:32.088091 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(a string, b string) string
2025/12/19 11:10:32.088110 [INFO] typesutil/gopinfo.go:215: ==> Type: &{add 261 [0xc000112060 0xc000112630] 0 [] 278 0} string
2025/12/19 11:10:32.088124 [INFO] typesutil/gopinfo.go:332: ==> Scope: func init scope 0xc0003d4120 {
}

2025/12/19 11:10:32 End // Func
2025/12/19 11:10:32.088157 [INFO] typesutil/gopinfo.go:215: ==> Type: &{162 <nil> 0xc00020dd10 0xc00020dd40} func(a string, b string) string
2025/12/19 11:10:32.088173 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0005523c0 0xc00020ddd0} func(a string, b string) string
2025/12/19 11:10:32.088185 [INFO] typesutil/gopinfo.go:292: ==> Implicit: func main.add__4(a string, b string) string
2025/12/19 11:10:32.088204 [INFO] typesutil/gopinfo.go:251: ==> Def: add func main.add(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:32.088216 [INFO] typesutil/gopinfo.go:265: ==> Use: addInt0 func main.addInt0()
2025/12/19 11:10:32.088229 [INFO] typesutil/gopinfo.go:265: ==> Use: addInt1 func main.addInt1(i int)
2025/12/19 11:10:32.088241 [INFO] typesutil/gopinfo.go:265: ==> Use: addInt2 func main.addInt2(i int, j int)
2025/12/19 11:10:32.088256 [INFO] typesutil/gopinfo.go:265: ==> Use: addInt3 var main.addInt3 func(i int, j int, k int)
    info_test.go:190: == types ==
        000:  0: 0 | "addInt0,addInt1,addInt2,addInt3," *ast.BasicLit                  | value   : untyped string = "addInt0,addInt1,addInt2,addInt3," | constant
        001:  5:16 | int                 *ast.Ident                     | type    : int | type
        002:  8:19 | int                 *ast.Ident                     | type    : int | type
        003: 11:15 | func(i, j, k int)   *ast.FuncType                  | type    : func(i int, j int, k int) | type
        004: 11:15 | func(i, j, k int) {
        } *ast.FuncLit                   | value   : func(i int, j int, k int) | value
        005: 11:28 | int                 *ast.Ident                     | type    : int | type
        006: 19: 2 | func(a, b string) string *ast.FuncType                  | type    : func(a string, b string) string | type
        007: 19: 2 | func(a, b string) string {
        	return a + b
        } *ast.FuncLit                   | value   : func(a string, b string) string | value
        008: 19:12 | string              *ast.Ident                     | type    : string | type
        009: 19:20 | string              *ast.Ident                     | type    : string | type
        010: 20:10 | a                   *ast.Ident                     | var     : string | variable
        011: 20:10 | a + b               *ast.BinaryExpr                | value   : string | value
        012: 20:14 | b                   *ast.Ident                     | var     : string | variable
        013: 25: 2 | add                 *ast.Ident                     | value   : func(i int, j int) | value
        014: 25: 2 | add 100, 200        *ast.CallExpr                  | void    : () | no value
        015: 25: 6 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        016: 25:11 | 200                 *ast.BasicLit                  | value   : untyped int = 200 | constant
        017: 26: 2 | add                 *ast.Ident                     | var     : func(i int, j int, k int) | variable
        018: 26: 2 | add 100, 200, 300   *ast.CallExpr                  | void    : () | no value
        019: 26: 6 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        020: 26:11 | 200                 *ast.BasicLit                  | value   : untyped int = 200 | constant
        021: 26:16 | 300                 *ast.BasicLit                  | value   : untyped int = 300 | constant
        022: 27: 2 | add                 *ast.Ident                     | value   : func(a string, b string) string | value
        023: 27: 2 | add("hello", "world") *ast.CallExpr                  | value   : string | value
        024: 27: 6 | "hello"             *ast.BasicLit                  | value   : untyped string = "hello" | constant
        025: 27:15 | "world"             *ast.BasicLit                  | value   : untyped string = "world" | constant
        == defs ==
        000:  0: 0 | Gopo_add            | const main.Gopo_add untyped string
        001:  2: 6 | addInt0             | func main.addInt0()
        002:  5: 6 | addInt1             | func main.addInt1(i int)
        003:  5:14 | i                   | var i int
        004:  8: 6 | addInt2             | func main.addInt2(i int, j int)
        005:  8:14 | i                   | var i int
        006:  8:17 | j                   | var j int
        007: 11: 5 | addInt3             | var main.addInt3 func(i int, j int, k int)
        008: 11:20 | i                   | var i int
        009: 11:23 | j                   | var j int
        010: 11:26 | k                   | var k int
        011: 14: 6 | add                 | func main.add(__xgo_overload_args__ interface{_()})
        012: 19: 2 | add__4              | func main.add__4(a string, b string) string
        013: 19: 7 | a                   | var a string
        014: 19:10 | b                   | var b string
        015: 24: 6 | init                | func main.init()
        == uses ==
        000:  5:16 | int                 | type int
        001:  8:19 | int                 | type int
        002: 11:28 | int                 | type int
        003: 15: 2 | addInt0             | func main.addInt0()
        004: 16: 2 | addInt1             | func main.addInt1(i int)
        005: 17: 2 | addInt2             | func main.addInt2(i int, j int)
        006: 18: 2 | addInt3             | var main.addInt3 func(i int, j int, k int)
        007: 19:12 | string              | type string
        008: 19:20 | string              | type string
        009: 20:10 | a                   | var a string
        010: 20:14 | b                   | var b string
        011: 25: 2 | add                 | func main.addInt2(i int, j int)
        012: 26: 2 | add                 | var main.addInt3 func(i int, j int, k int)
        013: 27: 2 | add                 | func main.add__4(a string, b string) string
        == overloads ==
        000: 25: 2 | add                 | func main.add(__xgo_overload_args__ interface{_()})
        001: 26: 2 | add                 | func main.add(__xgo_overload_args__ interface{_()})
        002: 27: 2 | add                 | func main.add(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:32.089693 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:10:32 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:32 ==> NewOverloadFunc NewRange
2025/12/19 11:10:32 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:32 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:32 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:32 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:32 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:32 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:32 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:32 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:32 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:32 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:32 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:32 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:32 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:32 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:32 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:32 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:32 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:32 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:32 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:32 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:32 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:32 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:32 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:32 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:32 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:32 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:32 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:32 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:32 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:32 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:32 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:32 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:32 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:32 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:32 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:32 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:32 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:32 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:32 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:32 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:32 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:32 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:33.181373 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0001f9c20 {
}

2025/12/19 11:10:33 ==> Preload func add__0
2025/12/19 11:10:33 ==> Preload func add__1
2025/12/19 11:10:33 ==> Preload func init
2025/12/19 11:10:33 ==> Load func add__0
2025/12/19 11:10:33.181496 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:33.181520 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:33.181534 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:33.181549 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a int
2025/12/19 11:10:33.181564 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b int
2025/12/19 11:10:33.181577 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:33.181588 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:33.181599 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:33.181621 [INFO] typesutil/gopinfo.go:251: ==> Def: add__0 func main.add__0(a int, b int) int
2025/12/19 11:10:33 NewFunc add__0 func(a int, b int) int
2025/12/19 11:10:33 Val a int
2025/12/19 11:10:33.181665 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a int
2025/12/19 11:10:33.181676 [INFO] typesutil/gopinfo.go:215: ==> Type: a int
2025/12/19 11:10:33 Val b int
2025/12/19 11:10:33.181694 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b int
2025/12/19 11:10:33.181705 [INFO] typesutil/gopinfo.go:215: ==> Type: b int
2025/12/19 11:10:33 BinaryOp +
2025/12/19 11:10:33 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:10:33 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:33 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:10:33.181804 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 48 + b} int
2025/12/19 11:10:33 Return 1
2025/12/19 11:10:33 ==> MatchType int, int
2025/12/19 11:10:33.181845 [INFO] typesutil/gopinfo.go:332: ==> Scope: func add__0 scope 0xc0001f9e00 {
.  var a int
.  var b int
}

2025/12/19 11:10:33 End // Func
2025/12/19 11:10:33 ==> Load func add__1
2025/12/19 11:10:33.181879 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/12/19 11:10:33.181891 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:10:33.181902 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:10:33.181918 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a string
2025/12/19 11:10:33.181929 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b string
2025/12/19 11:10:33.181941 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/12/19 11:10:33.181951 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:10:33.181961 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:10:33.181981 [INFO] typesutil/gopinfo.go:251: ==> Def: add__1 func main.add__1(a string, b string) string
2025/12/19 11:10:33 NewFunc add__1 func(a string, b string) string
2025/12/19 11:10:33 Val a string
2025/12/19 11:10:33.182016 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a string
2025/12/19 11:10:33.182028 [INFO] typesutil/gopinfo.go:215: ==> Type: a string
2025/12/19 11:10:33 Val b string
2025/12/19 11:10:33.182045 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b string
2025/12/19 11:10:33.182060 [INFO] typesutil/gopinfo.go:215: ==> Type: b string
2025/12/19 11:10:33 BinaryOp +
2025/12/19 11:10:33 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:10:33 ==> MatchType string, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:33 ==> MatchType string, unboundFuncParam{typ: string}
2025/12/19 11:10:33.182119 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 94 + b} string
2025/12/19 11:10:33 Return 1
2025/12/19 11:10:33 ==> MatchType string, string
2025/12/19 11:10:33.182153 [INFO] typesutil/gopinfo.go:332: ==> Scope: func add__1 scope 0xc000216180 {
.  var a string
.  var b string
}

2025/12/19 11:10:33 End // Func
2025/12/19 11:10:33 ==> NewOverloadFunc add
2025/12/19 11:10:33 ==> Load func init
2025/12/19 11:10:33.182197 [INFO] typesutil/gopinfo.go:251: ==> Def: init func main.init()
2025/12/19 11:10:33 NewFunc init func()
2025/12/19 11:10:33 Val add func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:33.182230 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:33.182243 [INFO] typesutil/gopinfo.go:274: ==> Overloads: add TyOverloadFunc
2025/12/19 11:10:33.182256 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:33 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:10:33.182293 [INFO] typesutil/gopinfo.go:215: ==> Type: &{123 INT 100 <nil>} untyped int
2025/12/19 11:10:33 Val &{0 INT 200} *ast.BasicLit
2025/12/19 11:10:33.182319 [INFO] typesutil/gopinfo.go:215: ==> Type: &{128 INT 200 <nil>} untyped int
2025/12/19 11:10:33 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:33 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:10:33 ==> MatchFuncCall func(a int, b int) int args: 2 flags: 0
2025/12/19 11:10:33 ==> MatchType untyped int (100), int
2025/12/19 11:10:33 ==> MatchType untyped int (200), int
2025/12/19 11:10:33.182388 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add__0(a int, b int) int
2025/12/19 11:10:33.182403 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(a int, b int) int
2025/12/19 11:10:33.182432 [INFO] typesutil/gopinfo.go:215: ==> Type: &{add 0 [0xc0003f0a20 0xc0003f0a50] 0 [] 0 131} int
2025/12/19 11:10:33 Val add func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:33.182467 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:33.182475 [INFO] typesutil/gopinfo.go:274: ==> Overloads: add TyOverloadFunc
2025/12/19 11:10:33.182486 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:33 Val &{0 STRING "hello"} *ast.BasicLit
2025/12/19 11:10:33.182510 [INFO] typesutil/gopinfo.go:215: ==> Type: &{137 STRING "hello" <nil>} untyped string
2025/12/19 11:10:33 Val &{0 STRING "world"} *ast.BasicLit
2025/12/19 11:10:33.182532 [INFO] typesutil/gopinfo.go:215: ==> Type: &{146 STRING "world" <nil>} untyped string
2025/12/19 11:10:33 Call 2 0 // func(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:33 ==> MatchFuncCall TyOverloadFunc args: 2 flags: 0
2025/12/19 11:10:33 ==> MatchFuncCall func(a int, b int) int args: 2 flags: 0
2025/12/19 11:10:33 ==> MatchType untyped string ("hello"), int
2025/12/19 11:10:33 ==> MatchFuncCall func(a string, b string) string args: 2 flags: 0
2025/12/19 11:10:33 ==> MatchType untyped string ("hello"), string
2025/12/19 11:10:33 ==> MatchType untyped string ("world"), string
2025/12/19 11:10:33.182606 [INFO] typesutil/gopinfo.go:265: ==> Use: add func main.add__1(a string, b string) string
2025/12/19 11:10:33.182618 [INFO] typesutil/gopinfo.go:215: ==> Type: add func(a string, b string) string
2025/12/19 11:10:33.182636 [INFO] typesutil/gopinfo.go:215: ==> Type: &{add 0 [0xc0003f0a80 0xc0003f0ab0] 0 [] 0 153} string
2025/12/19 11:10:33.182650 [INFO] typesutil/gopinfo.go:332: ==> Scope: func init scope 0xc0002164e0 {
}

2025/12/19 11:10:33 End // Func
2025/12/19 11:10:33.182677 [INFO] typesutil/gopinfo.go:215: ==> Type: &{16 <nil> 0xc0003f0780 0xc0003f07b0} func(a int, b int) int
2025/12/19 11:10:33.182698 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000684e00 0xc0003f0840} func(a int, b int) int
2025/12/19 11:10:33.182711 [INFO] typesutil/gopinfo.go:292: ==> Implicit: func main.add__0(a int, b int) int
2025/12/19 11:10:33.182728 [INFO] typesutil/gopinfo.go:215: ==> Type: &{56 <nil> 0xc0003f08a0 0xc0003f08d0} func(a string, b string) string
2025/12/19 11:10:33.182743 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc000684f40 0xc0003f0960} func(a string, b string) string
2025/12/19 11:10:33.182755 [INFO] typesutil/gopinfo.go:292: ==> Implicit: func main.add__1(a string, b string) string
2025/12/19 11:10:33.182768 [INFO] typesutil/gopinfo.go:251: ==> Def: add func main.add(__xgo_overload_args__ interface{_()})
    info_test.go:190: == types ==
        000:  3: 2 | func(a, b int) int  *ast.FuncType                  | type    : func(a int, b int) int | type
        001:  3: 2 | func(a, b int) int {
        	return a + b
        } *ast.FuncLit                   | value   : func(a int, b int) int | value
        002:  3:12 | int                 *ast.Ident                     | type    : int | type
        003:  3:17 | int                 *ast.Ident                     | type    : int | type
        004:  4:10 | a                   *ast.Ident                     | var     : int | variable
        005:  4:10 | a + b               *ast.BinaryExpr                | value   : int | value
        006:  4:14 | b                   *ast.Ident                     | var     : int | variable
        007:  6: 2 | func(a, b string) string *ast.FuncType                  | type    : func(a string, b string) string | type
        008:  6: 2 | func(a, b string) string {
        	return a + b
        } *ast.FuncLit                   | value   : func(a string, b string) string | value
        009:  6:12 | string              *ast.Ident                     | type    : string | type
        010:  6:20 | string              *ast.Ident                     | type    : string | type
        011:  7:10 | a                   *ast.Ident                     | var     : string | variable
        012:  7:10 | a + b               *ast.BinaryExpr                | value   : string | value
        013:  7:14 | b                   *ast.Ident                     | var     : string | variable
        014: 12: 2 | add                 *ast.Ident                     | value   : func(a int, b int) int | value
        015: 12: 2 | add 100, 200        *ast.CallExpr                  | value   : int | value
        016: 12: 6 | 100                 *ast.BasicLit                  | value   : untyped int = 100 | constant
        017: 12:11 | 200                 *ast.BasicLit                  | value   : untyped int = 200 | constant
        018: 13: 2 | add                 *ast.Ident                     | value   : func(a string, b string) string | value
        019: 13: 2 | add "hello", "world" *ast.CallExpr                  | value   : string | value
        020: 13: 6 | "hello"             *ast.BasicLit                  | value   : untyped string = "hello" | constant
        021: 13:15 | "world"             *ast.BasicLit                  | value   : untyped string = "world" | constant
        == defs ==
        000:  2: 6 | add                 | func main.add(__xgo_overload_args__ interface{_()})
        001:  3: 2 | add__0              | func main.add__0(a int, b int) int
        002:  3: 7 | a                   | var a int
        003:  3:10 | b                   | var b int
        004:  6: 2 | add__1              | func main.add__1(a string, b string) string
        005:  6: 7 | a                   | var a string
        006:  6:10 | b                   | var b string
        007: 11: 6 | init                | func main.init()
        == uses ==
        000:  3:12 | int                 | type int
        001:  3:17 | int                 | type int
        002:  4:10 | a                   | var a int
        003:  4:14 | b                   | var b int
        004:  6:12 | string              | type string
        005:  6:20 | string              | type string
        006:  7:10 | a                   | var a string
        007:  7:14 | b                   | var b string
        008: 12: 2 | add                 | func main.add__0(a int, b int) int
        009: 13: 2 | add                 | func main.add__1(a string, b string) string
        == overloads ==
        000: 12: 2 | add                 | func main.add(__xgo_overload_args__ interface{_()})
        001: 13: 2 | add                 | func main.add(__xgo_overload_args__ interface{_()})
--- PASS: TestGopOverloadDecl (2.18s)
=== RUN   TestGoxOverloadInfo
2025/12/19 11:10:33.184143 [INFO] typesutil/check.go:142: typesutil.Check: main xgoFiles = 1 goFiles = 0
2025/12/19 11:10:33 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:33 ==> NewOverloadFunc NewRange
2025/12/19 11:10:33 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:33 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:33 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:33 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:33 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:33 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:33 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:33 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:33 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:33 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:33 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:33 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:33 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:33 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:33 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:33 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:33 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:33 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:33 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:33 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:33 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:33 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:33 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:33 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:33 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:33 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:33 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:33 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:33 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:33 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:33 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:33 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:33 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:33 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:33 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:33 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:33 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:33 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:33 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:33 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:33 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:33 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:34.247068 [INFO] typesutil/gopinfo.go:332: ==> Scope: Rect.gox scope 0xc0001a1800 {
}

2025/12/19 11:10:34 ==> Preload type Rect
2025/12/19 11:10:34 ==> Preload method Rect.addInt
2025/12/19 11:10:34 ==> Preload method Rect.addString
2025/12/19 11:10:34 ==> Preload method Rect.add__1
2025/12/19 11:10:34 NewConstDefs
2025/12/19 11:10:34 ==> Preload const [Gopo_Rect_add]
2025/12/19 11:10:34 ==> Load > NewType Rect
2025/12/19 11:10:34 NewType Rect
2025/12/19 11:10:34 ==> Load > InitType Rect
2025/12/19 11:10:34 InitType Rect struct{}
2025/12/19 11:10:34 ==> LookupParent Rect => type main.Rect struct{}
2025/12/19 11:10:34.247273 [INFO] typesutil/gopinfo.go:265: ==> Use: Rect type main.Rect struct{}
2025/12/19 11:10:34.247294 [INFO] typesutil/gopinfo.go:215: ==> Type: Rect main.Rect
2025/12/19 11:10:34.247313 [INFO] typesutil/gopinfo.go:251: ==> Def: this var this *main.Rect
2025/12/19 11:10:34 ==> Load method *main.Rect.addInt
2025/12/19 11:10:34.247341 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:34.247355 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:34.247370 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:34.247385 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a int
2025/12/19 11:10:34.247399 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b int
2025/12/19 11:10:34.247413 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:34.247425 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:34.247437 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:34.247461 [INFO] typesutil/gopinfo.go:251: ==> Def: addInt func (*main.Rect).addInt(a int, b int) int
2025/12/19 11:10:34 ==> LookupParent Rect => type main.Rect struct{}
2025/12/19 11:10:34.247499 [INFO] typesutil/gopinfo.go:265: ==> Use: Rect type main.Rect struct{}
2025/12/19 11:10:34.247512 [INFO] typesutil/gopinfo.go:215: ==> Type: Rect main.Rect
2025/12/19 11:10:34.247525 [INFO] typesutil/gopinfo.go:251: ==> Def: this var this *main.Rect
2025/12/19 11:10:34 ==> Load method *main.Rect.addString
2025/12/19 11:10:34.247548 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/12/19 11:10:34.247560 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:10:34.247571 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:10:34.247585 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a string
2025/12/19 11:10:34.247598 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b string
2025/12/19 11:10:34.247610 [INFO] typesutil/gopinfo.go:265: ==> Use: string type string
2025/12/19 11:10:34.247622 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:10:34.247635 [INFO] typesutil/gopinfo.go:215: ==> Type: string string
2025/12/19 11:10:34.247654 [INFO] typesutil/gopinfo.go:251: ==> Def: addString func (*main.Rect).addString(a string, b string) string
2025/12/19 11:10:34 ==> LookupParent Rect => type main.Rect struct{}
2025/12/19 11:10:34.247677 [INFO] typesutil/gopinfo.go:265: ==> Use: Rect type main.Rect struct{}
2025/12/19 11:10:34.247689 [INFO] typesutil/gopinfo.go:215: ==> Type: Rect main.Rect
2025/12/19 11:10:34.247702 [INFO] typesutil/gopinfo.go:251: ==> Def: this var this *main.Rect
2025/12/19 11:10:34 ==> Load method *main.Rect.add__1
2025/12/19 11:10:34.247724 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/12/19 11:10:34.247734 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:10:34.247746 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:10:34.247758 [INFO] typesutil/gopinfo.go:251: ==> Def: a var a float64
2025/12/19 11:10:34.247770 [INFO] typesutil/gopinfo.go:251: ==> Def: b var b float64
2025/12/19 11:10:34.247786 [INFO] typesutil/gopinfo.go:265: ==> Use: float64 type float64
2025/12/19 11:10:34.247798 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:10:34.247810 [INFO] typesutil/gopinfo.go:215: ==> Type: float64 float64
2025/12/19 11:10:34.247833 [INFO] typesutil/gopinfo.go:251: ==> Def: add__1 func (*main.Rect).add__1(a float64, b float64) float64
2025/12/19 11:10:34 ==> Load const [Gopo_Rect_add] <nil>
2025/12/19 11:10:34 NewConst [Gopo_Rect_add] 0
2025/12/19 11:10:34 Val &{0 STRING ".addInt,,.addString"} *ast.BasicLit
2025/12/19 11:10:34.247896 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0 STRING ".addInt,,.addString" <nil>} untyped string
2025/12/19 11:10:34 EndInit 1
2025/12/19 11:10:34.247933 [INFO] typesutil/gopinfo.go:251: ==> Def: Gopo_Rect_add const main.Gopo_Rect_add untyped string
2025/12/19 11:10:34 ==> NewOverloadMethod Rect add
2025/12/19 11:10:34 NewFunc addInt (*main.Rect) func(a int, b int) int
2025/12/19 11:10:34 Val a int
2025/12/19 11:10:34.248022 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a int
2025/12/19 11:10:34.248040 [INFO] typesutil/gopinfo.go:215: ==> Type: a int
2025/12/19 11:10:34 Val b int
2025/12/19 11:10:34.248063 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b int
2025/12/19 11:10:34.248076 [INFO] typesutil/gopinfo.go:215: ==> Type: b int
2025/12/19 11:10:34 BinaryOp +
2025/12/19 11:10:34 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:10:34 ==> MatchType int, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:34 ==> MatchType int, unboundFuncParam{typ: int}
2025/12/19 11:10:34.248165 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 40 + b} int
2025/12/19 11:10:34 Return 1
2025/12/19 11:10:34 ==> MatchType int, int
2025/12/19 11:10:34.248224 [INFO] typesutil/gopinfo.go:332: ==> Scope: func addInt scope 0xc0001ba120 {
.  var a int
.  var b int
.  var this *main.Rect
}

2025/12/19 11:10:34 End // Func
2025/12/19 11:10:34 NewFunc addString (*main.Rect) func(a string, b string) string
2025/12/19 11:10:34 Val a string
2025/12/19 11:10:34.248289 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a string
2025/12/19 11:10:34.248301 [INFO] typesutil/gopinfo.go:215: ==> Type: a string
2025/12/19 11:10:34 Val b string
2025/12/19 11:10:34.248321 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b string
2025/12/19 11:10:34.248334 [INFO] typesutil/gopinfo.go:215: ==> Type: b string
2025/12/19 11:10:34 BinaryOp +
2025/12/19 11:10:34 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:10:34 ==> MatchType string, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:34 ==> MatchType string, unboundFuncParam{typ: string}
2025/12/19 11:10:34.248404 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 94 + b} string
2025/12/19 11:10:34 Return 1
2025/12/19 11:10:34 ==> MatchType string, string
2025/12/19 11:10:34.248450 [INFO] typesutil/gopinfo.go:332: ==> Scope: func addString scope 0xc0001ba2a0 {
.  var a string
.  var b string
.  var this *main.Rect
}

2025/12/19 11:10:34 End // Func
2025/12/19 11:10:34 NewFunc add__1 (*main.Rect) func(a float64, b float64) float64
2025/12/19 11:10:34 Val a float64
2025/12/19 11:10:34.248503 [INFO] typesutil/gopinfo.go:265: ==> Use: a var a float64
2025/12/19 11:10:34.248515 [INFO] typesutil/gopinfo.go:215: ==> Type: a float64
2025/12/19 11:10:34 Val b float64
2025/12/19 11:10:34.248534 [INFO] typesutil/gopinfo.go:265: ==> Use: b var b float64
2025/12/19 11:10:34.248546 [INFO] typesutil/gopinfo.go:215: ==> Type: b float64
2025/12/19 11:10:34 BinaryOp +
2025/12/19 11:10:34 ==> MatchFuncCall TemplateSignature{func(a TemplateParamType{name: T}, b TemplateParamType{name: T}) TemplateParamType{name: T}} args: 2 flags: 0
2025/12/19 11:10:34 ==> MatchType float64, unboundFuncParam{typ: <nil>}
2025/12/19 11:10:34 ==> MatchType float64, unboundFuncParam{typ: float64}
2025/12/19 11:10:34.248607 [INFO] typesutil/gopinfo.go:215: ==> Type: &{a 163 + b} float64
2025/12/19 11:10:34 Return 1
2025/12/19 11:10:34 ==> MatchType float64, float64
2025/12/19 11:10:34.248648 [INFO] typesutil/gopinfo.go:332: ==> Scope: func add__1 scope 0xc0001ba420 {
.  var a float64
.  var b float64
.  var this *main.Rect
}

2025/12/19 11:10:34 End // Func
2025/12/19 11:10:34.248685 [INFO] typesutil/gopinfo.go:251: ==> Def: add func (main.Rect).add(__xgo_overload_args__ interface{_()})
2025/12/19 11:10:34.248706 [INFO] typesutil/gopinfo.go:265: ==> Use: Rect type main.Rect struct{}
2025/12/19 11:10:34.248724 [INFO] typesutil/gopinfo.go:265: ==> Use: addInt func (*main.Rect).addInt(a int, b int) int
2025/12/19 11:10:34.248744 [INFO] typesutil/gopinfo.go:265: ==> Use: addString func (*main.Rect).addString(a string, b string) string
    info_test.go:190: == types ==
        000:  0: 0 | ".addInt,,.addString" *ast.BasicLit                  | value   : untyped string = ".addInt,,.addString" | constant
        001:  0: 0 | Rect                *ast.Ident                     | type    : main.Rect | type
        002:  2:18 | int                 *ast.Ident                     | type    : int | type
        003:  2:23 | int                 *ast.Ident                     | type    : int | type
        004:  3: 9 | a                   *ast.Ident                     | var     : int | variable
        005:  3: 9 | a + b               *ast.BinaryExpr                | value   : int | value
        006:  3:13 | b                   *ast.Ident                     | var     : int | variable
        007:  6:21 | string              *ast.Ident                     | type    : string | type
        008:  6:29 | string              *ast.Ident                     | type    : string | type
        009:  7: 9 | a                   *ast.Ident                     | var     : string | variable
        010:  7: 9 | a + b               *ast.BinaryExpr                | value   : string | value
        011:  7:13 | b                   *ast.Ident                     | var     : string | variable
        012: 12:12 | float64             *ast.Ident                     | type    : float64 | type
        013: 12:21 | float64             *ast.Ident                     | type    : float64 | type
        014: 13:10 | a                   *ast.Ident                     | var     : float64 | variable
        015: 13:10 | a + b               *ast.BinaryExpr                | value   : float64 | value
        016: 13:14 | b                   *ast.Ident                     | var     : float64 | variable
        == defs ==
        000:  0: 0 | Gopo_Rect_add       | const main.Gopo_Rect_add untyped string
        001:  0: 0 | this                | var this *main.Rect
        002:  2: 6 | addInt              | func (*main.Rect).addInt(a int, b int) int
        003:  2:13 | a                   | var a int
        004:  2:16 | b                   | var b int
        005:  6: 6 | addString           | func (*main.Rect).addString(a string, b string) string
        006:  6:16 | a                   | var a string
        007:  6:19 | b                   | var b string
        008: 10: 6 | add                 | func (main.Rect).add(__xgo_overload_args__ interface{_()})
        009: 12: 2 | add__1              | func (*main.Rect).add__1(a float64, b float64) float64
        010: 12: 7 | a                   | var a float64
        011: 12:10 | b                   | var b float64
        == uses ==
        000:  0: 0 | Rect                | type main.Rect struct{}
        001:  2:18 | int                 | type int
        002:  2:23 | int                 | type int
        003:  3: 9 | a                   | var a int
        004:  3:13 | b                   | var b int
        005:  6:21 | string              | type string
        006:  6:29 | string              | type string
        007:  7: 9 | a                   | var a string
        008:  7:13 | b                   | var b string
        009: 11: 2 | addInt              | func (*main.Rect).addInt(a int, b int) int
        010: 12:12 | float64             | type float64
        011: 12:21 | float64             | type float64
        012: 13:10 | a                   | var a float64
        013: 13:14 | b                   | var b float64
        014: 15: 2 | addString           | func (*main.Rect).addString(a string, b string) string
--- PASS: TestGoxOverloadInfo (1.07s)
=== RUN   TestTypesAlias
2025/12/19 11:10:34.249655 [INFO] typesutil/check.go:142: typesutil.Check:  xgoFiles = 1 goFiles = 0
2025/12/19 11:10:34 ==> Import github.com/qiniu/x/xgo
2025/12/19 11:10:34 ==> NewOverloadFunc NewRange
2025/12/19 11:10:35 ==> Import github.com/qiniu/x/xgo/ng
2025/12/19 11:10:35 ==> NewOverloadMethod Int128 Gop_Add
2025/12/19 11:10:35 ==> NewOverloadMethod Int128 Gop_LE
2025/12/19 11:10:35 ==> NewOverloadMethod Int128 Gop_Mul
2025/12/19 11:10:35 ==> NewOverloadMethod Uint128 Gop_Add
2025/12/19 11:10:35 ==> NewOverloadMethod Uint128 Gop_LE
2025/12/19 11:10:35 ==> NewOverloadMethod Int128 Gop_Rcast
2025/12/19 11:10:35 ==> NewOverloadMethod Int128 Abs
2025/12/19 11:10:35 ==> NewOverloadMethod Int128 Cmp
2025/12/19 11:10:35 ==> NewOverloadMethod Int128 Gop_GT
2025/12/19 11:10:35 ==> NewOverloadFunc UntypedBigint_Init
2025/12/19 11:10:35 ==> NewOverloadFunc Bigint_Init
2025/12/19 11:10:35 ==> NewOverloadFunc Bigrat_Init
2025/12/19 11:10:35 ==> NewOverloadMethod Int128 QuoRem
2025/12/19 11:10:35 ==> NewOverloadFunc Int128_Init
2025/12/19 11:10:35 ==> NewOverloadMethod Uint128 Gop_Rcast
2025/12/19 11:10:35 ==> NewOverloadMethod Uint128 Gop_Sub
2025/12/19 11:10:35 ==> NewOverloadMethod Uint128 Gop_EQ
2025/12/19 11:10:35 ==> NewOverloadMethod Uint128 QuoRem
2025/12/19 11:10:35 ==> NewOverloadFunc Bigrat_Cast
2025/12/19 11:10:35 ==> NewOverloadFunc Uint128_Init
2025/12/19 11:10:35 ==> NewOverloadMethod Int128 Gop_EQ
2025/12/19 11:10:35 ==> NewOverloadMethod Uint128 Gop_LT
2025/12/19 11:10:35 ==> NewOverloadMethod Uint128 Gop_Quo
2025/12/19 11:10:35 ==> NewOverloadMethod Bigint Gop_Rcast
2025/12/19 11:10:35 ==> NewOverloadMethod Uint128 Cmp
2025/12/19 11:10:35 ==> NewOverloadMethod Uint128 Gop_And
2025/12/19 11:10:35 ==> NewOverloadMethod Int128 Gop_Sub
2025/12/19 11:10:35 ==> NewOverloadMethod Int128 Gop_Rem
2025/12/19 11:10:35 ==> NewOverloadMethod Uint128 Gop_GT
2025/12/19 11:10:35 ==> NewOverloadMethod Int128 Gop_LT
2025/12/19 11:10:35 ==> NewOverloadMethod Uint128 Gop_GE
2025/12/19 11:10:35 ==> NewOverloadMethod Uint128 Gop_Or
2025/12/19 11:10:35 ==> NewOverloadMethod Uint128 Gop_Mul
2025/12/19 11:10:35 ==> NewOverloadMethod Uint128 Gop_Rem
2025/12/19 11:10:35 ==> NewOverloadMethod Int128 Gop_Quo
2025/12/19 11:10:35 ==> NewOverloadMethod Int128 Gop_GE
2025/12/19 11:10:35 ==> NewOverloadFunc Int128_Cast
2025/12/19 11:10:35 ==> NewOverloadMethod Uint128 Gop_Xor
2025/12/19 11:10:35 ==> NewOverloadFunc Uint128_Cast
2025/12/19 11:10:35 ==> NewOverloadFunc UntypedBigrat_Init
2025/12/19 11:10:35 ==> NewOverloadFunc Bigint_Cast
2025/12/19 11:10:35.418361 [INFO] typesutil/gopinfo.go:332: ==> Scope: main.xgo scope 0xc0002b2540 {
}

2025/12/19 11:10:35.418413 [INFO] typesutil/gopinfo.go:292: ==> Implicit: package fmt
2025/12/19 11:10:35 ==> Preload type T
2025/12/19 11:10:35 ==> Preload var [v]
2025/12/19 11:10:35 ==> Preload func demo
2025/12/19 11:10:35 ==> Preload func main
2025/12/19 11:10:35 ==> Load > AliasType T
2025/12/19 11:10:35.418489 [INFO] typesutil/gopinfo.go:265: ==> Use: int type int
2025/12/19 11:10:35.418509 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:35.418522 [INFO] typesutil/gopinfo.go:215: ==> Type: int int
2025/12/19 11:10:35 AliasType T int
2025/12/19 11:10:35.418550 [INFO] typesutil/gopinfo.go:251: ==> Def: T type T
2025/12/19 11:10:35 ==> LookupParent T => type T
2025/12/19 11:10:35.418572 [INFO] typesutil/gopinfo.go:265: ==> Use: T type T
2025/12/19 11:10:35.418582 [INFO] typesutil/gopinfo.go:215: ==> Type: T int
2025/12/19 11:10:35.418590 [INFO] typesutil/gopinfo.go:215: ==> Type: T int
2025/12/19 11:10:35 ==> Load var int [v]
2025/12/19 11:10:35 NewVarDefs
2025/12/19 11:10:35 NewVar [v]
2025/12/19 11:10:35.418623 [INFO] typesutil/gopinfo.go:251: ==> Def: v var v int
2025/12/19 11:10:35 ==> Load func demo
2025/12/19 11:10:35 ==> LookupParent T => type T
2025/12/19 11:10:35.418648 [INFO] typesutil/gopinfo.go:265: ==> Use: T type T
2025/12/19 11:10:35.418659 [INFO] typesutil/gopinfo.go:215: ==> Type: T int
2025/12/19 11:10:35.418668 [INFO] typesutil/gopinfo.go:215: ==> Type: T int
2025/12/19 11:10:35.418682 [INFO] typesutil/gopinfo.go:251: ==> Def: v var v int
2025/12/19 11:10:35.418700 [INFO] typesutil/gopinfo.go:251: ==> Def: demo func demo(v int)
2025/12/19 11:10:35 NewFunc demo func(v int)
2025/12/19 11:10:35.418732 [INFO] typesutil/gopinfo.go:265: ==> Use: fmt package fmt
2025/12/19 11:10:35.418749 [INFO] typesutil/gopinfo.go:265: ==> Use: Println func fmt.Println(a ...any) (n int, err error)
2025/12/19 11:10:35 Val Println func(a ...any) (n int, err error)
2025/12/19 11:10:35 Val v int
2025/12/19 11:10:35.418790 [INFO] typesutil/gopinfo.go:265: ==> Use: v var v int
2025/12/19 11:10:35.418800 [INFO] typesutil/gopinfo.go:215: ==> Type: v int
2025/12/19 11:10:35 Call 1 0 // func(a ...any) (n int, err error)
2025/12/19 11:10:35 ==> MatchFuncCall func(a ...any) (n int, err error) args: 1 flags: 0
2025/12/19 11:10:35 ==> MatchType int, any
2025/12/19 11:10:35.418938 [INFO] typesutil/gopinfo.go:215: ==> Type: &{fmt Println} func(a ...any) (n int, err error)
2025/12/19 11:10:35.418965 [INFO] typesutil/gopinfo.go:215: ==> Type: &{0xc0008197b8 78 [v] 0 [] 80 0} (n int, err error)
2025/12/19 11:10:35.418985 [INFO] typesutil/gopinfo.go:332: ==> Scope: func demo scope 0xc0002b2780 {
.  var v int
}

2025/12/19 11:10:35 End // Func
2025/12/19 11:10:35 ==> Load func main
2025/12/19 11:10:35.419016 [INFO] typesutil/gopinfo.go:251: ==> Def: main func main()
2025/12/19 11:10:35 NewFunc main func()
2025/12/19 11:10:35 Val demo func(v int)
2025/12/19 11:10:35.419045 [INFO] typesutil/gopinfo.go:265: ==> Use: demo func demo(v int)
2025/12/19 11:10:35.419055 [INFO] typesutil/gopinfo.go:215: ==> Type: demo func(v int)
2025/12/19 11:10:35 Val &{0 INT 100} *ast.BasicLit
2025/12/19 11:10:35.419088 [INFO] typesutil/gopinfo.go:215: ==> Type: &{104 INT 100 <nil>} untyped int
2025/12/19 11:10:35 Call 1 0 // func(v int)
2025/12/19 11:10:35 ==> MatchFuncCall func(v int) args: 1 flags: 0
2025/12/19 11:10:35 ==> MatchType untyped int (100), int
2025/12/19 11:10:35.419142 [INFO] typesutil/gopinfo.go:215: ==> Type: &{demo 103 [0xc000731dd0] 0 [] 107 0} ()
2025/12/19 11:10:35.419159 [INFO] typesutil/gopinfo.go:332: ==> Scope: func main scope 0xc0002b28a0 {
}

2025/12/19 11:10:35 End // Func
    info_test.go:226: ====== check types pass (count: 9) ======
        000:  4:10 | int                 *ast.Ident                     | type    : int | type
        001:  5: 7 | T                   *ast.Ident                     | type    : int | type
        002:  6:13 | T                   *ast.Ident                     | type    : int | type
        003:  7: 2 | fmt.Println         *ast.SelectorExpr              | value   : func(a ...any) (n int, err error) | value
        004:  7: 2 | fmt.Println(v)      *ast.CallExpr                  | value   : (n int, err error) | value
        005:  7:14 | v                   *ast.Ident                     | var     : int | variable
        006: 10: 2 | demo                *ast.Ident                     | value   : func(v int) | value
        007: 10: 2 | demo(100)           *ast.CallExpr                  | void    : () | no value
        008: 10: 7 | 100                 *ast.BasicLit                  | value   : INT = 100 | constant
    info_test.go:226: ====== check defs pass (count: 5) ======
        000:  4: 6 | T                   | type T
        001:  5: 5 | v                   | var v int
        002:  6: 6 | demo                | func demo(v int)
        003:  6:11 | v                   | var v int
        004:  9: 6 | main                | func main()
    info_test.go:226: ====== check uses pass (count: 7) ======
        000:  4:10 | int                 | type int
        001:  5: 7 | T                   | type T
        002:  6:13 | T                   | type T
        003:  7: 2 | fmt                 | package fmt
        004:  7: 6 | Println             | func fmt.Println(a ...any) (n int, err error)
        005:  7:14 | v                   | var v int
        006: 10: 2 | demo                | func demo(v int)
--- PASS: TestTypesAlias (1.17s)
PASS
coverage: 22.6% of statements
ok  	github.com/goplus/xgo/x/typesutil	71.504s	coverage: 22.6% of statements
=== RUN   TestIsLocal
--- PASS: TestIsLocal (0.00s)
=== RUN   TestParseOne
--- PASS: TestParseOne (0.00s)
=== RUN   TestParseAll_wildcard1
--- PASS: TestParseAll_wildcard1 (0.00s)
=== RUN   TestParseAll_wildcard2
--- PASS: TestParseAll_wildcard2 (0.00s)
=== RUN   TestParseAll_multiFiles
--- PASS: TestParseAll_multiFiles (0.00s)
=== RUN   TestParseAll_multiProjs
--- PASS: TestParseAll_multiProjs (0.00s)
=== RUN   TestParseAllErr
--- PASS: TestParseAllErr (0.00s)
PASS
coverage: 100.0% of statements
ok  	github.com/goplus/xgo/x/xgoprojs	0.008s	coverage: 100.0% of statements
Uploading coverage to Codecov...
/app/run.sh: line 20: curl: command not found
