Scope: all 10 workspace projects
Lockfile is up to date, resolution step is skipped
Already up to date

â•­ Warning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®â”‚                                                                              â”‚â”‚   Ignored build scripts: unrs-resolver.                                      â”‚â”‚   Run "pnpm approve-builds" to pick which dependencies should be allowed     â”‚â”‚   to run scripts.                                                            â”‚â”‚                                                                              â”‚â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

. prepare$ husky && pnpm build
. prepare: > mermaid-monorepo@10.2.4 build /app
. prepare: > pnpm build:esbuild && pnpm build:types
. prepare: > mermaid-monorepo@10.2.4 build:esbuild /app
. prepare: > pnpm run -r clean && tsx .esbuild/build.ts
. prepare: Scope: 9 of 10 workspace projects
. prepare: packages/parser clean$ rimraf dist src/language/generated
. prepare: packages/tiny clean$ rimraf dist
. prepare: packages/tiny clean: Done
. prepare: packages/parser clean: Done
. prepare: packages/mermaid clean$ rimraf dist
. prepare: packages/mermaid clean: Done
. prepare: packages/examples clean$ rimraf dist
. prepare: packages/mermaid-zenuml clean$ rimraf dist
. prepare: packages/examples clean: Done
. prepare: packages/mermaid-zenuml clean: Done
. prepare: Reading config from /app/packages/parser/langium-config.json
. prepare: src/language/info/info.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/info/info.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/info/info.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/common/common.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/common/common.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/common/common.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/packet/packet.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/packet/packet.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/packet/packet.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/pie/pie.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/pie/pie.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/pie/pie.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/architecture/architecture.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/architecture/architecture.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/architecture/architecture.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:29:15 - Found multiple assignments to 'id' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:30:18 - Found multiple assignments to 'message' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:32:18 - Found multiple assignments to 'type' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:42:15 - Found multiple assignments to 'id' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:44:18 - Found multiple assignments to 'type' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:53:15 - Found multiple assignments to 'id' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:55:20 - Found multiple assignments to 'parent' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/radar/radar.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/radar/radar.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/radar/radar.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:17:10 - This rule is declared but never referenced.
. prepare: Writing generated files to /app/packages/parser/src/language/generated
. prepare: [18:34:52] Langium generator finished successfully in 458ms
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-FPAJGGOC.mjs    75.6kb
. prepare:   packages/parser/dist/mermaid-parser.core.mjs                           5.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-FWNWRKHM.mjs     3.8kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-O7ZBX7Z2.mjs     1.9kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-T53DSG4Q.mjs     1.5kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-S6J4BHB3.mjs     1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-76Q3JFCE.mjs     1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-LHMN2FUI.mjs     1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-LBM3YZW2.mjs     1.2kb
. prepare:   ...parser/dist/chunks/mermaid-parser.core/architecture-U656AL7Q.mjs    185b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.core/gitGraph-F6HP7TQM.mjs    169b
. prepare:   ...ages/parser/dist/chunks/mermaid-parser.core/treemap-KMMF4GRG.mjs    165b
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/packet-BFZMPI3H.mjs    161b
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/radar-NHE76QYJ.mjs     157b
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/info-NVLQJR56.mjs      153b
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/pie-7BOR55EZ.mjs       149b
. prepare:   ...es/parser/dist/chunks/mermaid-parser.core/chunk-FPAJGGOC.mjs.map  114.9kb
. prepare:   ...es/parser/dist/chunks/mermaid-parser.core/chunk-FWNWRKHM.mjs.map    8.6kb
. prepare:   packages/parser/dist/mermaid-parser.core.mjs.map                       5.3kb
. prepare:   ...es/parser/dist/chunks/mermaid-parser.core/chunk-O7ZBX7Z2.mjs.map    4.4kb
. prepare:   ...and 12 more output files...
. prepare: âš¡ Done in 44ms
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-CUV4ONQR.mjs    802.5kb
. prepare:   packages/parser/dist/mermaid-parser.esm.mjs                            5.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-AAKHKIIX.mjs      3.7kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-FJ76IR54.mjs      1.8kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-M7HE2OLO.mjs      1.5kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-DLEEDQTW.mjs      1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-VGLBXUVE.mjs      1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-B3PWJQJV.mjs      1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-25RGGQC2.mjs      1.1kb
. prepare:   .../parser/dist/chunks/mermaid-parser.esm/architecture-3LUSXU7A.mjs    185b
. prepare:   ...ages/parser/dist/chunks/mermaid-parser.esm/gitGraph-QD2FAQA2.mjs    169b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/treemap-LTEPFSZC.mjs    165b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/packet-6CSEHWCI.mjs     161b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/radar-RQNMY3TF.mjs      157b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/info-GMZAA7BQ.mjs       153b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/pie-NGLVWQ3N.mjs        149b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm/chunk-CUV4ONQR.mjs.map    1.7mb
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm/chunk-AAKHKIIX.mjs.map    8.5kb
. prepare:   packages/parser/dist/mermaid-parser.esm.mjs.map                        5.3kb
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm/chunk-FJ76IR54.mjs.map    4.3kb
. prepare:   ...and 12 more output files...
. prepare: âš¡ Done in 195ms
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-L3Q2QJVV.mjs  381.1kb
. prepare:   packages/parser/dist/mermaid-parser.esm.min.mjs                        3.5kb
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-MMNLCZD2.mjs    1.6kb
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-T7ZF25BJ.mjs    761b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-H6ZBQRVM.mjs    606b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-IHLWZL4V.mjs    470b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-OQZUXTEW.mjs    465b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-OHOCZHKG.mjs    463b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-BI2MPBQI.mjs    462b
. prepare:   ...ser/dist/chunks/mermaid-parser.esm.min/architecture-PMHMJ2ZY.mjs    132b
. prepare:   .../parser/dist/chunks/mermaid-parser.esm.min/gitGraph-EH3HN3AX.mjs    124b
. prepare:   ...s/parser/dist/chunks/mermaid-parser.esm.min/treemap-KOFTZR4J.mjs    122b
. prepare:   ...es/parser/dist/chunks/mermaid-parser.esm.min/packet-AGCPRN6G.mjs    120b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/radar-S7LXCSCY.mjs    118b
. prepare:   ...ages/parser/dist/chunks/mermaid-parser.esm.min/info-HLY6SS6Y.mjs    116b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm.min/pie-65AXTC64.mjs    114b
. prepare:   ...parser/dist/chunks/mermaid-parser.esm.min/chunk-L3Q2QJVV.mjs.map    1.8mb
. prepare:   ...parser/dist/chunks/mermaid-parser.esm.min/chunk-MMNLCZD2.mjs.map    8.8kb
. prepare:   packages/parser/dist/mermaid-parser.esm.min.mjs.map                    5.3kb
. prepare:   ...parser/dist/chunks/mermaid-parser.esm.min/chunk-T7ZF25BJ.mjs.map    4.7kb
. prepare:   ...and 12 more output files...
. prepare: âš¡ Done in 195ms
. prepare:   packages/mermaid/dist/chunks/mermaid.core/chunk-CAFDVSDF.mjs         190.3kb
. prepare:   ...es/mermaid/dist/chunks/mermaid.core/sequenceDiagram-4MFPAR3R.mjs  166.8kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/blockDiagram-5IDQRC4B.mjs  134.2kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/chunk-5BCPVKH7.mjs         130.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/c4Diagram-HCZS3EEQ.mjs     117.7kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/flowDiagram-5V7A6S4G.mjs   102.3kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/chunk-PVNIGLJ4.mjs          91.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/chunk-ZR6OO2LE.mjs          77.6kb
. prepare:   ...ges/mermaid/dist/chunks/mermaid.core/xychartDiagram-SP5YYICK.mjs   72.3kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/ganttDiagram-FIS3RHJN.mjs   71.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/chunk-5CXSD3S5.mjs          70.1kb
. prepare:   ...es/mermaid/dist/chunks/mermaid.core/gitGraphDiagram-RZLGS73G.mjs   61.4kb
. prepare:   ...es/mermaid/dist/chunks/mermaid.core/quadrantDiagram-BCQQWS3J.mjs   61.1kb
. prepare:   ...mermaid/dist/chunks/mermaid.core/requirementDiagram-45J2LMHI.mjs   51.8kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/erDiagram-JJLDHNQT.mjs      46.6kb
. prepare:   ...ermaid/dist/chunks/mermaid.core/timeline-definition-ZHKM64B3.mjs   45.6kb
. prepare:   ...ges/mermaid/dist/chunks/mermaid.core/journeyDiagram-Z5LJP3VD.mjs   44.9kb
. prepare:   ...mermaid/dist/chunks/mermaid.core/mindmap-definition-5Q5I5IMX.mjs   43.4kb
. prepare:   ...ermaid/dist/chunks/mermaid.core/architectureDiagram-WHXNGPGA.mjs   43.3kb
. prepare:   packages/mermaid/dist/mermaid.core.mjs                                42.6kb
. prepare:   ...and 74 more output files...
. prepare: âš¡ Done in 2124ms
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-MBJCTAW2.mjs      433.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-L6MQJ2ZU.mjs      346.9kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/katex-RV2QPRKB.mjs      270.1kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-JBDS5CFN.mjs      241.5kb
. prepare:   ...aid/dist/chunks/mermaid.esm.min/architectureDiagram-QZI37QU3.mjs  148.2kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-JV2GL4YY.mjs      115.1kb
. prepare:   ...maid/dist/chunks/mermaid.esm.min/mindmap-definition-C6ZSUO3D.mjs  101.9kb
. prepare:   ...mermaid/dist/chunks/mermaid.esm.min/sequenceDiagram-22JRJPPJ.mjs   95.5kb
. prepare:   ...es/mermaid/dist/chunks/mermaid.esm.min/blockDiagram-EIMLCARR.mjs   70.4kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/c4Diagram-LE32TTGY.mjs   68.8kb
. prepare:   ...ges/mermaid/dist/chunks/mermaid.esm.min/flowDiagram-AZMRAUQX.mjs   59.5kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-CLXIQ5J6.mjs       57.1kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-ISRNPYBD.mjs       44.3kb
. prepare:   ...es/mermaid/dist/chunks/mermaid.esm.min/ganttDiagram-QXBDFQ5F.mjs   42.3kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-7LIB5WBN.mjs       41.4kb
. prepare:   .../mermaid/dist/chunks/mermaid.esm.min/xychartDiagram-QMMHAOKB.mjs   38.1kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-PUY575DY.mjs       35.8kb
. prepare:   ...mermaid/dist/chunks/mermaid.esm.min/quadrantDiagram-TU35FU7T.mjs   33.0kb
. prepare:   ...maid/dist/chunks/mermaid.esm.min/requirementDiagram-2QJQGYYE.mjs   29.7kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-FASC7IG4.mjs       27.8kb
. prepare:   ...and 124 more output files...
. prepare: âš¡ Done in 3519ms
. prepare:   packages/mermaid/dist/mermaid.tiny.min.js  1.7mb âš ï¸
. prepare: âš¡ Done in 3615ms
. prepare:   packages/mermaid/dist/mermaid.min.js       2.6mb âš ï¸
. prepare:   packages/mermaid/dist/mermaid.min.js.map  10.2mb
. prepare: âš¡ Done in 4436ms
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-COUQ6RZ3.mjs          933.4kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-YOB5EFFC.mjs          697.6kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/katex-A6QSACVP.mjs          494.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-2LMPSOYE.mjs          436.7kb
. prepare:   ...mermaid/dist/chunks/mermaid.esm/architectureDiagram-HQJI2CQA.mjs  417.2kb
. prepare:   .../mermaid/dist/chunks/mermaid.esm/mindmap-definition-ACOBXW7T.mjs  250.2kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-RS2X7L4X.mjs          232.4kb
. prepare:   ...ges/mermaid/dist/chunks/mermaid.esm/sequenceDiagram-CFSNADHA.mjs  167.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/blockDiagram-LWCUCYDG.mjs   134.2kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/c4Diagram-BL5AJUSD.mjs      117.8kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/flowDiagram-5F2WN3J7.mjs    102.4kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-6E2L56I3.mjs           93.4kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-W3YOBQ4T.mjs           91.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/ganttDiagram-5B6NCQMD.mjs    81.8kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-TGZYFRKZ.mjs           78.5kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-PRVDS7KV.mjs           77.6kb
. prepare:   ...ages/mermaid/dist/chunks/mermaid.esm/xychartDiagram-23T37V4G.mjs   72.3kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-URYKITSV.mjs           70.1kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-IHYUGLNO.mjs           62.9kb
. prepare:   ...ges/mermaid/dist/chunks/mermaid.esm/gitGraphDiagram-QPGFWVTA.mjs   61.7kb
. prepare:   ...and 124 more output files...
. prepare: âš¡ Done in 4720ms
. prepare:   packages/mermaid/dist/mermaid.js       6.1mb âš ï¸
. prepare:   packages/mermaid/dist/mermaid.js.map  10.2mb
. prepare: âš¡ Done in 5178ms
. prepare:   ...unks/mermaid-example-diagram.core/diagram-definition-AUF2VOIT.mjs  22.5kb
. prepare:   ...ges/mermaid-example-diagram/dist/mermaid-example-diagram.core.mjs   557b
. prepare:   ...agram/dist/chunks/mermaid-example-diagram.core/chunk-AKMCXCCK.mjs   291b
. prepare:   .../mermaid-example-diagram.core/diagram-definition-AUF2VOIT.mjs.map  40.9kb
. prepare:   ...mermaid-example-diagram/dist/mermaid-example-diagram.core.mjs.map   786b
. prepare:   ...m/dist/chunks/mermaid-example-diagram.core/chunk-AKMCXCCK.mjs.map    93b
. prepare: âš¡ Done in 35ms
. prepare:   ...unks/mermaid-example-diagram.esm/diagram-definition-ZN3FLJNS.mjs  109.0kb
. prepare:   ...ges/mermaid-example-diagram/dist/mermaid-example-diagram.esm.mjs    555b
. prepare:   ...agram/dist/chunks/mermaid-example-diagram.esm/chunk-6XSXFHVP.mjs    291b
. prepare:   .../mermaid-example-diagram.esm/diagram-definition-ZN3FLJNS.mjs.map  215.0kb
. prepare:   ...mermaid-example-diagram/dist/mermaid-example-diagram.esm.mjs.map    786b
. prepare:   ...m/dist/chunks/mermaid-example-diagram.esm/chunk-6XSXFHVP.mjs.map     93b
. prepare: âš¡ Done in 85ms
. prepare:   .../mermaid-example-diagram.esm.min/diagram-definition-2JINLXFM.mjs   53.0kb
. prepare:   ...mermaid-example-diagram/dist/mermaid-example-diagram.esm.min.mjs    355b
. prepare:   ...m/dist/chunks/mermaid-example-diagram.esm.min/chunk-D2P5M7FY.mjs    164b
. prepare:   ...maid-example-diagram.esm.min/diagram-definition-2JINLXFM.mjs.map  227.2kb
. prepare:   ...aid-example-diagram/dist/mermaid-example-diagram.esm.min.mjs.map    860b
. prepare:   ...st/chunks/mermaid-example-diagram.esm.min/chunk-D2P5M7FY.mjs.map     93b
. prepare: âš¡ Done in 85ms
. prepare:   ...uml/dist/chunks/mermaid-zenuml.core/zenuml-definition-AWJE5BBT.mjs  3.2kb
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.core.mjs                   520b
. prepare:   .../mermaid-zenuml/dist/chunks/mermaid-zenuml.core/chunk-CJCKSLXZ.mjs  151b
. prepare:   ...dist/chunks/mermaid-zenuml.core/zenuml-definition-AWJE5BBT.mjs.map  6.7kb
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.core.mjs.map               765b
. prepare:   ...maid-zenuml/dist/chunks/mermaid-zenuml.core/chunk-CJCKSLXZ.mjs.map   93b
. prepare: âš¡ Done in 5ms
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.js      5.1mb âš ï¸
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.js.map  6.4mb
. prepare: âš¡ Done in 683ms
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.min.js      4.1mb âš ï¸
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.min.js.map  6.2mb
. prepare: âš¡ Done in 698ms
. prepare:   ...ml/dist/chunks/mermaid-zenuml.esm/zenuml-definition-H5KMDA2O.mjs  4.9mb âš ï¸
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.esm.mjs                  518b
. prepare:   ...mermaid-zenuml/dist/chunks/mermaid-zenuml.esm/chunk-OS44DIFC.mjs  151b
. prepare:   ...ist/chunks/mermaid-zenuml.esm/zenuml-definition-H5KMDA2O.mjs.map  6.4mb
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.esm.mjs.map              765b
. prepare:   ...aid-zenuml/dist/chunks/mermaid-zenuml.esm/chunk-OS44DIFC.mjs.map   93b
. prepare: âš¡ Done in 763ms
. prepare:   ...ist/chunks/mermaid-zenuml.esm.min/zenuml-definition-XJYTECJ4.mjs  4.1mb âš ï¸
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.esm.min.mjs              323b
. prepare:   ...aid-zenuml/dist/chunks/mermaid-zenuml.esm.min/chunk-VDOFMJQL.mjs   95b
. prepare:   ...chunks/mermaid-zenuml.esm.min/zenuml-definition-XJYTECJ4.mjs.map  6.2mb
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.esm.min.mjs.map          837b
. prepare:   ...zenuml/dist/chunks/mermaid-zenuml.esm.min/chunk-VDOFMJQL.mjs.map   93b
. prepare: âš¡ Done in 814ms
. prepare:   ...ayout-elk/dist/chunks/mermaid-layout-elk.core/render-M6WAID4X.mjs  26.7kb
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.core.mjs           543b
. prepare:   ...layout-elk/dist/chunks/mermaid-layout-elk.core/chunk-ZW26E7AF.mjs   151b
. prepare:   ...t-elk/dist/chunks/mermaid-layout-elk.core/render-M6WAID4X.mjs.map  52.2kb
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.core.mjs.map       827b
. prepare:   ...ut-elk/dist/chunks/mermaid-layout-elk.core/chunk-ZW26E7AF.mjs.map    93b
. prepare: âš¡ Done in 12ms
. prepare:   ...ayout-elk/dist/chunks/mermaid-layout-elk.esm/render-P27B6YR6.mjs  3.6mb âš ï¸
. prepare:   ...layout-elk/dist/chunks/mermaid-layout-elk.esm/chunk-TWI3KLJS.mjs  1.8kb
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.esm.mjs          541b
. prepare:   ...t-elk/dist/chunks/mermaid-layout-elk.esm/render-P27B6YR6.mjs.map  4.4mb
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.esm.mjs.map      827b
. prepare:   ...ut-elk/dist/chunks/mermaid-layout-elk.esm/chunk-TWI3KLJS.mjs.map   93b
. prepare: âš¡ Done in 925ms
. prepare:   ...t-elk/dist/chunks/mermaid-layout-elk.esm.min/render-DDKIELPE.mjs  1.6mb âš ï¸
. prepare:   ...ut-elk/dist/chunks/mermaid-layout-elk.esm.min/chunk-SP2CHFBE.mjs  854b
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.esm.min.mjs      356b
. prepare:   ...k/dist/chunks/mermaid-layout-elk.esm.min/render-DDKIELPE.mjs.map  4.9mb
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.esm.min.mjs.map  842b
. prepare:   ...lk/dist/chunks/mermaid-layout-elk.esm.min/chunk-SP2CHFBE.mjs.map   93b
. prepare: âš¡ Done in 969ms
. prepare:   packages/examples/dist/mermaid-examples.core.mjs      15.7kb
. prepare:   packages/examples/dist/mermaid-examples.core.mjs.map  24.8kb
. prepare: âš¡ Done in 8ms
. prepare:   packages/examples/dist/mermaid-examples.esm.min.mjs      13.2kb
. prepare:   packages/examples/dist/mermaid-examples.esm.min.mjs.map  24.5kb
. prepare: âš¡ Done in 8ms
. prepare:   packages/examples/dist/mermaid-examples.esm.mjs      15.7kb
. prepare:   packages/examples/dist/mermaid-examples.esm.mjs.map  24.8kb
. prepare: âš¡ Done in 9ms
. prepare: > mermaid-monorepo@10.2.4 build:types /app
. prepare: > pnpm --filter mermaid types:build-config && tsx .build/types.ts
. prepare: > mermaid@11.10.0 types:build-config /app/packages/mermaid
. prepare: > tsx scripts/create-types-from-json-schema.mts
. prepare: Writing typescript file to ./src/config.type.ts
. prepare: Building types for parser
. prepare: Building types for mermaid
. prepare: Building types for mermaid-example-diagram
. prepare: Building types for mermaid-zenuml
. prepare: Building types for mermaid-layout-elk
. prepare: Building types for examples
. prepare: Done
Done in 32.7s using pnpm v10.4.1

> mermaid-monorepo@10.2.4 test /app
> pnpm lint && vitest run


> mermaid-monorepo@10.2.4 lint /app
> eslint --quiet --stats --cache --cache-strategy content . && pnpm lint:jison && prettier --cache --check .


> mermaid-monorepo@10.2.4 lint:jison /app
> tsx ./scripts/jison/lint.mts

Linting ./packages/mermaid-example-diagram/src/parser/exampleDiagram.jison
Linting ./packages/mermaid/src/diagrams/block/parser/block.jison
Linting ./packages/mermaid/src/diagrams/c4/parser/c4Diagram.jison
Linting ./packages/mermaid/src/diagrams/class/parser/classDiagram.jison
Linting ./packages/mermaid/src/diagrams/er/parser/erDiagram.jison
Linting ./packages/mermaid/src/diagrams/flowchart/parser/flow.jison
Linting ./packages/mermaid/src/diagrams/gantt/parser/gantt.jison
Linting ./packages/mermaid/src/diagrams/kanban/parser/kanban.jison
Linting ./packages/mermaid/src/diagrams/mindmap/parser/mindmap.jison
Linting ./packages/mermaid/src/diagrams/quadrant-chart/parser/quadrant.jison
Linting ./packages/mermaid/src/diagrams/sankey/parser/sankey.jison
Linting ./packages/mermaid/src/diagrams/requirement/parser/requirementDiagram.jison
Linting ./packages/mermaid/src/diagrams/timeline/parser/timeline.jison
Linting ./packages/mermaid/src/diagrams/sequence/parser/sequenceDiagram.jison
Linting ./packages/mermaid/src/diagrams/state/parser/stateDiagram.jison
Linting ./packages/mermaid/src/diagrams/xychart/parser/xychart.jison
Linting ./packages/mermaid/src/diagrams/user-journey/parser/journey.jison
Checking formatting...
All matched files use Prettier code style!
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid-example-diagram/src/exampleDiagramDb.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid-example-diagram/src/exampleDiagramRenderer.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid-example-diagram/src/styles.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/clusters.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/createLabel.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/edges.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/index.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/intersect/index.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-circle.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-ellipse.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-line.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-node.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-polygon.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-rect.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/markers.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/mermaid-graphlib.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/nodes.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/shapes/note.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/dagre-wrapper/shapes/util.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/c4/c4Db.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/c4/c4Renderer.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/c4/styles.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/c4/svgDraw.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/class/styles.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/er/erMarkers.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/er/erRenderer.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/gantt/ganttDb.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/gantt/ganttRenderer.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/gantt/styles.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/git/styles.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/requirement/styles.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/sankey/styles.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/sequence/styles.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/sequence/svgDraw.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/state/shapes.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/state/stateRenderer.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/state/styles.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/timeline/styles.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/timeline/svgDraw.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/timeline/timelineDb.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/user-journey/journeyDb.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/user-journey/styles.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/diagrams/user-journey/svgDraw.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/insertElementsForSize.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/layout-algorithms/dagre/index.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/clusters.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/createLabel.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/edges.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/index.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-circle.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-ellipse.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-line.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-node.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-polygon.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-rect.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/rendering-util/rendering-elements/markers.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/setupGraphViewbox.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/themes/index.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/themes/theme-base.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/themes/theme-dark.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/themes/theme-default.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/themes/theme-forest.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/themes/theme-helpers.js' because it would overwrite input file.
6:36:44 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/app/packages/mermaid/src/themes/theme-neutral.js' because it would overwrite input file.

 RUN  v3.0.6 /app

 âœ“ packages/mermaid/src/utils/lineWithOffset.ts (2 tests) 7ms
 âœ“ packages/mermaid/src/utils/imperativeState.spec.ts (3 tests) 8ms
 âœ“ packages/mermaid/src/diagrams/treemap/utils.test.ts (4 tests) 10ms
 âœ“ packages/mermaid/src/rendering-util/rendering-elements/edgeMarker.spec.ts (5 tests) 14ms
 âœ“ packages/mermaid/src/dagre-wrapper/edgeMarker.spec.ts (5 tests) 10ms
 âœ“ packages/mermaid/src/diagram-api/comments.spec.ts (5 tests) 30ms
 âœ“ packages/mermaid/src/diagrams/quadrant-chart/parser/quadrant.jison.spec.ts (14 tests) 42ms
 âœ“ packages/mermaid/src/diagrams/common/common.spec.ts (20 tests) 53ms
 âœ“ packages/mermaid/src/rendering-util/splitText.spec.ts (35 tests) 63ms
 âœ“ packages/mermaid/src/diagrams/flowchart/flowChartShapes.spec.js (11 tests) 23ms
 âœ“ packages/mermaid/src/diagrams/xychart/parser/xychart.jison.spec.ts (48 tests) 53ms
 âœ“ packages/mermaid/src/diagram-api/frontmatter.spec.ts (12 tests) 33ms
 âœ“ packages/mermaid/src/docs/.vitepress/theme/redirect.spec.ts (28 tests) 23ms
stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
47.879 : DEBUG :  Opting in, graph
47.879 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
47.879 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
47.879 : DEBUG :  Not a cluster  c { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
47.879 : DEBUG :  Cluster identified C1 { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
47.879 : DEBUG :  Cluster identified C2 { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
47.879 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
47.879 : DEBUG :  Extracting node a {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
47.879 : DEBUG :  Not a cluster a [33m0[39m
47.879 : DEBUG :  Extracting node b {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
47.879 : DEBUG :  Not a cluster b [33m0[39m
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
47.879 : WARN :  Cluster identified C1  Replacement id in edges:  a
47.879 : DEBUG :  Extracting node c {
47.879 : WARN :  Cluster identified C2  Replacement id in edges:  c
47.879 : WARN :  Edge a -> b: {"v":"a","w":"b"}
47.879 : WARN :  Edge a -> b: {}
47.879 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: a b Translating:  [90mundefined[39m  ---  [90mundefined[39m
47.879 : WARN :  Edge C1 -> C2: {"v":"C1","w":"C2"}
47.879 : WARN :  Edge C1 -> C2: {}
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
47.879 : DEBUG :  Not a cluster c [33m0[39m
47.879 : DEBUG :  Extracting node C1 {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.879 : INFO :  cp  a  to  C1  with parent  C1
47.879 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
47.879 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.879 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m }, { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
47.879 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m }
47.879 : INFO :  Edge data {} C1
47.879 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
47.879 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m }
47.879 : INFO :  Copying as  a b {} [90mundefined[39m
47.879 : INFO :  newGraph edges  [ { v: [32m'a'[39m, w: [32m'b'[39m } ] {}
47.879 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
47.879 : INFO :  Edge data {} C1
47.879 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
47.879 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
47.879 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
47.879 : DEBUG :  Removing node a
47.879 : WARN :  Fix XXX {
47.879 : INFO :  cp  b  to  C1  with parent  C1
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
47.879 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
47.879 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
47.879 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
} ids: C1 C2 Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'c'[39m, clusterData: [90mundefined[39m }
47.879 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
47.879 : WARN :  Fixing and trixing - removing XXX C1 C2 [90mundefined[39m
47.879 : INFO :  Edge data {} C1
47.879 : WARN :  Fix Replacing with XXX C1 C2 [90mundefined[39m
47.879 : WARN :  Adjusted Graph {
47.879 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.879 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
  nodes: [
47.879 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
47.879 : DEBUG :  Removing node b
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
47.879 : DEBUG :  Old graph after copy {
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    { v: [32m'C1'[39m },
  nodes: [
    { v: [32m'C2'[39m }
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.879 : DEBUG :  Extracting node C2 {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.879 : INFO :  cp  c  to  C2  with parent  C2
47.879 : INFO :  In copy  C2 root C2 data [90mundefined[39m C2
  ],
47.879 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
47.879 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.879 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
}
47.879 : INFO :  Edge data {} C2
47.879 : WARN :  extractor -  [33m0[39m {
47.879 : INFO :  Descendants of  C2  is  [ [32m'c'[39m ]
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.879 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
47.879 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
47.879 : DEBUG :  Removing node c
  nodes: [
47.879 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'C1'[39m, value: [36m[Object][39m }, { v: [32m'C2'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
}
47.879 : DEBUG :  Done, no node has children [ [32m'a'[39m, [32m'b'[39m ]
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
47.879 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
47.879 : INFO :  [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
    { v: [32m'C2'[39m }

  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.879 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
47.879 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.879 : WARN :  Copying children of  C1 root C1 data [90mundefined[39m C1
47.879 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m, [32m'b'[39m ]
47.879 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: {} }, { v: [32m'b'[39m, value: {} } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.879 : WARN :  Cluster without external connections, without a parent and with children C2 [33m0[39m
47.879 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.879 : WARN :  Copying children of  C2 root C2 data [90mundefined[39m C2
47.879 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'c'[39m ]
47.879 : WARN :  New graph after copy node: ( C2 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: {} } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.879 : WARN :  New list of nodes [ [32m'C1'[39m, [32m'C2'[39m ]
47.879 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: {}, b: {} },
    _parent: { a: [32m'\x00'[39m, b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {}, b: {} },
    _in: { a: {}, b: [36m[Object][39m },
    _preds: { a: {}, b: [36m[Object][39m },
    _out: { a: [36m[Object][39m, b: {} },
    _sucs: { a: [36m[Object][39m, b: {} },
    _edgeObjs: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'a\x01b\x01\x00'[39m: {} },
    _nodeCount: [33m2[39m,
    _edgeCount: [33m1[39m
  }
}
47.879 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: {} }, { v: [32m'b'[39m, value: {} } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.879 : WARN :   Now next level C2 {
  clusterNode: [33mtrue[39m,
  id: [32m'C2'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: {} },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
47.899 : DEBUG :  Opting in, graph
47.899 : DEBUG :  Not a cluster  a { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
47.899 : DEBUG :  Not a cluster  b { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
47.899 : DEBUG :  Not a cluster  c { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
47.899 : DEBUG :  Cluster identified C1 { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
47.899 : DEBUG :  Cluster identified C2 { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
47.899 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
47.899 : DEBUG :  Extracting node a {
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
47.879 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: {} } ],
  edges: [],
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [90mundefined[39m
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m

47.899 : DEBUG :  Not a cluster a [33m0[39m
47.899 : DEBUG :  Extracting node b {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
47.899 : WARN :  Cluster identified C1  Replacement id in edges:  b
47.899 : WARN :  Cluster identified C2  Replacement id in edges:  a
47.899 : WARN :  Edge:  { v: [32m'a'[39m, w: [32m'b'[39m }  leaves cluster  C2
47.899 : WARN :  Descendants of XXX  C2 :  [ [32m'a'[39m ]
47.899 : WARN :  Edge a -> b: {"v":"a","w":"b"}
47.899 : WARN :  Edge a -> b: {"name":"C1-internal-link"}
47.899 : WARN :  Fix XXX {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} ids: a b Translating:  [90mundefined[39m  ---  [90mundefined[39m
} [90mundefined[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
47.899 : WARN :  Edge C1 -> c: {"v":"C1","w":"c"}
47.899 : WARN :  Edge C1 -> c: {"name":"C1-external-link"}
47.899 : WARN :  Fix XXX {
47.899 : DEBUG :  Not a cluster b [33m0[39m
47.899 : DEBUG :  Extracting node c {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [90mundefined[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
47.899 : DEBUG :  Not a cluster c [33m0[39m
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} ids: C1 c Translating:  { id: [32m'b'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
47.899 : WARN :  Fixing and trixing - removing XXX C1 c [90mundefined[39m
47.899 : WARN :  Fix Replacing with XXX C1 c [90mundefined[39m
47.899 : DEBUG :  Extracting node C1 {
47.899 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  nodes: [
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
47.899 : INFO :  cp  b  to  C1  with parent  C1
47.899 : INFO :  In copy  C1 root C1 data { data: [33m4[39m } C1
47.899 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.899 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m } ]
47.899 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m }
47.899 : INFO :  Edge data { name: [32m'C1-internal-link'[39m } C1
47.899 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
    { v: [32m'C1'[39m, value: [36m[Object][39m },
47.899 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m }
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
47.899 : INFO :  Copying as  a b { name: [32m'C1-internal-link'[39m } [90mundefined[39m
  ],
47.899 : INFO :  newGraph edges  [ { v: [32m'a'[39m, w: [32m'b'[39m } ] { name: [32m'C1-internal-link'[39m }
  edges: [
47.899 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
47.899 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
47.899 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
47.899 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
47.899 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
47.899 : DEBUG :  Removing node b
47.899 : INFO :  cp  a  to  C1  with parent  C2
47.899 : DEBUG :  Setting parent a C2
47.899 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'c'[39m } ]
47.899 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
47.899 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
47.899 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
47.899 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.899 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
47.899 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
47.899 : DEBUG :  Removing node a
47.899 : INFO :  cp  C2  to  C1  with parent  C2
47.899 : INFO :  In copy  C2 root C1 data { data: [33m5[39m } C1
47.899 : DEBUG :  Not Setting parent for node= C2 cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
    { v: [32m'C1'[39m, value: [36m[Object][39m },
47.899 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'c'[39m } ]
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
47.899 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
  ],
47.899 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
  edges: [
47.899 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
47.899 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
47.899 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
47.899 : DEBUG :  Removing node C2
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
47.899 : DEBUG :  Removing node C2
  ],
47.899 : DEBUG :  Old graph after copy {
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
} [90mundefined[39m
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m }, { v: [32m'C1'[39m, value: [36m[Object][39m } ],
47.899 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
  edges: [ { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m } ],
47.899 : WARN :  Old graph before copy {
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
}
  nodes: [
47.899 : DEBUG :  Extracting node C2 {
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
    { v: [32m'c'[39m, value: [36m[Object][39m },
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
47.899 : DEBUG :  {
  ],
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  edges: [
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
}
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
47.899 : DEBUG :  Nodes =  [ [32m'b'[39m, [32m'a'[39m, [32m'C2'[39m ] [33m1[39m
  ],
47.899 : DEBUG :  Extracting node b {
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
}
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
47.899 : WARN :  Copying children of  C1 root C1 data { data: [33m4[39m } C1
} [90mundefined[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m1[39m
47.899 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'b'[39m, [32m'C2'[39m ]
47.899 : DEBUG :  Not a cluster b [33m1[39m
47.899 : WARN :  Copying children of  C2 root C1 data { data: [33m5[39m } C1
47.899 : DEBUG :  Extracting node a {
47.899 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'a'[39m, [32m'C2'[39m ]
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
47.899 : WARN :  Setting parent a C2
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
47.899 : WARN :  New graph after copy node: ( C1 ) {
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m1[39m
47.899 : DEBUG :  Not a cluster a [33m1[39m
47.899 : DEBUG :  Extracting node C2 {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m5[39m } [90mundefined[39m  Depth  [33m1[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.899 : WARN :  Cluster **  C2  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
47.899 : WARN :  New list of nodes [ [32m'c'[39m, [32m'C1'[39m ]
47.899 : WARN :   Now next level c { data: [33m3[39m }
47.899 : DEBUG :  {
47.899 : WARN :   Now next level C1 {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  clusterNode: [33mtrue[39m,
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
  id: [32m'C1'[39m,
}
  clusterData: { data: [33m4[39m },
47.899 : INFO :  [ [32m'c'[39m, [32m'C1'[39m ]
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m, a: [36m[Object][39m, C2: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m, a: [32m'C2'[39m, C2: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {}, a: {}, C2: [36m[Object][39m },
    _in: { b: [36m[Object][39m, a: {}, C2: {} },
    _preds: { b: [36m[Object][39m, a: {}, C2: {} },
    _out: { b: {}, a: [36m[Object][39m, C2: {} },
    _sucs: { b: {}, a: [36m[Object][39m, C2: {} },

    _edgeObjs: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
47.880 : DEBUG :  Opting in, graph
    _edgeLabels: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _nodeCount: [33m3[39m,
    _edgeCount: [33m1[39m
  }
}
47.899 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m } ],
47.880 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.880 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
} [90mundefined[39m
47.880 : DEBUG :  Not a cluster  c Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
47.899 : WARN :  Cluster **  C2  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [33mtrue[39m [90mundefined[39m [33m1[39m
47.880 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
47.899 : WARN :  New list of nodes [ [32m'b'[39m, [32m'a'[39m, [32m'C2'[39m ]
47.880 : DEBUG :  Cluster identified C2 Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
47.899 : WARN :   Now next level b { data: [33m2[39m }
47.880 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
47.899 : WARN :   Now next level a { data: [33m1[39m }
47.899 : WARN :   Now next level C2 { data: [33m5[39m }

stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
47.880 : WARN :  Cluster identified C1  Replacement id in edges:  a
47.880 : WARN :  Cluster identified C2  Replacement id in edges:  c
47.880 : WARN :  Edge a -> b: {"v":"a","w":"b"}
47.880 : WARN :  Edge a -> b: {}
47.880 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: a b Translating:  [90mundefined[39m  ---  [90mundefined[39m
47.880 : WARN :  Edge C1 -> C2: {"v":"C1","w":"C2"}
47.880 : WARN :  Edge C1 -> C2: {}
47.880 : DEBUG :  Extracting node a Map(2) {
47.880 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
47.880 : DEBUG :  Not a cluster a [33m0[39m
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
47.880 : DEBUG :  Extracting node b Map(2) {
} ids: C1 C2 Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'c'[39m, clusterData: [90mundefined[39m }
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
47.880 : WARN :  Fixing and trying - removing XXX C1 C2 [90mundefined[39m
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
47.880 : WARN :  Fix Replacing with XXX C1 C2 [90mundefined[39m
} [33mfalse[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
47.880 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.880 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.880 : DEBUG :  Not a cluster b [33m0[39m
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.880 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
47.880 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
47.880 : DEBUG :  Extracting node c Map(2) {
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.880 : WARN :  Copying children of  C1 root C1 data [90mundefined[39m C1
47.880 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m, [32m'b'[39m ]
47.880 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: {} }, { v: [32m'b'[39m, value: {} } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [33mfalse[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
47.880 : DEBUG :  Not a cluster c [33m0[39m
}
47.880 : WARN :  Cluster without external connections, without a parent and with children C2 [33m0[39m
47.880 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.880 : DEBUG :  Extracting node C1 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.880 : INFO :  cp  a  to  C1  with parent  C1
47.880 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
47.880 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.880 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m }, { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
47.880 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m }
47.880 : INFO :  Edge data {} C1
  nodes: [
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
47.880 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
47.880 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m }
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.880 : INFO :  Copying as  a b {} [90mundefined[39m
}
47.880 : INFO :  newGraph edges  [ { v: [32m'a'[39m, w: [32m'b'[39m } ] {}
47.880 : WARN :  Copying children of  C2 root C2 data [90mundefined[39m C2
47.880 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
47.880 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'c'[39m ]
47.880 : INFO :  Edge data {} C1
47.880 : WARN :  New graph after copy node: ( C2 ) {
47.880 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.880 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
  nodes: [ { v: [32m'c'[39m, value: {} } ],
47.880 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
47.880 : DEBUG :  Removing node a
47.880 : INFO :  cp  b  to  C1  with parent  C1
47.880 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
47.880 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.880 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
47.880 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
47.880 : INFO :  Edge data {} C1
47.880 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
47.880 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
47.880 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
47.880 : DEBUG :  Removing node b
47.880 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.880 : DEBUG :  Extracting node C2 Map(2) {
  edges: [],
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
}
47.880 : INFO :  cp  c  to  C2  with parent  C2
47.880 : WARN :  New list of nodes [ [32m'C1'[39m, [32m'C2'[39m ]
47.880 : INFO :  In copy  C2 root C2 data [90mundefined[39m C2
47.880 : WARN :   Now next level C1 {
47.880 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  clusterNode: [33mtrue[39m,
47.880 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
  id: [32m'C1'[39m,
47.880 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
  clusterData: [90mundefined[39m,
47.880 : INFO :  Edge data {} C2
  label: [90mundefined[39m,
47.880 : INFO :  Descendants of  C2  is  [ [32m'c'[39m ]
  graph: Graph {
47.880 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
    _isDirected: [33mtrue[39m,
47.880 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
    _isMultigraph: [33mtrue[39m,
47.880 : DEBUG :  Removing node c
    _isCompound: [33mtrue[39m,
47.880 : DEBUG :  Old graph after copy {
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
  nodes: [ { v: [32m'C1'[39m, value: [36m[Object][39m }, { v: [32m'C2'[39m, value: [36m[Object][39m } ],
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
    _nodes: { a: {}, b: {} },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    _parent: { a: [32m'\x00'[39m, b: [32m'\x00'[39m },
}
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {}, b: {} },
47.880 : DEBUG :  Done, no node has children [ [32m'a'[39m, [32m'b'[39m ]
47.880 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
47.880 : INFO :  [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
47.901 : DEBUG :  Opting in, graph
47.901 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
47.901 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
47.901 : DEBUG :  Not a cluster  c Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
47.901 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
47.901 : DEBUG :  Cluster identified C2 Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
47.901 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
47.901 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
47.901 : DEBUG :  Not a cluster a [33m0[39m
47.901 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
    _in: { a: {}, b: [36m[Object][39m },
47.901 : DEBUG :  Not a cluster b [33m0[39m
    _preds: { a: {}, b: [36m[Object][39m },
47.901 : DEBUG :  Extracting node c Map(2) {
    _out: { a: [36m[Object][39m, b: {} },
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    _sucs: { a: [36m[Object][39m, b: {} },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
    _edgeObjs: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
} [33mfalse[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
    _edgeLabels: { [32m'a\x01b\x01\x00'[39m: {} },
47.901 : DEBUG :  Not a cluster c [33m0[39m
47.901 : DEBUG :  Extracting node C1 Map(2) {
    _nodeCount: [33m2[39m,
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    _edgeCount: [33m1[39m
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
  }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
}
47.900 : INFO :  cp  b  to  C1  with parent  C1
47.880 : WARN :  extractor -  [33m1[39m {
47.900 : INFO :  In copy  C1 root C1 data { data: [33m4[39m } C1
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.901 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  nodes: [ { v: [32m'a'[39m, value: {} }, { v: [32m'b'[39m, value: {} } ],
47.901 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m } ]
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} } ],
47.900 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m }
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.900 : INFO :  Edge data { name: [32m'C1-internal-link'[39m } C1
} [90mundefined[39m
47.900 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
47.880 : WARN :   Now next level C2 {
47.900 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m }
  clusterNode: [33mtrue[39m,
47.900 : INFO :  Copying as  a b { name: [32m'C1-internal-link'[39m } [90mundefined[39m
  id: [32m'C2'[39m,
47.900 : INFO :  newGraph edges  [ { v: [32m'a'[39m, w: [32m'b'[39m } ] { name: [32m'C1-internal-link'[39m }
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: {} },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
47.900 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
47.900 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
  }
47.900 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
}
47.900 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
47.880 : WARN :  extractor -  [33m1[39m {
47.900 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.901 : DEBUG :  Removing node b
  nodes: [ { v: [32m'c'[39m, value: {} } ],
47.900 : INFO :  cp  a  to  C1  with parent  C2
  edges: [],
47.901 : DEBUG :  Setting parent a C2
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.901 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'c'[39m } ]
} [90mundefined[39m
47.900 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }

47.900 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
47.900 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
47.900 : WARN :  Cluster identified C1  Replacement id in edges:  b
47.900 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
47.900 : WARN :  Cluster identified C2  Replacement id in edges:  a
47.900 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
47.900 : WARN :  Edge:  { v: [32m'a'[39m, w: [32m'b'[39m }  leaves cluster  C2
47.901 : DEBUG :  Removing node a
47.900 : WARN :  Descendants of XXX  C2 :  [ [32m'a'[39m ]
47.900 : WARN :  Edge a -> b: {"v":"a","w":"b"}
47.900 : WARN :  Edge a -> b: {"name":"C1-internal-link"}
47.900 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} ids: a b Translating:  [90mundefined[39m  ---  [90mundefined[39m
47.900 : WARN :  Edge C1 -> c: {"v":"C1","w":"c"}
47.900 : WARN :  Edge C1 -> c: {"name":"C1-external-link"}
47.900 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} ids: C1 c Translating:  { id: [32m'b'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
47.900 : WARN :  Fixing and trying - removing XXX C1 c [90mundefined[39m
47.900 : WARN :  Fix Replacing with XXX C1 c [90mundefined[39m
47.900 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
47.900 : INFO :  cp  C2  to  C1  with parent  C2
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
47.900 : INFO :  In copy  C2 root C1 data { data: [33m5[39m } C1
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.900 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
47.901 : DEBUG :  Not Setting parent for node= C2 cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
  ],
47.901 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'c'[39m } ]
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.900 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
} [90mundefined[39m
47.900 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
47.900 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
47.900 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
47.900 : WARN :  Old graph before copy {
47.900 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
47.900 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
47.901 : DEBUG :  Removing node C2
    { v: [32m'c'[39m, value: [36m[Object][39m },
47.901 : DEBUG :  Removing node C2
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
47.901 : DEBUG :  Old graph after copy {
  ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  edges: [
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m }, { v: [32m'C1'[39m, value: [36m[Object][39m } ],
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
  edges: [ { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m } ],
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  ],
}
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.901 : DEBUG :  Extracting node C2 Map(2) {
}
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
47.900 : WARN :  Copying children of  C1 root C1 data { data: [33m4[39m } C1
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
47.900 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'b'[39m, [32m'C2'[39m ]
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.900 : WARN :  Copying children of  C2 root C1 data { data: [33m5[39m } C1
47.901 : DEBUG :  Map(2) {
47.900 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'a'[39m, [32m'C2'[39m ]
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
47.900 : WARN :  Setting parent a C2
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
47.900 : WARN :  New graph after copy node: ( C1 ) {
}
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.901 : DEBUG :  Nodes =  [ [32m'b'[39m, [32m'a'[39m, [32m'C2'[39m ] [33m1[39m
  nodes: [
47.901 : DEBUG :  Extracting node b Map(2) {
    { v: [32m'b'[39m, value: [36m[Object][39m },
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
    { v: [32m'C2'[39m, value: [36m[Object][39m }
} [33mfalse[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m1[39m
  ],
47.901 : DEBUG :  Not a cluster b [33m1[39m
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m } ],
47.901 : DEBUG :  Extracting node a Map(2) {
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
}
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m1[39m
47.901 : DEBUG :  Not a cluster a [33m1[39m
47.901 : DEBUG :  Extracting node C2 Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m5[39m } [90mundefined[39m  Depth  [33m1[39m
47.901 : DEBUG :  Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
}
47.900 : INFO :  [ [32m'c'[39m, [32m'C1'[39m ]

47.900 : WARN :  Cluster **  C2  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
47.900 : WARN :  New list of nodes [ [32m'c'[39m, [32m'C1'[39m ]
47.900 : WARN :   Now next level c { data: [33m3[39m }
47.900 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m4[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m, a: [36m[Object][39m, C2: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m, a: [32m'C2'[39m, C2: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {}, a: {}, C2: [36m[Object][39m },
    _in: { b: [36m[Object][39m, a: {}, C2: {} },
    _preds: { b: [36m[Object][39m, a: {}, C2: {} },
    _out: { b: {}, a: [36m[Object][39m, C2: {} },
    _sucs: { b: {}, a: [36m[Object][39m, C2: {} },
    _edgeObjs: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _nodeCount: [33m3[39m,
    _edgeCount: [33m1[39m
  }
}
47.900 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.900 : WARN :  Cluster **  C2  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [33mtrue[39m [90mundefined[39m [33m1[39m
47.900 : WARN :  New list of nodes [ [32m'b'[39m, [32m'a'[39m, [32m'C2'[39m ]
47.900 : WARN :   Now next level b { data: [33m2[39m }
47.900 : WARN :   Now next level a { data: [33m1[39m }
47.900 : WARN :   Now next level C2 { data: [33m5[39m }

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
47.906 : INFO :  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m, [32m'C2'[39m ]
47.906 : DEBUG :  Opting in, graph
47.906 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
47.906 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
47.906 : DEBUG :  Cluster identified C1 { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
47.906 : DEBUG :  Cluster identified C2 { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
47.906 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
47.906 : DEBUG :  Extracting node a {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
47.906 : DEBUG :  Not a cluster a [33m0[39m
47.906 : DEBUG :  Extracting node b {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
47.906 : DEBUG :  Not a cluster b [33m0[39m
47.906 : DEBUG :  Extracting node C1 {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.906 : INFO :  cp  a  to  C1  with parent  C1
47.906 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
47.906 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.906 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
47.906 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
47.906 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
47.906 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
47.906 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
47.906 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
47.906 : DEBUG :  Removing node a
47.906 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.906 : DEBUG :  Extracting node C2 {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.906 : INFO :  cp  b  to  C2  with parent  C2
47.906 : INFO :  In copy  C2 root C2 data [90mundefined[39m C2
47.906 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
47.906 : WARN :  Cluster identified C1  Replacement id in edges:  a
47.906 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
47.906 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
47.906 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C2
47.906 : INFO :  Descendants of  C2  is  [ [32m'b'[39m ]
47.906 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
47.906 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
47.906 : DEBUG :  Removing node b
47.906 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'C1'[39m, value: [36m[Object][39m }, { v: [32m'C2'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.906 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
47.906 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
47.906 : INFO :  [ [32m'C1'[39m, [32m'C2'[39m ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
47.911 : DEBUG :  Opting in, graph
47.911 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
47.911 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
47.906 : WARN :  Cluster identified C2  Replacement id in edges:  b
47.906 : WARN :  Edge C1 -> C2: {"v":"C1","w":"C2"}
47.911 : DEBUG :  Cluster identified C1 { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
47.906 : WARN :  Edge C1 -> C2: {"name":"C1-external-link"}
47.911 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m ] [33m0[39m
47.906 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 C2 Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'b'[39m, clusterData: [90mundefined[39m }
47.911 : DEBUG :  Extracting node a {
47.906 : WARN :  Fixing and trixing - removing XXX C1 C2 [90mundefined[39m
  C1: { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
47.906 : WARN :  Fix Replacing with XXX C1 C2 [90mundefined[39m
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
47.906 : WARN :  Adjusted Graph {
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.911 : DEBUG :  Not a cluster a [33m0[39m
  nodes: [
47.911 : DEBUG :  Extracting node b {
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
  C1: { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
    { v: [32m'C1'[39m },
} [90mundefined[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
    { v: [32m'C2'[39m }
47.911 : DEBUG :  Not a cluster b [33m0[39m
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.906 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.906 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
47.911 : DEBUG :  Extracting node C1 {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
47.911 : INFO :  cp  a  to  C1  with parent  C1
47.911 : INFO :  In copy  C1 root C1 data { data: [33m3[39m } C1
47.911 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.911 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
47.911 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
47.911 : INFO :  Edge data { data: [32m'link1'[39m } C1
47.911 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
47.911 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
47.911 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
47.906 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
47.911 : DEBUG :  Removing node a
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
47.911 : DEBUG :  Old graph after copy {
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    { v: [32m'C1'[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m }, { v: [32m'C1'[39m, value: [36m[Object][39m } ],
    { v: [32m'C2'[39m }
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
}
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.911 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
}
47.911 : INFO :  [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
47.906 : WARN :  Copying children of  C1 root C1 data [90mundefined[39m C1
47.906 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
47.906 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.906 : WARN :  Cluster without external connections, without a parent and with children C2 [33m0[39m
47.906 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.906 : WARN :  Copying children of  C2 root C2 data [90mundefined[39m C2
47.906 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'b'[39m ]

47.906 : WARN :  New graph after copy node: ( C2 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.906 : WARN :  New list of nodes [ [32m'C1'[39m, [32m'C2'[39m ]
47.906 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
47.906 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.906 : WARN :   Now next level C2 {
  clusterNode: [33mtrue[39m,
  id: [32m'C2'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
47.906 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
47.911 : WARN :  Cluster identified C1  Replacement id in edges:  a
47.911 : WARN :  Edge C1 -> b: {"v":"C1","w":"b","name":"1"}
47.911 : WARN :  Edge C1 -> b: {"data":"link1"}
47.911 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 b Translating:  { id: [32m'a'[39m, clusterData: { data: [33m3[39m } }  ---  [90mundefined[39m
47.911 : WARN :  Fixing and trixing - removing XXX C1 b 1
47.911 : WARN :  Fix Replacing with XXX C1 b 1
47.911 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.911 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.911 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
47.911 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.911 : WARN :  Copying children of  C1 root C1 data { data: [33m3[39m } C1
47.911 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
47.911 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.911 : WARN :  New list of nodes [ [32m'b'[39m, [32m'C1'[39m ]
47.911 : WARN :   Now next level b { data: [33m2[39m }
47.911 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m3[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
47.911 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
47.916 : INFO :  { data: [33m4[39m }
47.916 : DEBUG :  Opting in, graph
47.916 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
47.916 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
47.916 : DEBUG :  Not a cluster  c { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
47.916 : DEBUG :  Cluster identified C1 { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
47.916 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m ] [33m0[39m
47.916 : DEBUG :  Extracting node a {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
47.916 : DEBUG :  Not a cluster a [33m0[39m
47.916 : DEBUG :  Extracting node b {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
47.916 : DEBUG :  Not a cluster b [33m0[39m
47.916 : DEBUG :  Extracting node c {
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
47.916 : WARN :  Cluster identified C1  Replacement id in edges:  a
47.916 : WARN :  Edge C1 -> b: {"v":"C1","w":"b","name":"1"}
47.916 : WARN :  Edge C1 -> b: {"data":"link1"}
47.916 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 b Translating:  { id: [32m'a'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
47.916 : WARN :  Fixing and trixing - removing XXX C1 b 1
47.916 : WARN :  Fix Replacing with XXX C1 b 1
47.916 : WARN :  Edge C1 -> c: {"v":"C1","w":"c","name":"2"}
47.916 : WARN :  Edge C1 -> c: {"data":"link2"}
47.916 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
} ids: C1 c Translating:  { id: [32m'a'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
47.916 : DEBUG :  Not a cluster c [33m0[39m
47.916 : WARN :  Fixing and trixing - removing XXX C1 c 2
47.916 : DEBUG :  Extracting node C1 {
47.916 : WARN :  Fix Replacing with XXX C1 c 2
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
47.916 : WARN :  Adjusted Graph {
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
47.916 : INFO :  cp  a  to  C1  with parent  C1
47.916 : INFO :  In copy  C1 root C1 data { data: [33m4[39m } C1
  nodes: [
47.916 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
47.916 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
47.916 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
47.916 : INFO :  Edge data { data: [32m'link1'[39m } C1
47.916 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
    { v: [32m'b'[39m, value: [36m[Object][39m },
47.916 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
    { v: [32m'c'[39m, value: [36m[Object][39m },
47.916 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
    { v: [32m'C1'[39m, value: [36m[Object][39m }
47.916 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
  ],
47.916 : INFO :  Edge data { data: [32m'link2'[39m } C1
  edges: [
47.916 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
47.916 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
47.916 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
  ],
47.916 : DEBUG :  Removing node a
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.916 : DEBUG :  Old graph after copy {
}
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.916 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
47.916 : INFO :  [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
47.924 : DEBUG :  Opting in, graph
47.916 : WARN :  extractor -  [33m0[39m {
47.924 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.924 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
47.924 : DEBUG :  Not a cluster  c { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
  nodes: [
47.924 : DEBUG :  Cluster identified A { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
47.924 : DEBUG :  Cluster identified B { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
47.924 : DEBUG :  Cluster identified C { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
47.924 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ] [33m0[39m
47.924 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
47.924 : DEBUG :  Not a cluster a [33m0[39m
47.924 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'b'[39m, value: [36m[Object][39m },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
47.924 : DEBUG :  Not a cluster b [33m0[39m
47.924 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
47.924 : DEBUG :  Not a cluster c [33m0[39m
47.924 : DEBUG :  Extracting node A {
  ],
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  edges: [
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.924 : INFO :  cp  a  to  A  with parent  A
47.924 : INFO :  In copy  A root A data [90mundefined[39m A
47.924 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.924 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
47.924 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
47.924 : INFO :  Edge data { data: [32m'link1'[39m } A
47.924 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
47.924 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
47.924 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
47.924 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
47.924 : INFO :  Edge data { data: [32m'link2'[39m } A
47.924 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
47.924 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
47.924 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
47.924 : DEBUG :  Removing node a
47.924 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.924 : DEBUG :  Extracting node B {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.916 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
47.916 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
47.924 : INFO :  cp  b  to  B  with parent  B
47.924 : INFO :  In copy  B root B data [90mundefined[39m B
    { v: [32m'C1'[39m, value: [36m[Object][39m }
47.924 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.924 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
47.924 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
47.924 : INFO :  Edge data { data: [32m'link1'[39m } B
47.924 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
47.924 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
47.924 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
47.924 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
47.924 : INFO :  Edge data { data: [32m'link2'[39m } B
47.924 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
47.924 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
47.924 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
47.924 : DEBUG :  Removing node b
47.924 : DEBUG :  Old graph after copy {
  ],
  edges: [
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.924 : DEBUG :  Extracting node C {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.924 : INFO :  cp  c  to  C  with parent  C
47.924 : INFO :  In copy  C root C data [90mundefined[39m C
47.924 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.924 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
47.924 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
47.924 : INFO :  Edge data { data: [32m'link1'[39m } C
47.924 : INFO :  Descendants of  C  is  [ [32m'c'[39m ]
47.924 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
47.924 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: C
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
47.924 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
47.924 : INFO :  Edge data { data: [32m'link2'[39m } C
  ],
47.924 : INFO :  Descendants of  C  is  [ [32m'c'[39m ]
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.924 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
}
47.924 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: C
47.916 : WARN :  Copying children of  C1 root C1 data { data: [33m4[39m } C1
47.924 : DEBUG :  Removing node c
47.924 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.924 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
47.924 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
47.924 : DEBUG :  Done, no node has children [ [32m'c'[39m ]

47.916 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
47.916 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.916 : WARN :  New list of nodes [ [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m ]
47.916 : WARN :   Now next level b { data: [33m2[39m }
47.916 : WARN :   Now next level c { data: [33m3[39m }
47.916 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m4[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
47.908 : INFO :  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m, [32m'C2'[39m ]
47.908 : DEBUG :  Opting in, graph
47.908 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
47.908 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
47.908 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
47.908 : DEBUG :  Cluster identified C2 Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
47.908 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
47.908 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
47.916 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
47.908 : WARN :  Cluster identified C1  Replacement id in edges:  a
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
47.908 : DEBUG :  Not a cluster a [33m0[39m
47.908 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
47.908 : WARN :  Cluster identified C2  Replacement id in edges:  b
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
47.908 : WARN :  Edge C1 -> C2: {"v":"C1","w":"C2"}
} [33mfalse[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
47.908 : WARN :  Edge C1 -> C2: {"name":"C1-external-link"}
47.908 : DEBUG :  Not a cluster b [33m0[39m
47.908 : WARN :  Fix XXX Map(2) {
47.908 : DEBUG :  Extracting node C1 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.908 : INFO :  cp  a  to  C1  with parent  C1
47.908 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
47.908 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.908 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
47.908 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
47.908 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
47.908 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
47.908 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
47.908 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
47.908 : DEBUG :  Removing node a
47.908 : DEBUG :  Old graph after copy {
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 C2 Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'b'[39m, clusterData: [90mundefined[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
47.908 : WARN :  Fixing and trying - removing XXX C1 C2 [90mundefined[39m
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
47.908 : WARN :  Fix Replacing with XXX C1 C2 [90mundefined[39m
    { v: [32m'C1'[39m, value: [36m[Object][39m },
47.908 : WARN :  Adjusted Graph {
    { v: [32m'C2'[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.908 : DEBUG :  Extracting node C2 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.908 : INFO :  cp  b  to  C2  with parent  C2
47.908 : INFO :  In copy  C2 root C2 data [90mundefined[39m C2
47.908 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.908 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
47.908 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
  nodes: [
47.908 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C2
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.908 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.908 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
47.908 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
47.908 : INFO :  Descendants of  C2  is  [ [32m'b'[39m ]
47.908 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
47.908 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
47.908 : DEBUG :  Removing node b
47.908 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'C1'[39m, value: [36m[Object][39m }, { v: [32m'C2'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.908 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
47.908 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
47.908 : INFO :  [ [32m'C1'[39m, [32m'C2'[39m ]
    { v: [32m'C1'[39m },

    { v: [32m'C2'[39m }
stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
  ],
47.914 : DEBUG :  Opting in, graph
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
47.914 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.914 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
47.914 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
}
47.914 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m ] [33m0[39m
47.908 : WARN :  Copying children of  C1 root C1 data [90mundefined[39m C1
47.914 : DEBUG :  Extracting node a Map(2) {
47.908 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
47.914 : DEBUG :  Not a cluster a [33m0[39m
47.914 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
47.914 : DEBUG :  Not a cluster b [33m0[39m
47.914 : DEBUG :  Extracting node C1 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
47.908 : WARN :  New graph after copy node: ( C1 ) {
47.913 : INFO :  cp  a  to  C1  with parent  C1
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.913 : INFO :  In copy  C1 root C1 data { data: [33m3[39m } C1
47.914 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.908 : WARN :  Cluster without external connections, without a parent and with children C2 [33m0[39m
47.908 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.908 : WARN :  Copying children of  C2 root C2 data [90mundefined[39m C2
47.908 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'b'[39m ]
47.908 : WARN :  New graph after copy node: ( C2 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
47.914 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
47.913 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
47.913 : INFO :  Edge data { data: [32m'link1'[39m } C1
47.913 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
47.913 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
47.913 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
47.914 : DEBUG :  Removing node a
47.914 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m }, { v: [32m'C1'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.914 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.913 : INFO :  [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
}

47.908 : WARN :  New list of nodes [ [32m'C1'[39m, [32m'C2'[39m ]
47.908 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
47.908 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.908 : WARN :   Now next level C2 {
  clusterNode: [33mtrue[39m,
  id: [32m'C2'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
47.908 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
47.913 : WARN :  Cluster identified C1  Replacement id in edges:  a
47.913 : WARN :  Edge C1 -> b: {"v":"C1","w":"b","name":"1"}
47.913 : WARN :  Edge C1 -> b: {"data":"link1"}
47.913 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 b Translating:  { id: [32m'a'[39m, clusterData: { data: [33m3[39m } }  ---  [90mundefined[39m
47.913 : WARN :  Fixing and trying - removing XXX C1 b 1
47.913 : WARN :  Fix Replacing with XXX C1 b 1
47.913 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.913 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
47.918 : INFO :  { data: [33m4[39m }
47.918 : DEBUG :  Opting in, graph
47.918 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
47.918 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
47.918 : DEBUG :  Not a cluster  c Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
47.918 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
47.918 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m ] [33m0[39m
47.918 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
47.918 : DEBUG :  Not a cluster a [33m0[39m
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
47.918 : DEBUG :  Extracting node b Map(2) {
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
} [90mundefined[39m
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
47.913 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
} [33mfalse[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
47.913 : WARN :  Old graph before copy {
47.918 : DEBUG :  Not a cluster b [33m0[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.918 : DEBUG :  Extracting node c Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
47.918 : DEBUG :  Not a cluster c [33m0[39m
47.918 : DEBUG :  Extracting node C1 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
47.918 : INFO :  cp  a  to  C1  with parent  C1
47.918 : INFO :  In copy  C1 root C1 data { data: [33m4[39m } C1
47.918 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.918 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.913 : WARN :  Copying children of  C1 root C1 data { data: [33m3[39m } C1
47.913 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
47.913 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
47.918 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.918 : INFO :  Edge data { data: [32m'link1'[39m } C1
}
47.918 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
47.913 : WARN :  New list of nodes [ [32m'b'[39m, [32m'C1'[39m ]
47.918 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
47.913 : WARN :   Now next level b { data: [33m2[39m }
47.913 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
47.918 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
  id: [32m'C1'[39m,
47.918 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
  clusterData: { data: [33m3[39m },
47.918 : INFO :  Edge data { data: [32m'link2'[39m } C1
  label: [90mundefined[39m,
  graph: Graph {
47.918 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
47.918 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
47.918 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
47.918 : DEBUG :  Removing node a
47.918 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.918 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
    _sucs: { a: {} },
47.918 : INFO :  [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m

  }
stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
}
47.913 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
47.918 : WARN :  Cluster identified C1  Replacement id in edges:  a
47.925 : DEBUG :  Opting in, graph
47.918 : WARN :  Edge C1 -> b: {"v":"C1","w":"b","name":"1"}
47.918 : WARN :  Edge C1 -> b: {"data":"link1"}
47.925 : DEBUG :  Not a cluster  a Map(5) {
47.918 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
  [32m'C2'[39m => [ [32m'b'[39m ],
} ids: C1 b Translating:  { id: [32m'a'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
47.918 : WARN :  Fixing and trying - removing XXX C1 b 1
  [32m'A'[39m => [ [32m'a'[39m ],
47.918 : WARN :  Fix Replacing with XXX C1 b 1
47.918 : WARN :  Edge C1 -> c: {"v":"C1","w":"c","name":"2"}
47.918 : WARN :  Edge C1 -> c: {"data":"link2"}
47.918 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 c Translating:  { id: [32m'a'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
47.918 : WARN :  Fixing and trying - removing XXX C1 c 2
47.918 : WARN :  Fix Replacing with XXX C1 c 2
47.918 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
47.925 : DEBUG :  Not a cluster  b Map(5) {
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
    { v: [32m'b'[39m, value: [36m[Object][39m },
  [32m'A'[39m => [ [32m'a'[39m ],
    { v: [32m'c'[39m, value: [36m[Object][39m },
  [32m'B'[39m => [ [32m'b'[39m ],
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  [32m'C'[39m => [ [32m'c'[39m ]
}
  ],
47.925 : DEBUG :  Not a cluster  c Map(5) {
  edges: [
  [32m'C1'[39m => [ [32m'a'[39m ],
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
  [32m'C2'[39m => [ [32m'b'[39m ],
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
  ],
}
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.925 : DEBUG :  Cluster identified A Map(5) {
}
  [32m'C1'[39m => [ [32m'a'[39m ],
47.918 : WARN :  extractor -  [33m0[39m {
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
47.925 : DEBUG :  Cluster identified B Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
47.925 : DEBUG :  Cluster identified C Map(5) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'C1'[39m => [ [32m'a'[39m ],
  nodes: [
  [32m'C2'[39m => [ [32m'b'[39m ],
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
  [32m'A'[39m => [ [32m'a'[39m ],
    { v: [32m'b'[39m, value: [36m[Object][39m },
  [32m'B'[39m => [ [32m'b'[39m ],
    { v: [32m'c'[39m, value: [36m[Object][39m },
  [32m'C'[39m => [ [32m'c'[39m ]
    { v: [32m'C1'[39m, value: [36m[Object][39m }
}
  ],
47.925 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ] [33m0[39m
47.925 : DEBUG :  Extracting node a Map(5) {
  edges: [
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
47.925 : DEBUG :  Not a cluster a [33m0[39m
47.925 : DEBUG :  Extracting node b Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
  ],
} [33mfalse[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.925 : DEBUG :  Not a cluster b [33m0[39m
} [90mundefined[39m
47.925 : DEBUG :  Extracting node c Map(5) {
47.918 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
47.918 : WARN :  Old graph before copy {
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
47.925 : DEBUG :  Not a cluster c [33m0[39m
47.925 : DEBUG :  Extracting node A Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  nodes: [
47.925 : INFO :  cp  a  to  A  with parent  A
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
47.925 : INFO :  In copy  A root A data [90mundefined[39m A
    { v: [32m'b'[39m, value: [36m[Object][39m },
47.925 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    { v: [32m'c'[39m, value: [36m[Object][39m },
47.925 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
    { v: [32m'C1'[39m, value: [36m[Object][39m }
47.925 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
  ],
47.925 : INFO :  Edge data { data: [32m'link1'[39m } A
  edges: [
47.925 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.918 : WARN :  Copying children of  C1 root C1 data { data: [33m4[39m } C1
47.918 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
47.918 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.918 : WARN :  New list of nodes [ [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m ]
47.918 : WARN :   Now next level b { data: [33m2[39m }
47.918 : WARN :   Now next level c { data: [33m3[39m }
47.925 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
47.925 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
47.918 : WARN :   Now next level C1 {
47.925 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
  clusterNode: [33mtrue[39m,
47.925 : INFO :  Edge data { data: [32m'link2'[39m } A
  id: [32m'C1'[39m,
47.925 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
  clusterData: { data: [33m4[39m },
47.925 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
  label: [90mundefined[39m,
47.925 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
  graph: Graph {
    _isDirected: [33mtrue[39m,
47.925 : DEBUG :  Removing node a
47.925 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    _isMultigraph: [33mtrue[39m,
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    _isCompound: [33mtrue[39m,
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
  ],
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
}
    _nodes: { a: [36m[Object][39m },
47.925 : DEBUG :  Extracting node B Map(5) {
    _parent: { a: [32m'\x00'[39m },
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.925 : INFO :  cp  b  to  B  with parent  B
47.925 : INFO :  In copy  B root B data [90mundefined[39m B
47.925 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
47.925 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
    _in: { a: {} },
47.925 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
47.925 : INFO :  Edge data { data: [32m'link1'[39m } B
47.925 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
47.925 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
47.925 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
47.925 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
47.925 : INFO :  Edge data { data: [32m'link2'[39m } B
47.925 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
47.925 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
47.925 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
    _preds: { a: {} },
47.925 : DEBUG :  Removing node b
    _out: { a: {} },
47.925 : DEBUG :  Old graph after copy {
    _sucs: { a: {} },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    _edgeObjs: {},
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.925 : DEBUG :  Extracting node C Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.925 : INFO :  cp  c  to  C  with parent  C
47.925 : INFO :  In copy  C root C data [90mundefined[39m C
47.925 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.925 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
47.925 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
47.925 : INFO :  Edge data { data: [32m'link1'[39m } C
    _edgeLabels: {},
47.925 : INFO :  Descendants of  C  is  [ [32m'c'[39m ]
    _nodeCount: [33m1[39m
47.925 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
47.925 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: C
  }
47.925 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
47.925 : INFO :  Edge data { data: [32m'link2'[39m } C
}
47.925 : INFO :  Descendants of  C  is  [ [32m'c'[39m ]
47.925 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
47.925 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: C
47.918 : WARN :  extractor -  [33m1[39m {
47.925 : DEBUG :  Removing node c
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.925 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.925 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
47.925 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
47.925 : DEBUG :  Done, no node has children [ [32m'c'[39m ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
47.933 : DEBUG :  Opting in, graph
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
47.933 : DEBUG :  Cluster identified C Map(6) {
  edges: [],
  [32m'C1'[39m => [ [32m'a'[39m ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
} [90mundefined[39m
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}

47.933 : DEBUG :  Cluster identified D Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
47.933 : DEBUG :  Not a cluster  d Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
47.925 : WARN :  Cluster identified A  Replacement id in edges:  a
47.925 : WARN :  Cluster identified B  Replacement id in edges:  b
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
47.933 : DEBUG :  Nodes =  [ [32m'C'[39m, [32m'D'[39m, [32m'd'[39m ] [33m0[39m
47.933 : DEBUG :  Extracting node C Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
47.925 : WARN :  Cluster identified C  Replacement id in edges:  c
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [ [32m'd'[39m ]  Depth  [33m0[39m
47.933 : INFO :  cp  d  to  C  with parent  D
47.933 : DEBUG :  Setting parent d D
47.933 : DEBUG :  Copying Edges []
47.933 : DEBUG :  Removing node d
47.933 : INFO :  cp  D  to  C  with parent  D
47.933 : INFO :  In copy  D root C data { data: [33m2[39m } C
47.933 : DEBUG :  Not Setting parent for node= D cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
47.933 : DEBUG :  Copying Edges []
47.933 : DEBUG :  Removing node D
47.933 : DEBUG :  Removing node D
47.933 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'C'[39m, value: [36m[Object][39m } ],
47.925 : WARN :  Edge A -> B: {"v":"A","w":"B","name":"1"}
  edges: [],
47.925 : WARN :  Edge A -> B: {"data":"link1"}
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.933 : DEBUG :  Extracting node D Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.933 : DEBUG :  Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
47.925 : WARN :  Fix XXX Map(5) {
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
}
47.933 : DEBUG :  Extracting node d Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.933 : DEBUG :  Not a cluster d [33m0[39m
47.933 : DEBUG :  Nodes =  [ [32m'd'[39m, [32m'D'[39m ] [33m1[39m
47.933 : DEBUG :  Extracting node d Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} ids: A B Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m3[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
47.933 : DEBUG :  Not a cluster d [33m1[39m
47.933 : DEBUG :  Extracting node D Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
47.933 : INFO :  cp  d  to  D  with parent  D
47.933 : INFO :  In copy  D root D data { data: [33m2[39m } D
47.925 : WARN :  Fixing and trying - removing XXX A B 1
47.933 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.933 : DEBUG :  Copying Edges []
47.933 : DEBUG :  Removing node d
47.933 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'D'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.933 : DEBUG :  Done, no node has children [ [32m'd'[39m ]

47.925 : WARN :  Fix Replacing with XXX A B 1
47.925 : WARN :  Edge A -> C: {"v":"A","w":"C","name":"2"}
47.925 : WARN :  Edge A -> C: {"data":"link2"}
47.925 : WARN :  Fix XXX Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: A C Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'c'[39m, clusterData: [90mundefined[39m }
47.925 : WARN :  Fixing and trying - removing XXX A C 2
47.925 : WARN :  Fix Replacing with XXX A C 2
47.925 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.925 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.925 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
47.925 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.925 : WARN :  Copying children of  A root A data [90mundefined[39m A
47.925 : WARN :  Copying (nodes) clusterId A nodes [ [32m'a'[39m ]
47.925 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.925 : WARN :  Cluster without external connections, without a parent and with children B [33m0[39m
47.925 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.925 : WARN :  Copying children of  B root B data [90mundefined[39m B
47.925 : WARN :  Copying (nodes) clusterId B nodes [ [32m'b'[39m ]
47.925 : WARN :  New graph after copy node: ( B ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.925 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
47.925 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.925 : WARN :  Copying children of  C root C data [90mundefined[39m C
47.925 : WARN :  Copying (nodes) clusterId C nodes [ [32m'c'[39m ]
47.925 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.925 : WARN :  New list of nodes [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ]
47.925 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
47.925 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.925 : WARN :   Now next level B {
  clusterNode: [33mtrue[39m,
  id: [32m'B'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
47.925 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.925 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
47.925 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
47.933 : WARN :  Cluster identified C  Replacement id in edges:  d
47.933 : WARN :  Cluster identified D  Replacement id in edges:  d
47.933 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.933 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
47.933 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
47.933 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.933 : WARN :  Copying children of  C root C data { data: [33m1[39m } C
47.933 : WARN :  Copying (nodes) clusterId C nodes [ [32m'D'[39m ]
47.933 : WARN :  Copying children of  D root C data { data: [33m2[39m } C
47.933 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m, [32m'D'[39m ]
47.933 : WARN :  Setting parent d D
47.933 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.933 : WARN :  Cluster **  D  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
47.933 : WARN :  New list of nodes [ [32m'C'[39m ]
47.933 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: { data: [33m1[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m, D: [36m[Object][39m },
    _parent: { d: [32m'D'[39m, D: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {}, D: [36m[Object][39m },
    _in: { d: {}, D: {} },
    _preds: { d: {}, D: {} },
    _out: { d: {}, D: {} },
    _sucs: { d: {}, D: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m2[39m
  }
}
47.933 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
47.933 : WARN :  Cluster without external connections, without a parent and with children D [33m1[39m
47.933 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.933 : WARN :  Copying children of  D root D data { data: [33m2[39m } D
47.933 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m ]
47.933 : WARN :  New graph after copy node: ( D ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.933 : WARN :  New list of nodes [ [32m'D'[39m ]
47.933 : WARN :   Now next level D {
  clusterNode: [33mtrue[39m,
  id: [32m'D'[39m,
  clusterData: { data: [33m2[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m },
    _parent: { d: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {} },
    _in: { d: {} },
    _preds: { d: {} },
    _out: { d: {} },
    _sucs: { d: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
47.933 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
47.924 : WARN :  Cluster identified A  Replacement id in edges:  a
47.924 : WARN :  Cluster identified B  Replacement id in edges:  b
47.924 : WARN :  Cluster identified C  Replacement id in edges:  c
47.924 : WARN :  Edge A -> B: {"v":"A","w":"B","name":"1"}
47.924 : WARN :  Edge A -> B: {"data":"link1"}
47.924 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
47.938 : DEBUG :  Opting in, graph
47.938 : DEBUG :  Cluster identified C {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
47.938 : DEBUG :  Cluster identified D {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
47.938 : DEBUG :  Not a cluster  d {
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: A B Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'b'[39m, clusterData: [90mundefined[39m }
47.924 : WARN :  Fixing and trixing - removing XXX A B 1
47.924 : WARN :  Fix Replacing with XXX A B 1
47.924 : WARN :  Edge A -> C: {"v":"A","w":"C","name":"2"}
47.924 : WARN :  Edge A -> C: {"data":"link2"}
47.924 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: A C Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'c'[39m, clusterData: [90mundefined[39m }
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
47.924 : WARN :  Fixing and trixing - removing XXX A C 2
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
47.938 : DEBUG :  Nodes =  [ [32m'C'[39m, [32m'D'[39m, [32m'd'[39m ] [33m0[39m
47.938 : DEBUG :  Extracting node C {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [ [32m'd'[39m ]  Depth  [33m0[39m
47.938 : INFO :  cp  d  to  C  with parent  D
47.938 : DEBUG :  Setting parent d D
47.938 : DEBUG :  Copying Edges []
47.924 : WARN :  Fix Replacing with XXX A C 2
47.938 : DEBUG :  Removing node d
47.938 : INFO :  cp  D  to  C  with parent  D
47.938 : INFO :  In copy  D root C data { data: [33m2[39m } C
47.938 : DEBUG :  Not Setting parent for node= D cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
47.938 : DEBUG :  Copying Edges []
47.938 : DEBUG :  Removing node D
47.938 : DEBUG :  Removing node D
47.938 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'C'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.938 : DEBUG :  Extracting node D {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
47.924 : WARN :  Adjusted Graph {
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.938 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
}
47.938 : DEBUG :  Extracting node d {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  nodes: [
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
47.938 : DEBUG :  Not a cluster d [33m0[39m
47.938 : DEBUG :  Nodes =  [ [32m'd'[39m, [32m'D'[39m ] [33m1[39m
47.938 : DEBUG :  Extracting node d {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.924 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
    { v: [32m'B'[39m },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mfalse[39m { data: [33m3[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
47.938 : DEBUG :  Not a cluster d [33m1[39m
47.938 : DEBUG :  Extracting node D {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
47.938 : INFO :  cp  d  to  D  with parent  D
47.938 : INFO :  In copy  D root D data { data: [33m2[39m } D
47.938 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.938 : DEBUG :  Copying Edges []
47.938 : DEBUG :  Removing node d
47.938 : DEBUG :  Old graph after copy {
    { v: [32m'C'[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'D'[39m, value: [36m[Object][39m } ],
  edges: [],
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.924 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
47.924 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
}
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
47.938 : DEBUG :  Done, no node has children [ [32m'd'[39m ]
    { v: [32m'A'[39m },

    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.924 : WARN :  Copying children of  A root A data [90mundefined[39m A
47.924 : WARN :  Copying (nodes) clusterId A nodes [ [32m'a'[39m ]
47.924 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.924 : WARN :  Cluster without external connections, without a parent and with children B [33m0[39m
47.924 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.924 : WARN :  Copying children of  B root B data [90mundefined[39m B
47.924 : WARN :  Copying (nodes) clusterId B nodes [ [32m'b'[39m ]
47.924 : WARN :  New graph after copy node: ( B ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.924 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
47.924 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.924 : WARN :  Copying children of  C root C data [90mundefined[39m C
47.924 : WARN :  Copying (nodes) clusterId C nodes [ [32m'c'[39m ]
47.924 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.924 : WARN :  New list of nodes [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ]
47.924 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
47.924 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.924 : WARN :   Now next level B {
  clusterNode: [33mtrue[39m,
  id: [32m'B'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
47.924 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.924 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
47.947 : INFO :  Graph before { data: [33m2[39m }
47.947 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    _nodes: { c: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
    _parent: { c: [32m'\x00'[39m },
  ],
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    _in: { c: {} },
}
    _preds: { c: {} },
47.947 : DEBUG :  Opting in, graph
    _out: { c: {} },
47.947 : DEBUG :  Cluster identified C {
    _sucs: { c: {} },
  C1: [ [32m'a'[39m ],
    _edgeObjs: {},
  C2: [ [32m'b'[39m ],
    _edgeLabels: {},
  A: [ [32m'a'[39m ],
    _nodeCount: [33m1[39m
  B: [ [32m'b'[39m ],
  }
}
47.924 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
47.938 : WARN :  Cluster identified C  Replacement id in edges:  d
47.938 : WARN :  Cluster identified D  Replacement id in edges:  d
47.938 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
  C: [ [32m'D'[39m, [32m'd'[39m ],
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  D: [ [32m'd'[39m ]
  ],
}
  edges: [],
47.947 : DEBUG :  Cluster identified D {
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  C1: [ [32m'a'[39m ],
}
  C2: [ [32m'b'[39m ],
47.938 : WARN :  extractor -  [33m0[39m {
  A: [ [32m'a'[39m ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
47.947 : DEBUG :  Not a cluster  d {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
47.947 : DEBUG :  Cluster identified B {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  nodes: [
  B: [ [32m'b'[39m ],
    { v: [32m'C'[39m, value: [36m[Object][39m },
  C: [ [32m'D'[39m, [32m'd'[39m ],
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
  D: [ [32m'd'[39m ]
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
}
  ],
47.947 : DEBUG :  Not a cluster  b {
  edges: [],
  C1: [ [32m'a'[39m ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  C2: [ [32m'b'[39m ],
} [ [32m'd'[39m ]
  A: [ [32m'a'[39m ],
47.938 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
  B: [ [32m'b'[39m ],
47.938 : WARN :  Old graph before copy {
  C: [ [32m'D'[39m, [32m'd'[39m ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.938 : WARN :  Copying children of  C root C data { data: [33m1[39m } C
47.938 : WARN :  Copying (nodes) clusterId C nodes [ [32m'D'[39m ]
47.938 : WARN :  Copying children of  D root C data { data: [33m2[39m } C
47.938 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m, [32m'D'[39m ]
47.938 : WARN :  Setting parent d D
47.938 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
  D: [ [32m'd'[39m ]
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
}
    { v: [32m'D'[39m, value: [36m[Object][39m }
47.947 : DEBUG :  Cluster identified A {
  ],
  C1: [ [32m'a'[39m ],
  edges: [],
  C2: [ [32m'b'[39m ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  A: [ [32m'a'[39m ],
}
  B: [ [32m'b'[39m ],
47.938 : WARN :  Cluster **  D  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
47.938 : WARN :  New list of nodes [ [32m'C'[39m ]
47.938 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: { data: [33m1[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m, D: [36m[Object][39m },
    _parent: { d: [32m'D'[39m, D: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {}, D: [36m[Object][39m },
  C: [ [32m'D'[39m, [32m'd'[39m ],
    _in: { d: {}, D: {} },
  D: [ [32m'd'[39m ]
    _preds: { d: {}, D: {} },
}
    _out: { d: {}, D: {} },
47.947 : DEBUG :  Not a cluster  a {
    _sucs: { d: {}, D: {} },
  C1: [ [32m'a'[39m ],
    _edgeObjs: {},
  C2: [ [32m'b'[39m ],
    _edgeLabels: {},
  A: [ [32m'a'[39m ],
    _nodeCount: [33m2[39m
  B: [ [32m'b'[39m ],
  }
  C: [ [32m'D'[39m, [32m'd'[39m ],
}
  D: [ [32m'd'[39m ]
47.938 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
}
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
47.947 : DEBUG :  Nodes =  [
    { v: [32m'D'[39m, value: [36m[Object][39m }
  [32m'C'[39m, [32m'D'[39m, [32m'd'[39m,
  ],
  [32m'B'[39m, [32m'b'[39m, [32m'A'[39m,
  edges: [],
  [32m'a'[39m
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
] [33m0[39m
} [ [32m'd'[39m ]
47.947 : DEBUG :  Extracting node C {
47.938 : WARN :  Cluster without external connections, without a parent and with children D [33m1[39m
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
47.938 : WARN :  Old graph before copy {
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  nodes: [
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
  ],
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [ [32m'd'[39m ]  Depth  [33m0[39m
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.938 : WARN :  Copying children of  D root D data { data: [33m2[39m } D
47.938 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m ]
47.938 : WARN :  New graph after copy node: ( D ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.938 : WARN :  New list of nodes [ [32m'D'[39m ]
47.938 : WARN :   Now next level D {
  clusterNode: [33mtrue[39m,
  id: [32m'D'[39m,
  clusterData: { data: [33m2[39m },
47.947 : INFO :  cp  d  to  C  with parent  D
  labelText: [90mundefined[39m,
47.947 : DEBUG :  Setting parent d D
  graph: Graph {
47.947 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
    _isDirected: [33mtrue[39m,
47.947 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
    _isMultigraph: [33mtrue[39m,
47.947 : INFO :  Edge data { data: [32m'link1'[39m } C
    _isCompound: [33mtrue[39m,
47.947 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
47.947 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m },
    _parent: { d: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {} },
    _in: { d: {} },
    _preds: { d: {} },
    _out: { d: {} },
    _sucs: { d: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
47.938 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.947 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
47.947 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
  edges: [],
47.947 : INFO :  Edge data { data: [32m'link2'[39m } C
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.947 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
} [90mundefined[39m
47.947 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }

47.947 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
47.947 : DEBUG :  Removing node d
47.947 : INFO :  cp  D  to  C  with parent  D
47.947 : INFO :  In copy  D root C data { data: [33m2[39m } C
47.947 : DEBUG :  Not Setting parent for node= D cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
47.947 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
47.947 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
47.947 : INFO :  Edge data { data: [32m'link1'[39m } C
47.947 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
47.947 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
47.947 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
47.947 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
47.947 : INFO :  Edge data { data: [32m'link2'[39m } C
47.947 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
47.947 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
47.947 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
47.947 : DEBUG :  Removing node D
47.947 : DEBUG :  Removing node D
47.947 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.947 : DEBUG :  Extracting node D {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.947 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
}
47.947 : DEBUG :  Extracting node d {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.947 : DEBUG :  Not a cluster d [33m0[39m
47.947 : DEBUG :  Extracting node B {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
47.947 : INFO :  cp  b  to  B  with parent  B
47.947 : INFO :  In copy  B root B data { data: [33m4[39m } B
47.947 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.947 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
47.947 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
47.947 : INFO :  Edge data { data: [32m'link1'[39m } B
47.947 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
47.947 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
47.947 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
47.947 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
47.947 : INFO :  Edge data { data: [32m'link2'[39m } B
47.947 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
47.947 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
47.947 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
47.947 : DEBUG :  Removing node b
47.947 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.947 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.947 : DEBUG :  Not a cluster b [33m0[39m
47.947 : DEBUG :  Extracting node A {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m6[39m } [90mundefined[39m  Depth  [33m0[39m
47.947 : INFO :  cp  a  to  A  with parent  A
47.947 : INFO :  In copy  A root A data { data: [33m6[39m } A
47.947 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.947 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
47.947 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
47.947 : INFO :  Edge data { data: [32m'link1'[39m } A
47.947 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
47.947 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
47.947 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
47.947 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
47.947 : INFO :  Edge data { data: [32m'link2'[39m } A
47.947 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
47.947 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
47.947 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
47.947 : DEBUG :  Removing node a
47.947 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.947 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.947 : DEBUG :  Not a cluster a [33m0[39m
47.947 : DEBUG :  Nodes =  [ [32m'd'[39m, [32m'D'[39m ] [33m1[39m
47.947 : DEBUG :  Extracting node d {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mfalse[39m { data: [33m3[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
47.947 : DEBUG :  Not a cluster d [33m1[39m
47.947 : DEBUG :  Extracting node D {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
47.947 : INFO :  cp  d  to  D  with parent  D
47.947 : INFO :  In copy  D root D data { data: [33m2[39m } D
47.947 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.947 : DEBUG :  Copying Edges []
47.947 : DEBUG :  Removing node d
47.947 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'D'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.947 : DEBUG :  Done, no node has children [ [32m'd'[39m ]
47.947 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
47.947 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
47.947 : INFO :  A [ [32m'a'[39m ]

stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
47.947 : WARN :  Cluster identified C  Replacement id in edges:  d
47.947 : WARN :  Cluster identified D  Replacement id in edges:  d
47.947 : WARN :  Cluster identified B  Replacement id in edges:  b
47.947 : WARN :  Cluster identified A  Replacement id in edges:  a
47.947 : WARN :  Edge A -> B: {"v":"A","w":"B","name":"1"}
47.947 : WARN :  Edge A -> B: {"data":"link1"}
47.947 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} ids: A B Translating:  { id: [32m'a'[39m, clusterData: { data: [33m6[39m } }  ---  { id: [32m'b'[39m, clusterData: { data: [33m4[39m } }
47.947 : WARN :  Fixing and trixing - removing XXX A B 1
47.947 : WARN :  Fix Replacing with XXX A B 1
47.947 : WARN :  Edge A -> C: {"v":"A","w":"C","name":"2"}
47.947 : WARN :  Edge A -> C: {"data":"link2"}
47.947 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} ids: A C Translating:  { id: [32m'a'[39m, clusterData: { data: [33m6[39m } }  ---  { id: [32m'D'[39m, clusterData: { data: [33m1[39m } }
47.947 : WARN :  Fixing and trixing - removing XXX A C 2
47.947 : WARN :  Fix Replacing with XXX A C 2
47.947 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.947 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
47.947 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
47.947 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.947 : WARN :  Copying children of  C root C data { data: [33m1[39m } C
47.947 : WARN :  Copying (nodes) clusterId C nodes [ [32m'D'[39m ]
47.947 : WARN :  Copying children of  D root C data { data: [33m2[39m } C
47.947 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m, [32m'D'[39m ]
47.947 : WARN :  Setting parent d D
47.947 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.947 : WARN :  Cluster **  D  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
47.947 : WARN :  Cluster without external connections, without a parent and with children B [33m0[39m
47.947 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.947 : WARN :  Copying children of  B root B data { data: [33m4[39m } B
47.947 : WARN :  Copying (nodes) clusterId B nodes [ [32m'b'[39m ]
47.947 : WARN :  New graph after copy node: ( B ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.947 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
47.947 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.947 : WARN :  Copying children of  A root A data { data: [33m6[39m } A
47.947 : WARN :  Copying (nodes) clusterId A nodes [ [32m'a'[39m ]
47.947 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.947 : WARN :  New list of nodes [ [32m'C'[39m, [32m'B'[39m, [32m'A'[39m ]
47.947 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: { data: [33m1[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m, D: [36m[Object][39m },
    _parent: { d: [32m'D'[39m, D: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {}, D: [36m[Object][39m },
    _in: { d: {}, D: {} },
    _preds: { d: {}, D: {} },
    _out: { d: {}, D: {} },
    _sucs: { d: {}, D: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m2[39m
  }
}
47.947 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
47.947 : WARN :  Cluster without external connections, without a parent and with children D [33m1[39m
47.947 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.947 : WARN :  Copying children of  D root D data { data: [33m2[39m } D
47.947 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m ]
47.947 : WARN :  New graph after copy node: ( D ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.947 : WARN :  New list of nodes [ [32m'D'[39m ]
47.947 : WARN :   Now next level D {
  clusterNode: [33mtrue[39m,
  id: [32m'D'[39m,
  clusterData: { data: [33m2[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m },
    _parent: { d: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {} },
    _in: { d: {} },
    _preds: { d: {} },
    _out: { d: {} },
    _sucs: { d: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
47.947 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.947 : WARN :   Now next level B {
  clusterNode: [33mtrue[39m,
  id: [32m'B'[39m,
  clusterData: { data: [33m4[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
47.947 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.947 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: { data: [33m6[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
47.968 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
47.947 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
47.968 : WARN :  Cluster identified b  Replacement id in edges:  c
47.968 : WARN :  Edge a -> b: {"v":"a","w":"b","name":"1"}
47.968 : WARN :  Edge a -> b: {"data":"link1"}
    { v: [32m'b'[39m, value: [36m[Object][39m },
47.968 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} ids: a b Translating:  [90mundefined[39m  ---  { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
47.968 : WARN :  Fixing and trixing - removing XXX a b 1
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
47.968 : WARN :  Fix Replacing with XXX a b 1
47.968 : WARN :  Edge c -> d: {"v":"c","w":"d","name":"2"}
47.968 : WARN :  Edge c -> d: {"data":"link2"}
47.968 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  ],
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  edges: [
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
} ids: c d Translating:  [90mundefined[39m  ---  [90mundefined[39m
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
47.968 : WARN :  Edge d -> e: {"v":"d","w":"e","name":"2"}
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.968 : WARN :  Edge d -> e: {"data":"link2"}
47.968 : WARN :  Fix XXX {
}
47.968 : DEBUG :  Opting in, graph
47.968 : DEBUG :  Not a cluster  a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} ids: d e Translating:  [90mundefined[39m  ---  [90mundefined[39m
47.968 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  C1: [ [32m'a'[39m ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.968 : WARN :  extractor -  [33m0[39m {
  C2: [ [32m'b'[39m ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  A: [ [32m'a'[39m ],
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
  B: [ [32m'b'[39m ],
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.968 : WARN :  Cluster without external connections, without a parent and with children b [33m0[39m
47.968 : WARN :  Old graph before copy {
  C: [ [32m'D'[39m, [32m'd'[39m ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  D: [ [32m'd'[39m ],
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
}
  ],
47.968 : DEBUG :  Cluster identified b {
  C1: [ [32m'a'[39m ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.968 : WARN :  Copying children of  b root b data { data: [33m2[39m } b
47.968 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
47.968 : WARN :  New graph after copy node: ( b ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.968 : WARN :  New list of nodes [ [32m'a'[39m, [32m'b'[39m ]
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
47.968 : WARN :   Now next level a { data: [33m1[39m }
47.968 : WARN :   Now next level b {
  clusterNode: [33mtrue[39m,
  id: [32m'b'[39m,
  clusterData: { data: [33m2[39m },
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
47.968 : DEBUG :  Not a cluster  c {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
47.968 : DEBUG :  Not a cluster  d {
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
  C1: [ [32m'a'[39m ],
    _isMultigraph: [33mtrue[39m,
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m, d: [36m[Object][39m, e: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m, d: [32m'\x00'[39m, e: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {}, d: {}, e: {} },
    _in: { c: {}, d: [36m[Object][39m, e: [36m[Object][39m },
  B: [ [32m'b'[39m ],
    _preds: { c: {}, d: [36m[Object][39m, e: [36m[Object][39m },
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
    _out: { c: [36m[Object][39m, d: [36m[Object][39m, e: {} },
    _sucs: { c: [36m[Object][39m, d: [36m[Object][39m, e: {} },
    _edgeObjs: { [32m'c\x01d\x012'[39m: [36m[Object][39m, [32m'd\x01e\x012'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'c\x01d\x012'[39m: [36m[Object][39m, [32m'd\x01e\x012'[39m: [36m[Object][39m },
    _nodeCount: [33m3[39m,
    _edgeCount: [33m2[39m
  }
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
}
47.968 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m },
47.968 : DEBUG :  Not a cluster  e {
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  ],
  edges: [
  C1: [ [32m'a'[39m ],
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
  C2: [ [32m'b'[39m ],
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  A: [ [32m'a'[39m ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
  B: [ [32m'b'[39m ],

  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
47.968 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ] [33m0[39m
47.968 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
47.968 : DEBUG :  Not a cluster a [33m0[39m
47.968 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
47.968 : INFO :  cp  c  to  b  with parent  b
47.968 : INFO :  In copy  b root b data { data: [33m2[39m } b
47.968 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.968 : DEBUG :  Copying Edges [
  { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m },
  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m },
  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
]
47.968 : INFO :  Edge { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }
47.968 : INFO :  Edge data { data: [32m'link2'[39m } b
47.968 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
47.968 : INFO :  Edge is  { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }
47.968 : INFO :  Copying as  c d { data: [32m'link2'[39m } 2
47.968 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
47.968 : INFO :  Edge { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
47.968 : INFO :  Edge data { data: [32m'link2'[39m } b
47.968 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
47.968 : INFO :  Edge is  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
47.968 : INFO :  Copying as  d e { data: [32m'link2'[39m } 2
47.968 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }, { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
47.968 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
47.968 : INFO :  Edge data { data: [32m'link1'[39m } b
47.968 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
47.968 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
47.968 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
47.968 : DEBUG :  Removing node c
47.968 : INFO :  cp  d  to  b  with parent  b
47.968 : INFO :  In copy  b root b data { data: [33m2[39m } b
47.968 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.968 : DEBUG :  Copying Edges [ { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }, { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
47.968 : INFO :  Edge { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
47.968 : INFO :  Edge data { data: [32m'link2'[39m } b
47.968 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
47.968 : INFO :  Edge is  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
47.968 : INFO :  Copying as  d e { data: [32m'link2'[39m } 2
47.968 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }, { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
47.968 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
47.968 : INFO :  Edge data { data: [32m'link1'[39m } b
47.968 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
47.968 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
47.968 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
47.968 : DEBUG :  Removing node d
47.968 : INFO :  cp  e  to  b  with parent  b
47.968 : INFO :  In copy  b root b data { data: [33m2[39m } b
47.968 : DEBUG :  Not Setting parent for node= e cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.968 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
47.968 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
47.968 : INFO :  Edge data { data: [32m'link1'[39m } b
47.968 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
47.968 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
47.968 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
47.968 : DEBUG :  Removing node e
47.968 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m }, { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.968 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.968 : DEBUG :  Not a cluster c [33m0[39m
47.968 : DEBUG :  Extracting node d {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.968 : DEBUG :  Not a cluster d [33m0[39m
47.968 : DEBUG :  Extracting node e {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.968 : DEBUG :  Not a cluster e [33m0[39m
47.968 : DEBUG :  Done, no node has children [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
47.968 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
47.939 : INFO :  Graph before { data: [33m2[39m }
47.939 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.939 : DEBUG :  Opting in, graph
47.939 : DEBUG :  Cluster identified C Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
47.939 : DEBUG :  Cluster identified D Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
47.939 : DEBUG :  Not a cluster  d Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
47.939 : DEBUG :  Cluster identified B Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
47.939 : DEBUG :  Not a cluster  b Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
47.939 : DEBUG :  Cluster identified A Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
47.939 : DEBUG :  Not a cluster  a Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
47.939 : DEBUG :  Nodes =  [
  [32m'C'[39m, [32m'D'[39m, [32m'd'[39m,
  [32m'B'[39m, [32m'b'[39m, [32m'A'[39m,
  [32m'a'[39m
] [33m0[39m
47.939 : DEBUG :  Extracting node C Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [ [32m'd'[39m ]  Depth  [33m0[39m
47.939 : INFO :  cp  d  to  C  with parent  D
47.939 : DEBUG :  Setting parent d D
47.939 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
47.939 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
47.939 : INFO :  Edge data { data: [32m'link1'[39m } C
47.939 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
47.939 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
47.939 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
47.939 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
47.939 : INFO :  Edge data { data: [32m'link2'[39m } C
47.939 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
47.939 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
47.939 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
47.939 : DEBUG :  Removing node d
47.939 : INFO :  cp  D  to  C  with parent  D
47.939 : INFO :  In copy  D root C data { data: [33m2[39m } C
47.939 : DEBUG :  Not Setting parent for node= D cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
47.939 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
47.939 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
47.939 : INFO :  Edge data { data: [32m'link1'[39m } C
47.939 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
47.939 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
47.939 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
47.939 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
47.939 : INFO :  Edge data { data: [32m'link2'[39m } C
47.939 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
47.939 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
47.939 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
47.939 : DEBUG :  Removing node D
47.939 : DEBUG :  Removing node D
47.939 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
47.939 : WARN :  Cluster identified C  Replacement id in edges:  d
47.939 : WARN :  Cluster identified D  Replacement id in edges:  d
47.939 : WARN :  Cluster identified B  Replacement id in edges:  b
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
47.939 : WARN :  Cluster identified A  Replacement id in edges:  a
    { v: [32m'B'[39m, value: [36m[Object][39m },
47.939 : WARN :  Edge A -> B: {"v":"A","w":"B","name":"1"}
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.939 : DEBUG :  Extracting node D Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
47.939 : WARN :  Edge A -> B: {"data":"link1"}
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.939 : DEBUG :  Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
47.939 : WARN :  Fix XXX Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} ids: A B Translating:  { id: [32m'a'[39m, clusterData: { data: [33m6[39m } }  ---  { id: [32m'b'[39m, clusterData: { data: [33m4[39m } }
47.939 : WARN :  Fixing and trying - removing XXX A B 1
47.939 : WARN :  Fix Replacing with XXX A B 1
47.939 : WARN :  Edge A -> C: {"v":"A","w":"C","name":"2"}
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
47.939 : WARN :  Edge A -> C: {"data":"link2"}
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
47.939 : WARN :  Fix XXX Map(6) {
}
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
47.939 : DEBUG :  Extracting node d Map(6) {
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} ids: A C Translating:  { id: [32m'a'[39m, clusterData: { data: [33m6[39m } }  ---  { id: [32m'D'[39m, clusterData: { data: [33m1[39m } }
47.939 : WARN :  Fixing and trying - removing XXX A C 2
47.939 : WARN :  Fix Replacing with XXX A C 2
47.939 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    { v: [32m'B'[39m, value: [36m[Object][39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    { v: [32m'A'[39m, value: [36m[Object][39m },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  ],
47.939 : DEBUG :  Not a cluster d [33m0[39m
  edges: [
47.939 : DEBUG :  Extracting node B Map(6) {
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
47.939 : INFO :  cp  b  to  B  with parent  B
47.939 : INFO :  In copy  B root B data { data: [33m4[39m } B
47.939 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
47.939 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
  ],
47.939 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.939 : INFO :  Edge data { data: [32m'link1'[39m } B
}
47.939 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
47.939 : WARN :  extractor -  [33m0[39m {
47.939 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.939 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
  nodes: [
47.939 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
    { v: [32m'C'[39m, value: [36m[Object][39m },
47.939 : INFO :  Edge data { data: [32m'link2'[39m } B
47.939 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
47.939 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
47.939 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
    { v: [32m'B'[39m, value: [36m[Object][39m },
47.939 : DEBUG :  Removing node b
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
47.939 : DEBUG :  Old graph after copy {
    { v: [32m'A'[39m, value: [36m[Object][39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  nodes: [
  ],
    { v: [32m'C'[39m, value: [36m[Object][39m },
  edges: [
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  edges: [
} [ [32m'd'[39m ]
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
47.939 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
47.939 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  edges: [
  ],
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
}
  ],
47.939 : DEBUG :  Extracting node b Map(6) {
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
}
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
47.939 : WARN :  Copying children of  C root C data { data: [33m1[39m } C
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
47.939 : WARN :  Copying (nodes) clusterId C nodes [ [32m'D'[39m ]
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
47.939 : WARN :  Copying children of  D root C data { data: [33m2[39m } C
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
47.939 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m, [32m'D'[39m ]
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
47.939 : WARN :  Setting parent d D
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.939 : WARN :  New graph after copy node: ( C ) {
47.939 : DEBUG :  Not a cluster b [33m0[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.939 : WARN :  Cluster **  D  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
47.939 : WARN :  Cluster without external connections, without a parent and with children B [33m0[39m
47.939 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
47.939 : DEBUG :  Extracting node A Map(6) {
    { v: [32m'C'[39m, value: [36m[Object][39m },
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'B'[39m, value: [36m[Object][39m },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    { v: [32m'A'[39m, value: [36m[Object][39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  ],
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
  edges: [
} [33mtrue[39m [33mtrue[39m { data: [33m6[39m } [90mundefined[39m  Depth  [33m0[39m
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
47.939 : INFO :  cp  a  to  A  with parent  A
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
47.939 : INFO :  In copy  A root A data { data: [33m6[39m } A
  ],
47.939 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.939 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
}
47.939 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
47.939 : WARN :  Copying children of  B root B data { data: [33m4[39m } B
47.939 : INFO :  Edge data { data: [32m'link1'[39m } A
47.939 : WARN :  Copying (nodes) clusterId B nodes [ [32m'b'[39m ]
47.939 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
47.939 : WARN :  New graph after copy node: ( B ) {
47.939 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.939 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
47.939 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
  edges: [],
47.939 : INFO :  Edge data { data: [32m'link2'[39m } A
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.939 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
47.939 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
47.939 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
47.939 : WARN :  Old graph before copy {
47.939 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.939 : DEBUG :  Removing node a
  nodes: [
47.939 : DEBUG :  Old graph after copy {
    { v: [32m'C'[39m, value: [36m[Object][39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
    { v: [32m'B'[39m, value: [36m[Object][39m },
  ],
    { v: [32m'A'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.939 : WARN :  Copying children of  A root A data { data: [33m6[39m } A
47.939 : WARN :  Copying (nodes) clusterId A nodes [ [32m'a'[39m ]
47.939 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
47.939 : DEBUG :  Extracting node a Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.939 : WARN :  New list of nodes [ [32m'C'[39m, [32m'B'[39m, [32m'A'[39m ]
47.939 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: { data: [33m1[39m },
  label: [90mundefined[39m,
  graph: Graph {
47.939 : DEBUG :  Not a cluster a [33m0[39m
    _isDirected: [33mtrue[39m,
47.939 : DEBUG :  Nodes =  [ [32m'd'[39m, [32m'D'[39m ] [33m1[39m
47.939 : DEBUG :  Extracting node d Map(6) {
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m, D: [36m[Object][39m },
    _parent: { d: [32m'D'[39m, D: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {}, D: [36m[Object][39m },
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    _in: { d: {}, D: {} },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    _preds: { d: {}, D: {} },
    _out: { d: {}, D: {} },
    _sucs: { d: {}, D: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m2[39m
  }
}
47.939 : WARN :  extractor -  [33m1[39m {
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mfalse[39m { data: [33m3[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
47.939 : DEBUG :  Not a cluster d [33m1[39m
47.939 : DEBUG :  Extracting node D Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.939 : INFO :  cp  d  to  D  with parent  D
  nodes: [
47.939 : INFO :  In copy  D root D data { data: [33m2[39m } D
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
47.939 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  ],
47.939 : DEBUG :  Copying Edges []
  edges: [],
47.939 : DEBUG :  Removing node d
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.939 : DEBUG :  Old graph after copy {
} [ [32m'd'[39m ]
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.939 : WARN :  Cluster without external connections, without a parent and with children D [33m1[39m
  nodes: [ { v: [32m'D'[39m, value: [36m[Object][39m } ],
47.939 : WARN :  Old graph before copy {
  edges: [],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  nodes: [
}
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
47.939 : DEBUG :  Done, no node has children [ [32m'd'[39m ]
    { v: [32m'D'[39m, value: [36m[Object][39m }
47.939 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
  ],
47.939 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
  edges: [],
47.939 : INFO :  A [ [32m'a'[39m ]
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }

}
stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
47.939 : WARN :  Copying children of  D root D data { data: [33m2[39m } D
47.951 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
47.939 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m ]
  ],
47.939 : WARN :  New graph after copy node: ( D ) {
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
}
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
47.951 : DEBUG :  Opting in, graph
  edges: [],
47.951 : DEBUG :  Not a cluster  a Map(7) {
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'C1'[39m => [ [32m'a'[39m ],
}
  [32m'C2'[39m => [ [32m'b'[39m ],
47.939 : WARN :  New list of nodes [ [32m'D'[39m ]
  [32m'A'[39m => [ [32m'a'[39m ],
47.939 : WARN :   Now next level D {
  [32m'B'[39m => [ [32m'b'[39m ],
  clusterNode: [33mtrue[39m,
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  id: [32m'D'[39m,
  [32m'D'[39m => [ [32m'd'[39m ],
  clusterData: { data: [33m2[39m },
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
  label: [90mundefined[39m,
}
  graph: Graph {
47.951 : DEBUG :  Cluster identified b Map(7) {
    _isDirected: [33mtrue[39m,
  [32m'C1'[39m => [ [32m'a'[39m ],
    _isMultigraph: [33mtrue[39m,
  [32m'C2'[39m => [ [32m'b'[39m ],
    _isCompound: [33mtrue[39m,
  [32m'A'[39m => [ [32m'a'[39m ],
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
  [32m'B'[39m => [ [32m'b'[39m ],
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
  [32m'D'[39m => [ [32m'd'[39m ],
    _nodes: { d: [36m[Object][39m },
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
    _parent: { d: [32m'\x00'[39m },
}
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {} },
47.951 : DEBUG :  Not a cluster  c Map(7) {
    _in: { d: {} },
  [32m'C1'[39m => [ [32m'a'[39m ],
    _preds: { d: {} },
  [32m'C2'[39m => [ [32m'b'[39m ],
    _out: { d: {} },
  [32m'A'[39m => [ [32m'a'[39m ],
    _sucs: { d: {} },
  [32m'B'[39m => [ [32m'b'[39m ],
    _edgeObjs: {},
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
    _edgeLabels: {},
  [32m'D'[39m => [ [32m'd'[39m ],
    _nodeCount: [33m1[39m
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
  }
}
}
47.951 : DEBUG :  Not a cluster  d Map(7) {
47.939 : WARN :  extractor -  [33m2[39m {
  [32m'C1'[39m => [ [32m'a'[39m ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'C2'[39m => [ [32m'b'[39m ],
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  [32m'A'[39m => [ [32m'a'[39m ],
  edges: [],
  [32m'B'[39m => [ [32m'b'[39m ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
} [90mundefined[39m
  [32m'D'[39m => [ [32m'd'[39m ],
47.939 : WARN :   Now next level B {
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
  clusterNode: [33mtrue[39m,
}
  id: [32m'B'[39m,
47.951 : DEBUG :  Not a cluster  e Map(7) {
  clusterData: { data: [33m4[39m },
  [32m'C1'[39m => [ [32m'a'[39m ],
  label: [90mundefined[39m,
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  graph: Graph {
  [32m'B'[39m => [ [32m'b'[39m ],
    _isDirected: [33mtrue[39m,
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
    _isMultigraph: [33mtrue[39m,
  [32m'D'[39m => [ [32m'd'[39m ],
    _isCompound: [33mtrue[39m,
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
47.951 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ] [33m0[39m
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
47.951 : DEBUG :  Extracting node a Map(7) {
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    _nodes: { b: [36m[Object][39m },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    _parent: { b: [32m'\x00'[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    _in: { b: {} },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    _preds: { b: {} },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
    _out: { b: {} },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
47.951 : DEBUG :  Not a cluster a [33m0[39m
47.951 : DEBUG :  Extracting node b Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
47.951 : INFO :  cp  c  to  b  with parent  b
47.951 : INFO :  In copy  b root b data { data: [33m2[39m } b
47.951 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.951 : DEBUG :  Copying Edges [
    _sucs: { b: {} },
  { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m },
    _edgeObjs: {},
  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m },
    _edgeLabels: {},
  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
    _nodeCount: [33m1[39m
  }
}
47.939 : WARN :  extractor -  [33m1[39m {
]
47.951 : INFO :  Edge { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.951 : INFO :  Edge data { data: [32m'link2'[39m } b
47.951 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
47.951 : INFO :  Edge is  { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }
47.951 : INFO :  Copying as  c d { data: [32m'link2'[39m } 2
47.951 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
47.951 : INFO :  Edge { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
47.951 : INFO :  Edge data { data: [32m'link2'[39m } b
47.951 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
47.951 : INFO :  Edge is  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
47.951 : INFO :  Copying as  d e { data: [32m'link2'[39m } 2
47.951 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }, { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
47.951 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
47.951 : INFO :  Edge data { data: [32m'link1'[39m } b
47.951 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
47.951 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
47.951 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
  edges: [],
47.951 : DEBUG :  Removing node c
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.951 : INFO :  cp  d  to  b  with parent  b
} [90mundefined[39m
47.951 : INFO :  In copy  b root b data { data: [33m2[39m } b
47.939 : WARN :   Now next level A {
47.951 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.951 : DEBUG :  Copying Edges [ { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }, { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
47.951 : INFO :  Edge { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
47.951 : INFO :  Edge data { data: [32m'link2'[39m } b
47.951 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
47.951 : INFO :  Edge is  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
47.951 : INFO :  Copying as  d e { data: [32m'link2'[39m } 2
47.951 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }, { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
47.951 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
47.951 : INFO :  Edge data { data: [32m'link1'[39m } b
47.951 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
47.951 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
47.951 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
47.951 : DEBUG :  Removing node d
47.951 : INFO :  cp  e  to  b  with parent  b
  clusterNode: [33mtrue[39m,
47.951 : INFO :  In copy  b root b data { data: [33m2[39m } b
  id: [32m'A'[39m,
47.951 : DEBUG :  Not Setting parent for node= e cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  clusterData: { data: [33m6[39m },
47.951 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
  label: [90mundefined[39m,
47.951 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
47.951 : INFO :  Edge data { data: [32m'link1'[39m } b
47.951 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
47.951 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
47.951 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
47.951 : DEBUG :  Removing node e
47.951 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m }, { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.951 : DEBUG :  Extracting node c Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  graph: Graph {
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    _isDirected: [33mtrue[39m,
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    _isMultigraph: [33mtrue[39m,
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    _isCompound: [33mtrue[39m,
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
47.951 : DEBUG :  Not a cluster c [33m0[39m
47.951 : DEBUG :  Extracting node d Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.951 : DEBUG :  Not a cluster d [33m0[39m
47.951 : DEBUG :  Extracting node e Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    _nodes: { a: [36m[Object][39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    _parent: { a: [32m'\x00'[39m },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
    _in: { a: {} },
47.951 : DEBUG :  Not a cluster e [33m0[39m
    _preds: { a: {} },
47.951 : DEBUG :  Done, no node has children [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
47.951 : INFO :  Graph after {
    _out: { a: {} },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    _sucs: { a: {} },
  nodes: [
    _edgeObjs: {},
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
    _edgeLabels: {},
    { v: [32m'e'[39m, value: [36m[Object][39m }
    _nodeCount: [33m1[39m
  ],
  }
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
}
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
47.939 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
47.951 : WARN :  Cluster identified b  Replacement id in edges:  c
47.951 : WARN :  Edge a -> b: {"v":"a","w":"b","name":"1"}
47.951 : WARN :  Edge a -> b: {"data":"link1"}
47.951 : WARN :  Fix XXX Map(7) {
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
47.961 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
}
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
47.961 : DEBUG :  Opting in, graph
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
47.961 : DEBUG :  Cluster identified a Map(9) {
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
} ids: a b Translating:  [90mundefined[39m  ---  { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
47.951 : WARN :  Fixing and trying - removing XXX a b 1
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
47.951 : WARN :  Fix Replacing with XXX a b 1
  [32m'c'[39m => [ [32m'e'[39m ]
47.951 : WARN :  Edge c -> d: {"v":"c","w":"d","name":"2"}
}
47.951 : WARN :  Edge c -> d: {"data":"link2"}
47.961 : DEBUG :  Cluster identified b Map(9) {
47.951 : WARN :  Fix XXX Map(7) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
}
} ids: c d Translating:  [90mundefined[39m  ---  [90mundefined[39m
47.961 : DEBUG :  Cluster identified c Map(9) {
47.951 : WARN :  Edge d -> e: {"v":"d","w":"e","name":"2"}
  [32m'C1'[39m => [ [32m'a'[39m ],
47.951 : WARN :  Edge d -> e: {"data":"link2"}
  [32m'C2'[39m => [ [32m'b'[39m ],
47.951 : WARN :  Fix XXX Map(7) {
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'c'[39m => [ [32m'e'[39m ]
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
}
} ids: d e Translating:  [90mundefined[39m  ---  [90mundefined[39m
47.961 : DEBUG :  Not a cluster  e Map(9) {
47.951 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  [32m'C1'[39m => [ [32m'a'[39m ],
  ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'A'[39m => [ [32m'a'[39m ],
}
  [32m'B'[39m => [ [32m'b'[39m ],
47.951 : WARN :  extractor -  [33m0[39m {
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'D'[39m => [ [32m'd'[39m ],
  nodes: [
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
    { v: [32m'a'[39m, value: [36m[Object][39m },
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
  [32m'c'[39m => [ [32m'e'[39m ]
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
}
  ],
47.961 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ] [33m0[39m
  edges: [
47.961 : DEBUG :  Extracting node a Map(9) {
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  ],
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
} [90mundefined[39m
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
47.951 : WARN :  Cluster without external connections, without a parent and with children b [33m0[39m
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
47.951 : WARN :  Old graph before copy {
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
}
47.961 : INFO :  cp  e  to  a  with parent  c
47.951 : WARN :  Copying children of  b root b data { data: [33m2[39m } b
47.961 : DEBUG :  Setting parent e c
47.951 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
47.961 : DEBUG :  Copying Edges []
47.951 : WARN :  New graph after copy node: ( b ) {
47.961 : DEBUG :  Removing node e
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.961 : INFO :  cp  c  to  a  with parent  c
47.961 : INFO :  In copy  c root a data { data: [33m3[39m } a
  nodes: [
47.961 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
47.961 : DEBUG :  Copying Edges []
47.961 : DEBUG :  Removing node c
47.961 : DEBUG :  Removing node c
47.961 : INFO :  cp  b  to  a  with parent  b
47.961 : INFO :  In copy  b root a data { data: [33m2[39m } a
47.961 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
47.961 : DEBUG :  Copying Edges []
47.961 : DEBUG :  Removing node b
47.961 : DEBUG :  Removing node b
47.961 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
    { v: [32m'c'[39m, value: [36m[Object][39m },
  edges: [],
    { v: [32m'd'[39m, value: [36m[Object][39m },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
    { v: [32m'e'[39m, value: [36m[Object][39m }
47.961 : DEBUG :  Extracting node b Map(9) {
  ],
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  edges: [
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  ],
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.961 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
47.951 : WARN :  New list of nodes [ [32m'a'[39m, [32m'b'[39m ]
47.961 : DEBUG :  Extracting node c Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.961 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
47.951 : WARN :   Now next level a { data: [33m1[39m }
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
47.951 : WARN :   Now next level b {
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
47.961 : DEBUG :  Extracting node e Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  clusterNode: [33mtrue[39m,
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  id: [32m'b'[39m,
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  clusterData: { data: [33m2[39m },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.961 : DEBUG :  Not a cluster e [33m0[39m
47.961 : DEBUG :  Nodes =  [ [32m'e'[39m, [32m'c'[39m, [32m'b'[39m ] [33m1[39m
47.961 : DEBUG :  Extracting node e Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  label: [90mundefined[39m,
  graph: Graph {
} [33mfalse[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m1[39m
47.961 : DEBUG :  Not a cluster e [33m1[39m
47.961 : DEBUG :  Extracting node c Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    _isDirected: [33mtrue[39m,
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    _isMultigraph: [33mtrue[39m,
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
    _isCompound: [33mtrue[39m,
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
    _nodes: { c: [36m[Object][39m, d: [36m[Object][39m, e: [36m[Object][39m },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
    _parent: { c: [32m'\x00'[39m, d: [32m'\x00'[39m, e: [32m'\x00'[39m },
} [33mtrue[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m1[39m
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {}, d: {}, e: {} },
47.961 : INFO :  cp  e  to  c  with parent  c
    _in: { c: {}, d: [36m[Object][39m, e: [36m[Object][39m },
47.961 : INFO :  In copy  c root c data { data: [33m3[39m } c
    _preds: { c: {}, d: [36m[Object][39m, e: [36m[Object][39m },
47.961 : DEBUG :  Not Setting parent for node= e cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.961 : DEBUG :  Copying Edges []
    _out: { c: [36m[Object][39m, d: [36m[Object][39m, e: {} },
47.961 : DEBUG :  Removing node e
    _sucs: { c: [36m[Object][39m, d: [36m[Object][39m, e: {} },
47.961 : DEBUG :  Old graph after copy {
    _edgeObjs: { [32m'c\x01d\x012'[39m: [36m[Object][39m, [32m'd\x01e\x012'[39m: [36m[Object][39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    _edgeLabels: { [32m'c\x01d\x012'[39m: [36m[Object][39m, [32m'd\x01e\x012'[39m: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    _nodeCount: [33m3[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m }
    _edgeCount: [33m2[39m
  ],
  }
  edges: [],
}
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
47.951 : WARN :  extractor -  [33m1[39m {
}
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.961 : DEBUG :  Extracting node b Map(9) {
  nodes: [
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'c'[39m, value: [36m[Object][39m },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m1[39m
47.961 : INFO :  cp  c  to  b  with parent  b
47.961 : INFO :  In copy  b root b data { data: [33m2[39m } b
47.961 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.961 : DEBUG :  Copying Edges []
47.961 : DEBUG :  Removing node c
47.961 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  edges: [
}
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
47.961 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
47.961 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
47.961 : WARN :  Cluster identified a  Replacement id in edges:  e
47.961 : WARN :  Cluster identified b  Replacement id in edges:  e
47.961 : WARN :  Cluster identified c  Replacement id in edges:  e
47.961 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.961 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.961 : WARN :  Cluster without external connections, without a parent and with children a [33m0[39m
47.961 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.961 : WARN :  Copying children of  a root a data { data: [33m1[39m } a
47.961 : WARN :  Copying (nodes) clusterId a nodes [ [32m'b'[39m ]
47.961 : WARN :  Copying children of  b root a data { data: [33m2[39m } a
47.961 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m, [32m'b'[39m ]
47.961 : WARN :  Copying children of  c root a data { data: [33m3[39m } a
47.961 : WARN :  Copying (nodes) clusterId c nodes [ [32m'e'[39m, [32m'c'[39m ]
47.961 : WARN :  Setting parent e c
47.961 : WARN :  Setting parent c b
47.961 : WARN :  New graph after copy node: ( a ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.961 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
47.961 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
47.961 : WARN :  New list of nodes [ [32m'a'[39m ]
47.961 : WARN :   Now next level a {
  clusterNode: [33mtrue[39m,
  id: [32m'a'[39m,
  clusterData: { data: [33m1[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { e: [36m[Object][39m, c: [36m[Object][39m, b: [36m[Object][39m },
    _parent: { e: [32m'c'[39m, c: [32m'b'[39m, b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, e: {}, c: [36m[Object][39m, b: [36m[Object][39m },
    _in: { e: {}, c: {}, b: {} },
    _preds: { e: {}, c: {}, b: {} },
    _out: { e: {}, c: {}, b: {} },
    _sucs: { e: {}, c: {}, b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m3[39m
  }
}
47.961 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.961 : WARN :  Cluster without external connections, without a parent and with children c [33m1[39m
47.961 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
47.961 : WARN :  Copying children of  c root c data { data: [33m3[39m } c
47.968 : INFO :  Graph before {
47.961 : WARN :  Copying (nodes) clusterId c nodes [ [32m'e'[39m ]
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
47.961 : WARN :  New graph after copy node: ( c ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'e'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.961 : WARN :  Cluster without external connections, without a parent and with children b [33m1[39m
47.961 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  nodes: [
  edges: [],
    { v: [32m'A'[39m, value: [36m[Object][39m },
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
}
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
47.961 : WARN :  Copying children of  b root b data { data: [33m2[39m } b
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
47.961 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m ]
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
47.961 : WARN :  New graph after copy node: ( b ) {
  ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  edges: [
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
    { v: [32m'b'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
}
47.968 : DEBUG :  Opting in, graph
47.961 : WARN :  New list of nodes [ [32m'b'[39m ]
47.968 : DEBUG :  Cluster identified A Map(9) {
47.961 : WARN :   Now next level b {
  [32m'C1'[39m => [ [32m'a'[39m ],
  clusterNode: [33mtrue[39m,
  [32m'C2'[39m => [ [32m'b'[39m ],
  id: [32m'b'[39m,
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  clusterData: { data: [33m2[39m },
  [32m'B'[39m => [ [32m'c'[39m ],
  label: [90mundefined[39m,
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  graph: Graph {
  [32m'D'[39m => [ [32m'd'[39m ],
    _isDirected: [33mtrue[39m,
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
    _isMultigraph: [33mtrue[39m,
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
    _isCompound: [33mtrue[39m,
  [32m'c'[39m => [ [32m'e'[39m ]
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
}
    _nodes: { c: [36m[Object][39m },
47.968 : DEBUG :  Cluster identified B Map(9) {
    _parent: { c: [32m'\x00'[39m },
  [32m'C1'[39m => [ [32m'a'[39m ],
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
  [32m'C2'[39m => [ [32m'b'[39m ],
    _in: { c: {} },
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
    _preds: { c: {} },
  [32m'B'[39m => [ [32m'c'[39m ],
    _out: { c: {} },
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
    _sucs: { c: {} },
  [32m'D'[39m => [ [32m'd'[39m ],
    _edgeObjs: {},
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
    _edgeLabels: {},
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
    _nodeCount: [33m1[39m
  [32m'c'[39m => [ [32m'e'[39m ]
  }
}
}
47.968 : DEBUG :  Not a cluster  b Map(9) {
47.961 : WARN :  extractor -  [33m2[39m {
  [32m'C1'[39m => [ [32m'a'[39m ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'C2'[39m => [ [32m'b'[39m ],
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
47.968 : DEBUG :  Not a cluster  c Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  edges: [],
  [32m'D'[39m => [ [32m'd'[39m ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
} [90mundefined[39m
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],

  [32m'c'[39m => [ [32m'e'[39m ]
}
47.968 : DEBUG :  Not a cluster  a Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
47.968 : DEBUG :  Nodes =  [ [32m'A'[39m, [32m'B'[39m, [32m'b'[39m, [32m'c'[39m, [32m'a'[39m ] [33m0[39m
47.968 : DEBUG :  Extracting node A Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  cssClass: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m0[39m
47.968 : INFO :  cp  c  to  A  with parent  B
47.968 : DEBUG :  Setting parent c B
47.968 : DEBUG :  Copying Edges [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }, { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
47.968 : INFO :  Edge { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }
47.968 : INFO :  Edge data {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  cssClasses: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
} A
47.968 : INFO :  Descendants of  A  is  [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ]
47.968 : INFO :  Edge is  { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }
47.968 : INFO :  Copying as  b c {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  cssClasses: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
} 1
47.968 : INFO :  newGraph edges  [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m } ] {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  cssClasses: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
}
47.968 : INFO :  Edge { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
47.968 : WARN :  Cluster identified A  Replacement id in edges:  c
47.968 : WARN :  Cluster identified B  Replacement id in edges:  c
47.968 : INFO :  Edge data {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
47.968 : WARN :  Edge:  { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }  leaves cluster  B
  id: [32m'L-a-c'[39m,
47.968 : WARN :  Descendants of XXX  B :  [ [32m'c'[39m ]
  cssClasses: [32m'flowchart-link LS-a LE-c'[39m
} A
47.968 : INFO :  Descendants of  A  is  [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ]
47.968 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
47.968 : INFO :  Copying as  a c {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
47.968 : WARN :  Edge b -> B: {"v":"b","w":"B","name":"1"}
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
47.968 : WARN :  Edge b -> B: {"minlen":1,"arrowhead":"normal","arrowTypeStart":"arrow_open","arrowTypeEnd":"arrow_point","thickness":"normal","pattern":"solid","style":"fill:none","labelStyle":"","arrowheadStyle":"fill: #333","labelpos":"c","labelType":"text","label":"","id":"L-b-B","cssClasses":"flowchart-link LS-b LE-B"}
  id: [32m'L-a-c'[39m,
  cssClasses: [32m'flowchart-link LS-a LE-c'[39m
47.968 : WARN :  Fix XXX Map(9) {
} 2
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
47.968 : INFO :  newGraph edges  [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }, { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ] {
  minlen: [33m1[39m,
  [32m'A'[39m => {
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  cssClasses: [32m'flowchart-link LS-b LE-B'[39m,
    id: [32m'c'[39m,
  toCluster: [32m'B'[39m
    clusterData: {
}
      labelStyle: [32m''[39m,
47.968 : DEBUG :  Removing node c
47.968 : INFO :  cp  B  to  A  with parent  B
47.968 : INFO :  In copy  B root A data {
      shape: [32m'rect'[39m,
  labelStyle: [32m''[39m,
      labelText: [32m'A'[39m,
  shape: [32m'rect'[39m,
      rx: [33m0[39m,
  labelText: [32m'B'[39m,
      ry: [33m0[39m,
  rx: [33m0[39m,
      cssClass: [32m'default'[39m,
  ry: [33m0[39m,
      style: [32m''[39m,
  class: [32m'default'[39m,
      id: [32m'A'[39m,
  style: [32m''[39m,
      width: [33m500[39m,
  id: [32m'B'[39m,
      type: [32m'group'[39m,
  width: [33m500[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
} ids: b B Translating:  { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }  ---  {
  id: [32m'c'[39m,
  clusterData: {
    labelStyle: [32m''[39m,
    shape: [32m'rect'[39m,
    labelText: [32m'B'[39m,
    rx: [33m0[39m,
    ry: [33m0[39m,
    class: [32m'default'[39m,
    style: [32m''[39m,
47.968 : DEBUG :  Not Setting parent for node= B cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
    id: [32m'B'[39m,
47.968 : DEBUG :  Copying Edges []
    width: [33m500[39m,
47.968 : DEBUG :  Removing node B
    type: [32m'group'[39m,
47.968 : DEBUG :  Removing node B
    padding: [33m15[39m
47.968 : INFO :  cp  b  to  A  with parent  A
  },
47.968 : INFO :  In copy  A root A data {
  externalConnections: [33mtrue[39m
  labelStyle: [32m''[39m,
}
  shape: [32m'rect'[39m,
47.968 : WARN :  Fixing and trying - removing XXX b B 1
  labelText: [32m'A'[39m,
47.968 : WARN :  Fix Replacing with XXX b c 1
  rx: [33m0[39m,
47.968 : WARN :  Edge a -> c: {"v":"a","w":"c","name":"2"}
  ry: [33m0[39m,
  cssClass: [32m'default'[39m,
47.968 : WARN :  Edge a -> c: {"minlen":1,"arrowhead":"normal","arrowTypeStart":"arrow_open","arrowTypeEnd":"arrow_point","thickness":"normal","pattern":"solid","style":"fill:none","labelStyle":"","arrowheadStyle":"fill: #333","labelpos":"c","labelType":"text","label":"","id":"L-a-c","cssClasses":"flowchart-link LS-a LE-c"}
  style: [32m''[39m,
47.968 : WARN :  Fix XXX Map(9) {
  id: [32m'A'[39m,
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  width: [33m500[39m,
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  type: [32m'group'[39m,
  [32m'A'[39m => {
  padding: [33m15[39m
} A
47.968 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.968 : DEBUG :  Copying Edges []
47.968 : DEBUG :  Removing node b
    id: [32m'c'[39m,
47.968 : INFO :  cp  a  to  A  with parent  A
    clusterData: {
47.968 : INFO :  In copy  A root A data {
      labelStyle: [32m''[39m,
  labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
  shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
  labelText: [32m'A'[39m,
      rx: [33m0[39m,
  rx: [33m0[39m,
      ry: [33m0[39m,
  ry: [33m0[39m,
      cssClass: [32m'default'[39m,
  cssClass: [32m'default'[39m,
      style: [32m''[39m,
  style: [32m''[39m,
      id: [32m'A'[39m,
  id: [32m'A'[39m,
      width: [33m500[39m,
  width: [33m500[39m,
      type: [32m'group'[39m,
  type: [32m'group'[39m,
      padding: [33m15[39m
  padding: [33m15[39m
    }
} A
  },
47.968 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  [32m'B'[39m => {
47.968 : DEBUG :  Copying Edges []
    id: [32m'c'[39m,
47.968 : DEBUG :  Removing node a
47.968 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'A'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.968 : DEBUG :  Extracting node B Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  [32m'B'[39m => {
} ids: a c Translating:  { id: [32m'c'[39m, clusterData: { data: [33m1[39m } }  ---  { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
    id: [32m'c'[39m,
47.968 : WARN :  Fixing and trying - removing XXX a c 2
    clusterData: {
47.968 : WARN :  Fix Replacing with XXX a c 2
      labelStyle: [32m''[39m,
47.968 : WARN :  Adjusted Graph {
      shape: [32m'rect'[39m,
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
      labelText: [32m'B'[39m,
  nodes: [
      rx: [33m0[39m,
    { v: [32m'A'[39m, value: [36m[Object][39m },
      ry: [33m0[39m,
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
      class: [32m'default'[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
      style: [32m''[39m,
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.968 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
  edges: [
      id: [32m'B'[39m,
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
      width: [33m500[39m,
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
      type: [32m'group'[39m,
  ],
      padding: [33m15[39m
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    },
}
    externalConnections: [33mtrue[39m
47.968 : WARN :  extractor -  [33m0[39m {
  },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  nodes: [
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
    { v: [32m'A'[39m, value: [36m[Object][39m },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
47.968 : DEBUG :  Extracting node b Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
      id: [32m'A'[39m,
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
      width: [33m500[39m,
      type: [32m'group'[39m,
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
      padding: [33m15[39m
  ],
    }
  edges: [
  },
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
  [32m'B'[39m => {
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
    id: [32m'c'[39m,
  ],
    clusterData: {
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.968 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
47.968 : WARN :  Old graph before copy {
      labelStyle: [32m''[39m,
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
      shape: [32m'rect'[39m,
  nodes: [
      labelText: [32m'B'[39m,
    { v: [32m'A'[39m, value: [36m[Object][39m },
      rx: [33m0[39m,
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
      ry: [33m0[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
      class: [32m'default'[39m,
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
      style: [32m''[39m,
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.968 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  ],
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  edges: [
  [32m'A'[39m => {
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    id: [32m'c'[39m,
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
    clusterData: {
  ],
      labelStyle: [32m''[39m,
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
      shape: [32m'rect'[39m,
}
      labelText: [32m'A'[39m,
47.968 : WARN :  Copying children of  A root A data {
      rx: [33m0[39m,
  labelStyle: [32m''[39m,
      ry: [33m0[39m,
  shape: [32m'rect'[39m,
      cssClass: [32m'default'[39m,
  labelText: [32m'A'[39m,
      style: [32m''[39m,
  rx: [33m0[39m,
      id: [32m'A'[39m,
  ry: [33m0[39m,
      width: [33m500[39m,
  cssClass: [32m'default'[39m,
      type: [32m'group'[39m,
  style: [32m''[39m,
      padding: [33m15[39m
  id: [32m'A'[39m,
    }
  width: [33m500[39m,
  },
  [32m'B'[39m => {
  type: [32m'group'[39m,
    id: [32m'c'[39m,
  padding: [33m15[39m
    clusterData: {
} A
      labelStyle: [32m''[39m,
47.968 : WARN :  Copying (nodes) clusterId A nodes [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ]
      shape: [32m'rect'[39m,
47.968 : WARN :  Copying children of  B root A data {
      labelText: [32m'B'[39m,
  labelStyle: [32m''[39m,
      rx: [33m0[39m,
  shape: [32m'rect'[39m,
      ry: [33m0[39m,
  labelText: [32m'B'[39m,
      class: [32m'default'[39m,
  rx: [33m0[39m,
      style: [32m''[39m,
  ry: [33m0[39m,
      id: [32m'B'[39m,
  class: [32m'default'[39m,
      width: [33m500[39m,
  style: [32m''[39m,
      type: [32m'group'[39m,
  id: [32m'B'[39m,
      padding: [33m15[39m
  width: [33m500[39m,
    },
  type: [32m'group'[39m,
    externalConnections: [33mtrue[39m
  padding: [33m15[39m
  },
} A
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
47.968 : WARN :  Copying (nodes) clusterId B nodes [ [32m'c'[39m, [32m'B'[39m ]
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
47.968 : WARN :  Setting parent c B
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
47.968 : WARN :  New graph after copy node: ( A ) {
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
}
  nodes: [
47.968 : DEBUG :  Extracting node c Map(9) {
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'B'[39m, value: [36m[Object][39m },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
  [32m'A'[39m => {
    { v: [32m'a'[39m, value: [36m[Object][39m }
    id: [32m'c'[39m,
  ],
    clusterData: {
  edges: [
      labelStyle: [32m''[39m,
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
      shape: [32m'rect'[39m,
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
      labelText: [32m'A'[39m,
  ],
      rx: [33m0[39m,
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
      ry: [33m0[39m,
}
      cssClass: [32m'default'[39m,
47.968 : WARN :  Cluster **  B  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
      style: [32m''[39m,
47.968 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
      id: [32m'A'[39m,
47.968 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
      width: [33m500[39m,
47.968 : WARN :  Cluster **  a  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
      type: [32m'group'[39m,
47.968 : WARN :  New list of nodes [ [32m'A'[39m ]
      padding: [33m15[39m
47.968 : WARN :   Now next level A {
    }
  clusterNode: [33mtrue[39m,
  },
  id: [32m'A'[39m,
  [32m'B'[39m => {
  clusterData: {
    id: [32m'c'[39m,
    labelStyle: [32m''[39m,
    clusterData: {
    shape: [32m'rect'[39m,
      labelStyle: [32m''[39m,
    labelText: [32m'A'[39m,
      shape: [32m'rect'[39m,
    rx: [33m0[39m,
      labelText: [32m'B'[39m,
    ry: [33m0[39m,
      rx: [33m0[39m,
    cssClass: [32m'default'[39m,
      ry: [33m0[39m,
    style: [32m''[39m,
      class: [32m'default'[39m,
    id: [32m'A'[39m,
      style: [32m''[39m,
    width: [33m500[39m,
      id: [32m'B'[39m,
    type: [32m'group'[39m,
      width: [33m500[39m,
    padding: [33m15[39m
      type: [32m'group'[39m,
  },
      padding: [33m15[39m
  label: [90mundefined[39m,
    },
  graph: Graph {
    externalConnections: [33mtrue[39m
    _isDirected: [33mtrue[39m,
  },
    _isMultigraph: [33mtrue[39m,
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    _isCompound: [33mtrue[39m,
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
    _nodes: { c: [36m[Object][39m, B: [36m[Object][39m, b: [36m[Object][39m, a: [36m[Object][39m },
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
    _parent: { c: [32m'B'[39m, B: [32m'\x00'[39m, b: [32m'\x00'[39m, a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {}, B: [36m[Object][39m, b: {}, a: {} },
    _in: { c: [36m[Object][39m, B: {}, b: {}, a: {} },
    _preds: { c: [36m[Object][39m, B: {}, b: {}, a: {} },
    _out: { c: {}, B: {}, b: [36m[Object][39m, a: [36m[Object][39m },
    _sucs: { c: {}, B: {}, b: [36m[Object][39m, a: [36m[Object][39m },
    _edgeObjs: { [32m'b\x01c\x011'[39m: [36m[Object][39m, [32m'a\x01c\x012'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'b\x01c\x011'[39m: [36m[Object][39m, [32m'a\x01c\x012'[39m: [36m[Object][39m },
    _nodeCount: [33m4[39m,
    _edgeCount: [33m2[39m
  }
}
47.968 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
47.968 : DEBUG :  Map(9) {
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  ],
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'A'[39m => {
} [90mundefined[39m
47.968 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mfalse[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
    id: [32m'c'[39m,
47.968 : WARN :  Cluster **  B  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [33mtrue[39m [90mundefined[39m [33m1[39m
    clusterData: {
47.968 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
      labelStyle: [32m''[39m,
47.968 : WARN :  Cluster **  a  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
      shape: [32m'rect'[39m,
47.968 : WARN :  New list of nodes [ [32m'c'[39m, [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ]
      labelText: [32m'A'[39m,
47.968 : WARN :   Now next level c {
      rx: [33m0[39m,
  labelStyle: [32m''[39m,
      ry: [33m0[39m,
  shape: [32m'rect'[39m,
      cssClass: [32m'default'[39m,
  labelText: [32m'c'[39m,
      style: [32m''[39m,
  rx: [33m0[39m,
      id: [32m'A'[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'c'[39m,
      width: [33m500[39m,
  padding: [33m15[39m
      type: [32m'group'[39m,
}
      padding: [33m15[39m
47.968 : WARN :   Now next level B {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
}
47.968 : WARN :   Now next level b {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'b'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'b'[39m,
    }
  padding: [33m15[39m
  },
}
  [32m'B'[39m => {
47.968 : WARN :   Now next level a {
    id: [32m'c'[39m,
  labelStyle: [32m''[39m,
    clusterData: {
  shape: [32m'rect'[39m,
      labelStyle: [32m''[39m,
  labelText: [32m'a'[39m,
      shape: [32m'rect'[39m,
  rx: [33m0[39m,
      labelText: [32m'B'[39m,
  ry: [33m0[39m,
      rx: [33m0[39m,
  class: [32m'default'[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
47.968 : DEBUG :  Extracting node a Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
  style: [32m''[39m,
      labelStyle: [32m''[39m,
  id: [32m'a'[39m,
      shape: [32m'rect'[39m,
  padding: [33m15[39m
      labelText: [32m'A'[39m,
}
      rx: [33m0[39m,

      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.968 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
47.968 : DEBUG :  Nodes =  [ [32m'c'[39m, [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ] [33m1[39m
47.968 : DEBUG :  Extracting node c Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mfalse[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'c'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'c'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
47.968 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
47.968 : DEBUG :  Extracting node B Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
47.968 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
47.968 : DEBUG :  Extracting node b Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'b'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'b'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
47.968 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
47.968 : DEBUG :  Extracting node a Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'a'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'a'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
47.968 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
47.968 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

 âœ“ packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js (15 tests) 112ms
stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
47.983 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.983 : DEBUG :  Opting in, graph
47.983 : DEBUG :  Cluster identified a {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
47.983 : DEBUG :  Cluster identified b {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
47.983 : DEBUG :  Cluster identified c {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
47.983 : DEBUG :  Not a cluster  e {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
47.983 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ] [33m0[39m
47.983 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
47.983 : INFO :  cp  e  to  a  with parent  c
47.983 : DEBUG :  Setting parent e c
47.983 : DEBUG :  Copying Edges []
47.983 : DEBUG :  Removing node e
47.983 : INFO :  cp  c  to  a  with parent  c
47.983 : INFO :  In copy  c root a data { data: [33m3[39m } a
47.983 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
47.983 : DEBUG :  Copying Edges []
47.983 : DEBUG :  Removing node c
47.983 : DEBUG :  Removing node c
47.983 : INFO :  cp  b  to  a  with parent  b
47.983 : INFO :  In copy  b root a data { data: [33m2[39m } a
47.983 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
47.983 : DEBUG :  Copying Edges []
47.983 : DEBUG :  Removing node b
47.983 : DEBUG :  Removing node b
47.983 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.983 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.983 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
47.983 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.983 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
47.983 : DEBUG :  Extracting node e {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.983 : DEBUG :  Not a cluster e [33m0[39m
47.983 : DEBUG :  Nodes =  [ [32m'e'[39m, [32m'c'[39m, [32m'b'[39m ] [33m1[39m
47.983 : DEBUG :  Extracting node e {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [90mundefined[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m1[39m
47.983 : DEBUG :  Not a cluster e [33m1[39m
47.983 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m1[39m
47.983 : INFO :  cp  e  to  c  with parent  c
47.983 : INFO :  In copy  c root c data { data: [33m3[39m } c
47.983 : DEBUG :  Not Setting parent for node= e cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.983 : DEBUG :  Copying Edges []
47.983 : DEBUG :  Removing node e
47.983 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.983 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m1[39m
47.983 : INFO :  cp  c  to  b  with parent  b
47.983 : INFO :  In copy  b root b data { data: [33m2[39m } b
47.983 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.983 : DEBUG :  Copying Edges []
47.983 : DEBUG :  Removing node c
47.983 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.983 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
47.983 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
47.983 : WARN :  Cluster identified a  Replacement id in edges:  e
47.983 : WARN :  Cluster identified b  Replacement id in edges:  e
47.983 : WARN :  Cluster identified c  Replacement id in edges:  e
47.983 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.983 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.983 : WARN :  Cluster without external connections, without a parent and with children a [33m0[39m
47.983 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.983 : WARN :  Copying children of  a root a data { data: [33m1[39m } a
47.983 : WARN :  Copying (nodes) clusterId a nodes [ [32m'b'[39m ]
47.983 : WARN :  Copying children of  b root a data { data: [33m2[39m } a
47.983 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m, [32m'b'[39m ]
47.983 : WARN :  Copying children of  c root a data { data: [33m3[39m } a
47.983 : WARN :  Copying (nodes) clusterId c nodes [ [32m'e'[39m, [32m'c'[39m ]
47.983 : WARN :  Setting parent e c
47.983 : WARN :  Setting parent c b
47.983 : WARN :  New graph after copy node: ( a ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.983 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
47.983 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
47.983 : WARN :  New list of nodes [ [32m'a'[39m ]
47.983 : WARN :   Now next level a {
  clusterNode: [33mtrue[39m,
  id: [32m'a'[39m,
  clusterData: { data: [33m1[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { e: [36m[Object][39m, c: [36m[Object][39m, b: [36m[Object][39m },
    _parent: { e: [32m'c'[39m, c: [32m'b'[39m, b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, e: {}, c: [36m[Object][39m, b: [36m[Object][39m },
    _in: { e: {}, c: {}, b: {} },
    _preds: { e: {}, c: {}, b: {} },
    _out: { e: {}, c: {}, b: {} },
    _sucs: { e: {}, c: {}, b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m3[39m
  }
}
47.983 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.983 : WARN :  Cluster without external connections, without a parent and with children c [33m1[39m
47.983 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.983 : WARN :  Copying children of  c root c data { data: [33m3[39m } c
47.983 : WARN :  Copying (nodes) clusterId c nodes [ [32m'e'[39m ]
47.983 : WARN :  New graph after copy node: ( c ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'e'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.983 : WARN :  Cluster without external connections, without a parent and with children b [33m1[39m
47.983 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.983 : WARN :  Copying children of  b root b data { data: [33m2[39m } b
47.983 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m ]
47.983 : WARN :  New graph after copy node: ( b ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.983 : WARN :  New list of nodes [ [32m'b'[39m ]
47.983 : WARN :   Now next level b {
  clusterNode: [33mtrue[39m,
  id: [32m'b'[39m,
  clusterData: { data: [33m2[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
47.983 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
47.995 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.995 : DEBUG :  Opting in, graph
47.995 : DEBUG :  Cluster identified A {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
47.995 : DEBUG :  Cluster identified B {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
47.995 : DEBUG :  Not a cluster  b {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
47.995 : DEBUG :  Not a cluster  c {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
47.995 : DEBUG :  Not a cluster  a {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
47.995 : DEBUG :  Nodes =  [ [32m'A'[39m, [32m'B'[39m, [32m'b'[39m, [32m'c'[39m, [32m'a'[39m ] [33m0[39m
47.995 : DEBUG :  Extracting node A {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m0[39m
47.995 : INFO :  cp  c  to  A  with parent  B
47.995 : DEBUG :  Setting parent c B
47.995 : DEBUG :  Copying Edges [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }, { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
47.995 : INFO :  Edge { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }
47.995 : INFO :  Edge data {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  classes: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
} A
47.995 : INFO :  Descendants of  A  is  [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ]
47.995 : INFO :  Edge is  { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }
47.995 : INFO :  Copying as  b c {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  classes: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
} 1
47.995 : INFO :  newGraph edges  [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m } ] {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  classes: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
}
47.995 : INFO :  Edge { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
47.995 : INFO :  Edge data {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-a-c'[39m,
  classes: [32m'flowchart-link LS-a LE-c'[39m
} A
47.995 : INFO :  Descendants of  A  is  [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ]
47.995 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
47.995 : INFO :  Copying as  a c {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-a-c'[39m,
  classes: [32m'flowchart-link LS-a LE-c'[39m
} 2
47.995 : INFO :  newGraph edges  [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }, { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ] {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  classes: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
47.995 : WARN :  Cluster identified A  Replacement id in edges:  c
47.995 : WARN :  Cluster identified B  Replacement id in edges:  c
47.995 : WARN :  Edge:  { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }  leaves cluster  B
47.995 : WARN :  Descendants of XXX  B :  [ [32m'c'[39m ]
47.995 : WARN :  Edge b -> B: {"v":"b","w":"B","name":"1"}
47.995 : WARN :  Edge b -> B: {"minlen":1,"arrowhead":"normal","arrowTypeStart":"arrow_open","arrowTypeEnd":"arrow_point","thickness":"normal","pattern":"solid","style":"fill:none","labelStyle":"","arrowheadStyle":"fill: #333","labelpos":"c","labelType":"text","label":"","id":"L-b-B","classes":"flowchart-link LS-b LE-B"}
}
47.995 : DEBUG :  Removing node c
47.995 : INFO :  cp  B  to  A  with parent  B
47.995 : INFO :  In copy  B root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
47.995 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
47.995 : DEBUG :  Not Setting parent for node= B cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
47.995 : DEBUG :  Copying Edges []
47.995 : DEBUG :  Removing node B
47.995 : DEBUG :  Removing node B
47.995 : INFO :  cp  b  to  A  with parent  A
47.995 : INFO :  In copy  A root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
      ry: [33m0[39m,
  rx: [33m0[39m,
      class: [32m'default'[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
47.995 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.995 : DEBUG :  Copying Edges []
47.995 : DEBUG :  Removing node b
47.995 : INFO :  cp  a  to  A  with parent  A
47.995 : INFO :  In copy  A root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
      style: [32m''[39m,
  rx: [33m0[39m,
      id: [32m'A'[39m,
  ry: [33m0[39m,
      width: [33m500[39m,
  class: [32m'default'[39m,
      type: [32m'group'[39m,
  style: [32m''[39m,
      padding: [33m15[39m
  id: [32m'A'[39m,
  width: [33m500[39m,
    }
  type: [32m'group'[39m,
  },
  padding: [33m15[39m
  B: {
} A
    id: [32m'c'[39m,
    clusterData: {
47.995 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
47.995 : DEBUG :  Copying Edges []
47.995 : DEBUG :  Removing node a
47.995 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'A'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.995 : DEBUG :  Extracting node B {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.995 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} ids: b B Translating:  { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }  ---  {
  id: [32m'c'[39m,
  clusterData: {
    labelStyle: [32m''[39m,
    shape: [32m'rect'[39m,
    labelText: [32m'B'[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
    rx: [33m0[39m,
  },
    ry: [33m0[39m,
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    class: [32m'default'[39m,
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
    style: [32m''[39m,
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
    id: [32m'B'[39m,
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
    width: [33m500[39m,
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
    type: [32m'group'[39m,
}
    padding: [33m15[39m
47.995 : DEBUG :  Extracting node b {
  },
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  externalConnections: [33mtrue[39m
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
}
  A: {
47.995 : WARN :  Fixing and trixing - removing XXX b B 1
    id: [32m'c'[39m,
47.995 : WARN :  Fix Replacing with XXX b c 1
    clusterData: {
47.995 : WARN :  Edge a -> c: {"v":"a","w":"c","name":"2"}
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
47.995 : WARN :  Edge a -> c: {"minlen":1,"arrowhead":"normal","arrowTypeStart":"arrow_open","arrowTypeEnd":"arrow_point","thickness":"normal","pattern":"solid","style":"fill:none","labelStyle":"","arrowheadStyle":"fill: #333","labelpos":"c","labelType":"text","label":"","id":"L-a-c","classes":"flowchart-link LS-a LE-c"}
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
47.995 : WARN :  Fix XXX {
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  A: {
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
    id: [32m'c'[39m,
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.995 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
    clusterData: {
      labelStyle: [32m''[39m,
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      id: [32m'A'[39m,
      padding: [33m15[39m
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    },
    id: [32m'c'[39m,
    externalConnections: [33mtrue[39m
    clusterData: {
  },
      labelStyle: [32m''[39m,
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
      shape: [32m'rect'[39m,
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
      labelText: [32m'B'[39m,
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
      rx: [33m0[39m,
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
      ry: [33m0[39m,
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
      class: [32m'default'[39m,
}
      style: [32m''[39m,
47.995 : DEBUG :  Extracting node c {
      id: [32m'B'[39m,
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
      width: [33m500[39m,
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
      type: [32m'group'[39m,
  A: {
      padding: [33m15[39m
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
    },
      id: [32m'B'[39m,
    externalConnections: [33mtrue[39m
      width: [33m500[39m,
  },
      type: [32m'group'[39m,
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
      padding: [33m15[39m
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
    },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
    externalConnections: [33mtrue[39m
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
} ids: a c Translating:  { id: [32m'c'[39m, clusterData: { data: [33m1[39m } }  ---  { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
47.995 : WARN :  Fixing and trixing - removing XXX a c 2
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.995 : WARN :  Fix Replacing with XXX a c 2
47.995 : DEBUG :  {
47.995 : WARN :  Adjusted Graph {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  nodes: [
  A: {
    { v: [32m'A'[39m, value: [36m[Object][39m },
    id: [32m'c'[39m,
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    clusterData: {
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
      labelStyle: [32m''[39m,
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
      shape: [32m'rect'[39m,
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
      labelText: [32m'A'[39m,
  ],
      rx: [33m0[39m,
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
      ry: [33m0[39m,
  ],
      class: [32m'default'[39m,
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
      style: [32m''[39m,
}
      id: [32m'A'[39m,
47.995 : WARN :  extractor -  [33m0[39m {
      width: [33m500[39m,
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
      type: [32m'group'[39m,
  nodes: [
      padding: [33m15[39m
    { v: [32m'A'[39m, value: [36m[Object][39m },
    }
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
  },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
  B: {
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    id: [32m'c'[39m,
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
    clusterData: {
  ],
      labelStyle: [32m''[39m,
  edges: [
      shape: [32m'rect'[39m,
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
      labelText: [32m'B'[39m,
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
47.995 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
47.995 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.995 : WARN :  Copying children of  A root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
      rx: [33m0[39m,
  rx: [33m0[39m,
      ry: [33m0[39m,
  ry: [33m0[39m,
      class: [32m'default'[39m,
  class: [32m'default'[39m,
      style: [32m''[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
47.995 : WARN :  Copying (nodes) clusterId A nodes [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ]
47.995 : WARN :  Copying children of  B root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
47.995 : WARN :  Copying (nodes) clusterId B nodes [ [32m'c'[39m, [32m'B'[39m ]
47.995 : WARN :  Setting parent c B
47.995 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
      id: [32m'B'[39m,
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
      width: [33m500[39m,
    { v: [32m'B'[39m, value: [36m[Object][39m },
      type: [32m'group'[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m },
      padding: [33m15[39m
    { v: [32m'a'[39m, value: [36m[Object][39m }
    },
  ],
    externalConnections: [33mtrue[39m
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
47.995 : WARN :  Cluster **  B  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
47.995 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
47.995 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
47.995 : WARN :  Cluster **  a  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
47.995 : WARN :  New list of nodes [ [32m'A'[39m ]
47.995 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: {
    labelStyle: [32m''[39m,
    shape: [32m'rect'[39m,
    labelText: [32m'A'[39m,
    rx: [33m0[39m,
    ry: [33m0[39m,
    class: [32m'default'[39m,
    style: [32m''[39m,
    id: [32m'A'[39m,
    width: [33m500[39m,
  },
    type: [32m'group'[39m,
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    padding: [33m15[39m
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
47.995 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  },
  B: {
  labelText: [90mundefined[39m,
    id: [32m'c'[39m,
  graph: Graph {
    clusterData: {
    _isDirected: [33mtrue[39m,
      labelStyle: [32m''[39m,
    _isMultigraph: [33mtrue[39m,
      shape: [32m'rect'[39m,
    _isCompound: [33mtrue[39m,
      labelText: [32m'B'[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m, B: [36m[Object][39m, b: [36m[Object][39m, a: [36m[Object][39m },
    _parent: { c: [32m'B'[39m, B: [32m'\x00'[39m, b: [32m'\x00'[39m, a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {}, B: [36m[Object][39m, b: {}, a: {} },
    _in: { c: [36m[Object][39m, B: {}, b: {}, a: {} },
    _preds: { c: [36m[Object][39m, B: {}, b: {}, a: {} },
    _out: { c: {}, B: {}, b: [36m[Object][39m, a: [36m[Object][39m },
    _sucs: { c: {}, B: {}, b: [36m[Object][39m, a: [36m[Object][39m },
    _edgeObjs: { [32m'b\x01c\x011'[39m: [36m[Object][39m, [32m'a\x01c\x012'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'b\x01c\x011'[39m: [36m[Object][39m, [32m'a\x01c\x012'[39m: [36m[Object][39m },
    _nodeCount: [33m4[39m,
    _edgeCount: [33m2[39m
  }
}
47.995 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
      rx: [33m0[39m,
  ],
      ry: [33m0[39m,
  edges: [
      class: [32m'default'[39m,
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
      style: [32m''[39m,
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
      id: [32m'B'[39m,
  ],
      width: [33m500[39m,
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
      type: [32m'group'[39m,
} [90mundefined[39m
      padding: [33m15[39m
47.995 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mfalse[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
    },
47.995 : WARN :  Cluster **  B  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [33mtrue[39m [90mundefined[39m [33m1[39m
    externalConnections: [33mtrue[39m
47.995 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
  },
47.995 : WARN :  Cluster **  a  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
47.995 : WARN :  New list of nodes [ [32m'c'[39m, [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ]
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
47.995 : WARN :   Now next level c {
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  labelStyle: [32m''[39m,
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  shape: [32m'rect'[39m,
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  labelText: [32m'c'[39m,
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
47.995 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  rx: [33m0[39m,
  A: {
  ry: [33m0[39m,
    id: [32m'c'[39m,
  class: [32m'default'[39m,
    clusterData: {
  style: [32m''[39m,
      labelStyle: [32m''[39m,
  id: [32m'c'[39m,
      shape: [32m'rect'[39m,
  padding: [33m15[39m
      labelText: [32m'A'[39m,
}
      rx: [33m0[39m,
47.995 : WARN :   Now next level B {
      ry: [33m0[39m,
  labelStyle: [32m''[39m,
      class: [32m'default'[39m,
  shape: [32m'rect'[39m,
      style: [32m''[39m,
  labelText: [32m'B'[39m,
      id: [32m'A'[39m,
  rx: [33m0[39m,
      width: [33m500[39m,
  ry: [33m0[39m,
      type: [32m'group'[39m,
  class: [32m'default'[39m,
      padding: [33m15[39m
  style: [32m''[39m,
    }
  id: [32m'B'[39m,
  },
  width: [33m500[39m,
  B: {
  type: [32m'group'[39m,
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
47.995 : DEBUG :  Nodes =  [ [32m'c'[39m, [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ] [33m1[39m
47.995 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  padding: [33m15[39m
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
}
  A: {
47.995 : WARN :   Now next level b {
    id: [32m'c'[39m,
  labelStyle: [32m''[39m,
    clusterData: {
  shape: [32m'rect'[39m,
      labelStyle: [32m''[39m,
  labelText: [32m'b'[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
  rx: [33m0[39m,
      class: [32m'default'[39m,
  ry: [33m0[39m,
      style: [32m''[39m,
  class: [32m'default'[39m,
      id: [32m'A'[39m,
  style: [32m''[39m,
      width: [33m500[39m,
  id: [32m'b'[39m,
      type: [32m'group'[39m,
  padding: [33m15[39m
      padding: [33m15[39m
}
    }
47.995 : WARN :   Now next level a {
  },
  labelStyle: [32m''[39m,
  B: {
  shape: [32m'rect'[39m,
    id: [32m'c'[39m,
  labelText: [32m'a'[39m,
    clusterData: {
  rx: [33m0[39m,
      labelStyle: [32m''[39m,
  ry: [33m0[39m,
      shape: [32m'rect'[39m,
  class: [32m'default'[39m,
      labelText: [32m'B'[39m,
  style: [32m''[39m,
      rx: [33m0[39m,
  id: [32m'a'[39m,
      ry: [33m0[39m,
  padding: [33m15[39m
      class: [32m'default'[39m,
}
      style: [32m''[39m,

      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mfalse[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'c'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'c'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
47.995 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
47.995 : DEBUG :  Extracting node B {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
47.995 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
47.995 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'b'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'b'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
47.995 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
47.995 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'a'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'a'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
47.995 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
47.995 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

 âœ“ packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js (15 tests) 149ms
 âœ“ packages/mermaid/src/rendering-util/handle-markdown-text.spec.ts (19 tests) 70ms
 âœ“ |@mermaid-js/docs| .vitepress/theme/redirect.spec.ts (28 tests) 10ms
 âœ“ packages/mermaid/src/accessibility.spec.ts (20 tests) 256ms
 âœ“ packages/mermaid/src/config.spec.ts (14 tests) 50ms
 âœ“ packages/mermaid/src/diagrams/requirement/requirementDb.spec.ts (9 tests) 10ms
stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with a node
Found block-beta
.

Lex: NODE_ID id
.

Lex: EOF
Rule: node (NODE_ID separator):  id
Rule: nodeStatement (node)  { id: [32m'id'[39m }
Rule: statement:  {
  id: [32m'id'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a node with a square shape and a label
Found block
.

Lex: NODE_ID id
Lexa: [
Lex: Starting string
LEX: STR end: A label
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ A label ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id { typeStr: [32m'[]'[39m, label: [32m'A label'[39m }
Rule: nodeStatement (node)  { id: [32m'id'[39m, label: [32m'A label'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Rule: statement:  {
  id: [32m'id'[39m,
  label: [32m'A label'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id'[39m,
    label: [32m'A label'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with multiple nodes
Found block
.

Lex: NODE_ID id1
.

Lex: NODE_ID id2
Rule: node (NODE_ID separator):  id1
Rule: nodeStatement (node)  { id: [32m'id1'[39m }
.

Lex: EOF
Rule: node (NODE_ID separator):  id2
Rule: nodeStatement (node)  { id: [32m'id2'[39m }
Rule: statement:  {
  id: [32m'id2'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id1'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id1'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id2'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with multiple nodes
Found block
.

Lex: NODE_ID id1
.

Lex: NODE_ID id2
Rule: node (NODE_ID separator):  id1
Rule: nodeStatement (node)  { id: [32m'id1'[39m }
.

Lex: NODE_ID id3
Rule: node (NODE_ID separator):  id2
Rule: nodeStatement (node)  { id: [32m'id2'[39m }
.

Lex: EOF
Rule: node (NODE_ID separator):  id3
Rule: nodeStatement (node)  { id: [32m'id3'[39m }
Rule: statement:  {
  id: [32m'id3'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id2'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id1'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id1'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id2'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id3'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a node with a square shape and a label
Found block
.

Lex: NODE_ID id
Lexa: [
Lex: Starting string
LEX: STR end: A label
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID id2
Rule: nodeShapeNLabel:  [ A label ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id { typeStr: [32m'[]'[39m, label: [32m'A label'[39m }
Rule: nodeStatement (node)  { id: [32m'id'[39m, label: [32m'A label'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Lex: EOF
Rule: node (NODE_ID separator):  id2
Rule: nodeStatement (node)  { id: [32m'id2'[39m }
Rule: statement:  {
  id: [32m'id2'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id'[39m,
  label: [32m'A label'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id'[39m,
    label: [32m'A label'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id2'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with multiple nodes with edges abc123
Found block
.

Lex: NODE_ID id1
Lexa: [
Lex: Starting string
LEX: STR end: first
LEX: POPPING STR: "
Lex: ]
.
Lex: LINK #-->   #
Rule: nodeShapeNLabel:  [ first ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id1 { typeStr: [32m'[]'[39m, label: [32m'first'[39m }
Rule: nodeStatement (node)  { id: [32m'id1'[39m, label: [32m'first'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Rule: link:  -->    -->
Lex: NODE_ID id2
Lexa: [
Lex: Starting string
LEX: STR end: second
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ second ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id2 { typeStr: [32m'[]'[39m, label: [32m'second'[39m }
Rule: (nodeStatement link node)  {
  id: [32m'id1'[39m,
  label: [32m'first'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
} { edgeTypeStr: [32m'-->   '[39m, label: [32m''[39m } { id: [32m'id2'[39m, label: [32m'second'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }  typestr:  -->
Rule: statement:  [
  { id: [32m'id1'[39m, label: [32m'first'[39m, type: [32m'square'[39m, directions: [90mundefined[39m },
  {
    id: [32m'id1-id2'[39m,
    start: [32m'id1'[39m,
    end: [32m'id2'[39m,
    label: [32m''[39m,
    type: [32m'edge'[39m,
    directions: [90mundefined[39m,
    arrowTypeEnd: [32m'arrow_point'[39m,
    arrowTypeStart: [32m'arrow_open'[39m
  },
  { id: [32m'id2'[39m, label: [32m'second'[39m, type: [32m'square'[39m, directions: [90mundefined[39m }
]
Rule: hierarchy:  [
  { id: [32m'id1'[39m, label: [32m'first'[39m, type: [32m'square'[39m, directions: [90mundefined[39m },
  {
    id: [32m'id1-id2'[39m,
    start: [32m'id1'[39m,
    end: [32m'id2'[39m,
    label: [32m''[39m,
    type: [32m'edge'[39m,
    directions: [90mundefined[39m,
    arrowTypeEnd: [32m'arrow_point'[39m,
    arrowTypeStart: [32m'arrow_open'[39m
  },
  { id: [32m'id2'[39m, label: [32m'second'[39m, type: [32m'square'[39m, directions: [90mundefined[39m }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with multiple nodes with edges abc123
Found block
.

Lex: NODE_ID id1
Lexa: [
Lex: Starting string
LEX: STR end: first
LEX: POPPING STR: "
Lex: ]
.
Lex: START_LINK --
Rule: nodeShapeNLabel:  [ first ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id1 { typeStr: [32m'[]'[39m, label: [32m'first'[39m }
Rule: nodeStatement (node)  { id: [32m'id1'[39m, label: [32m'first'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Lex: Starting string
LEX: STR end: a label
LEX: POPPING STR: "
Lex: LINK # -->   #
Rule: LABEL link:  --  a label  -->
Lex: NODE_ID id2
Lexa: [
Lex: Starting string
LEX: STR end: second
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ second ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id2 { typeStr: [32m'[]'[39m, label: [32m'second'[39m }
Rule: (nodeStatement link node)  {
  id: [32m'id1'[39m,
  label: [32m'first'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
} { edgeTypeStr: [32m' -->   '[39m, label: [32m'a label'[39m } { id: [32m'id2'[39m, label: [32m'second'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }  typestr:   -->
Rule: statement:  [
  { id: [32m'id1'[39m, label: [32m'first'[39m, type: [32m'square'[39m, directions: [90mundefined[39m },
  {
    id: [32m'id1-id2'[39m,
    start: [32m'id1'[39m,
    end: [32m'id2'[39m,
    label: [32m'a label'[39m,
    type: [32m'edge'[39m,
    directions: [90mundefined[39m,
    arrowTypeEnd: [32m'arrow_point'[39m,
    arrowTypeStart: [32m'arrow_open'[39m
  },
  { id: [32m'id2'[39m, label: [32m'second'[39m, type: [32m'square'[39m, directions: [90mundefined[39m }
]
Rule: hierarchy:  [
  { id: [32m'id1'[39m, label: [32m'first'[39m, type: [32m'square'[39m, directions: [90mundefined[39m },
  {
    id: [32m'id1-id2'[39m,
    start: [32m'id1'[39m,
    end: [32m'id2'[39m,
    label: [32m'a label'[39m,
    type: [32m'edge'[39m,
    directions: [90mundefined[39m,
    arrowTypeEnd: [32m'arrow_point'[39m,
    arrowTypeStart: [32m'arrow_open'[39m
  },
  { id: [32m'id2'[39m, label: [32m'second'[39m, type: [32m'square'[39m, directions: [90mundefined[39m }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with column statements
Found block
.

COLUMNS (LEX) 2
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'2'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  2
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m2[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m2[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram without column statements
Found block
.

Lex: NODE_ID block1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with auto column statements
Found block
.

.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [33m-1[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m22[39m }
}
COLUMNS:  [33m-1[39m
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m-1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m-1[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > blocks next to each other
Found block
.

COLUMNS (LEX) 2
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'2'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  2
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID block2
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m2[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m2[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > blocks on top of each other
Found block
.

COLUMNS (LEX) 1
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID block2
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > compound blocks 2
Found block
.

Found block
.

Lex: NODE_ID aBlock
Lexa: [
Lex: Starting string
LEX: STR end: ABlock
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID bBlock
Rule: nodeShapeNLabel:  [ ABlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  aBlock { typeStr: [32m'[]'[39m, label: [32m'ABlock'[39m }
Rule: nodeStatement (node)  { id: [32m'aBlock'[39m, label: [32m'ABlock'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Lexa: [
Lex: Starting string
LEX: STR end: BBlock
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ BBlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  bBlock { typeStr: [32m'[]'[39m, label: [32m'BBlock'[39m }
Rule: nodeStatement (node)  { id: [32m'bBlock'[39m, label: [32m'BBlock'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Rule: statement:  {
  id: [32m'bBlock'[39m,
  label: [32m'BBlock'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'aBlock'[39m,
  label: [32m'ABlock'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Lex: EOF
Rule: blockStatement :  block [
  {
    id: [32m'aBlock'[39m,
    label: [32m'ABlock'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'bBlock'[39m,
    label: [32m'BBlock'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
] end

Rule: statement:  {
  id: [32m'id-2hpnwpuz14b-1'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    {
      id: [32m'aBlock'[39m,
      label: [32m'ABlock'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'bBlock'[39m,
      label: [32m'BBlock'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: hierarchy:  [
  {
    id: [32m'id-2hpnwpuz14b-1'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > compound blocks of compound blocks
Found block
.

Found block
.

Lex: NODE_ID aBlock
Lexa: [
Lex: Starting string
LEX: STR end: ABlock
LEX: POPPING STR: "
Lex: ]
.

Found block
Rule: nodeShapeNLabel:  [ ABlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  aBlock { typeStr: [32m'[]'[39m, label: [32m'ABlock'[39m }
Rule: nodeStatement (node)  { id: [32m'aBlock'[39m, label: [32m'ABlock'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
.

Lex: NODE_ID bBlock
Lexa: [
Lex: Starting string
LEX: STR end: BBlock
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ BBlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  bBlock { typeStr: [32m'[]'[39m, label: [32m'BBlock'[39m }
Rule: nodeStatement (node)  { id: [32m'bBlock'[39m, label: [32m'BBlock'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Rule: statement:  {
  id: [32m'bBlock'[39m,
  label: [32m'BBlock'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: blockStatement :  block [
  {
    id: [32m'bBlock'[39m,
    label: [32m'BBlock'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
] end

Rule: statement:  {
  id: [32m'id-kzwg0g3421-2'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    {
      id: [32m'bBlock'[39m,
      label: [32m'BBlock'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: statement #2:  {
  id: [32m'aBlock'[39m,
  label: [32m'ABlock'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Lex: EOF
Rule: blockStatement :  block [
  {
    id: [32m'aBlock'[39m,
    label: [32m'ABlock'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id-kzwg0g3421-2'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m ]
  }
] end

Rule: statement:  {
  id: [32m'id-83euihybwqm-3'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    {
      id: [32m'aBlock'[39m,
      label: [32m'ABlock'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'id-kzwg0g3421-2'[39m,
      type: [32m'composite'[39m,
      label: [32m''[39m,
      children: [36m[Array][39m
    }
  ]
}
Rule: hierarchy:  [
  {
    id: [32m'id-83euihybwqm-3'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > compound blocks with title
Found block
.

Found id-block
Lex: NODE_ID compoundBlock
Lexa: [
Lex: Starting string
LEX: STR end: Compound block
LEX: POPPING STR: "
Lex: ]
.

COLUMNS (LEX) 1
Rule: nodeShapeNLabel:  [ Compound block ]
Rule: node (NODE_ID nodeShapeNLabel separator):  compoundBlock { typeStr: [32m'[]'[39m, label: [32m'Compound block'[39m }
Rule: nodeStatement (node)  {
  id: [32m'compoundBlock'[39m,
  label: [32m'Compound block'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
.

Lex: NODE_ID block2
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m3[39m, last_line: [33m3[39m, first_column: [33m12[39m, last_column: [33m21[39m }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Lex: EOF
Rule: id-block statement :  {
  id: [32m'compoundBlock'[39m,
  label: [32m'Compound block'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
} [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]
Rule: statement:  {
  id: [32m'compoundBlock'[39m,
  label: [32m'Compound block'[39m,
  type: [32m'composite'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m,
  children: [
    { type: [32m'column-setting'[39m, columns: [33m1[39m },
    {
      id: [32m'block2'[39m,
      label: [32m'Block 2'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: hierarchy:  [
  {
    id: [32m'compoundBlock'[39m,
    label: [32m'Compound block'[39m,
    type: [32m'composite'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m,
    children: [ [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > blocks mixed with compound blocks
Found block
.

COLUMNS (LEX) 1
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.


Found block
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
.

COLUMNS (LEX) 2
.

Lex: NODE_ID block2
APA123 {
  [32m'$'[39m: [32m'2'[39m,
  [32m'_$'[39m: { first_line: [33m6[39m, last_line: [33m6[39m, first_column: [33m12[39m, last_column: [33m21[39m }
}
COLUMNS:  2
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID block3
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 3
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ Block 3 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block3 { typeStr: [32m'[]'[39m, label: [32m'Block 3'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block3'[39m,
  label: [32m'Block 3'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block3'[39m,
  label: [32m'Block 3'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m2[39m }
Lex: EOF
Rule: blockStatement :  block [
  { type: [32m'column-setting'[39m, columns: [33m2[39m },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'block3'[39m,
    label: [32m'Block 3'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
] end

Rule: statement:  {
  id: [32m'id-pcnovrv7ehm-5'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    { type: [32m'column-setting'[39m, columns: [33m2[39m },
    {
      id: [32m'block2'[39m,
      label: [32m'Block 2'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'block3'[39m,
      label: [32m'Block 3'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: statement #2:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id-pcnovrv7ehm-5'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m, [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > Arrow blocks
Found block
.

COLUMNS (LEX) 3
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'3'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m8[39m, last_column: [33m17[39m }
}
COLUMNS:  3
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID blockArrow
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
LEX ARR START
LEX ARR: Starting string
LEX: STR end: &nbsp;&nbsp;&nbsp;
LEX: POPPING STR: "
Lex: =>BAE
Lex (right): dir: right
Lex (ARROW_DIR end): ]>
Rule: dirList:  right
Lex: NODE_ID block2
Rule: BLOCK_ARROW nodeShapeNLabel:  <[ &nbsp;&nbsp;&nbsp;  #3: [ [32m'right'[39m ] ]>
Rule: node (NODE_ID nodeShapeNLabel separator):  blockArrow {
  typeStr: [32m'<[]>'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  directions: [ [32m'right'[39m ]
}
Rule: nodeStatement (node)  {
  id: [32m'blockArrow'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  typeStr: [32m'<[]>'[39m,
  directions: [ [32m'right'[39m ]
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
Lex: EOF
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'blockArrow'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  type: [32m'block_arrow'[39m,
  directions: [ [32m'right'[39m ],
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m3[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m3[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'blockArrow'[39m,
    label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
    type: [32m'block_arrow'[39m,
    directions: [ [32m'right'[39m ],
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > Arrow blocks with multiple points
Found block
.

COLUMNS (LEX) 1
.

Lex: NODE_ID A
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m8[39m, last_column: [33m17[39m }
}
COLUMNS:  1
.

Lex: NODE_ID blockArrow
Rule: node (NODE_ID separator):  A
Rule: nodeStatement (node)  { id: [32m'A'[39m }
LEX ARR START
LEX ARR: Starting string
LEX: STR end: &nbsp;&nbsp;&nbsp;
LEX: POPPING STR: "
Lex: =>BAE
Lex (up): up
Lex (down): down
Lex (ARROW_DIR end): ]>
Rule: dirList:  down
Rule: dirList:  up [ [32m'down'[39m ]
Found block
Rule: BLOCK_ARROW nodeShapeNLabel:  <[ &nbsp;&nbsp;&nbsp;  #3: [ [32m'up'[39m, [32m'down'[39m ] ]>
Rule: node (NODE_ID nodeShapeNLabel separator):  blockArrow {
  typeStr: [32m'<[]>'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  directions: [ [32m'up'[39m, [32m'down'[39m ]
}
Rule: nodeStatement (node)  {
  id: [32m'blockArrow'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  typeStr: [32m'<[]>'[39m,
  directions: [ [32m'up'[39m, [32m'down'[39m ]
}
.

COLUMNS (LEX) 3
.

Lex: NODE_ID B
APA123 {
  [32m'$'[39m: [32m'3'[39m,
  [32m'_$'[39m: { first_line: [33m6[39m, last_line: [33m6[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  3
.

Lex: NODE_ID C
Rule: node (NODE_ID separator):  B
Rule: nodeStatement (node)  { id: [32m'B'[39m }
.

Lex: NODE_ID D
Rule: node (NODE_ID separator):  C
Rule: nodeStatement (node)  { id: [32m'C'[39m }
.

Rule: node (NODE_ID separator):  D
Rule: nodeStatement (node)  { id: [32m'D'[39m }
Rule: statement:  {
  id: [32m'D'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'C'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'B'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m3[39m }
Lex: EOF
Rule: blockStatement :  block [
  { type: [32m'column-setting'[39m, columns: [33m3[39m },
  {
    id: [32m'B'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'C'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'D'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
] end
Rule: statement:  {
  id: [32m'id-l8yjp9wpw2f-6'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    { type: [32m'column-setting'[39m, columns: [33m3[39m },
    {
      id: [32m'B'[39m,
      label: [90mundefined[39m,
      type: [32m'na'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'C'[39m,
      label: [90mundefined[39m,
      type: [32m'na'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'D'[39m,
      label: [90mundefined[39m,
      type: [32m'na'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: statement #2:  {
  id: [32m'blockArrow'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  type: [32m'block_arrow'[39m,
  directions: [ [32m'up'[39m, [32m'down'[39m ],
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'A'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'A'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'blockArrow'[39m,
    label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
    type: [32m'block_arrow'[39m,
    directions: [ [32m'up'[39m, [32m'down'[39m ],
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id-l8yjp9wpw2f-6'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m, [36m[Object][39m, [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > blocks with different widths
Found block
.

COLUMNS (LEX) 3
.

Lex: NODE_ID one
APA123 {
  [32m'$'[39m: [32m'3'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m8[39m, last_column: [33m17[39m }
}
COLUMNS:  3
Lexa: [
Lex: Starting string
LEX: STR end: One Slot
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID two
Rule: nodeShapeNLabel:  [ One Slot ]
Rule: node (NODE_ID nodeShapeNLabel separator):  one { typeStr: [32m'[]'[39m, label: [32m'One Slot'[39m }
Rule: nodeStatement (node)  { id: [32m'one'[39m, label: [32m'One Slot'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Lexa: [
Lex: Starting string
LEX: STR end: Two slots
LEX: POPPING STR: "
Lex: ]
Lex: COLON :2
Rule: nodeShapeNLabel:  [ Two slots ]
Rule: node (NODE_ID nodeShapeNLabel separator):  two { typeStr: [32m'[]'[39m, label: [32m'Two slots'[39m }
.

Lex: EOF
Rule: nodeStatement (abc88 node size)  { id: [32m'two'[39m, label: [32m'Two slots'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m } 2
Rule: statement:  {
  id: [32m'two'[39m,
  label: [32m'Two slots'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m2[39m
}
Rule: statement #2:  {
  id: [32m'one'[39m,
  label: [32m'One Slot'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m3[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m3[39m },
  {
    id: [32m'one'[39m,
    label: [32m'One Slot'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'two'[39m,
    label: [32m'Two slots'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m2[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > empty blocks
Found block
.

COLUMNS (LEX) 3
.

COLUMNS (LEX) 1
APA123 {
  [32m'$'[39m: [32m'3'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m8[39m, last_column: [33m17[39m }
}
COLUMNS:  3
.

Lex: NODE_ID middle
Lexa: [
Lex: Starting string
LEX: STR end: In the middle
LEX: POPPING STR: "
Lex: ]
.

COLUMNS (LEX) 1
Rule: nodeShapeNLabel:  [ In the middle ]
Rule: node (NODE_ID nodeShapeNLabel separator):  middle { typeStr: [32m'[]'[39m, label: [32m'In the middle'[39m }
Rule: nodeStatement (node)  {
  id: [32m'middle'[39m,
  label: [32m'In the middle'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
.

Lex: EOF
Rule: statement:  {
  id: [32m'id-uhkyx3cc6a-8'[39m,
  type: [32m'space'[39m,
  label: [32m''[39m,
  width: [33m1[39m,
  children: []
}
Rule: statement #2:  {
  id: [32m'middle'[39m,
  label: [32m'In the middle'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id-jyivto791ng-7'[39m,
  type: [32m'space'[39m,
  label: [32m''[39m,
  width: [33m1[39m,
  children: []
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m3[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m3[39m },
  {
    id: [32m'id-jyivto791ng-7'[39m,
    type: [32m'space'[39m,
    label: [32m''[39m,
    width: [33m1[39m,
    children: []
  },
  {
    id: [32m'middle'[39m,
    label: [32m'In the middle'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id-uhkyx3cc6a-8'[39m,
    type: [32m'space'[39m,
    label: [32m''[39m,
    width: [33m1[39m,
    children: []
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > classDef statements applied to a block
Found block
.

.


Lex: NODE_ID mc
Lexa: [
Lex: Starting string
LEX: STR end: Memcache
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ Memcache ]
Rule: node (NODE_ID nodeShapeNLabel separator):  mc { typeStr: [32m'[]'[39m, label: [32m'Memcache'[39m }
Rule: nodeStatement (node)  { id: [32m'mc'[39m, label: [32m'Memcache'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
.

Lex: EOF
Rule: statement:  { type: [32m'applyClass'[39m, id: [32m'mc'[39m, styleClass: [32m'black'[39m }
Rule: statement #2:  {
  id: [32m'mc'[39m,
  label: [32m'Memcache'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'classDef'[39m, id: [32m'black'[39m, css: [32m'color:#ffffff, fill:#000000;'[39m }
Rule: hierarchy:  [
  {
    type: [32m'classDef'[39m,
    id: [32m'black'[39m,
    css: [32m'color:#ffffff, fill:#000000;'[39m
  },
  {
    id: [32m'mc'[39m,
    label: [32m'Memcache'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  { type: [32m'applyClass'[39m, id: [32m'mc'[39m, styleClass: [32m'black'[39m }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > style statements applied to a block
Found block
.

COLUMNS (LEX) 1
.

Lex: NODE_ID B
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m0[39m, last_column: [33m9[39m }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: A wide one in the middle
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ A wide one in the middle ]
Rule: node (NODE_ID nodeShapeNLabel separator):  B { typeStr: [32m'[]'[39m, label: [32m'A wide one in the middle'[39m }
Rule: nodeStatement (node)  {
  id: [32m'B'[39m,
  label: [32m'A wide one in the middle'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
.

Lex: EOF
Rule: statement:  {
  type: [32m'applyStyles'[39m,
  id: [32m'B'[39m,
  stylesStr: [32m'fill:#f9F,stroke:#333,stroke-width:4px'[39m
}
Rule: statement #2:  {
  id: [32m'B'[39m,
  label: [32m'A wide one in the middle'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'B'[39m,
    label: [32m'A wide one in the middle'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    type: [32m'applyStyles'[39m,
    id: [32m'B'[39m,
    stylesStr: [32m'fill:#f9F,stroke:#333,stroke-width:4px'[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > should log a warning when block width exceeds column width
Found block-beta
.

COLUMNS (LEX) 1
.

Lex: NODE_ID A
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m2[39m, last_column: [33m11[39m }
}
COLUMNS:  1
Lex: COLON :1
Rule: node (NODE_ID separator):  A
.

Lex: NODE_ID B
Rule: nodeStatement (abc88 node size)  { id: [32m'A'[39m } 1
Lex: COLON :2
Rule: node (NODE_ID separator):  B
.

Lex: NODE_ID C
Rule: nodeStatement (abc88 node size)  { id: [32m'B'[39m } 2
Lex: COLON :3
Rule: node (NODE_ID separator):  C
.

Lex: NODE_ID D
Rule: nodeStatement (abc88 node size)  { id: [32m'C'[39m } 3
Lex: COLON :4
Rule: node (NODE_ID separator):  D
.

Lex: NODE_ID E
Rule: nodeStatement (abc88 node size)  { id: [32m'D'[39m } 4
Lex: COLON :3
Rule: node (NODE_ID separator):  E
.

Lex: NODE_ID F
Rule: nodeStatement (abc88 node size)  { id: [32m'E'[39m } 3
Lex: COLON :2
Rule: node (NODE_ID separator):  F
.

Lex: NODE_ID G
Rule: nodeStatement (abc88 node size)  { id: [32m'F'[39m } 2
Lex: COLON :1
Rule: node (NODE_ID separator):  G
Lex: EOF
Rule: nodeStatement (abc88 node size)  { id: [32m'G'[39m } 1
Rule: statement:  {
  id: [32m'G'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'F'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m2[39m
}
Rule: statement #2:  {
  id: [32m'E'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m3[39m
}
Rule: statement #2:  {
  id: [32m'D'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m4[39m
}
Rule: statement #2:  {
  id: [32m'C'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m3[39m
}
Rule: statement #2:  {
  id: [32m'B'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m2[39m
}
Rule: statement #2:  {
  id: [32m'A'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'A'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'B'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m2[39m
  },
  {
    id: [32m'C'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m3[39m
  },
  {
    id: [32m'D'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m4[39m
  },
  {
    id: [32m'E'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m3[39m
  },
  {
    id: [32m'F'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m2[39m
  },
  {
    id: [32m'G'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > prototype properties > should work with a __proto__ property
Found block
.

Lex: NODE_ID __proto__
Lex: EOF
Rule: node (NODE_ID separator):  __proto__
Rule: nodeStatement (node)  { id: [32m'__proto__'[39m }
Rule: statement:  {
  id: [32m'__proto__'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'__proto__'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]
Found block
.

Lex: NODE_ID A;
.
Rule: node (NODE_ID separator):  A;
Rule: nodeStatement (node)  { id: [32m'A;'[39m }
Lex: EOF
Rule: statement:  {
  type: [32m'classDef'[39m,
  id: [32m'__proto__'[39m,
  css: [32m'color:#ffffff,fill:#000000; class A __proto__'[39m
}
Rule: statement #2:  {
  id: [32m'A;'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'A;'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    type: [32m'classDef'[39m,
    id: [32m'__proto__'[39m,
    css: [32m'color:#ffffff,fill:#000000; class A __proto__'[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > prototype properties > should work with a constructor property
Found block
.

Lex: NODE_ID constructor
Lex: EOF
Rule: node (NODE_ID separator):  constructor
Rule: nodeStatement (node)  { id: [32m'constructor'[39m }
Rule: statement:  {
  id: [32m'constructor'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'constructor'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]
Found block
.

Lex: NODE_ID A;
.
Rule: node (NODE_ID separator):  A;
Rule: nodeStatement (node)  { id: [32m'A;'[39m }
Lex: EOF
Rule: statement:  {
  type: [32m'classDef'[39m,
  id: [32m'constructor'[39m,
  css: [32m'color:#ffffff,fill:#000000; class A constructor'[39m
}
Rule: statement #2:  {
  id: [32m'A;'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'A;'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    type: [32m'classDef'[39m,
    id: [32m'constructor'[39m,
    css: [32m'color:#ffffff,fill:#000000; class A constructor'[39m
  }
]

 âœ“ packages/mermaid/src/diagrams/block/parser/block.spec.ts (25 tests) 61ms
stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > MMP-1 should handle a simple root definition abc122
49.190 : INFO :  Node:  root
49.190 : INFO :  addNode [33m4[39m root root [33m0[39m
49.190 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > MMP-2 should handle a hierarchical mindmap definition
49.204 : INFO :  Node:  root
49.204 : INFO :  addNode [33m4[39m root root [33m0[39m
49.204 : TRACE :  Stop NL
49.204 : INFO :  Node:  child1
49.204 : INFO :  addNode [33m6[39m child1 child1 [33m0[39m
49.204 : TRACE :  Stop NL
49.204 : INFO :  Node:  child2
49.204 : INFO :  addNode [33m6[39m child2 child2 [33m0[39m
49.204 : TRACE :  Stop NL
49.204 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > 3 should handle a simple root definition with a shape and without an id abc123
49.211 : TRACE :  Long description: root
49.211 : TRACE :  node end )
49.211 : TRACE :  node found .. (
49.211 : DEBUG :  In get type ( )
49.211 : INFO :  Node:  root
49.211 : INFO :  addNode [33m4[39m root root [33m1[39m
49.211 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > MMP-4 should handle a deeper hierarchical mindmap definition
49.215 : INFO :  Node:  root
49.215 : INFO :  addNode [33m4[39m root root [33m0[39m
49.215 : TRACE :  Stop NL
49.215 : INFO :  Node:  child1
49.215 : INFO :  addNode [33m6[39m child1 child1 [33m0[39m
49.215 : TRACE :  Stop NL
49.215 : INFO :  Node:  leaf1
49.215 : INFO :  addNode [33m8[39m leaf1 leaf1 [33m0[39m
49.215 : TRACE :  Stop NL
49.215 : INFO :  Node:  child2
49.215 : INFO :  addNode [33m6[39m child2 child2 [33m0[39m
49.215 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > 5 Multiple roots are illegal
49.221 : INFO :  Node:  root
49.221 : INFO :  addNode [33m4[39m root root [33m0[39m
49.222 : TRACE :  Stop NL
49.221 : INFO :  Node:  fakeRoot
49.221 : INFO :  addNode [33m4[39m fakeRoot fakeRoot [33m0[39m

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > MMP-6 real root in wrong place
49.227 : INFO :  Node:  root
49.227 : INFO :  addNode [33m10[39m root root [33m0[39m
49.227 : TRACE :  Stop NL
49.227 : INFO :  Node:  fakeRoot
49.227 : INFO :  addNode [33m8[39m fakeRoot fakeRoot [33m0[39m

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-7 should handle an id and type for a node definition
49.231 : TRACE :  Long description: The root
49.231 : TRACE :  node end ... ]
49.231 : TRACE :  node found .. root
49.231 : DEBUG :  In get type [ ]
49.231 : INFO :  Node:  root
49.231 : INFO :  addNode [33m4[39m root The root [33m2[39m
49.231 : TRACE :  Stop NL
49.231 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-8 should handle an id and type for a node definition
49.232 : INFO :  Node:  root
49.232 : INFO :  addNode [33m4[39m root root [33m0[39m
49.232 : TRACE :  Stop NL
49.232 : TRACE :  Long description: child1
49.232 : TRACE :  node end )
49.232 : TRACE :  node found .. theId
49.232 : DEBUG :  In get type ( )
49.232 : INFO :  Node:  theId
49.232 : INFO :  addNode [33m6[39m theId child1 [33m1[39m
49.232 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-9 should handle an id and type for a node definition
49.235 : TRACE :  Node:  root
49.235 : INFO :  addNode [33m0[39m root root [33m0[39m
49.235 : TRACE :  Stop NL
49.235 : TRACE :  Long description: child1
49.235 : TRACE :  node end )
49.235 : TRACE :  node found .. theId
49.235 : DEBUG :  In get type ( )
49.235 : INFO :  Node:  theId
49.235 : INFO :  addNode [33m6[39m theId child1 [33m1[39m
49.235 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-10 multiple types (circle)
49.237 : TRACE :  Long description: the root
49.237 : TRACE :  node end ))
49.237 : TRACE :  node found .. root
49.237 : DEBUG :  In get type (( ))
49.237 : INFO :  Node:  root
49.237 : INFO :  addNode [33m1[39m root the root [33m3[39m
49.237 : TRACE :  Stop NL
49.237 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-11 multiple types (cloud)
49.239 : TRACE :  Cloud Bang
49.239 : TRACE :  Long description: the root
49.239 : TRACE :  node end ((
49.239 : TRACE :  node found .. root
49.239 : DEBUG :  In get type ) (
49.239 : INFO :  Node:  root
49.239 : INFO :  addNode [33m1[39m root the root [33m4[39m
49.239 : TRACE :  Stop NL
49.239 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-12 multiple types (bang)
49.240 : TRACE :  Explosion Bang
49.240 : TRACE :  Long description: the root
49.240 : TRACE :  node end ((
49.240 : TRACE :  node found .. root
49.240 : DEBUG :  In get type )) ((
49.240 : INFO :  Node:  root
49.240 : INFO :  addNode [33m1[39m root the root [33m5[39m
49.240 : TRACE :  Stop NL
49.240 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-12-a multiple types (hexagon)
49.242 : TRACE :  Long description: the root
49.242 : TRACE :  node end ((
49.242 : TRACE :  node found .. root
49.242 : DEBUG :  In get type {{ }}
49.242 : INFO :  Node:  root
49.242 : INFO :  addNode [33m1[39m root the root [33m6[39m
49.242 : TRACE :  Stop NL
49.242 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-13 should be possible to set an icon for the node
49.244 : TRACE :  Long description: The root
49.244 : TRACE :  node end ... ]
49.244 : TRACE :  node found .. root
49.244 : DEBUG :  In get type [ ]
49.244 : INFO :  Node:  root
49.244 : INFO :  addNode [33m4[39m root The root [33m2[39m
49.244 : TRACE :  Stop NL
49.244 : TRACE :  Begin icon
49.244 : TRACE :  end icon
49.244 : TRACE :  Icon:  bomb
49.244 : TRACE :  Stop NL
49.244 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-14 should be possible to set classes for the node
49.246 : TRACE :  Long description: The root
49.246 : TRACE :  node end ... ]
49.246 : TRACE :  node found .. root
49.246 : DEBUG :  In get type [ ]
49.246 : INFO :  Node:  root
49.246 : INFO :  addNode [33m4[39m root The root [33m2[39m
49.246 : TRACE :  Stop NL
49.246 : TRACE :  Stop NL
49.246 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-15 should be possible to set both classes and icon for the node
49.248 : TRACE :  Long description: The root
49.248 : TRACE :  node end ... ]
49.248 : TRACE :  node found .. root
49.248 : DEBUG :  In get type [ ]
49.248 : INFO :  Node:  root
49.248 : INFO :  addNode [33m4[39m root The root [33m2[39m
49.248 : TRACE :  Stop NL
49.248 : TRACE :  Stop NL
49.248 : TRACE :  Begin icon
49.248 : TRACE :  end icon
49.248 : TRACE :  Icon:  bomb
49.248 : TRACE :  Stop NL
49.248 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-16 should be possible to set both classes and icon for the node
49.251 : TRACE :  Long description: The root
49.251 : TRACE :  node end ... ]
49.251 : TRACE :  node found .. root
49.251 : DEBUG :  In get type [ ]
49.251 : INFO :  Node:  root
49.251 : INFO :  addNode [33m4[39m root The root [33m2[39m
49.251 : TRACE :  Stop NL
49.251 : TRACE :  Begin icon
49.251 : TRACE :  end icon
49.251 : TRACE :  Icon:  bomb
49.251 : TRACE :  Stop NL
49.251 : TRACE :  Stop NL
49.251 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > descriptions > MMP-17 should be possible to use node syntax in the descriptions
49.254 : TRACE :  Starting NSTR
49.254 : TRACE :  description: String containing []
49.254 : TRACE :  node end ... ]
49.254 : TRACE :  node found .. root
49.254 : DEBUG :  In get type [ ]
49.254 : INFO :  Node:  root
49.254 : INFO :  addNode [33m4[39m root String containing [] [33m2[39m
49.254 : TRACE :  Stop NL
49.254 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > descriptions > MMP-18 should be possible to use node syntax in the descriptions in children
49.255 : TRACE :  Starting NSTR
49.255 : TRACE :  description: String containing []
49.255 : TRACE :  node end ... ]
49.255 : TRACE :  node found .. root
49.255 : DEBUG :  In get type [ ]
49.255 : INFO :  Node:  root
49.255 : INFO :  addNode [33m4[39m root String containing [] [33m2[39m
49.255 : TRACE :  Stop NL
49.255 : TRACE :  Starting NSTR
49.255 : TRACE :  description: String containing ()
49.255 : TRACE :  node end ... ]
49.255 : TRACE :  node found .. child1
49.255 : DEBUG :  In get type [ ]
49.255 : INFO :  Node:  child1
49.255 : INFO :  addNode [33m6[39m child1 String containing () [33m2[39m
49.255 : TRACE :  Stop NL
49.255 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > descriptions > MMP-19 should be possible to have a child after a class assignment
49.257 : TRACE :  Long description: Root
49.257 : TRACE :  node end )
49.257 : TRACE :  node found .. root
49.257 : DEBUG :  In get type ( )
49.257 : INFO :  Node:  root
49.257 : INFO :  addNode [33m2[39m root Root [33m1[39m
49.257 : TRACE :  Stop NL
49.257 : TRACE :  Long description: Child
49.257 : TRACE :  node end )
49.257 : TRACE :  node found .. Child
49.257 : DEBUG :  In get type ( )
49.257 : INFO :  Node:  Child
49.257 : INFO :  addNode [33m4[39m Child Child [33m1[39m
49.257 : TRACE :  Stop NL
49.257 : TRACE :  Stop NL
49.257 : TRACE :  Long description: a
49.257 : TRACE :  node end )
49.257 : TRACE :  node found .. a
49.257 : DEBUG :  In get type ( )
49.257 : INFO :  Node:  a
49.257 : INFO :  addNode [33m6[39m a a [33m1[39m
49.257 : TRACE :  Stop NL
49.257 : TRACE :  Long description: New Stuff
49.257 : TRACE :  node end ... ]
49.257 : TRACE :  node found .. b
49.257 : DEBUG :  In get type [ ]
49.257 : INFO :  Node:  b
49.257 : INFO :  addNode [33m6[39m b New Stuff [33m2[39m
49.257 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-20 should be possible to have meaningless empty rows in a mindmap abc124
49.263 : TRACE :  Long description: Root
49.263 : TRACE :  node end )
49.263 : TRACE :  node found .. root
49.263 : DEBUG :  In get type ( )
49.263 : INFO :  Node:  root
49.263 : INFO :  addNode [33m2[39m root Root [33m1[39m
49.263 : TRACE :  Stop NL
49.263 : TRACE :  Long description: Child
49.263 : TRACE :  node end )
49.263 : TRACE :  node found .. Child
49.263 : DEBUG :  In get type ( )
49.263 : INFO :  Node:  Child
49.263 : INFO :  addNode [33m4[39m Child Child [33m1[39m
49.263 : TRACE :  Stop NL
49.263 : TRACE :  Long description: a
49.263 : TRACE :  node end )
49.263 : TRACE :  SPACELINE
49.263 : TRACE :  node found .. a
49.263 : DEBUG :  In get type ( )
49.263 : INFO :  Node:  a
49.263 : INFO :  addNode [33m6[39m a a [33m1[39m
49.263 : TRACE :  Long description: New Stuff
49.263 : TRACE :  node end ... ]
49.263 : TRACE :  node found .. b
49.263 : DEBUG :  In get type [ ]
49.263 : INFO :  Node:  b
49.263 : INFO :  addNode [33m6[39m b New Stuff [33m2[39m
49.263 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-21 should be possible to have comments in a mindmap
49.267 : TRACE :  Long description: Root
49.267 : TRACE :  node end )
49.267 : TRACE :  node found .. root
49.267 : DEBUG :  In get type ( )
49.267 : INFO :  Node:  root
49.267 : INFO :  addNode [33m2[39m root Root [33m1[39m
49.267 : TRACE :  Stop NL
49.267 : TRACE :  Long description: Child
49.267 : TRACE :  node end )
49.267 : TRACE :  node found .. Child
49.267 : DEBUG :  In get type ( )
49.267 : INFO :  Node:  Child
49.267 : INFO :  addNode [33m4[39m Child Child [33m1[39m
49.267 : TRACE :  Stop NL
49.267 : TRACE :  Long description: a
49.267 : TRACE :  node end )
49.267 : TRACE :  Found comment

      %% This is a comment
49.267 : TRACE :  node found .. a
49.267 : DEBUG :  In get type ( )
49.267 : INFO :  Node:  a
49.267 : INFO :  addNode [33m6[39m a a [33m1[39m
49.267 : TRACE :  Stop NL2
49.267 : TRACE :  Long description: New Stuff
49.267 : TRACE :  node end ... ]
49.267 : TRACE :  node found .. b
49.267 : DEBUG :  In get type [ ]
49.267 : INFO :  Node:  b
49.267 : INFO :  addNode [33m6[39m b New Stuff [33m2[39m
49.267 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-22 should be possible to have comments at the end of a line
49.270 : TRACE :  Long description: Root
49.270 : TRACE :  node end )
49.270 : TRACE :  node found .. root
49.270 : DEBUG :  In get type ( )
49.270 : INFO :  Node:  root
49.270 : INFO :  addNode [33m2[39m root Root [33m1[39m
49.270 : TRACE :  Stop NL
49.270 : TRACE :  Long description: Child
49.270 : TRACE :  node end )
49.270 : TRACE :  node found .. Child
49.270 : DEBUG :  In get type ( )
49.270 : INFO :  Node:  Child
49.270 : INFO :  addNode [33m4[39m Child Child [33m1[39m
49.270 : TRACE :  Stop NL
49.270 : TRACE :  Long description: a
49.270 : TRACE :  node end )
49.270 : TRACE :  Found comment  %% This is a comment
49.270 : TRACE :  node found .. a
49.270 : DEBUG :  In get type ( )
49.270 : INFO :  Node:  a
49.270 : INFO :  addNode [33m6[39m a a [33m1[39m
49.270 : TRACE :  Stop NL2
49.270 : TRACE :  Long description: New Stuff
49.270 : TRACE :  node end ... ]
49.270 : TRACE :  node found .. b
49.270 : DEBUG :  In get type [ ]
49.270 : INFO :  Node:  b
49.270 : INFO :  addNode [33m6[39m b New Stuff [33m2[39m
49.270 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-23 Rows with only spaces should not interfere
49.274 : TRACE :  Node:  root
49.274 : INFO :  addNode [33m0[39m root root [33m0[39m
49.274 : TRACE :  Stop NL
49.274 : TRACE :  SPACELINE
49.274 : INFO :  Node:  A
49.274 : INFO :  addNode [33m1[39m A A [33m0[39m
49.274 : INFO :  Node:  B
49.274 : INFO :  addNode [33m1[39m B B [33m0[39m
49.274 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-24 Handle rows above the mindmap declarations
49.276 : TRACE :  SPACELINE
49.276 : TRACE :  Node:  root
49.276 : INFO :  addNode [33m0[39m root root [33m0[39m
49.276 : TRACE :  Stop NL
49.276 : TRACE :  SPACELINE
49.276 : INFO :  Node:  A
49.276 : INFO :  addNode [33m1[39m A A [33m0[39m
49.276 : INFO :  Node:  B
49.276 : INFO :  addNode [33m1[39m B B [33m0[39m
49.276 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-25 Handle rows above the mindmap declarations, no space
49.279 : TRACE :  SPACELINE
49.279 : TRACE :  Node:  root
49.279 : INFO :  addNode [33m0[39m root root [33m0[39m
49.279 : TRACE :  Stop NL
49.279 : TRACE :  SPACELINE
49.279 : INFO :  Node:  A
49.279 : INFO :  addNode [33m1[39m A A [33m0[39m
49.279 : INFO :  Node:  B
49.279 : INFO :  addNode [33m1[39m B B [33m0[39m
49.279 : TRACE :  Stop EOF

 âœ“ packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts (26 tests) 96ms
 âœ“ packages/mermaid/src/diagrams/user-journey/parser/journey.spec.js (7 tests) 20ms
stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > KNBN-1 should handle a simple root definition abc122
49.197 : INFO :  Node:  root
49.197 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > KNBN-2 should handle a hierarchical kanban definition
49.207 : INFO :  Node:  root
49.207 : TRACE :  Stop NL
49.207 : INFO :  Node:  child1
49.207 : TRACE :  Stop NL
49.207 : INFO :  Node:  child2
49.207 : TRACE :  Stop NL
49.207 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > 3 should handle a simple root definition with a shape and without an id abc123
49.216 : TRACE :  Long description: root
49.216 : TRACE :  node end )
49.216 : TRACE :  node found .. (
49.215 : DEBUG :  In get type ( )
49.215 : INFO :  Node:  root
49.216 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > KNBN-4 should not distinguish between deeper hierarchical levels in the kanban definition
49.218 : INFO :  Node:  root
49.218 : TRACE :  Stop NL
49.218 : INFO :  Node:  child1
49.218 : TRACE :  Stop NL
49.218 : INFO :  Node:  leaf1
49.218 : TRACE :  Stop NL
49.218 : INFO :  Node:  child2
49.218 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > 5 Multiple sections are ok
49.223 : INFO :  Node:  section1
49.223 : TRACE :  Stop NL
49.223 : INFO :  Node:  section2
49.223 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > KNBN-6 real root in wrong place
49.227 : INFO :  Node:  root
49.227 : TRACE :  Stop NL
49.227 : INFO :  Node:  fakeRoot
49.227 : TRACE :  Stop NL
49.227 : INFO :  Node:  realRootWrongPlace

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > nodes > KNBN-7 should handle an id and type for a node definition
49.233 : TRACE :  Long description: The root
49.233 : TRACE :  node end ... ]
49.233 : TRACE :  node found .. root
49.233 : DEBUG :  In get type [ ]
49.233 : INFO :  Node:  root
49.233 : TRACE :  Stop NL
49.233 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > nodes > KNBN-8 should handle an id and type for a node definition
49.237 : INFO :  Node:  root
49.237 : TRACE :  Stop NL
49.237 : TRACE :  Long description: child1
49.237 : TRACE :  node end )
49.237 : TRACE :  node found .. theId
49.237 : DEBUG :  In get type ( )
49.237 : INFO :  Node:  theId
49.237 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > nodes > KNBN-9 should handle an id and type for a node definition
49.242 : TRACE :  Node:  root
49.242 : TRACE :  Stop NL
49.242 : TRACE :  Long description: child1
49.242 : TRACE :  node end )
49.242 : TRACE :  node found .. theId
49.242 : DEBUG :  In get type ( )
49.242 : INFO :  Node:  theId
49.242 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-13 should be possible to set an icon for the node
49.246 : TRACE :  Long description: The root
49.246 : TRACE :  node end ... ]
49.246 : TRACE :  node found .. root
49.246 : DEBUG :  In get type [ ]
49.246 : INFO :  Node:  root
49.246 : TRACE :  Stop NL
49.246 : TRACE :  Begin icon
49.246 : TRACE :  end icon
49.246 : TRACE :  Icon:  bomb
49.246 : TRACE :  Stop NL
49.246 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-14 should be possible to set classes for the node
49.251 : TRACE :  Long description: The root
49.251 : TRACE :  node end ... ]
49.251 : TRACE :  node found .. root
49.251 : DEBUG :  In get type [ ]
49.251 : INFO :  Node:  root
49.251 : TRACE :  Stop NL
49.251 : TRACE :  Stop NL
49.251 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-15 should be possible to set both classes and icon for the node
49.254 : TRACE :  Long description: The root
49.254 : TRACE :  node end ... ]
49.254 : TRACE :  node found .. root
49.254 : DEBUG :  In get type [ ]
49.254 : INFO :  Node:  root
49.254 : TRACE :  Stop NL
49.254 : TRACE :  Stop NL
49.254 : TRACE :  Begin icon
49.254 : TRACE :  end icon
49.254 : TRACE :  Icon:  bomb
49.254 : TRACE :  Stop NL
49.254 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-16 should be possible to set both classes and icon for the node
49.258 : TRACE :  Long description: The root
49.258 : TRACE :  node end ... ]
49.258 : TRACE :  node found .. root
49.258 : DEBUG :  In get type [ ]
49.258 : INFO :  Node:  root
49.258 : TRACE :  Stop NL
49.258 : TRACE :  Begin icon
49.258 : TRACE :  end icon
49.258 : TRACE :  Icon:  bomb
49.258 : TRACE :  Stop NL
49.258 : TRACE :  Stop NL
49.258 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > descriptions > KNBN-17 should be possible to use node syntax in the descriptions
49.262 : TRACE :  Starting NSTR
49.262 : TRACE :  description: String containing []
49.262 : TRACE :  node end ... ]
49.262 : TRACE :  node found .. root
49.262 : DEBUG :  In get type [ ]
49.262 : INFO :  Node:  root
49.262 : TRACE :  Stop NL
49.262 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > descriptions > KNBN-18 should be possible to use node syntax in the descriptions in children
49.265 : TRACE :  Starting NSTR
49.265 : TRACE :  description: String containing []
49.265 : TRACE :  node end ... ]
49.265 : TRACE :  node found .. root
49.265 : DEBUG :  In get type [ ]
49.265 : INFO :  Node:  root
49.265 : TRACE :  Stop NL
49.265 : TRACE :  Starting NSTR
49.265 : TRACE :  description: String containing ()
49.265 : TRACE :  node end ... ]
49.265 : TRACE :  node found .. child1
49.265 : DEBUG :  In get type [ ]
49.265 : INFO :  Node:  child1
49.265 : TRACE :  Stop NL
49.265 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > descriptions > KNBN-19 should be possible to have a child after a class assignment
49.268 : TRACE :  Long description: Root
49.268 : TRACE :  node end )
49.268 : TRACE :  node found .. root
49.268 : DEBUG :  In get type ( )
49.268 : INFO :  Node:  root
49.268 : TRACE :  Stop NL
49.268 : TRACE :  Long description: Child
49.268 : TRACE :  node end )
49.268 : TRACE :  node found .. Child
49.268 : DEBUG :  In get type ( )
49.268 : INFO :  Node:  Child
49.268 : TRACE :  Stop NL
49.268 : TRACE :  Stop NL
49.268 : TRACE :  Long description: a
49.268 : TRACE :  node end )
49.268 : TRACE :  node found .. a
49.268 : DEBUG :  In get type ( )
49.268 : INFO :  Node:  a
49.268 : TRACE :  Stop NL
49.268 : TRACE :  Long description: New Stuff
49.268 : TRACE :  node end ... ]
49.268 : TRACE :  node found .. b
49.268 : DEBUG :  In get type [ ]
49.268 : INFO :  Node:  b
49.268 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-20 should be possible to have meaningless empty rows in a kanban abc124
49.278 : TRACE :  Long description: Root
49.278 : TRACE :  node end )
49.278 : TRACE :  node found .. root
49.278 : DEBUG :  In get type ( )
49.278 : INFO :  Node:  root
49.278 : TRACE :  Stop NL
49.278 : TRACE :  Long description: Child
49.278 : TRACE :  node end )
49.278 : TRACE :  node found .. Child
49.278 : DEBUG :  In get type ( )
49.278 : INFO :  Node:  Child
49.278 : TRACE :  Stop NL
49.278 : TRACE :  Long description: a
49.278 : TRACE :  node end )
49.278 : TRACE :  SPACELINE
49.278 : TRACE :  node found .. a
49.278 : DEBUG :  In get type ( )
49.278 : INFO :  Node:  a
49.278 : TRACE :  Long description: New Stuff
49.278 : TRACE :  node end ... ]
49.278 : TRACE :  node found .. b
49.278 : DEBUG :  In get type [ ]
49.278 : INFO :  Node:  b
49.278 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-21 should be possible to have comments in a kanban
49.283 : TRACE :  Long description: Root
49.283 : TRACE :  node end )
49.283 : TRACE :  node found .. root
49.283 : DEBUG :  In get type ( )
49.283 : INFO :  Node:  root
49.283 : TRACE :  Stop NL
49.283 : TRACE :  Long description: Child
49.283 : TRACE :  node end )
49.283 : TRACE :  node found .. Child
49.283 : DEBUG :  In get type ( )
49.283 : INFO :  Node:  Child
49.283 : TRACE :  Stop NL
49.283 : TRACE :  Long description: a
49.283 : TRACE :  node end )
49.283 : TRACE :  Found comment

      %% This is a comment
49.283 : TRACE :  node found .. a
49.283 : DEBUG :  In get type ( )
49.283 : INFO :  Node:  a
49.283 : TRACE :  Stop NL2
49.283 : TRACE :  Long description: New Stuff
49.283 : TRACE :  node end ... ]
49.283 : TRACE :  node found .. b
49.283 : DEBUG :  In get type [ ]
49.283 : INFO :  Node:  b
49.283 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-22 should be possible to have comments at the end of a line
49.288 : TRACE :  Long description: Root
49.288 : TRACE :  node end )
49.288 : TRACE :  node found .. root
49.288 : DEBUG :  In get type ( )
49.288 : INFO :  Node:  root
49.288 : TRACE :  Stop NL
49.288 : TRACE :  Long description: Child
49.288 : TRACE :  node end )
49.288 : TRACE :  node found .. Child
49.288 : DEBUG :  In get type ( )
49.288 : INFO :  Node:  Child
49.288 : TRACE :  Stop NL
49.288 : TRACE :  Long description: a
49.288 : TRACE :  node end )
49.288 : TRACE :  Found comment  %% This is a comment
49.288 : TRACE :  node found .. a
49.288 : DEBUG :  In get type ( )
49.288 : INFO :  Node:  a
49.288 : TRACE :  Stop NL2
49.288 : TRACE :  Long description: New Stuff
49.288 : TRACE :  node end ... ]
49.288 : TRACE :  node found .. b
49.288 : DEBUG :  In get type [ ]
49.288 : INFO :  Node:  b
49.288 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-23 Rows with only spaces should not interfere
49.291 : TRACE :  Node:  root
49.291 : TRACE :  Stop NL
49.291 : TRACE :  SPACELINE
49.291 : INFO :  Node:  A
49.291 : INFO :  Node:  B
49.291 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-24 Handle rows above the kanban declarations
49.294 : TRACE :  SPACELINE
49.294 : TRACE :  Node:  root
49.294 : TRACE :  Stop NL
49.294 : TRACE :  SPACELINE
49.294 : INFO :  Node:  A
49.294 : INFO :  Node:  B
49.294 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-25 Handle rows above the kanban declarations, no space
49.297 : TRACE :  SPACELINE
49.297 : TRACE :  Node:  root
49.297 : TRACE :  Stop NL
49.297 : TRACE :  SPACELINE
49.297 : INFO :  Node:  A
49.297 : INFO :  Node:  B
49.297 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-30 should be possible to set the priority
49.301 : INFO :  Node:  root
49.301 : TRACE :  Stop NL
49.301 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-31 should be possible to set the assignment
49.305 : INFO :  Node:  root
49.305 : TRACE :  Stop NL
49.305 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-32 should be possible to set the icon
49.306 : INFO :  Node:  root
49.306 : TRACE :  Stop NL
49.306 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-33 should be possible to set the icon
49.308 : INFO :  Node:  root
49.308 : TRACE :  Stop NL
49.308 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-34 should be possible to set the metadata using multiple lines
49.309 : INFO :  Node:  root
49.309 : TRACE :  Stop NL
49.309 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-35 should be possible to set the metadata using one line
49.311 : INFO :  Node:  root
49.311 : TRACE :  Stop NL
49.311 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-36 should be possible to set the label using the new syntax
49.312 : INFO :  Node:  root
49.312 : TRACE :  Stop NL
49.312 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-37 should be possible to set the external id
49.313 : INFO :  Node:  root
49.313 : TRACE :  Stop NL
49.313 : TRACE :  Stop EOF

 âœ“ packages/mermaid/src/diagrams/kanban/kanban.spec.ts (30 tests) 123ms
 âœ“ packages/mermaid/src/diagrams/class/classTypes.spec.ts (93 tests) 85ms
 âœ“ packages/mermaid/src/diagrams/class/classDiagram-styles.spec.js (10 tests) 49ms
 âœ“ packages/mermaid/src/diagrams/c4/parser/c4Diagram.spec.js (3 tests) 16ms
 âœ“ packages/mermaid/src/diagrams/git/gitGraphRenderer.ts (30 tests) 23ms
 âœ“ packages/mermaid/src/diagrams/c4/parser/c4Boundary.spec.js (6 tests) 21ms
 âœ“ packages/mermaid/src/diagrams/c4/parser/c4PersonExt.spec.js (7 tests) 24ms
 âœ“ packages/mermaid/src/diagrams/c4/parser/c4Person.spec.js (7 tests) 30ms
 âœ“ packages/mermaid/src/diagrams/requirement/parser/requirementDiagram.spec.js (43 tests) 50ms
 âœ“ packages/mermaid/src/diagrams/c4/parser/c4System.spec.js (42 tests) 61ms
 âœ“ packages/mermaid/src/diagrams/c4/parser/c4Container.spec.js (48 tests) 72ms
 âœ“ packages/mermaid/src/utils/subGraphTitleMargins.spec.ts (1 test) 6ms
 âœ“ packages/mermaid/src/diagrams/gantt/parser/gantt.spec.js (27 tests) 80ms
 âœ“ packages/mermaid/src/diagrams/sankey/parser/sankey.spec.ts (4 tests) 160ms
 âœ“ packages/mermaid/src/diagrams/timeline/timeline.spec.js (8 tests) 42ms
 âœ“ packages/mermaid/src/diagrams/user-journey/journeyDb.spec.js (9 tests) 17ms
 âœ“ packages/mermaid/src/diagrams/sequence/svgDraw.spec.js (6 tests) 21ms
stdout | packages/mermaid/src/dagre-wrapper/edges.spec.js > Graphlib decorations > intersection > case 1 - intersection on left edge of box
49.814 : DEBUG :  intersection calc abc89:
  outsidePoint: {"x":31,"y":143.2257070163421}
  insidePoint : {"x":99.3359375,"y":100}
  node        : x:171 y:100 w:210 h:184
49.814 : DEBUG :  sides calc abc89, Q 43.22570701634211, q 22.139152558958802, R 68.3359375, r 35 { _x: [33m66[39m, _y: [33m122.1391525589588[39m }

stdout | packages/mermaid/src/dagre-wrapper/edges.spec.js > Graphlib decorations > intersection > case 2 - intersection on left edge of box
49.821 : DEBUG :  intersection calc abc89:
  outsidePoint: {"x":310.2578125,"y":169.88002060631462}
  insidePoint : {"x":127.96875,"y":100}
  node        : x:100.23046875 y:176.75 w:184.4609375 h:337.5
49.821 : DEBUG :  sides calc abc89, Q 69.88002060631462, q 45.15711441743504, R 182.2890625, r 117.796875 { _x: [33m192.4609375[39m, _y: [33m145.15711441743503[39m }

stdout | packages/mermaid/src/dagre-wrapper/edges.spec.js > Graphlib decorations > intersection > case 3 - intersection on top of box outside point greater than inside point
49.822 : DEBUG :  intersection calc abc89:
  outsidePoint: {"x":157,"y":39}
  insidePoint : {"x":104,"y":105}
  node        : x:114 y:164 w:212 h:176
49.822 : DEBUG :  abc89 topp/bott calc, Q 66, q 37, R 53, r 29.71212121212121 { x: [33m133.71212121212122[39m, y: [33m76[39m }

stdout | packages/mermaid/src/dagre-wrapper/edges.spec.js > Graphlib decorations > intersection > case 4 - intersection on top of box inside point greater than inside point
49.823 : DEBUG :  intersection calc abc89:
  outsidePoint: {"x":144,"y":38}
  insidePoint : {"x":198,"y":105}
  node        : x:114 y:164 w:212 h:176
49.823 : DEBUG :  abc89 topp/bott calc, Q 67, q 38, R 54, r 30.62686567164179 { x: [33m174.62686567164178[39m, y: [33m76[39m }

 âœ“ packages/mermaid/src/dagre-wrapper/edges.spec.js (4 tests) 14ms
 âœ“ packages/mermaid/src/diagrams/gantt/ganttDb.spec.ts (43 tests) 47ms
 âœ“ packages/mermaid/src/diagrams/block/layout.spec.ts (1 test) 6ms
 âœ“ packages/mermaid/src/diagrams/quadrant-chart/quadrantDb.spec.ts (4 tests) 8ms
 âœ“ packages/mermaid/src/diagrams/info/info.spec.ts (4 tests) 104ms
 âœ“ packages/mermaid/src/diagrams/class/svgDraw.spec.js (2 tests) 8ms
 âœ“ packages/mermaid-example-diagram/src/exampleDiagram.spec.js (1 test) 5ms
 âœ“ packages/mermaid/src/diagrams/class/parser/class.spec.js (3 tests) 24ms
 âœ“ packages/mermaid/src/diagrams/er/erRenderer.spec.ts (1 test) 7ms
 âœ“ packages/mermaid/src/setupGraphViewbox.spec.js (2 tests) 7ms
 âœ“ packages/mermaid/src/diagrams/pie/pie.spec.ts (16 tests | 2 skipped) 94ms
 âœ“ packages/mermaid/src/diagrams/packet/packet.spec.ts (15 tests) 155ms
 âœ“ packages/mermaid/src/diagrams/git/gitGraphParser.ts (6 tests) 11ms
 âœ“ packages/mermaid/src/utils.spec.ts (53 tests) 145ms
 âœ“ packages/mermaid/src/diagrams/git/gitGraph.spec.ts (69 tests | 4 skipped) 412ms
 âœ“ packages/mermaid/src/diagrams/er/parser/erDiagram.spec.js (611 tests | 1 skipped) 439ms
 âœ“ packages/mermaid/src/diagram-api/diagram-orchestration.spec.ts (24 tests) 39ms
 âœ“ packages/mermaid/src/diagram-api/diagramAPI.spec.ts (3 tests) 322ms
 âœ“ packages/mermaid/src/diagrams/architecture/architecture.spec.ts (6 tests) 140ms
 âœ“ packages/parser/tests/architecture.test.ts (12 tests) 25ms
 âœ“ packages/parser/tests/packet.test.ts (8 tests) 17ms
 âœ“ packages/parser/tests/gitGraph.test.ts (27 tests) 39ms
 âœ“ packages/parser/tests/info.test.ts (12 tests) 21ms
 âœ“ packages/parser/tests/pie.test.ts (32 tests) 43ms
 âœ“ packages/parser/tests/treemap.test.ts (17 tests) 51ms
 âœ“ packages/mermaid/src/diagrams/radar/radar.spec.ts (19 tests) 205ms
 âœ“ packages/parser/tests/radar.test.ts (80 tests) 91ms
 âœ“ packages/mermaid/src/diagrams/class/classDiagram.spec.ts (368 tests | 1 skipped) 1381ms
 âœ“ packages/examples/src/example.spec.ts (1 test) 8ms
 âœ“ packages/mermaid/src/rendering-util/rendering-elements/nodes.spec.ts (39 tests) 13ms
 âœ“ packages/mermaid/src/diagrams/flowchart/flowDb.spec.ts (13 tests) 33ms
 âœ“ packages/mermaid/src/diagrams/state/stateDb.spec.js (6 tests) 28ms
 âœ“ packages/mermaid/src/rendering-util/createText.spec.ts (5 tests) 44ms
 âœ“ packages/mermaid/src/diagrams/sequence/sequenceDiagram.spec.js (120 tests) 866ms
 âœ“ packages/mermaid/src/diagrams/state/parser/state-style.spec.js (15 tests) 70ms
 âœ“ packages/mermaid/src/diagrams/state/parser/state-parser.spec.js (9 tests) 73ms
 â†“ packages/mermaid/src/diagrams/flowchart/parser/flow-huge.spec.js (1 test | 1 skipped)
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-md-string.spec.js (2 tests) 26ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-direction.spec.js (4 tests) 27ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-comments.spec.js (9 tests) 30ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-vertice-chaining.spec.js (7 tests) 53ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-arrows.spec.js (14 tests) 59ms
 âœ“ packages/mermaid/src/diagrams/state/stateDiagram.spec.js (30 tests | 1 skipped) 201ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-interactions.spec.js (13 tests) 54ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-style.spec.js (24 tests) 82ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-lines.spec.js (12 tests) 69ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow.spec.js (25 tests) 106ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-node-data.spec.js (31 tests | 1 skipped) 136ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/subgraph.spec.js (22 tests | 1 skipped) 114ms
 âœ“ packages/mermaid/src/diagrams/state/stateDiagram-v2.spec.js (31 tests) 312ms
 âœ“ packages/mermaid/src/diagram.spec.ts (6 tests) 1711ms
   âœ“ diagram detection > should detect inbuilt diagrams 1680ms
 â¯ packages/mermaid/scripts/docs.spec.ts (0 test)
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-singlenode.spec.js (148 tests) 306ms
 âœ“ packages/mermaid/src/styles.spec.ts (81 tests) 1513ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-text.spec.js (342 tests) 519ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-edges.spec.js (293 tests) 588ms
 âœ“ packages/mermaid/src/mermaid.spec.ts (13 tests) 1238ms
   âœ“ when using mermaid and  > when using #registerExternalDiagrams > should throw error (but still render) if registerExternalDiagrams fails 1155ms
 âœ“ packages/mermaid/src/mermaidAPI.spec.ts (78 tests) 1737ms
   âœ“ mermaidAPI > render > accessibility > classDiagram > should set aria-roledescription to the diagram type AND should call addSVGa11yTitleDescription 382ms

âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯ Failed Suites 1 âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯

 FAIL  packages/mermaid/scripts/docs.spec.ts [ packages/mermaid/scripts/docs.spec.ts ]
Error: ENOENT: no such file or directory, open '../mermaid/package.json'
 â¯ packages/mermaid/scripts/docs.mts:61:51
     59| const { shapesDefs } = await import('../src/rendering-util/rendering-eâ€¦
     60|
     61| export const MERMAID_RELEASE_VERSION = JSON.parse(readFileSync('../merâ€¦
       |                                                   ^
     62|   .version as string;
     63| const MERMAID_MAJOR_VERSION = MERMAID_RELEASE_VERSION.split('.')[0];
 â¯ packages/mermaid/scripts/docs.spec.ts:1:1

âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[1/1]âŽ¯


 Test Files  1 failed | 96 passed | 1 skipped (98)
      Tests  3569 passed | 10 skipped | 2 todo (3581)
   Start at  18:36:34
   Duration  9.09s (transform 59.86s, setup 0ms, collect 328.49s, tests 15.96s, environment 95.97s, prepare 16.97s)

â€‰ELIFECYCLEâ€‰ Test failed. See above for more details.
