Scope: all 10 workspace projects
Lockfile is up to date, resolution step is skipped
Already up to date

â•­ Warning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®â”‚                                                                              â”‚â”‚   Ignored build scripts: unrs-resolver.                                      â”‚â”‚   Run "pnpm approve-builds" to pick which dependencies should be allowed     â”‚â”‚   to run scripts.                                                            â”‚â”‚                                                                              â”‚â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

. prepare$ husky && pnpm build
. prepare: > mermaid-monorepo@10.2.4 build /usr/src/app
. prepare: > pnpm build:esbuild && pnpm build:types
. prepare: > mermaid-monorepo@10.2.4 build:esbuild /usr/src/app
. prepare: > pnpm run -r clean && tsx .esbuild/build.ts
. prepare: Scope: 9 of 10 workspace projects
. prepare: packages/parser clean$ rimraf dist src/language/generated
. prepare: packages/tiny clean$ rimraf dist
. prepare: packages/tiny clean: Done
. prepare: packages/parser clean: Done
. prepare: packages/mermaid clean$ rimraf dist
. prepare: packages/mermaid clean: Done
. prepare: packages/examples clean$ rimraf dist
. prepare: packages/mermaid-zenuml clean$ rimraf dist
. prepare: packages/examples clean: Done
. prepare: packages/mermaid-zenuml clean: Done
. prepare: Reading config from /usr/src/app/packages/parser/langium-config.json
. prepare: src/language/info/info.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/info/info.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/info/info.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/common/common.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/common/common.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/common/common.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/packet/packet.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/packet/packet.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/packet/packet.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/pie/pie.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/pie/pie.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/pie/pie.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/architecture/architecture.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/architecture/architecture.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/architecture/architecture.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:29:15 - Found multiple assignments to 'id' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:30:18 - Found multiple assignments to 'message' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:32:18 - Found multiple assignments to 'type' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:42:15 - Found multiple assignments to 'id' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:44:18 - Found multiple assignments to 'type' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:53:15 - Found multiple assignments to 'id' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:55:20 - Found multiple assignments to 'parent' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/radar/radar.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/radar/radar.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/radar/radar.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:17:10 - This rule is declared but never referenced.
. prepare: Writing generated files to /usr/src/app/packages/parser/src/language/generated
. prepare: [16:06:17] Langium generator finished successfully in 474ms
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-FPAJGGOC.mjs    75.6kb
. prepare:   packages/parser/dist/mermaid-parser.core.mjs                           5.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-FWNWRKHM.mjs     3.8kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-O7ZBX7Z2.mjs     1.9kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-T53DSG4Q.mjs     1.5kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-S6J4BHB3.mjs     1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-76Q3JFCE.mjs     1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-LHMN2FUI.mjs     1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-LBM3YZW2.mjs     1.2kb
. prepare:   ...parser/dist/chunks/mermaid-parser.core/architecture-U656AL7Q.mjs    185b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.core/gitGraph-F6HP7TQM.mjs    169b
. prepare:   ...ages/parser/dist/chunks/mermaid-parser.core/treemap-KMMF4GRG.mjs    165b
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/packet-BFZMPI3H.mjs    161b
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/radar-NHE76QYJ.mjs     157b
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/info-NVLQJR56.mjs      153b
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/pie-7BOR55EZ.mjs       149b
. prepare:   ...es/parser/dist/chunks/mermaid-parser.core/chunk-FPAJGGOC.mjs.map  114.9kb
. prepare:   ...es/parser/dist/chunks/mermaid-parser.core/chunk-FWNWRKHM.mjs.map    8.6kb
. prepare:   packages/parser/dist/mermaid-parser.core.mjs.map                       5.3kb
. prepare:   ...es/parser/dist/chunks/mermaid-parser.core/chunk-O7ZBX7Z2.mjs.map    4.4kb
. prepare:   ...and 12 more output files...
. prepare: âš¡ Done in 53ms
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-L3Q2QJVV.mjs  381.1kb
. prepare:   packages/parser/dist/mermaid-parser.esm.min.mjs                        3.5kb
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-MMNLCZD2.mjs    1.6kb
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-T7ZF25BJ.mjs    761b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-H6ZBQRVM.mjs    606b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-IHLWZL4V.mjs    470b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-OQZUXTEW.mjs    465b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-OHOCZHKG.mjs    463b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-BI2MPBQI.mjs    462b
. prepare:   ...ser/dist/chunks/mermaid-parser.esm.min/architecture-PMHMJ2ZY.mjs    132b
. prepare:   .../parser/dist/chunks/mermaid-parser.esm.min/gitGraph-EH3HN3AX.mjs    124b
. prepare:   ...s/parser/dist/chunks/mermaid-parser.esm.min/treemap-KOFTZR4J.mjs    122b
. prepare:   ...es/parser/dist/chunks/mermaid-parser.esm.min/packet-AGCPRN6G.mjs    120b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/radar-S7LXCSCY.mjs    118b
. prepare:   ...ages/parser/dist/chunks/mermaid-parser.esm.min/info-HLY6SS6Y.mjs    116b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm.min/pie-65AXTC64.mjs    114b
. prepare:   ...parser/dist/chunks/mermaid-parser.esm.min/chunk-L3Q2QJVV.mjs.map    1.8mb
. prepare:   ...parser/dist/chunks/mermaid-parser.esm.min/chunk-MMNLCZD2.mjs.map    8.8kb
. prepare:   packages/parser/dist/mermaid-parser.esm.min.mjs.map                    5.3kb
. prepare:   ...parser/dist/chunks/mermaid-parser.esm.min/chunk-T7ZF25BJ.mjs.map    4.7kb
. prepare:   ...and 12 more output files...
. prepare: âš¡ Done in 202ms
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-CUV4ONQR.mjs    802.5kb
. prepare:   packages/parser/dist/mermaid-parser.esm.mjs                            5.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-AAKHKIIX.mjs      3.7kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-FJ76IR54.mjs      1.8kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-M7HE2OLO.mjs      1.5kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-DLEEDQTW.mjs      1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-VGLBXUVE.mjs      1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-B3PWJQJV.mjs      1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-25RGGQC2.mjs      1.1kb
. prepare:   .../parser/dist/chunks/mermaid-parser.esm/architecture-3LUSXU7A.mjs    185b
. prepare:   ...ages/parser/dist/chunks/mermaid-parser.esm/gitGraph-QD2FAQA2.mjs    169b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/treemap-LTEPFSZC.mjs    165b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/packet-6CSEHWCI.mjs     161b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/radar-RQNMY3TF.mjs      157b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/info-GMZAA7BQ.mjs       153b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/pie-NGLVWQ3N.mjs        149b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm/chunk-CUV4ONQR.mjs.map    1.7mb
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm/chunk-AAKHKIIX.mjs.map    8.5kb
. prepare:   packages/parser/dist/mermaid-parser.esm.mjs.map                        5.3kb
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm/chunk-FJ76IR54.mjs.map    4.3kb
. prepare:   ...and 12 more output files...
. prepare: âš¡ Done in 206ms
. prepare:   packages/mermaid/dist/chunks/mermaid.core/chunk-CV3G5MRU.mjs         190.3kb
. prepare:   ...es/mermaid/dist/chunks/mermaid.core/sequenceDiagram-4MX5Z3NR.mjs  149.9kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/blockDiagram-ZYB65J3Q.mjs  134.2kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/chunk-VIW5F6AA.mjs         130.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/c4Diagram-AAMF2YG6.mjs     117.7kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/flowDiagram-THRYKUMA.mjs   102.3kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/chunk-MRT3R2DC.mjs          91.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/chunk-JBRWN2VN.mjs          77.6kb
. prepare:   ...ges/mermaid/dist/chunks/mermaid.core/xychartDiagram-FDP5SA34.mjs   72.3kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/ganttDiagram-WV7ZQ7D5.mjs   71.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/chunk-LXBSTHXV.mjs          70.1kb
. prepare:   ...es/mermaid/dist/chunks/mermaid.core/gitGraphDiagram-OJR772UL.mjs   61.4kb
. prepare:   ...es/mermaid/dist/chunks/mermaid.core/quadrantDiagram-YPSRARAO.mjs   61.1kb
. prepare:   ...mermaid/dist/chunks/mermaid.core/requirementDiagram-EGVEC5DT.mjs   51.8kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/erDiagram-HZWUO2LU.mjs      46.6kb
. prepare:   ...ermaid/dist/chunks/mermaid.core/timeline-definition-3HZDQTIS.mjs   45.6kb
. prepare:   ...ges/mermaid/dist/chunks/mermaid.core/journeyDiagram-FFXJYRFH.mjs   44.9kb
. prepare:   ...mermaid/dist/chunks/mermaid.core/mindmap-definition-LNHGMQRG.mjs   43.4kb
. prepare:   ...ermaid/dist/chunks/mermaid.core/architectureDiagram-KFL7JDKH.mjs   43.3kb
. prepare:   packages/mermaid/dist/mermaid.core.mjs                                42.6kb
. prepare:   ...and 74 more output files...
. prepare: âš¡ Done in 1253ms
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-MBJCTAW2.mjs      433.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-L6MQJ2ZU.mjs      346.9kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/katex-RV2QPRKB.mjs      270.1kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-F632ZYSZ.mjs      241.5kb
. prepare:   ...aid/dist/chunks/mermaid.esm.min/architectureDiagram-GXAZU6X5.mjs  148.2kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-DPMNACAB.mjs      115.1kb
. prepare:   ...maid/dist/chunks/mermaid.esm.min/mindmap-definition-75HPFGON.mjs  101.9kb
. prepare:   ...mermaid/dist/chunks/mermaid.esm.min/sequenceDiagram-NCT4EGAA.mjs   86.5kb
. prepare:   ...es/mermaid/dist/chunks/mermaid.esm.min/blockDiagram-HV7WRKX4.mjs   70.4kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/c4Diagram-S26XAWAN.mjs   68.8kb
. prepare:   ...ges/mermaid/dist/chunks/mermaid.esm.min/flowDiagram-7YKJRSJY.mjs   59.5kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-IXVBHSNP.mjs       57.1kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-44WDCOIT.mjs       44.3kb
. prepare:   ...es/mermaid/dist/chunks/mermaid.esm.min/ganttDiagram-5J5FM7L2.mjs   42.3kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-7LIB5WBN.mjs       41.4kb
. prepare:   .../mermaid/dist/chunks/mermaid.esm.min/xychartDiagram-WBSIB3YZ.mjs   38.1kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-S3YGE35Q.mjs       35.8kb
. prepare:   ...mermaid/dist/chunks/mermaid.esm.min/quadrantDiagram-5BXOXB7R.mjs   33.0kb
. prepare:   ...maid/dist/chunks/mermaid.esm.min/requirementDiagram-CG6N56KZ.mjs   29.7kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-FASC7IG4.mjs       27.8kb
. prepare:   ...and 124 more output files...
. prepare: âš¡ Done in 3153ms
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-COUQ6RZ3.mjs          933.4kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-YOB5EFFC.mjs          697.6kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/katex-A6QSACVP.mjs          494.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-NC4V57XB.mjs          436.7kb
. prepare:   ...mermaid/dist/chunks/mermaid.esm/architectureDiagram-L76ZKZTK.mjs  417.2kb
. prepare:   .../mermaid/dist/chunks/mermaid.esm/mindmap-definition-KYUYEQSL.mjs  250.2kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-3AU3J4PQ.mjs          232.4kb
. prepare:   ...ges/mermaid/dist/chunks/mermaid.esm/sequenceDiagram-WN2LQSXR.mjs  150.1kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/blockDiagram-5FNOSGNS.mjs   134.2kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/c4Diagram-SNKOAWKG.mjs      117.8kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/flowDiagram-ADV24XW4.mjs    102.4kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-VNOTBLTU.mjs           93.4kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-W3YOBQ4T.mjs           91.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/ganttDiagram-NY35QN2E.mjs    81.8kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-TGZYFRKZ.mjs           78.5kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-JUNTMEQM.mjs           77.6kb
. prepare:   ...ages/mermaid/dist/chunks/mermaid.esm/xychartDiagram-LLVWJMIC.mjs   72.3kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-JRY5QETF.mjs           70.1kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-IHYUGLNO.mjs           62.9kb
. prepare:   ...ges/mermaid/dist/chunks/mermaid.esm/gitGraphDiagram-36KJ7O45.mjs   61.7kb
. prepare:   ...and 124 more output files...
. prepare: âš¡ Done in 3746ms
. prepare:   packages/mermaid/dist/mermaid.js       6.1mb âš ï¸
. prepare:   packages/mermaid/dist/mermaid.js.map  10.1mb
. prepare: âš¡ Done in 3863ms
. prepare:   packages/mermaid/dist/mermaid.tiny.min.js  1.6mb âš ï¸
. prepare: âš¡ Done in 4254ms
. prepare:   packages/mermaid/dist/mermaid.min.js       2.6mb âš ï¸
. prepare:   packages/mermaid/dist/mermaid.min.js.map  10.2mb
. prepare: âš¡ Done in 4796ms
. prepare:   ...unks/mermaid-example-diagram.core/diagram-definition-AUF2VOIT.mjs  22.5kb
. prepare:   ...ges/mermaid-example-diagram/dist/mermaid-example-diagram.core.mjs   557b
. prepare:   ...agram/dist/chunks/mermaid-example-diagram.core/chunk-AKMCXCCK.mjs   291b
. prepare:   .../mermaid-example-diagram.core/diagram-definition-AUF2VOIT.mjs.map  40.9kb
. prepare:   ...mermaid-example-diagram/dist/mermaid-example-diagram.core.mjs.map   786b
. prepare:   ...m/dist/chunks/mermaid-example-diagram.core/chunk-AKMCXCCK.mjs.map    93b
. prepare: âš¡ Done in 45ms
. prepare:   ...unks/mermaid-example-diagram.esm/diagram-definition-ZN3FLJNS.mjs  109.0kb
. prepare:   ...ges/mermaid-example-diagram/dist/mermaid-example-diagram.esm.mjs    555b
. prepare:   ...agram/dist/chunks/mermaid-example-diagram.esm/chunk-6XSXFHVP.mjs    291b
. prepare:   .../mermaid-example-diagram.esm/diagram-definition-ZN3FLJNS.mjs.map  215.0kb
. prepare:   ...mermaid-example-diagram/dist/mermaid-example-diagram.esm.mjs.map    786b
. prepare:   ...m/dist/chunks/mermaid-example-diagram.esm/chunk-6XSXFHVP.mjs.map     93b
. prepare: âš¡ Done in 111ms
. prepare:   .../mermaid-example-diagram.esm.min/diagram-definition-2JINLXFM.mjs   53.0kb
. prepare:   ...mermaid-example-diagram/dist/mermaid-example-diagram.esm.min.mjs    355b
. prepare:   ...m/dist/chunks/mermaid-example-diagram.esm.min/chunk-D2P5M7FY.mjs    164b
. prepare:   ...maid-example-diagram.esm.min/diagram-definition-2JINLXFM.mjs.map  227.2kb
. prepare:   ...aid-example-diagram/dist/mermaid-example-diagram.esm.min.mjs.map    860b
. prepare:   ...st/chunks/mermaid-example-diagram.esm.min/chunk-D2P5M7FY.mjs.map     93b
. prepare: âš¡ Done in 114ms
. prepare:   ...uml/dist/chunks/mermaid-zenuml.core/zenuml-definition-AWJE5BBT.mjs  3.2kb
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.core.mjs                   520b
. prepare:   .../mermaid-zenuml/dist/chunks/mermaid-zenuml.core/chunk-CJCKSLXZ.mjs  151b
. prepare:   ...dist/chunks/mermaid-zenuml.core/zenuml-definition-AWJE5BBT.mjs.map  6.7kb
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.core.mjs.map               765b
. prepare:   ...maid-zenuml/dist/chunks/mermaid-zenuml.core/chunk-CJCKSLXZ.mjs.map   93b
. prepare: âš¡ Done in 5ms
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.js      5.1mb âš ï¸
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.js.map  6.4mb
. prepare: âš¡ Done in 617ms
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.min.js      4.1mb âš ï¸
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.min.js.map  6.2mb
. prepare: âš¡ Done in 656ms
. prepare:   ...ml/dist/chunks/mermaid-zenuml.esm/zenuml-definition-H5KMDA2O.mjs  4.9mb âš ï¸
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.esm.mjs                  518b
. prepare:   ...mermaid-zenuml/dist/chunks/mermaid-zenuml.esm/chunk-OS44DIFC.mjs  151b
. prepare:   ...ist/chunks/mermaid-zenuml.esm/zenuml-definition-H5KMDA2O.mjs.map  6.4mb
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.esm.mjs.map              765b
. prepare:   ...aid-zenuml/dist/chunks/mermaid-zenuml.esm/chunk-OS44DIFC.mjs.map   93b
. prepare: âš¡ Done in 711ms
. prepare:   ...ist/chunks/mermaid-zenuml.esm.min/zenuml-definition-XJYTECJ4.mjs  4.1mb âš ï¸
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.esm.min.mjs              323b
. prepare:   ...aid-zenuml/dist/chunks/mermaid-zenuml.esm.min/chunk-VDOFMJQL.mjs   95b
. prepare:   ...chunks/mermaid-zenuml.esm.min/zenuml-definition-XJYTECJ4.mjs.map  6.2mb
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.esm.min.mjs.map          837b
. prepare:   ...zenuml/dist/chunks/mermaid-zenuml.esm.min/chunk-VDOFMJQL.mjs.map   93b
. prepare: âš¡ Done in 753ms
. prepare:   ...ayout-elk/dist/chunks/mermaid-layout-elk.core/render-M6WAID4X.mjs  26.7kb
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.core.mjs           543b
. prepare:   ...layout-elk/dist/chunks/mermaid-layout-elk.core/chunk-ZW26E7AF.mjs   151b
. prepare:   ...t-elk/dist/chunks/mermaid-layout-elk.core/render-M6WAID4X.mjs.map  52.2kb
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.core.mjs.map       827b
. prepare:   ...ut-elk/dist/chunks/mermaid-layout-elk.core/chunk-ZW26E7AF.mjs.map    93b
. prepare: âš¡ Done in 11ms
. prepare:   ...ayout-elk/dist/chunks/mermaid-layout-elk.esm/render-P27B6YR6.mjs  3.6mb âš ï¸
. prepare:   ...layout-elk/dist/chunks/mermaid-layout-elk.esm/chunk-TWI3KLJS.mjs  1.8kb
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.esm.mjs          541b
. prepare:   ...t-elk/dist/chunks/mermaid-layout-elk.esm/render-P27B6YR6.mjs.map  4.4mb
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.esm.mjs.map      827b
. prepare:   ...ut-elk/dist/chunks/mermaid-layout-elk.esm/chunk-TWI3KLJS.mjs.map   93b
. prepare: âš¡ Done in 837ms
. prepare:   ...t-elk/dist/chunks/mermaid-layout-elk.esm.min/render-DDKIELPE.mjs  1.6mb âš ï¸
. prepare:   ...ut-elk/dist/chunks/mermaid-layout-elk.esm.min/chunk-SP2CHFBE.mjs  854b
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.esm.min.mjs      356b
. prepare:   ...k/dist/chunks/mermaid-layout-elk.esm.min/render-DDKIELPE.mjs.map  4.9mb
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.esm.min.mjs.map  842b
. prepare:   ...lk/dist/chunks/mermaid-layout-elk.esm.min/chunk-SP2CHFBE.mjs.map   93b
. prepare: âš¡ Done in 852ms
. prepare:   packages/examples/dist/mermaid-examples.esm.mjs      15.7kb
. prepare:   packages/examples/dist/mermaid-examples.esm.mjs.map  24.8kb
. prepare: âš¡ Done in 7ms
. prepare:   packages/examples/dist/mermaid-examples.esm.min.mjs      13.2kb
. prepare:   packages/examples/dist/mermaid-examples.esm.min.mjs.map  24.5kb
. prepare: âš¡ Done in 7ms
. prepare:   packages/examples/dist/mermaid-examples.core.mjs      15.7kb
. prepare:   packages/examples/dist/mermaid-examples.core.mjs.map  24.8kb
. prepare: âš¡ Done in 7ms
. prepare: > mermaid-monorepo@10.2.4 build:types /usr/src/app
. prepare: > pnpm --filter mermaid types:build-config && tsx .build/types.ts
. prepare: > mermaid@11.10.0 types:build-config /usr/src/app/packages/mermaid
. prepare: > tsx scripts/create-types-from-json-schema.mts
. prepare: Writing typescript file to ./src/config.type.ts
. prepare: Building types for parser
. prepare: Building types for mermaid
. prepare: Building types for mermaid-example-diagram
. prepare: Building types for mermaid-zenuml
. prepare: Building types for mermaid-layout-elk
. prepare: Building types for examples
. prepare: Done
Done in 32.6s using pnpm v10.4.1

> mermaid-monorepo@10.2.4 test /usr/src/app
> pnpm lint && vitest run


> mermaid-monorepo@10.2.4 lint /usr/src/app
> eslint --quiet --stats --cache --cache-strategy content . && pnpm lint:jison && prettier --cache --check .


> mermaid-monorepo@10.2.4 lint:jison /usr/src/app
> tsx ./scripts/jison/lint.mts

Linting ./packages/mermaid-example-diagram/src/parser/exampleDiagram.jison
Linting ./packages/mermaid/src/diagrams/block/parser/block.jison
Linting ./packages/mermaid/src/diagrams/c4/parser/c4Diagram.jison
Linting ./packages/mermaid/src/diagrams/class/parser/classDiagram.jison
Linting ./packages/mermaid/src/diagrams/er/parser/erDiagram.jison
Linting ./packages/mermaid/src/diagrams/flowchart/parser/flow.jison
Linting ./packages/mermaid/src/diagrams/gantt/parser/gantt.jison
Linting ./packages/mermaid/src/diagrams/mindmap/parser/mindmap.jison
Linting ./packages/mermaid/src/diagrams/kanban/parser/kanban.jison
Linting ./packages/mermaid/src/diagrams/quadrant-chart/parser/quadrant.jison
Linting ./packages/mermaid/src/diagrams/sankey/parser/sankey.jison
Linting ./packages/mermaid/src/diagrams/requirement/parser/requirementDiagram.jison
Linting ./packages/mermaid/src/diagrams/timeline/parser/timeline.jison
Linting ./packages/mermaid/src/diagrams/sequence/parser/sequenceDiagram.jison
Linting ./packages/mermaid/src/diagrams/state/parser/stateDiagram.jison
Linting ./packages/mermaid/src/diagrams/xychart/parser/xychart.jison
Linting ./packages/mermaid/src/diagrams/user-journey/parser/journey.jison
Checking formatting...
All matched files use Prettier code style!
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid-example-diagram/src/exampleDiagramDb.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid-example-diagram/src/exampleDiagramRenderer.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid-example-diagram/src/styles.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/clusters.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/createLabel.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/edges.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/index.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/intersect/index.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-circle.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-ellipse.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-line.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-node.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-polygon.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-rect.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/markers.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/mermaid-graphlib.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/nodes.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/shapes/note.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/shapes/util.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/c4/c4Db.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/c4/c4Renderer.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/c4/styles.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/c4/svgDraw.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/class/styles.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/er/erMarkers.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/er/erRenderer.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/gantt/ganttDb.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/gantt/ganttRenderer.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/gantt/styles.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/git/styles.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/requirement/styles.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/sankey/styles.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/sequence/styles.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/sequence/svgDraw.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/state/shapes.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/state/stateRenderer.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/state/styles.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/timeline/styles.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/timeline/svgDraw.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/timeline/timelineDb.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/user-journey/journeyDb.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/user-journey/styles.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/user-journey/svgDraw.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/insertElementsForSize.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/layout-algorithms/dagre/index.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/clusters.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/createLabel.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/edges.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/index.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-circle.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-ellipse.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-line.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-node.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-polygon.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-rect.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/markers.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/setupGraphViewbox.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/themes/index.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/themes/theme-base.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/themes/theme-dark.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/themes/theme-default.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/themes/theme-forest.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/themes/theme-helpers.js' because it would overwrite input file.
4:08:05 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/themes/theme-neutral.js' because it would overwrite input file.

 RUN  v3.0.6 /usr/src/app

 âœ“ packages/mermaid/src/utils/lineWithOffset.ts (2 tests) 6ms
 âœ“ packages/mermaid/src/utils/imperativeState.spec.ts (3 tests) 7ms
 âœ“ packages/mermaid/src/diagrams/common/common.spec.ts (20 tests) 66ms
 âœ“ packages/mermaid/src/diagram-api/comments.spec.ts (5 tests) 23ms
 âœ“ packages/mermaid/src/diagrams/treemap/utils.test.ts (4 tests) 8ms
 âœ“ packages/mermaid/src/rendering-util/splitText.spec.ts (35 tests) 79ms
 âœ“ packages/mermaid/src/dagre-wrapper/edgeMarker.spec.ts (5 tests) 10ms
 âœ“ packages/mermaid/src/rendering-util/rendering-elements/edgeMarker.spec.ts (5 tests) 11ms
 âœ“ packages/mermaid/src/diagrams/quadrant-chart/parser/quadrant.jison.spec.ts (14 tests) 39ms
 âœ“ packages/mermaid/src/diagrams/xychart/parser/xychart.jison.spec.ts (48 tests) 51ms
 âœ“ packages/mermaid/src/diagram-api/frontmatter.spec.ts (12 tests) 39ms
 âœ“ packages/mermaid/src/diagrams/flowchart/flowChartShapes.spec.js (11 tests) 20ms
 âœ“ packages/mermaid/src/docs/.vitepress/theme/redirect.spec.ts (28 tests) 23ms
 âœ“ packages/mermaid/src/rendering-util/handle-markdown-text.spec.ts (19 tests) 65ms
stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
09.814 : DEBUG :  Opting in, graph
09.814 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
09.814 : WARN :  Cluster identified C1  Replacement id in edges:  a
09.814 : WARN :  Cluster identified C2  Replacement id in edges:  c
09.814 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
09.814 : DEBUG :  Not a cluster  c { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
09.814 : DEBUG :  Cluster identified C1 { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
09.814 : DEBUG :  Cluster identified C2 { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
09.814 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
09.814 : DEBUG :  Extracting node a {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
09.814 : DEBUG :  Not a cluster a [33m0[39m
09.814 : DEBUG :  Extracting node b {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
09.814 : DEBUG :  Not a cluster b [33m0[39m
09.814 : DEBUG :  Extracting node c {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
09.814 : DEBUG :  Not a cluster c [33m0[39m
09.814 : DEBUG :  Extracting node C1 {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.814 : INFO :  cp  a  to  C1  with parent  C1
09.814 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
09.814 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.814 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m }, { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
09.814 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m }
09.814 : INFO :  Edge data {} C1
09.814 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
09.814 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m }
09.814 : INFO :  Copying as  a b {} [90mundefined[39m
09.814 : INFO :  newGraph edges  [ { v: [32m'a'[39m, w: [32m'b'[39m } ] {}
09.814 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
09.814 : INFO :  Edge data {} C1
09.814 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
09.814 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
09.814 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
09.814 : DEBUG :  Removing node a
09.814 : INFO :  cp  b  to  C1  with parent  C1
09.814 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
09.814 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.814 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
09.814 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
09.814 : INFO :  Edge data {} C1
09.814 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
09.814 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
09.814 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
09.814 : DEBUG :  Removing node b
09.814 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.814 : DEBUG :  Extracting node C2 {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.814 : INFO :  cp  c  to  C2  with parent  C2
09.814 : INFO :  In copy  C2 root C2 data [90mundefined[39m C2
09.814 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.814 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
09.814 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
09.814 : INFO :  Edge data {} C2
09.814 : INFO :  Descendants of  C2  is  [ [32m'c'[39m ]
09.814 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
09.814 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
09.814 : DEBUG :  Removing node c
09.814 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'C1'[39m, value: [36m[Object][39m }, { v: [32m'C2'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.814 : DEBUG :  Done, no node has children [ [32m'a'[39m, [32m'b'[39m ]
09.814 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
09.814 : INFO :  [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]

09.814 : WARN :  Edge a -> b: {"v":"a","w":"b"}
09.814 : WARN :  Edge a -> b: {}
09.814 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: a b Translating:  [90mundefined[39m  ---  [90mundefined[39m
09.814 : WARN :  Edge C1 -> C2: {"v":"C1","w":"C2"}
09.814 : WARN :  Edge C1 -> C2: {}
09.814 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: C1 C2 Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'c'[39m, clusterData: [90mundefined[39m }
09.814 : WARN :  Fixing and trixing - removing XXX C1 C2 [90mundefined[39m
09.814 : WARN :  Fix Replacing with XXX C1 C2 [90mundefined[39m
09.814 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.814 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.814 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
09.814 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.814 : WARN :  Copying children of  C1 root C1 data [90mundefined[39m C1
09.814 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m, [32m'b'[39m ]
09.814 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: {} }, { v: [32m'b'[39m, value: {} } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.814 : WARN :  Cluster without external connections, without a parent and with children C2 [33m0[39m
09.814 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.814 : WARN :  Copying children of  C2 root C2 data [90mundefined[39m C2
09.814 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'c'[39m ]
09.814 : WARN :  New graph after copy node: ( C2 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: {} } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.814 : WARN :  New list of nodes [ [32m'C1'[39m, [32m'C2'[39m ]
09.814 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: {}, b: {} },
    _parent: { a: [32m'\x00'[39m, b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {}, b: {} },
    _in: { a: {}, b: [36m[Object][39m },
    _preds: { a: {}, b: [36m[Object][39m },
    _out: { a: [36m[Object][39m, b: {} },
    _sucs: { a: [36m[Object][39m, b: {} },
    _edgeObjs: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'a\x01b\x01\x00'[39m: {} },
    _nodeCount: [33m2[39m,
    _edgeCount: [33m1[39m
  }
}
09.814 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: {} }, { v: [32m'b'[39m, value: {} } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.814 : WARN :   Now next level C2 {
  clusterNode: [33mtrue[39m,
  id: [32m'C2'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: {} },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
09.814 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: {} } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
09.840 : DEBUG :  Opting in, graph
09.840 : DEBUG :  Not a cluster  a { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
09.840 : DEBUG :  Not a cluster  b { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
09.840 : DEBUG :  Not a cluster  c { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
09.840 : DEBUG :  Cluster identified C1 { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
09.840 : WARN :  Cluster identified C1  Replacement id in edges:  b
09.840 : WARN :  Cluster identified C2  Replacement id in edges:  a
09.840 : WARN :  Edge:  { v: [32m'a'[39m, w: [32m'b'[39m }  leaves cluster  C2
09.840 : WARN :  Descendants of XXX  C2 :  [ [32m'a'[39m ]
09.840 : WARN :  Edge a -> b: {"v":"a","w":"b"}
09.840 : WARN :  Edge a -> b: {"name":"C1-internal-link"}
09.840 : WARN :  Fix XXX {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} ids: a b Translating:  [90mundefined[39m  ---  [90mundefined[39m
09.840 : WARN :  Edge C1 -> c: {"v":"C1","w":"c"}
09.840 : WARN :  Edge C1 -> c: {"name":"C1-external-link"}
09.840 : WARN :  Fix XXX {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
09.840 : DEBUG :  Cluster identified C2 { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
09.840 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
09.840 : DEBUG :  Extracting node a {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
09.840 : DEBUG :  Not a cluster a [33m0[39m
09.840 : DEBUG :  Extracting node b {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
09.840 : DEBUG :  Not a cluster b [33m0[39m
09.840 : DEBUG :  Extracting node c {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
} ids: C1 c Translating:  { id: [32m'b'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
09.840 : WARN :  Fixing and trixing - removing XXX C1 c [90mundefined[39m
09.840 : WARN :  Fix Replacing with XXX C1 c [90mundefined[39m
09.840 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.840 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
} [90mundefined[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
09.840 : DEBUG :  Not a cluster c [33m0[39m
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.840 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
09.840 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.840 : WARN :  Copying children of  C1 root C1 data { data: [33m4[39m } C1
09.840 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'b'[39m, [32m'C2'[39m ]
09.840 : WARN :  Copying children of  C2 root C1 data { data: [33m5[39m } C1
09.840 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'a'[39m, [32m'C2'[39m ]
09.840 : WARN :  Setting parent a C2
09.840 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
09.840 : DEBUG :  Extracting node C1 {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
09.840 : INFO :  cp  b  to  C1  with parent  C1
09.840 : INFO :  In copy  C1 root C1 data { data: [33m4[39m } C1
09.840 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.840 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m } ]
09.840 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m }
09.840 : INFO :  Edge data { name: [32m'C1-internal-link'[39m } C1
09.840 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
09.840 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m }
09.840 : INFO :  Copying as  a b { name: [32m'C1-internal-link'[39m } [90mundefined[39m
09.840 : INFO :  newGraph edges  [ { v: [32m'a'[39m, w: [32m'b'[39m } ] { name: [32m'C1-internal-link'[39m }
09.840 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
09.840 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
09.840 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
09.840 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
09.840 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
09.840 : DEBUG :  Removing node b
09.840 : INFO :  cp  a  to  C1  with parent  C2
09.840 : DEBUG :  Setting parent a C2
09.840 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'c'[39m } ]
09.840 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
09.840 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
09.840 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
09.840 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
09.840 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
09.840 : DEBUG :  Removing node a
09.840 : INFO :  cp  C2  to  C1  with parent  C2
09.840 : INFO :  In copy  C2 root C1 data { data: [33m5[39m } C1
09.840 : DEBUG :  Not Setting parent for node= C2 cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
09.840 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'c'[39m } ]
09.840 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
09.840 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
09.840 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
09.840 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
09.840 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
09.840 : DEBUG :  Removing node C2
09.840 : DEBUG :  Removing node C2
09.840 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m }, { v: [32m'C1'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.840 : DEBUG :  Extracting node C2 {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.840 : DEBUG :  {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
}
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.840 : WARN :  Cluster **  C2  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
09.840 : WARN :  New list of nodes [ [32m'c'[39m, [32m'C1'[39m ]
09.840 : WARN :   Now next level c { data: [33m3[39m }
09.840 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
09.840 : DEBUG :  Nodes =  [ [32m'b'[39m, [32m'a'[39m, [32m'C2'[39m ] [33m1[39m
  clusterData: { data: [33m4[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m, a: [36m[Object][39m, C2: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m, a: [32m'C2'[39m, C2: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {}, a: {}, C2: [36m[Object][39m },
    _in: { b: [36m[Object][39m, a: {}, C2: {} },
09.840 : DEBUG :  Extracting node b {
    _preds: { b: [36m[Object][39m, a: {}, C2: {} },
    _out: { b: {}, a: [36m[Object][39m, C2: {} },
    _sucs: { b: {}, a: [36m[Object][39m, C2: {} },
    _edgeObjs: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _nodeCount: [33m3[39m,
    _edgeCount: [33m1[39m
  }
}
09.840 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m } ],
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [90mundefined[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m1[39m
09.840 : DEBUG :  Not a cluster b [33m1[39m
09.840 : DEBUG :  Extracting node a {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m1[39m
09.840 : DEBUG :  Not a cluster a [33m1[39m
09.840 : DEBUG :  Extracting node C2 {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m5[39m } [90mundefined[39m  Depth  [33m1[39m
09.840 : DEBUG :  {
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.840 : WARN :  Cluster **  C2  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [33mtrue[39m [90mundefined[39m [33m1[39m
09.840 : WARN :  New list of nodes [ [32m'b'[39m, [32m'a'[39m, [32m'C2'[39m ]
09.840 : WARN :   Now next level b { data: [33m2[39m }
09.840 : WARN :   Now next level a { data: [33m1[39m }
09.840 : WARN :   Now next level C2 { data: [33m5[39m }
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
}
09.840 : INFO :  [ [32m'c'[39m, [32m'C1'[39m ]


stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
09.826 : DEBUG :  Opting in, graph
09.826 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
09.826 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
09.826 : DEBUG :  Not a cluster  c Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
09.826 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
09.826 : DEBUG :  Cluster identified C2 Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
09.826 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
09.826 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
09.826 : DEBUG :  Not a cluster a [33m0[39m
09.826 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
09.826 : DEBUG :  Not a cluster b [33m0[39m
09.826 : DEBUG :  Extracting node c Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
09.826 : DEBUG :  Not a cluster c [33m0[39m
09.826 : DEBUG :  Extracting node C1 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.826 : INFO :  cp  a  to  C1  with parent  C1
09.826 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
09.826 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.826 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m }, { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
09.826 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m }
09.826 : INFO :  Edge data {} C1
09.826 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
09.826 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m }
09.826 : INFO :  Copying as  a b {} [90mundefined[39m
09.826 : INFO :  newGraph edges  [ { v: [32m'a'[39m, w: [32m'b'[39m } ] {}
09.826 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
09.826 : INFO :  Edge data {} C1
09.826 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
09.826 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
09.826 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
09.826 : DEBUG :  Removing node a
09.826 : INFO :  cp  b  to  C1  with parent  C1
09.826 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
09.826 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.826 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
09.826 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
09.826 : INFO :  Edge data {} C1
09.826 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
09.826 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
09.826 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
09.826 : DEBUG :  Removing node b
09.826 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.826 : DEBUG :  Extracting node C2 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.826 : INFO :  cp  c  to  C2  with parent  C2
09.826 : INFO :  In copy  C2 root C2 data [90mundefined[39m C2
09.826 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.826 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
09.826 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
09.826 : INFO :  Edge data {} C2
09.826 : INFO :  Descendants of  C2  is  [ [32m'c'[39m ]
09.826 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
09.826 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
09.826 : DEBUG :  Removing node c
09.826 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'C1'[39m, value: [36m[Object][39m }, { v: [32m'C2'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.826 : DEBUG :  Done, no node has children [ [32m'a'[39m, [32m'b'[39m ]
09.826 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
09.826 : INFO :  [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]

stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
09.826 : WARN :  Cluster identified C1  Replacement id in edges:  a
09.826 : WARN :  Cluster identified C2  Replacement id in edges:  c
09.826 : WARN :  Edge a -> b: {"v":"a","w":"b"}
09.826 : WARN :  Edge a -> b: {}
09.826 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: a b Translating:  [90mundefined[39m  ---  [90mundefined[39m
09.826 : WARN :  Edge C1 -> C2: {"v":"C1","w":"C2"}
09.826 : WARN :  Edge C1 -> C2: {}
09.826 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: C1 C2 Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'c'[39m, clusterData: [90mundefined[39m }
09.826 : WARN :  Fixing and trying - removing XXX C1 C2 [90mundefined[39m
09.826 : WARN :  Fix Replacing with XXX C1 C2 [90mundefined[39m
09.826 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.826 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.826 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
09.826 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.826 : WARN :  Copying children of  C1 root C1 data [90mundefined[39m C1
09.826 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m, [32m'b'[39m ]
09.826 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: {} }, { v: [32m'b'[39m, value: {} } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.826 : WARN :  Cluster without external connections, without a parent and with children C2 [33m0[39m
09.826 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.826 : WARN :  Copying children of  C2 root C2 data [90mundefined[39m C2
09.826 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'c'[39m ]
09.826 : WARN :  New graph after copy node: ( C2 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: {} } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.826 : WARN :  New list of nodes [ [32m'C1'[39m, [32m'C2'[39m ]
09.826 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: {}, b: {} },
    _parent: { a: [32m'\x00'[39m, b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {}, b: {} },
    _in: { a: {}, b: [36m[Object][39m },
    _preds: { a: {}, b: [36m[Object][39m },
    _out: { a: [36m[Object][39m, b: {} },
    _sucs: { a: [36m[Object][39m, b: {} },
    _edgeObjs: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'a\x01b\x01\x00'[39m: {} },
    _nodeCount: [33m2[39m,
    _edgeCount: [33m1[39m
  }
}
09.826 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: {} }, { v: [32m'b'[39m, value: {} } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.826 : WARN :   Now next level C2 {
  clusterNode: [33mtrue[39m,
  id: [32m'C2'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: {} },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
09.826 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: {} } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
09.845 : DEBUG :  Opting in, graph
09.845 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
09.845 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
09.845 : DEBUG :  Not a cluster  c Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
09.845 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
09.845 : DEBUG :  Cluster identified C2 Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
09.845 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
09.845 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
09.845 : DEBUG :  Not a cluster a [33m0[39m
09.845 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
09.845 : DEBUG :  Not a cluster b [33m0[39m
09.845 : DEBUG :  Extracting node c Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
09.845 : DEBUG :  Not a cluster c [33m0[39m
09.845 : DEBUG :  Extracting node C1 Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
09.845 : INFO :  cp  b  to  C1  with parent  C1
09.845 : INFO :  In copy  C1 root C1 data { data: [33m4[39m } C1
09.845 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.845 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m } ]
09.845 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m }
09.845 : INFO :  Edge data { name: [32m'C1-internal-link'[39m } C1
09.845 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
09.845 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m }
09.845 : INFO :  Copying as  a b { name: [32m'C1-internal-link'[39m } [90mundefined[39m
09.845 : INFO :  newGraph edges  [ { v: [32m'a'[39m, w: [32m'b'[39m } ] { name: [32m'C1-internal-link'[39m }
09.845 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
09.845 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
09.845 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
09.845 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
09.845 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
09.845 : DEBUG :  Removing node b
09.845 : INFO :  cp  a  to  C1  with parent  C2
09.845 : DEBUG :  Setting parent a C2
09.845 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'c'[39m } ]
09.845 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
09.845 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
09.845 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
09.845 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
09.845 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
09.845 : DEBUG :  Removing node a
09.845 : INFO :  cp  C2  to  C1  with parent  C2
09.845 : INFO :  In copy  C2 root C1 data { data: [33m5[39m } C1
09.845 : DEBUG :  Not Setting parent for node= C2 cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
09.845 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'c'[39m } ]
09.845 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
09.845 : WARN :  Cluster identified C1  Replacement id in edges:  b
09.845 : WARN :  Cluster identified C2  Replacement id in edges:  a
09.845 : WARN :  Edge:  { v: [32m'a'[39m, w: [32m'b'[39m }  leaves cluster  C2
09.845 : WARN :  Descendants of XXX  C2 :  [ [32m'a'[39m ]
09.845 : WARN :  Edge a -> b: {"v":"a","w":"b"}
09.845 : WARN :  Edge a -> b: {"name":"C1-internal-link"}
09.845 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} ids: a b Translating:  [90mundefined[39m  ---  [90mundefined[39m
09.845 : WARN :  Edge C1 -> c: {"v":"C1","w":"c"}
09.845 : WARN :  Edge C1 -> c: {"name":"C1-external-link"}
09.845 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} ids: C1 c Translating:  { id: [32m'b'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
09.845 : WARN :  Fixing and trying - removing XXX C1 c [90mundefined[39m
09.845 : WARN :  Fix Replacing with XXX C1 c [90mundefined[39m
09.845 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
09.845 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
09.845 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
    { v: [32m'c'[39m, value: [36m[Object][39m },
09.845 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
    { v: [32m'C1'[39m, value: [36m[Object][39m },
09.845 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
09.845 : DEBUG :  Removing node C2
  ],
09.845 : DEBUG :  Removing node C2
  edges: [
09.845 : DEBUG :  Old graph after copy {
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m }, { v: [32m'C1'[39m, value: [36m[Object][39m } ],
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.845 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.845 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
09.845 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
}
    { v: [32m'c'[39m, value: [36m[Object][39m },
09.845 : DEBUG :  Extracting node C2 Map(2) {
    { v: [32m'C1'[39m, value: [36m[Object][39m },
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
  ],
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  edges: [
09.845 : DEBUG :  Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
}
09.845 : DEBUG :  Nodes =  [ [32m'b'[39m, [32m'a'[39m, [32m'C2'[39m ] [33m1[39m
09.845 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m1[39m
09.845 : DEBUG :  Not a cluster b [33m1[39m
09.845 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m1[39m
09.845 : DEBUG :  Not a cluster a [33m1[39m
09.845 : DEBUG :  Extracting node C2 Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m5[39m } [90mundefined[39m  Depth  [33m1[39m
09.845 : DEBUG :  Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
}
09.845 : INFO :  [ [32m'c'[39m, [32m'C1'[39m ]

    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.845 : WARN :  Copying children of  C1 root C1 data { data: [33m4[39m } C1
09.845 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'b'[39m, [32m'C2'[39m ]
09.845 : WARN :  Copying children of  C2 root C1 data { data: [33m5[39m } C1
09.845 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'a'[39m, [32m'C2'[39m ]
09.845 : WARN :  Setting parent a C2
09.845 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.845 : WARN :  Cluster **  C2  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
09.845 : WARN :  New list of nodes [ [32m'c'[39m, [32m'C1'[39m ]
09.845 : WARN :   Now next level c { data: [33m3[39m }
09.845 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m4[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m, a: [36m[Object][39m, C2: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m, a: [32m'C2'[39m, C2: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {}, a: {}, C2: [36m[Object][39m },
    _in: { b: [36m[Object][39m, a: {}, C2: {} },
    _preds: { b: [36m[Object][39m, a: {}, C2: {} },
    _out: { b: {}, a: [36m[Object][39m, C2: {} },
    _sucs: { b: {}, a: [36m[Object][39m, C2: {} },
    _edgeObjs: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _nodeCount: [33m3[39m,
    _edgeCount: [33m1[39m
  }
}
09.845 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.845 : WARN :  Cluster **  C2  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [33mtrue[39m [90mundefined[39m [33m1[39m
09.845 : WARN :  New list of nodes [ [32m'b'[39m, [32m'a'[39m, [32m'C2'[39m ]
09.845 : WARN :   Now next level b { data: [33m2[39m }
09.845 : WARN :   Now next level a { data: [33m1[39m }
09.845 : WARN :   Now next level C2 { data: [33m5[39m }

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
09.849 : INFO :  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m, [32m'C2'[39m ]
09.849 : DEBUG :  Opting in, graph
09.849 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
09.849 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
09.849 : DEBUG :  Cluster identified C1 { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
09.849 : DEBUG :  Cluster identified C2 { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
09.849 : WARN :  Cluster identified C1  Replacement id in edges:  a
09.849 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
09.849 : DEBUG :  Extracting node a {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
09.849 : WARN :  Cluster identified C2  Replacement id in edges:  b
09.849 : WARN :  Edge C1 -> C2: {"v":"C1","w":"C2"}
09.849 : WARN :  Edge C1 -> C2: {"name":"C1-external-link"}
09.849 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 C2 Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'b'[39m, clusterData: [90mundefined[39m }
09.849 : WARN :  Fixing and trixing - removing XXX C1 C2 [90mundefined[39m
09.849 : WARN :  Fix Replacing with XXX C1 C2 [90mundefined[39m
09.849 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
09.849 : DEBUG :  Not a cluster a [33m0[39m
    { v: [32m'C1'[39m },
09.849 : DEBUG :  Extracting node b {
    { v: [32m'C2'[39m }
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  ],
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
} [90mundefined[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
09.849 : DEBUG :  Not a cluster b [33m0[39m
}
09.849 : DEBUG :  Extracting node C1 {
09.849 : WARN :  extractor -  [33m0[39m {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
  nodes: [
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.849 : INFO :  cp  a  to  C1  with parent  C1
09.849 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
09.849 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
09.849 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
    { v: [32m'C1'[39m },
09.849 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
    { v: [32m'C2'[39m }
09.849 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
  ],
09.849 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
09.849 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
09.849 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
} [90mundefined[39m
09.849 : DEBUG :  Removing node a
09.849 : DEBUG :  Old graph after copy {
09.849 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
09.849 : WARN :  Old graph before copy {
  nodes: [
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
  nodes: [
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
    { v: [32m'C2'[39m }
  ],
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
}
09.849 : DEBUG :  Extracting node C2 {
09.849 : WARN :  Copying children of  C1 root C1 data [90mundefined[39m C1
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
09.849 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
09.849 : WARN :  New graph after copy node: ( C1 ) {
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
09.849 : INFO :  cp  b  to  C2  with parent  C2
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
09.849 : INFO :  In copy  C2 root C2 data [90mundefined[39m C2
  edges: [],
09.849 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
09.849 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
09.849 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
09.849 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C2
}
09.849 : INFO :  Descendants of  C2  is  [ [32m'b'[39m ]
09.849 : WARN :  Cluster without external connections, without a parent and with children C2 [33m0[39m
09.849 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
09.849 : WARN :  Old graph before copy {
09.849 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
09.849 : DEBUG :  Removing node b
  nodes: [
09.849 : DEBUG :  Old graph after copy {
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
  nodes: [ { v: [32m'C1'[39m, value: [36m[Object][39m }, { v: [32m'C2'[39m, value: [36m[Object][39m } ],
    { v: [32m'C2'[39m }
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
}
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
09.849 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
}
09.849 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
09.849 : INFO :  [ [32m'C1'[39m, [32m'C2'[39m ]
09.849 : WARN :  Copying children of  C2 root C2 data [90mundefined[39m C2
09.849 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'b'[39m ]
09.849 : WARN :  New graph after copy node: ( C2 ) {

  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.849 : WARN :  New list of nodes [ [32m'C1'[39m, [32m'C2'[39m ]
09.849 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
09.849 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.849 : WARN :   Now next level C2 {
  clusterNode: [33mtrue[39m,
  id: [32m'C2'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
09.849 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
09.851 : INFO :  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m, [32m'C2'[39m ]
09.851 : DEBUG :  Opting in, graph
09.851 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
09.851 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
09.851 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
09.851 : DEBUG :  Cluster identified C2 Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
09.851 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
09.851 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
09.851 : DEBUG :  Not a cluster a [33m0[39m
09.851 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
09.851 : DEBUG :  Not a cluster b [33m0[39m
09.851 : DEBUG :  Extracting node C1 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.851 : INFO :  cp  a  to  C1  with parent  C1
09.851 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
09.851 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.851 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
09.851 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
09.851 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
09.851 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
09.851 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
09.851 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
09.851 : DEBUG :  Removing node a
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
09.851 : WARN :  Cluster identified C1  Replacement id in edges:  a
09.851 : WARN :  Cluster identified C2  Replacement id in edges:  b
09.851 : WARN :  Edge C1 -> C2: {"v":"C1","w":"C2"}
09.851 : WARN :  Edge C1 -> C2: {"name":"C1-external-link"}
09.851 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 C2 Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'b'[39m, clusterData: [90mundefined[39m }
09.851 : WARN :  Fixing and trying - removing XXX C1 C2 [90mundefined[39m
09.851 : WARN :  Fix Replacing with XXX C1 C2 [90mundefined[39m
09.851 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
09.851 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.851 : DEBUG :  Extracting node C2 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.851 : INFO :  cp  b  to  C2  with parent  C2
09.851 : INFO :  In copy  C2 root C2 data [90mundefined[39m C2
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.851 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
09.851 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.851 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
09.851 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
09.851 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C2
09.851 : INFO :  Descendants of  C2  is  [ [32m'b'[39m ]
09.851 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
09.851 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
09.851 : DEBUG :  Removing node b
09.851 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'C1'[39m, value: [36m[Object][39m }, { v: [32m'C2'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.851 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
09.851 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
09.851 : INFO :  [ [32m'C1'[39m, [32m'C2'[39m ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
09.857 : DEBUG :  Opting in, graph
    { v: [32m'C1'[39m },
09.857 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
    { v: [32m'C2'[39m }
09.857 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
  ],
09.857 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
09.857 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m ] [33m0[39m
09.857 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
09.857 : DEBUG :  Not a cluster a [33m0[39m
09.857 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
09.857 : DEBUG :  Not a cluster b [33m0[39m
09.857 : DEBUG :  Extracting node C1 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
09.857 : INFO :  cp  a  to  C1  with parent  C1
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.851 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
09.851 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.857 : INFO :  In copy  C1 root C1 data { data: [33m3[39m } C1
09.851 : WARN :  Copying children of  C1 root C1 data [90mundefined[39m C1
09.851 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
09.851 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
09.857 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  edges: [],
09.857 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
09.857 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
}
09.857 : INFO :  Edge data { data: [32m'link1'[39m } C1
09.851 : WARN :  Cluster without external connections, without a parent and with children C2 [33m0[39m
09.857 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
09.851 : WARN :  Old graph before copy {
09.857 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
09.857 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
09.857 : DEBUG :  Removing node a
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.851 : WARN :  Copying children of  C2 root C2 data [90mundefined[39m C2
09.851 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'b'[39m ]
09.851 : WARN :  New graph after copy node: ( C2 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.851 : WARN :  New list of nodes [ [32m'C1'[39m, [32m'C2'[39m ]
09.851 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
09.857 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m }, { v: [32m'C1'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.857 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
09.857 : INFO :  [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]

  id: [32m'C1'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
09.851 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.851 : WARN :   Now next level C2 {
  clusterNode: [33mtrue[39m,
  id: [32m'C2'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
09.851 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
09.857 : WARN :  Cluster identified C1  Replacement id in edges:  a
09.857 : WARN :  Edge C1 -> b: {"v":"C1","w":"b","name":"1"}
09.857 : WARN :  Edge C1 -> b: {"data":"link1"}
09.857 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 b Translating:  { id: [32m'a'[39m, clusterData: { data: [33m3[39m } }  ---  [90mundefined[39m
09.857 : WARN :  Fixing and trying - removing XXX C1 b 1
09.857 : WARN :  Fix Replacing with XXX C1 b 1
09.857 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.857 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.857 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
09.857 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.857 : WARN :  Copying children of  C1 root C1 data { data: [33m3[39m } C1
09.857 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
09.857 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.857 : WARN :  New list of nodes [ [32m'b'[39m, [32m'C1'[39m ]
09.857 : WARN :   Now next level b { data: [33m2[39m }
09.857 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m3[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
09.857 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
09.857 : DEBUG :  Opting in, graph
09.857 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
09.857 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
09.857 : DEBUG :  Cluster identified C1 { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
09.857 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m ] [33m0[39m
09.857 : DEBUG :  Extracting node a {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
09.857 : DEBUG :  Not a cluster a [33m0[39m
09.857 : DEBUG :  Extracting node b {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
09.857 : DEBUG :  Not a cluster b [33m0[39m
09.857 : DEBUG :  Extracting node C1 {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
09.857 : INFO :  cp  a  to  C1  with parent  C1
09.857 : INFO :  In copy  C1 root C1 data { data: [33m3[39m } C1
09.857 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
09.857 : WARN :  Cluster identified C1  Replacement id in edges:  a
09.857 : WARN :  Edge C1 -> b: {"v":"C1","w":"b","name":"1"}
09.857 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
09.857 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
09.857 : INFO :  Edge data { data: [32m'link1'[39m } C1
09.857 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
09.857 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
09.857 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
09.857 : DEBUG :  Removing node a
09.857 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m }, { v: [32m'C1'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.857 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
09.857 : INFO :  [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]

09.857 : WARN :  Edge C1 -> b: {"data":"link1"}
09.857 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 b Translating:  { id: [32m'a'[39m, clusterData: { data: [33m3[39m } }  ---  [90mundefined[39m
09.857 : WARN :  Fixing and trixing - removing XXX C1 b 1
09.857 : WARN :  Fix Replacing with XXX C1 b 1
09.857 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.857 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.857 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
09.857 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.857 : WARN :  Copying children of  C1 root C1 data { data: [33m3[39m } C1
09.857 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
09.857 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.857 : WARN :  New list of nodes [ [32m'b'[39m, [32m'C1'[39m ]
09.857 : WARN :   Now next level b { data: [33m2[39m }
09.857 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m3[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
09.857 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
09.864 : INFO :  { data: [33m4[39m }
09.864 : DEBUG :  Opting in, graph
09.864 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
09.864 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
09.864 : DEBUG :  Not a cluster  c { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
09.864 : DEBUG :  Cluster identified C1 { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
09.864 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m ] [33m0[39m
09.864 : DEBUG :  Extracting node a {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
09.864 : DEBUG :  Not a cluster a [33m0[39m
09.864 : DEBUG :  Extracting node b {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
09.864 : DEBUG :  Not a cluster b [33m0[39m
09.864 : DEBUG :  Extracting node c {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
09.864 : DEBUG :  Not a cluster c [33m0[39m
09.864 : DEBUG :  Extracting node C1 {
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
09.864 : WARN :  Cluster identified C1  Replacement id in edges:  a
09.864 : WARN :  Edge C1 -> b: {"v":"C1","w":"b","name":"1"}
09.864 : WARN :  Edge C1 -> b: {"data":"link1"}
09.864 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
09.864 : INFO :  cp  a  to  C1  with parent  C1
09.864 : INFO :  In copy  C1 root C1 data { data: [33m4[39m } C1
09.864 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
09.864 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
09.864 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
} ids: C1 b Translating:  { id: [32m'a'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
09.864 : INFO :  Edge data { data: [32m'link1'[39m } C1
09.864 : WARN :  Fixing and trixing - removing XXX C1 b 1
09.864 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
09.864 : WARN :  Fix Replacing with XXX C1 b 1
09.864 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
09.864 : WARN :  Edge C1 -> c: {"v":"C1","w":"c","name":"2"}
09.864 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
09.864 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
09.864 : INFO :  Edge data { data: [32m'link2'[39m } C1
09.864 : WARN :  Edge C1 -> c: {"data":"link2"}
09.864 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 c Translating:  { id: [32m'a'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
09.864 : WARN :  Fixing and trixing - removing XXX C1 c 2
09.864 : WARN :  Fix Replacing with XXX C1 c 2
09.864 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
09.864 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.864 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
09.864 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
09.864 : WARN :  extractor -  [33m0[39m {
09.864 : DEBUG :  Removing node a
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
09.864 : DEBUG :  Old graph after copy {
  nodes: [
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.864 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
09.864 : INFO :  [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]

    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.864 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
09.864 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.864 : WARN :  Copying children of  C1 root C1 data { data: [33m4[39m } C1
09.864 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
09.863 : INFO :  { data: [33m4[39m }
09.863 : DEBUG :  Opting in, graph
09.863 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
09.863 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
09.863 : DEBUG :  Not a cluster  c Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
09.863 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
09.863 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m ] [33m0[39m
09.863 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
09.864 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.864 : WARN :  New list of nodes [ [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m ]
09.864 : WARN :   Now next level b { data: [33m2[39m }
09.864 : WARN :   Now next level c { data: [33m3[39m }
09.864 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m4[39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
  labelText: [90mundefined[39m,
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
  graph: Graph {
09.863 : DEBUG :  Not a cluster a [33m0[39m
    _isDirected: [33mtrue[39m,
09.863 : DEBUG :  Extracting node b Map(2) {
    _isMultigraph: [33mtrue[39m,
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
    _isCompound: [33mtrue[39m,
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
09.863 : DEBUG :  Not a cluster b [33m0[39m
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
09.863 : DEBUG :  Extracting node c Map(2) {
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
    _nodes: { a: [36m[Object][39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
    _parent: { a: [32m'\x00'[39m },
} [33mfalse[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
09.863 : DEBUG :  Not a cluster c [33m0[39m
    _in: { a: {} },
    _preds: { a: {} },
09.863 : DEBUG :  Extracting node C1 Map(2) {
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
    _edgeLabels: {},
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
    _nodeCount: [33m1[39m
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
  }
09.863 : INFO :  cp  a  to  C1  with parent  C1
}
09.863 : INFO :  In copy  C1 root C1 data { data: [33m4[39m } C1
09.864 : WARN :  extractor -  [33m1[39m {
09.863 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
09.863 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
09.863 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
  edges: [],
09.863 : INFO :  Edge data { data: [32m'link1'[39m } C1
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
09.863 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
} [90mundefined[39m
09.863 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }

09.863 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
09.863 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
09.863 : INFO :  Edge data { data: [32m'link2'[39m } C1
09.863 : WARN :  Cluster identified C1  Replacement id in edges:  a
09.863 : WARN :  Edge C1 -> b: {"v":"C1","w":"b","name":"1"}
09.863 : WARN :  Edge C1 -> b: {"data":"link1"}
09.863 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 b Translating:  { id: [32m'a'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
09.863 : WARN :  Fixing and trying - removing XXX C1 b 1
09.863 : WARN :  Fix Replacing with XXX C1 b 1
09.863 : WARN :  Edge C1 -> c: {"v":"C1","w":"c","name":"2"}
09.863 : WARN :  Edge C1 -> c: {"data":"link2"}
09.863 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
09.863 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
} ids: C1 c Translating:  { id: [32m'a'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
09.863 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
09.863 : WARN :  Fixing and trying - removing XXX C1 c 2
09.863 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
09.863 : WARN :  Fix Replacing with XXX C1 c 2
09.863 : DEBUG :  Removing node a
09.863 : WARN :  Adjusted Graph {
09.863 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.863 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
    { v: [32m'c'[39m, value: [36m[Object][39m },
  ],
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  edges: [
  ],
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
  edges: [
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.863 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
09.863 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.863 : WARN :  Copying children of  C1 root C1 data { data: [33m4[39m } C1
09.863 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
09.863 : WARN :  New graph after copy node: ( C1 ) {
  ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
}
  edges: [],
09.863 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.863 : WARN :  New list of nodes [ [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m ]
09.863 : WARN :   Now next level b { data: [33m2[39m }
09.863 : WARN :   Now next level c { data: [33m3[39m }
09.863 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m4[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
09.863 : INFO :  [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,

    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
09.863 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
09.868 : DEBUG :  Opting in, graph
09.868 : DEBUG :  Not a cluster  a Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
09.868 : DEBUG :  Not a cluster  b Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
09.868 : DEBUG :  Not a cluster  c Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
09.868 : DEBUG :  Cluster identified A Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
09.868 : DEBUG :  Cluster identified B Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
09.868 : DEBUG :  Cluster identified C Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
09.868 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ] [33m0[39m
09.868 : DEBUG :  Extracting node a Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
09.868 : DEBUG :  Not a cluster a [33m0[39m
09.868 : DEBUG :  Extracting node b Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
09.868 : DEBUG :  Not a cluster b [33m0[39m
09.868 : DEBUG :  Extracting node c Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
09.868 : DEBUG :  Not a cluster c [33m0[39m
09.868 : DEBUG :  Extracting node A Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
09.868 : WARN :  Cluster identified A  Replacement id in edges:  a
09.868 : WARN :  Cluster identified B  Replacement id in edges:  b
09.868 : WARN :  Cluster identified C  Replacement id in edges:  c
09.868 : WARN :  Edge A -> B: {"v":"A","w":"B","name":"1"}
09.868 : WARN :  Edge A -> B: {"data":"link1"}
09.868 : WARN :  Fix XXX Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: A B Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'b'[39m, clusterData: [90mundefined[39m }
09.868 : WARN :  Fixing and trying - removing XXX A B 1
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
09.868 : WARN :  Fix Replacing with XXX A B 1
09.868 : WARN :  Edge A -> C: {"v":"A","w":"C","name":"2"}
09.868 : WARN :  Edge A -> C: {"data":"link2"}
09.868 : WARN :  Fix XXX Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: A C Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'c'[39m, clusterData: [90mundefined[39m }
09.868 : WARN :  Fixing and trying - removing XXX A C 2
09.868 : WARN :  Fix Replacing with XXX A C 2
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
09.868 : WARN :  Adjusted Graph {
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
09.868 : INFO :  cp  a  to  A  with parent  A
  nodes: [
09.868 : INFO :  In copy  A root A data [90mundefined[39m A
09.868 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.868 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
09.868 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
09.868 : INFO :  Edge data { data: [32m'link1'[39m } A
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
09.868 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
    { v: [32m'A'[39m },
09.868 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
    { v: [32m'B'[39m },
09.868 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
    { v: [32m'C'[39m }
09.868 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
  ],
09.868 : INFO :  Edge data { data: [32m'link2'[39m } A
  edges: [
09.868 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
09.868 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.868 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
09.868 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
09.868 : DEBUG :  Removing node a
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
09.868 : DEBUG :  Old graph after copy {
  ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  nodes: [
} [90mundefined[39m
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
09.868 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
09.868 : WARN :  Old graph before copy {
    { v: [32m'A'[39m, value: [36m[Object][39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    { v: [32m'B'[39m },
  nodes: [
    { v: [32m'C'[39m }
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
  ],
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.868 : WARN :  Copying children of  A root A data [90mundefined[39m A
09.868 : WARN :  Copying (nodes) clusterId A nodes [ [32m'a'[39m ]
09.868 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  edges: [
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
}
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
09.868 : WARN :  Cluster without external connections, without a parent and with children B [33m0[39m
  ],
09.868 : WARN :  Old graph before copy {
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
}
09.868 : DEBUG :  Extracting node B Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.868 : INFO :  cp  b  to  B  with parent  B
09.868 : INFO :  In copy  B root B data [90mundefined[39m B
09.868 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.868 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
09.868 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
09.868 : INFO :  Edge data { data: [32m'link1'[39m } B
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
09.868 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
09.868 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
    { v: [32m'A'[39m, value: [36m[Object][39m },
09.868 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
    { v: [32m'B'[39m },
09.868 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
    { v: [32m'C'[39m }
09.868 : INFO :  Edge data { data: [32m'link2'[39m } B
  ],
09.868 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
09.868 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.868 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
  edges: [
09.868 : DEBUG :  Removing node b
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
09.868 : DEBUG :  Old graph after copy {
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  ],
  nodes: [
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
}
    { v: [32m'A'[39m, value: [36m[Object][39m },
09.868 : WARN :  Copying children of  B root B data [90mundefined[39m B
    { v: [32m'B'[39m, value: [36m[Object][39m },
09.868 : WARN :  Copying (nodes) clusterId B nodes [ [32m'b'[39m ]
    { v: [32m'C'[39m }
09.868 : WARN :  New graph after copy node: ( B ) {
  ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  edges: [
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
  edges: [],
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  ],
}
09.868 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
09.868 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.868 : WARN :  Copying children of  C root C data [90mundefined[39m C
09.868 : WARN :  Copying (nodes) clusterId C nodes [ [32m'c'[39m ]
09.868 : WARN :  New graph after copy node: ( C ) {
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
}
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
09.868 : DEBUG :  Extracting node C Map(5) {
  edges: [],
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
}
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
09.868 : WARN :  New list of nodes [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ]
09.868 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.868 : INFO :  cp  c  to  C  with parent  C
09.868 : INFO :  In copy  C root C data [90mundefined[39m C
09.868 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.868 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
09.868 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
09.868 : INFO :  Edge data { data: [32m'link1'[39m } C
09.868 : INFO :  Descendants of  C  is  [ [32m'c'[39m ]
09.868 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
09.868 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.868 : WARN :   Now next level B {
  clusterNode: [33mtrue[39m,
  id: [32m'B'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
09.868 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: C
09.868 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.868 : INFO :  Edge data { data: [32m'link2'[39m } C
09.868 : INFO :  Descendants of  C  is  [ [32m'c'[39m ]
09.868 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.868 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: C
09.868 : DEBUG :  Removing node c
09.868 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    _nodeCount: [33m1[39m
    { v: [32m'C'[39m, value: [36m[Object][39m }
  }
  ],
  edges: [
}
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
09.868 : WARN :  extractor -  [33m1[39m {
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  ],
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  edges: [],
}
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
09.868 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
09.868 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
} [90mundefined[39m
09.868 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
09.868 : WARN :   Now next level C {

  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
09.868 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
09.869 : DEBUG :  Opting in, graph
09.869 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
09.869 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
09.869 : DEBUG :  Not a cluster  c { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
09.869 : DEBUG :  Cluster identified A { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
09.869 : DEBUG :  Cluster identified B { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
09.869 : DEBUG :  Cluster identified C { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
09.869 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ] [33m0[39m
09.869 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
09.869 : DEBUG :  Not a cluster a [33m0[39m
09.869 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
09.869 : DEBUG :  Not a cluster b [33m0[39m
09.869 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
09.869 : DEBUG :  Not a cluster c [33m0[39m
09.869 : DEBUG :  Extracting node A {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.869 : INFO :  cp  a  to  A  with parent  A
09.869 : INFO :  In copy  A root A data [90mundefined[39m A
09.869 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.869 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
09.869 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
09.869 : INFO :  Edge data { data: [32m'link1'[39m } A
09.869 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
09.869 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
09.869 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
09.869 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.869 : INFO :  Edge data { data: [32m'link2'[39m } A
09.869 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
09.869 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.869 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
09.869 : DEBUG :  Removing node a
09.869 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.869 : DEBUG :  Extracting node B {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.869 : INFO :  cp  b  to  B  with parent  B
09.869 : INFO :  In copy  B root B data [90mundefined[39m B
09.869 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.869 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
09.869 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
09.869 : INFO :  Edge data { data: [32m'link1'[39m } B
09.869 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
09.869 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
09.869 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
09.869 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.869 : INFO :  Edge data { data: [32m'link2'[39m } B
09.869 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
09.869 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.869 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
09.869 : DEBUG :  Removing node b
09.869 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.869 : DEBUG :  Extracting node C {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.869 : INFO :  cp  c  to  C  with parent  C
09.869 : INFO :  In copy  C root C data [90mundefined[39m C
09.869 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.869 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
09.869 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
09.869 : INFO :  Edge data { data: [32m'link1'[39m } C
09.869 : INFO :  Descendants of  C  is  [ [32m'c'[39m ]
09.869 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
09.869 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: C
09.869 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.869 : INFO :  Edge data { data: [32m'link2'[39m } C
09.869 : INFO :  Descendants of  C  is  [ [32m'c'[39m ]
09.869 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.869 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: C
09.869 : DEBUG :  Removing node c
09.869 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.869 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
09.869 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
09.869 : DEBUG :  Done, no node has children [ [32m'c'[39m ]

stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
09.869 : WARN :  Cluster identified A  Replacement id in edges:  a
09.869 : WARN :  Cluster identified B  Replacement id in edges:  b
09.869 : WARN :  Cluster identified C  Replacement id in edges:  c
09.869 : WARN :  Edge A -> B: {"v":"A","w":"B","name":"1"}
09.869 : WARN :  Edge A -> B: {"data":"link1"}
09.869 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: A B Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'b'[39m, clusterData: [90mundefined[39m }
09.869 : WARN :  Fixing and trixing - removing XXX A B 1
09.869 : WARN :  Fix Replacing with XXX A B 1
09.869 : WARN :  Edge A -> C: {"v":"A","w":"C","name":"2"}
09.869 : WARN :  Edge A -> C: {"data":"link2"}
09.869 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: A C Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'c'[39m, clusterData: [90mundefined[39m }
09.869 : WARN :  Fixing and trixing - removing XXX A C 2
09.869 : WARN :  Fix Replacing with XXX A C 2
09.869 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.869 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.869 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
09.869 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.869 : WARN :  Copying children of  A root A data [90mundefined[39m A
09.869 : WARN :  Copying (nodes) clusterId A nodes [ [32m'a'[39m ]
09.869 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.869 : WARN :  Cluster without external connections, without a parent and with children B [33m0[39m
09.869 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.869 : WARN :  Copying children of  B root B data [90mundefined[39m B
09.869 : WARN :  Copying (nodes) clusterId B nodes [ [32m'b'[39m ]
09.869 : WARN :  New graph after copy node: ( B ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.869 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
09.869 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.869 : WARN :  Copying children of  C root C data [90mundefined[39m C
09.869 : WARN :  Copying (nodes) clusterId C nodes [ [32m'c'[39m ]
09.869 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.869 : WARN :  New list of nodes [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ]
09.869 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
09.869 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.869 : WARN :   Now next level B {
  clusterNode: [33mtrue[39m,
  id: [32m'B'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
09.869 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.869 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
09.869 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
09.877 : DEBUG :  Opting in, graph
09.877 : DEBUG :  Cluster identified C {
  C1: [ [32m'a'[39m ],
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
09.877 : WARN :  Cluster identified C  Replacement id in edges:  d
09.877 : WARN :  Cluster identified D  Replacement id in edges:  d
09.877 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.877 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
09.877 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
09.877 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.877 : WARN :  Copying children of  C root C data { data: [33m1[39m } C
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
09.877 : DEBUG :  Cluster identified D {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
09.877 : DEBUG :  Not a cluster  d {
09.877 : WARN :  Copying (nodes) clusterId C nodes [ [32m'D'[39m ]
09.877 : WARN :  Copying children of  D root C data { data: [33m2[39m } C
09.877 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m, [32m'D'[39m ]
09.877 : WARN :  Setting parent d D
09.877 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
09.877 : DEBUG :  Nodes =  [ [32m'C'[39m, [32m'D'[39m, [32m'd'[39m ] [33m0[39m
09.877 : DEBUG :  Extracting node C {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [ [32m'd'[39m ]  Depth  [33m0[39m
09.877 : INFO :  cp  d  to  C  with parent  D
09.877 : DEBUG :  Setting parent d D
09.877 : DEBUG :  Copying Edges []
09.877 : DEBUG :  Removing node d
09.877 : INFO :  cp  D  to  C  with parent  D
09.877 : INFO :  In copy  D root C data { data: [33m2[39m } C
09.877 : DEBUG :  Not Setting parent for node= D cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
09.877 : DEBUG :  Copying Edges []
09.877 : DEBUG :  Removing node D
09.877 : DEBUG :  Removing node D
09.877 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
09.877 : WARN :  Cluster **  D  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
09.877 : WARN :  New list of nodes [ [32m'C'[39m ]
  nodes: [ { v: [32m'C'[39m, value: [36m[Object][39m } ],
09.877 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: { data: [33m1[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
09.877 : DEBUG :  Extracting node D {
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    _nodes: { d: [36m[Object][39m, D: [36m[Object][39m },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    _parent: { d: [32m'D'[39m, D: [32m'\x00'[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {}, D: [36m[Object][39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
    _in: { d: {}, D: {} },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    _preds: { d: {}, D: {} },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
    _out: { d: {}, D: {} },
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
    _sucs: { d: {}, D: {} },
09.877 : DEBUG :  {
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m2[39m
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  }
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
}
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
09.877 : WARN :  extractor -  [33m1[39m {
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  nodes: [
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
}
    { v: [32m'D'[39m, value: [36m[Object][39m }
09.877 : DEBUG :  Extracting node d {
  ],
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  edges: [],
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
} [ [32m'd'[39m ]
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
09.877 : WARN :  Cluster without external connections, without a parent and with children D [33m1[39m
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
09.877 : WARN :  Old graph before copy {
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.877 : WARN :  Copying children of  D root D data { data: [33m2[39m } D
09.877 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m ]
09.877 : WARN :  New graph after copy node: ( D ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
09.877 : DEBUG :  Not a cluster d [33m0[39m
  edges: [],
09.877 : DEBUG :  Nodes =  [ [32m'd'[39m, [32m'D'[39m ] [33m1[39m
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
09.877 : DEBUG :  Extracting node d {
}
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
09.877 : WARN :  New list of nodes [ [32m'D'[39m ]
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
09.877 : WARN :   Now next level D {
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  clusterNode: [33mtrue[39m,
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  id: [32m'D'[39m,
  clusterData: { data: [33m2[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m },
    _parent: { d: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {} },
    _in: { d: {} },
    _preds: { d: {} },
    _out: { d: {} },
    _sucs: { d: {} },
    _edgeObjs: {},
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mfalse[39m { data: [33m3[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
    _edgeLabels: {},
09.877 : DEBUG :  Not a cluster d [33m1[39m
    _nodeCount: [33m1[39m
09.877 : DEBUG :  Extracting node D {
  }
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
}
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
09.877 : WARN :  extractor -  [33m2[39m {
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
09.877 : INFO :  cp  d  to  D  with parent  D
09.877 : INFO :  In copy  D root D data { data: [33m2[39m } D
09.877 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.877 : DEBUG :  Copying Edges []
09.877 : DEBUG :  Removing node d
09.877 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'D'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.877 : DEBUG :  Done, no node has children [ [32m'd'[39m ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
09.875 : DEBUG :  Opting in, graph
09.875 : DEBUG :  Cluster identified C Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
09.875 : DEBUG :  Cluster identified D Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
09.875 : DEBUG :  Not a cluster  d Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
09.875 : DEBUG :  Nodes =  [ [32m'C'[39m, [32m'D'[39m, [32m'd'[39m ] [33m0[39m
09.875 : DEBUG :  Extracting node C Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [ [32m'd'[39m ]  Depth  [33m0[39m
09.875 : INFO :  cp  d  to  C  with parent  D
09.875 : DEBUG :  Setting parent d D
09.875 : DEBUG :  Copying Edges []
09.875 : DEBUG :  Removing node d
09.875 : INFO :  cp  D  to  C  with parent  D
09.875 : INFO :  In copy  D root C data { data: [33m2[39m } C
09.875 : DEBUG :  Not Setting parent for node= D cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
09.875 : WARN :  Cluster identified C  Replacement id in edges:  d
09.875 : WARN :  Cluster identified D  Replacement id in edges:  d
09.875 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.875 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
09.875 : DEBUG :  Copying Edges []
    { v: [32m'C'[39m, value: [36m[Object][39m },
09.875 : DEBUG :  Removing node D
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
09.875 : DEBUG :  Removing node D
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
09.875 : DEBUG :  Old graph after copy {
  ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  edges: [],
  nodes: [ { v: [32m'C'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
  edges: [],
09.875 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
09.875 : WARN :  Old graph before copy {
}
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
09.875 : DEBUG :  Extracting node D Map(6) {
  nodes: [
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'C'[39m, value: [36m[Object][39m },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  ],
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  edges: [],
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
}
09.875 : DEBUG :  Map(6) {
09.875 : WARN :  Copying children of  C root C data { data: [33m1[39m } C
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
}
09.875 : DEBUG :  Extracting node d Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.875 : DEBUG :  Not a cluster d [33m0[39m
09.875 : DEBUG :  Nodes =  [ [32m'd'[39m, [32m'D'[39m ] [33m1[39m
09.875 : WARN :  Copying (nodes) clusterId C nodes [ [32m'D'[39m ]
09.875 : DEBUG :  Extracting node d Map(6) {
09.875 : WARN :  Copying children of  D root C data { data: [33m2[39m } C
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
09.875 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m, [32m'D'[39m ]
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
09.875 : WARN :  Setting parent d D
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
09.875 : WARN :  New graph after copy node: ( C ) {
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mfalse[39m { data: [33m3[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
09.875 : DEBUG :  Not a cluster d [33m1[39m
09.875 : DEBUG :  Extracting node D Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
09.875 : INFO :  cp  d  to  D  with parent  D
09.875 : INFO :  In copy  D root D data { data: [33m2[39m } D
09.875 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.875 : DEBUG :  Copying Edges []
09.875 : DEBUG :  Removing node d
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.875 : WARN :  Cluster **  D  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
09.875 : WARN :  New list of nodes [ [32m'C'[39m ]
09.875 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: { data: [33m1[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
09.875 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'D'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.875 : DEBUG :  Done, no node has children [ [32m'd'[39m ]

    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m, D: [36m[Object][39m },
    _parent: { d: [32m'D'[39m, D: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {}, D: [36m[Object][39m },
    _in: { d: {}, D: {} },
    _preds: { d: {}, D: {} },
    _out: { d: {}, D: {} },
    _sucs: { d: {}, D: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m2[39m
  }
}
09.875 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
09.875 : WARN :  Cluster without external connections, without a parent and with children D [33m1[39m
09.875 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.875 : WARN :  Copying children of  D root D data { data: [33m2[39m } D
09.875 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m ]
09.875 : WARN :  New graph after copy node: ( D ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.875 : WARN :  New list of nodes [ [32m'D'[39m ]
09.875 : WARN :   Now next level D {
  clusterNode: [33mtrue[39m,
  id: [32m'D'[39m,
  clusterData: { data: [33m2[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m },
    _parent: { d: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {} },
    _in: { d: {} },
    _preds: { d: {} },
    _out: { d: {} },
    _sucs: { d: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
09.875 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
09.883 : INFO :  Graph before { data: [33m2[39m }
09.883 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.883 : DEBUG :  Opting in, graph
09.883 : DEBUG :  Cluster identified C Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
09.883 : DEBUG :  Cluster identified D Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
09.883 : DEBUG :  Not a cluster  d Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
09.883 : DEBUG :  Cluster identified B Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
09.883 : DEBUG :  Not a cluster  b Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
09.883 : DEBUG :  Cluster identified A Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
09.883 : DEBUG :  Not a cluster  a Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
09.883 : DEBUG :  Nodes =  [
  [32m'C'[39m, [32m'D'[39m, [32m'd'[39m,
  [32m'B'[39m, [32m'b'[39m, [32m'A'[39m,
  [32m'a'[39m
] [33m0[39m
09.883 : DEBUG :  Extracting node C Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [ [32m'd'[39m ]  Depth  [33m0[39m
09.883 : INFO :  cp  d  to  C  with parent  D
09.883 : DEBUG :  Setting parent d D
09.883 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
09.883 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
09.883 : INFO :  Edge data { data: [32m'link1'[39m } C
09.883 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
09.883 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
09.883 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
09.883 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.883 : INFO :  Edge data { data: [32m'link2'[39m } C
09.883 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
09.883 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.883 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
09.883 : DEBUG :  Removing node d
09.883 : INFO :  cp  D  to  C  with parent  D
09.883 : INFO :  In copy  D root C data { data: [33m2[39m } C
09.883 : DEBUG :  Not Setting parent for node= D cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
09.883 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
09.883 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
09.883 : INFO :  Edge data { data: [32m'link1'[39m } C
09.883 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
09.883 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
09.883 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
09.883 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.883 : INFO :  Edge data { data: [32m'link2'[39m } C
09.883 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
09.883 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.883 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
09.883 : DEBUG :  Removing node D
09.883 : DEBUG :  Removing node D
09.883 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.883 : DEBUG :  Extracting node D Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
09.883 : WARN :  Cluster identified C  Replacement id in edges:  d
09.883 : WARN :  Cluster identified D  Replacement id in edges:  d
09.883 : WARN :  Cluster identified B  Replacement id in edges:  b
09.883 : WARN :  Cluster identified A  Replacement id in edges:  a
09.883 : WARN :  Edge A -> B: {"v":"A","w":"B","name":"1"}
09.883 : WARN :  Edge A -> B: {"data":"link1"}
09.883 : WARN :  Fix XXX Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} ids: A B Translating:  { id: [32m'a'[39m, clusterData: { data: [33m6[39m } }  ---  { id: [32m'b'[39m, clusterData: { data: [33m4[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.883 : DEBUG :  Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
}
09.883 : DEBUG :  Extracting node d Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
09.883 : WARN :  Fixing and trying - removing XXX A B 1
09.883 : WARN :  Fix Replacing with XXX A B 1
09.883 : WARN :  Edge A -> C: {"v":"A","w":"C","name":"2"}
09.883 : WARN :  Edge A -> C: {"data":"link2"}
09.883 : WARN :  Fix XXX Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} ids: A C Translating:  { id: [32m'a'[39m, clusterData: { data: [33m6[39m } }  ---  { id: [32m'D'[39m, clusterData: { data: [33m1[39m } }
09.883 : WARN :  Fixing and trying - removing XXX A C 2
09.883 : WARN :  Fix Replacing with XXX A C 2
09.883 : WARN :  Adjusted Graph {
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.883 : DEBUG :  Not a cluster d [33m0[39m
09.883 : DEBUG :  Extracting node B Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
09.883 : INFO :  cp  b  to  B  with parent  B
09.883 : INFO :  In copy  B root B data { data: [33m4[39m } B
09.883 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.883 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
09.883 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
  nodes: [
09.883 : INFO :  Edge data { data: [32m'link1'[39m } B
09.883 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
09.883 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
09.883 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
09.883 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.883 : INFO :  Edge data { data: [32m'link2'[39m } B
09.883 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
09.883 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.883 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
09.883 : DEBUG :  Removing node b
09.883 : DEBUG :  Old graph after copy {
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.883 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
    { v: [32m'B'[39m, value: [36m[Object][39m },
  ],
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
  edges: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.883 : DEBUG :  Extracting node b Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.883 : DEBUG :  Not a cluster b [33m0[39m
09.883 : DEBUG :  Extracting node A Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m6[39m } [90mundefined[39m  Depth  [33m0[39m
09.883 : INFO :  cp  a  to  A  with parent  A
  ],
09.883 : INFO :  In copy  A root A data { data: [33m6[39m } A
  edges: [
09.883 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
09.883 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
09.883 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
09.883 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
  ],
09.883 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
  edges: [
09.883 : INFO :  Edge data { data: [32m'link1'[39m } A
09.883 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
09.883 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.883 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
09.883 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.883 : INFO :  Edge data { data: [32m'link2'[39m } A
09.883 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
09.883 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.883 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
09.883 : DEBUG :  Removing node a
09.883 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
09.883 : WARN :  Copying children of  C root C data { data: [33m1[39m } C
09.883 : WARN :  Copying (nodes) clusterId C nodes [ [32m'D'[39m ]
09.883 : WARN :  Copying children of  D root C data { data: [33m2[39m } C
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.883 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m, [32m'D'[39m ]
09.883 : WARN :  Setting parent d D
09.883 : WARN :  New graph after copy node: ( C ) {
09.883 : DEBUG :  Extracting node a Map(6) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  nodes: [
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  ],
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  edges: [],
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
}
09.883 : DEBUG :  Not a cluster a [33m0[39m
09.883 : WARN :  Cluster **  D  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
09.883 : DEBUG :  Nodes =  [ [32m'd'[39m, [32m'D'[39m ] [33m1[39m
09.883 : DEBUG :  Extracting node d Map(6) {
09.883 : WARN :  Cluster without external connections, without a parent and with children B [33m0[39m
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
09.883 : WARN :  Old graph before copy {
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  nodes: [
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    { v: [32m'C'[39m, value: [36m[Object][39m },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
    { v: [32m'B'[39m, value: [36m[Object][39m },
} [33mfalse[39m [33mfalse[39m { data: [33m3[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
09.883 : DEBUG :  Not a cluster d [33m1[39m
    { v: [32m'A'[39m, value: [36m[Object][39m },
09.883 : DEBUG :  Extracting node D Map(6) {
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  ],
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  edges: [
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  ],
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
}
09.883 : WARN :  Copying children of  B root B data { data: [33m4[39m } B
09.883 : WARN :  Copying (nodes) clusterId B nodes [ [32m'b'[39m ]
09.883 : WARN :  New graph after copy node: ( B ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.883 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
09.883 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
09.883 : INFO :  cp  d  to  D  with parent  D
09.883 : INFO :  In copy  D root D data { data: [33m2[39m } D
    { v: [32m'C'[39m, value: [36m[Object][39m },
09.883 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    { v: [32m'B'[39m, value: [36m[Object][39m },
09.883 : DEBUG :  Copying Edges []
    { v: [32m'A'[39m, value: [36m[Object][39m },
09.883 : DEBUG :  Removing node d
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
09.883 : DEBUG :  Old graph after copy {
  ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  edges: [
  nodes: [ { v: [32m'D'[39m, value: [36m[Object][39m } ],
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
  edges: [],
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.883 : WARN :  Copying children of  A root A data { data: [33m6[39m } A
09.883 : WARN :  Copying (nodes) clusterId A nodes [ [32m'a'[39m ]
09.883 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.883 : WARN :  New list of nodes [ [32m'C'[39m, [32m'B'[39m, [32m'A'[39m ]
09.883 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: { data: [33m1[39m },
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.883 : DEBUG :  Done, no node has children [ [32m'd'[39m ]
09.883 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
09.883 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
09.883 : INFO :  A [ [32m'a'[39m ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
09.883 : INFO :  Graph before { data: [33m2[39m }
09.883 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.883 : DEBUG :  Opting in, graph
09.883 : DEBUG :  Cluster identified C {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
09.883 : DEBUG :  Cluster identified D {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m, D: [36m[Object][39m },
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
    _parent: { d: [32m'D'[39m, D: [32m'\x00'[39m },
  D: [ [32m'd'[39m ]
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {}, D: [36m[Object][39m },
}
    _in: { d: {}, D: {} },
09.883 : DEBUG :  Not a cluster  d {
    _preds: { d: {}, D: {} },
  C1: [ [32m'a'[39m ],
    _out: { d: {}, D: {} },
  C2: [ [32m'b'[39m ],
    _sucs: { d: {}, D: {} },
  A: [ [32m'a'[39m ],
    _edgeObjs: {},
  B: [ [32m'b'[39m ],
    _edgeLabels: {},
  C: [ [32m'D'[39m, [32m'd'[39m ],
    _nodeCount: [33m2[39m
  D: [ [32m'd'[39m ]
  }
}
}
09.883 : DEBUG :  Cluster identified B {
09.883 : WARN :  extractor -  [33m1[39m {
  C1: [ [32m'a'[39m ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  C2: [ [32m'b'[39m ],
  nodes: [
  A: [ [32m'a'[39m ],
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
  B: [ [32m'b'[39m ],
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
09.883 : WARN :  Cluster without external connections, without a parent and with children D [33m1[39m
09.883 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.883 : WARN :  Copying children of  D root D data { data: [33m2[39m } D
09.883 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m ]
09.883 : WARN :  New graph after copy node: ( D ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.883 : WARN :  New list of nodes [ [32m'D'[39m ]
09.883 : WARN :   Now next level D {
  clusterNode: [33mtrue[39m,
  id: [32m'D'[39m,
  clusterData: { data: [33m2[39m },
  label: [90mundefined[39m,
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
09.883 : DEBUG :  Not a cluster  b {
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m },
    _parent: { d: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {} },
    _in: { d: {} },
    _preds: { d: {} },
    _out: { d: {} },
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
    _sucs: { d: {} },
  A: [ [32m'a'[39m ],
    _edgeObjs: {},
  B: [ [32m'b'[39m ],
    _edgeLabels: {},
  C: [ [32m'D'[39m, [32m'd'[39m ],
    _nodeCount: [33m1[39m
  }
}
09.883 : WARN :  extractor -  [33m2[39m {
  D: [ [32m'd'[39m ]
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.883 : WARN :   Now next level B {
  clusterNode: [33mtrue[39m,
  id: [32m'B'[39m,
  clusterData: { data: [33m4[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
}
09.883 : DEBUG :  Cluster identified A {
  C1: [ [32m'a'[39m ],
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
09.883 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.883 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: { data: [33m6[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
09.883 : DEBUG :  Not a cluster  a {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
09.883 : DEBUG :  Nodes =  [
  [32m'C'[39m, [32m'D'[39m, [32m'd'[39m,
  [32m'B'[39m, [32m'b'[39m, [32m'A'[39m,
  [32m'a'[39m
] [33m0[39m
09.883 : DEBUG :  Extracting node C {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    _in: { a: {} },
    _preds: { a: {} },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [ [32m'd'[39m ]  Depth  [33m0[39m
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
09.883 : INFO :  cp  d  to  C  with parent  D
}
09.883 : DEBUG :  Setting parent d D
09.883 : WARN :  extractor -  [33m1[39m {
09.883 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
09.883 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
09.883 : INFO :  Edge data { data: [32m'link1'[39m } C
09.883 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
09.883 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
09.883 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
09.883 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.883 : INFO :  Edge data { data: [32m'link2'[39m } C
09.883 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
09.883 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.883 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
09.883 : DEBUG :  Removing node d
09.883 : INFO :  cp  D  to  C  with parent  D
09.883 : INFO :  In copy  D root C data { data: [33m2[39m } C
09.883 : DEBUG :  Not Setting parent for node= D cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
09.883 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
09.883 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
09.883 : INFO :  Edge data { data: [32m'link1'[39m } C
09.883 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
09.883 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
09.883 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
09.883 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.883 : INFO :  Edge data { data: [32m'link2'[39m } C
09.883 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
09.883 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.883 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
09.883 : DEBUG :  Removing node D
09.883 : DEBUG :  Removing node D
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
09.883 : WARN :  Cluster identified C  Replacement id in edges:  d
09.883 : WARN :  Cluster identified D  Replacement id in edges:  d
09.883 : WARN :  Cluster identified B  Replacement id in edges:  b
09.883 : WARN :  Cluster identified A  Replacement id in edges:  a
09.883 : WARN :  Edge A -> B: {"v":"A","w":"B","name":"1"}
09.883 : WARN :  Edge A -> B: {"data":"link1"}
09.883 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} ids: A B Translating:  { id: [32m'a'[39m, clusterData: { data: [33m6[39m } }  ---  { id: [32m'b'[39m, clusterData: { data: [33m4[39m } }
09.883 : DEBUG :  Old graph after copy {
09.883 : WARN :  Fixing and trixing - removing XXX A B 1
09.883 : WARN :  Fix Replacing with XXX A B 1
09.883 : WARN :  Edge A -> C: {"v":"A","w":"C","name":"2"}
09.883 : WARN :  Edge A -> C: {"data":"link2"}
09.883 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} ids: A C Translating:  { id: [32m'a'[39m, clusterData: { data: [33m6[39m } }  ---  { id: [32m'D'[39m, clusterData: { data: [33m1[39m } }
09.883 : WARN :  Fixing and trixing - removing XXX A C 2
09.883 : WARN :  Fix Replacing with XXX A C 2
09.883 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.883 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
09.883 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
09.883 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.883 : WARN :  Copying children of  C root C data { data: [33m1[39m } C
09.883 : WARN :  Copying (nodes) clusterId C nodes [ [32m'D'[39m ]
09.883 : WARN :  Copying children of  D root C data { data: [33m2[39m } C
    { v: [32m'C'[39m, value: [36m[Object][39m },
09.883 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m, [32m'D'[39m ]
    { v: [32m'B'[39m, value: [36m[Object][39m },
09.883 : WARN :  Setting parent d D
09.883 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.883 : WARN :  Cluster **  D  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
09.883 : WARN :  Cluster without external connections, without a parent and with children B [33m0[39m
09.883 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
  edges: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.883 : WARN :  Copying children of  B root B data { data: [33m4[39m } B
09.883 : WARN :  Copying (nodes) clusterId B nodes [ [32m'b'[39m ]
09.883 : WARN :  New graph after copy node: ( B ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.883 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
09.883 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.883 : WARN :  Copying children of  A root A data { data: [33m6[39m } A
09.883 : WARN :  Copying (nodes) clusterId A nodes [ [32m'a'[39m ]
09.883 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.883 : WARN :  New list of nodes [ [32m'C'[39m, [32m'B'[39m, [32m'A'[39m ]
09.883 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: { data: [33m1[39m },
  labelText: [90mundefined[39m,
  ],
  graph: Graph {
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    _isDirected: [33mtrue[39m,
}
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m, D: [36m[Object][39m },
    _parent: { d: [32m'D'[39m, D: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {}, D: [36m[Object][39m },
    _in: { d: {}, D: {} },
    _preds: { d: {}, D: {} },
    _out: { d: {}, D: {} },
    _sucs: { d: {}, D: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m2[39m
  }
}
09.883 : DEBUG :  Extracting node D {
09.883 : WARN :  extractor -  [33m1[39m {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  nodes: [
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  ],
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
  edges: [],
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
09.883 : DEBUG :  {
} [ [32m'd'[39m ]
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
09.883 : WARN :  Cluster without external connections, without a parent and with children D [33m1[39m
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
09.883 : WARN :  Old graph before copy {
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
}
  nodes: [
09.883 : DEBUG :  Extracting node d {
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  edges: [],
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
}
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
09.883 : WARN :  Copying children of  D root D data { data: [33m2[39m } D
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
09.883 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m ]
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
09.883 : WARN :  New graph after copy node: ( D ) {
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
09.883 : DEBUG :  Not a cluster d [33m0[39m
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
09.883 : DEBUG :  Extracting node B {
  edges: [],
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
09.883 : INFO :  cp  b  to  B  with parent  B
09.883 : INFO :  In copy  B root B data { data: [33m4[39m } B
09.883 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.883 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
09.883 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
09.883 : INFO :  Edge data { data: [32m'link1'[39m } B
09.883 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
09.883 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
09.883 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
09.883 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.883 : INFO :  Edge data { data: [32m'link2'[39m } B
09.883 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
09.883 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
09.883 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
09.883 : DEBUG :  Removing node b
09.883 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
}
    { v: [32m'B'[39m, value: [36m[Object][39m },
09.883 : WARN :  New list of nodes [ [32m'D'[39m ]
    { v: [32m'A'[39m, value: [36m[Object][39m },
09.883 : WARN :   Now next level D {
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  clusterNode: [33mtrue[39m,
  ],
  id: [32m'D'[39m,
  edges: [
  clusterData: { data: [33m2[39m },
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
  labelText: [90mundefined[39m,
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  graph: Graph {
  ],
    _isDirected: [33mtrue[39m,
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    _isMultigraph: [33mtrue[39m,
}
    _isCompound: [33mtrue[39m,
09.883 : DEBUG :  Extracting node b {
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    _nodes: { d: [36m[Object][39m },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    _parent: { d: [32m'\x00'[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {} },
    _in: { d: {} },
    _preds: { d: {} },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
    _out: { d: {} },
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
    _sucs: { d: {} },
09.883 : DEBUG :  Not a cluster b [33m0[39m
    _edgeObjs: {},
09.883 : DEBUG :  Extracting node A {
    _edgeLabels: {},
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    _nodeCount: [33m1[39m
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  }
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
}
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
09.883 : WARN :  extractor -  [33m2[39m {
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
} [33mtrue[39m [33mtrue[39m { data: [33m6[39m } [90mundefined[39m  Depth  [33m0[39m
  edges: [],
09.883 : INFO :  cp  a  to  A  with parent  A
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
09.883 : INFO :  In copy  A root A data { data: [33m6[39m } A
} [90mundefined[39m
09.883 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.883 : WARN :   Now next level B {
09.883 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
  clusterNode: [33mtrue[39m,
09.883 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
  id: [32m'B'[39m,
09.883 : INFO :  Edge data { data: [32m'link1'[39m } A
  clusterData: { data: [33m4[39m },
09.883 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
  labelText: [90mundefined[39m,
09.883 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
  graph: Graph {
09.883 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
    _isDirected: [33mtrue[39m,
09.883 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
    _isMultigraph: [33mtrue[39m,
09.883 : INFO :  Edge data { data: [32m'link2'[39m } A
    _isCompound: [33mtrue[39m,
09.883 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
09.883 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
09.883 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
09.883 : DEBUG :  Removing node a
    _nodes: { b: [36m[Object][39m },
09.883 : DEBUG :  Old graph after copy {
    _parent: { b: [32m'\x00'[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
  nodes: [
    _sucs: { b: {} },
    { v: [32m'C'[39m, value: [36m[Object][39m },
    _edgeObjs: {},
    { v: [32m'B'[39m, value: [36m[Object][39m },
    _edgeLabels: {},
    { v: [32m'A'[39m, value: [36m[Object][39m }
    _nodeCount: [33m1[39m
  ],
  }
}
09.883 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.883 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: { data: [33m6[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
  edges: [
    _preds: { a: {} },
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    _out: { a: {} },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
    _sucs: { a: {} },
09.883 : DEBUG :  Extracting node a {
    _edgeObjs: {},
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    _edgeLabels: {},
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    _nodeCount: [33m1[39m
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  }
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
}
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.883 : DEBUG :  Not a cluster a [33m0[39m
09.883 : DEBUG :  Nodes =  [ [32m'd'[39m, [32m'D'[39m ] [33m1[39m
09.883 : DEBUG :  Extracting node d {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mfalse[39m { data: [33m3[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
09.883 : DEBUG :  Not a cluster d [33m1[39m
09.883 : DEBUG :  Extracting node D {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
09.883 : INFO :  cp  d  to  D  with parent  D
09.883 : INFO :  In copy  D root D data { data: [33m2[39m } D
09.883 : WARN :  extractor -  [33m1[39m {
09.883 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
09.883 : DEBUG :  Copying Edges []
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
09.883 : DEBUG :  Removing node d
  edges: [],
09.883 : DEBUG :  Old graph after copy {
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
} [90mundefined[39m
  nodes: [ { v: [32m'D'[39m, value: [36m[Object][39m } ],

  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.883 : DEBUG :  Done, no node has children [ [32m'd'[39m ]
09.883 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
09.883 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
09.883 : INFO :  A [ [32m'a'[39m ]

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
09.896 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.896 : DEBUG :  Opting in, graph
09.896 : DEBUG :  Not a cluster  a Map(7) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
09.896 : DEBUG :  Cluster identified b Map(7) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
09.896 : DEBUG :  Not a cluster  c Map(7) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
09.896 : DEBUG :  Not a cluster  d Map(7) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
09.896 : DEBUG :  Not a cluster  e Map(7) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
09.896 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ] [33m0[39m
09.896 : DEBUG :  Extracting node a Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
09.896 : DEBUG :  Not a cluster a [33m0[39m
09.896 : DEBUG :  Extracting node b Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
09.896 : WARN :  Cluster identified b  Replacement id in edges:  c
09.896 : WARN :  Edge a -> b: {"v":"a","w":"b","name":"1"}
09.896 : WARN :  Edge a -> b: {"data":"link1"}
09.896 : WARN :  Fix XXX Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} ids: a b Translating:  [90mundefined[39m  ---  { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
09.896 : WARN :  Fixing and trying - removing XXX a b 1
09.896 : WARN :  Fix Replacing with XXX a b 1
09.896 : WARN :  Edge c -> d: {"v":"c","w":"d","name":"2"}
09.896 : WARN :  Edge c -> d: {"data":"link2"}
09.896 : WARN :  Fix XXX Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
} ids: c d Translating:  [90mundefined[39m  ---  [90mundefined[39m
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
09.896 : WARN :  Edge d -> e: {"v":"d","w":"e","name":"2"}
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
09.896 : WARN :  Edge d -> e: {"data":"link2"}
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
09.896 : WARN :  Fix XXX Map(7) {
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
09.896 : INFO :  cp  c  to  b  with parent  b
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
09.896 : INFO :  In copy  b root b data { data: [33m2[39m } b
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
09.896 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
09.896 : DEBUG :  Copying Edges [
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
} ids: d e Translating:  [90mundefined[39m  ---  [90mundefined[39m
]
09.896 : INFO :  Edge { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }
09.896 : INFO :  Edge data { data: [32m'link2'[39m } b
09.896 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
09.896 : INFO :  Edge is  { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }
09.896 : INFO :  Copying as  c d { data: [32m'link2'[39m } 2
09.896 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
09.896 : INFO :  Edge { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
09.896 : INFO :  Edge data { data: [32m'link2'[39m } b
09.896 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
09.896 : INFO :  Edge is  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
09.896 : INFO :  Copying as  d e { data: [32m'link2'[39m } 2
09.896 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }, { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
09.896 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
09.896 : WARN :  Adjusted Graph {
09.896 : INFO :  Edge data { data: [32m'link1'[39m } b
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
09.896 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
  nodes: [
09.896 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
    { v: [32m'a'[39m, value: [36m[Object][39m },
09.896 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
    { v: [32m'b'[39m, value: [36m[Object][39m },
09.896 : DEBUG :  Removing node c
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
09.896 : INFO :  cp  d  to  b  with parent  b
09.896 : INFO :  In copy  b root b data { data: [33m2[39m } b
09.896 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.896 : DEBUG :  Copying Edges [ { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }, { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
09.896 : INFO :  Edge { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
09.896 : INFO :  Edge data { data: [32m'link2'[39m } b
09.896 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
09.896 : INFO :  Edge is  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
09.896 : INFO :  Copying as  d e { data: [32m'link2'[39m } 2
09.896 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }, { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
09.896 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
09.896 : INFO :  Edge data { data: [32m'link1'[39m } b
09.896 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
09.896 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
09.896 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
  ],
09.896 : DEBUG :  Removing node d
  edges: [
09.896 : INFO :  cp  e  to  b  with parent  b
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
09.896 : INFO :  In copy  b root b data { data: [33m2[39m } b
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
09.896 : DEBUG :  Not Setting parent for node= e cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.896 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
09.896 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
  ],
09.896 : INFO :  Edge data { data: [32m'link1'[39m } b
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
09.896 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
09.896 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
09.896 : WARN :  extractor -  [33m0[39m {
09.896 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
09.896 : DEBUG :  Removing node e
  nodes: [
09.896 : DEBUG :  Old graph after copy {
    { v: [32m'a'[39m, value: [36m[Object][39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m }, { v: [32m'b'[39m, value: [36m[Object][39m } ],
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
}
  ],
09.896 : DEBUG :  Extracting node c Map(7) {
  edges: [
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  ],
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
} [90mundefined[39m
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
09.896 : WARN :  Cluster without external connections, without a parent and with children b [33m0[39m
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.896 : WARN :  Old graph before copy {
09.896 : DEBUG :  Not a cluster c [33m0[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
09.896 : DEBUG :  Extracting node d Map(7) {
  nodes: [
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'a'[39m, value: [36m[Object][39m },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  ],
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
  edges: [
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
09.896 : DEBUG :  Not a cluster d [33m0[39m
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
09.896 : DEBUG :  Extracting node e Map(7) {
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  ],
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
}
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
09.896 : WARN :  Copying children of  b root b data { data: [33m2[39m } b
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
09.896 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
09.896 : WARN :  New graph after copy node: ( b ) {
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
09.896 : DEBUG :  Not a cluster e [33m0[39m
  nodes: [
09.896 : DEBUG :  Done, no node has children [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
    { v: [32m'c'[39m, value: [36m[Object][39m },
09.896 : INFO :  Graph after {
    { v: [32m'd'[39m, value: [36m[Object][39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  nodes: [
  ],
    { v: [32m'c'[39m, value: [36m[Object][39m },
  edges: [
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  ],
  edges: [
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

}
09.896 : WARN :  New list of nodes [ [32m'a'[39m, [32m'b'[39m ]
09.896 : WARN :   Now next level a { data: [33m1[39m }
09.896 : WARN :   Now next level b {
  clusterNode: [33mtrue[39m,
  id: [32m'b'[39m,
  clusterData: { data: [33m2[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m, d: [36m[Object][39m, e: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m, d: [32m'\x00'[39m, e: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {}, d: {}, e: {} },
    _in: { c: {}, d: [36m[Object][39m, e: [36m[Object][39m },
    _preds: { c: {}, d: [36m[Object][39m, e: [36m[Object][39m },
    _out: { c: [36m[Object][39m, d: [36m[Object][39m, e: {} },
    _sucs: { c: [36m[Object][39m, d: [36m[Object][39m, e: {} },
    _edgeObjs: { [32m'c\x01d\x012'[39m: [36m[Object][39m, [32m'd\x01e\x012'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'c\x01d\x012'[39m: [36m[Object][39m, [32m'd\x01e\x012'[39m: [36m[Object][39m },
    _nodeCount: [33m3[39m,
    _edgeCount: [33m2[39m
  }
}
09.896 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
09.902 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.902 : DEBUG :  Opting in, graph
09.902 : DEBUG :  Cluster identified a Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
09.902 : DEBUG :  Cluster identified b Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
09.902 : DEBUG :  Cluster identified c Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
09.902 : DEBUG :  Not a cluster  e Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
09.902 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ] [33m0[39m
09.902 : DEBUG :  Extracting node a Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
09.902 : INFO :  cp  e  to  a  with parent  c
09.902 : DEBUG :  Setting parent e c
09.902 : DEBUG :  Copying Edges []
09.902 : DEBUG :  Removing node e
09.902 : INFO :  cp  c  to  a  with parent  c
09.902 : INFO :  In copy  c root a data { data: [33m3[39m } a
09.902 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
09.902 : DEBUG :  Copying Edges []
09.902 : DEBUG :  Removing node c
09.902 : DEBUG :  Removing node c
09.902 : INFO :  cp  b  to  a  with parent  b
09.902 : INFO :  In copy  b root a data { data: [33m2[39m } a
09.902 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
09.902 : DEBUG :  Copying Edges []
09.902 : DEBUG :  Removing node b
09.902 : DEBUG :  Removing node b
09.902 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.902 : DEBUG :  Extracting node b Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.902 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
09.902 : DEBUG :  Extracting node c Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.902 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
09.902 : DEBUG :  Extracting node e Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.902 : DEBUG :  Not a cluster e [33m0[39m
09.902 : DEBUG :  Nodes =  [ [32m'e'[39m, [32m'c'[39m, [32m'b'[39m ] [33m1[39m
09.902 : DEBUG :  Extracting node e Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m1[39m
09.902 : DEBUG :  Not a cluster e [33m1[39m
09.902 : DEBUG :  Extracting node c Map(9) {
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
09.902 : WARN :  Cluster identified a  Replacement id in edges:  e
09.902 : WARN :  Cluster identified b  Replacement id in edges:  e
09.902 : WARN :  Cluster identified c  Replacement id in edges:  e
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
09.902 : WARN :  Adjusted Graph {
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.902 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  ],
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  edges: [],
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [90mundefined[39m
} [33mtrue[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m1[39m
09.902 : WARN :  Cluster without external connections, without a parent and with children a [33m0[39m
09.902 : WARN :  Old graph before copy {
09.902 : INFO :  cp  e  to  c  with parent  c
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
09.902 : INFO :  In copy  c root c data { data: [33m3[39m } c
09.902 : DEBUG :  Not Setting parent for node= e cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.902 : DEBUG :  Copying Edges []
09.902 : DEBUG :  Removing node e
09.902 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.902 : DEBUG :  Extracting node b Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.902 : WARN :  Copying children of  a root a data { data: [33m1[39m } a
09.902 : WARN :  Copying (nodes) clusterId a nodes [ [32m'b'[39m ]
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
09.902 : WARN :  Copying children of  b root a data { data: [33m2[39m } a
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
09.902 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m, [32m'b'[39m ]
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
09.902 : WARN :  Copying children of  c root a data { data: [33m3[39m } a
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
09.902 : WARN :  Copying (nodes) clusterId c nodes [ [32m'e'[39m, [32m'c'[39m ]
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
09.902 : WARN :  Setting parent e c
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m1[39m
09.902 : WARN :  Setting parent c b
09.902 : INFO :  cp  c  to  b  with parent  b
09.902 : WARN :  New graph after copy node: ( a ) {
09.902 : INFO :  In copy  b root b data { data: [33m2[39m } b
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
09.902 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  nodes: [
09.902 : DEBUG :  Copying Edges []
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
09.902 : DEBUG :  Removing node c
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
09.902 : DEBUG :  Old graph after copy {
  edges: [],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
}
  edges: [],
09.902 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
09.902 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
}
09.902 : WARN :  New list of nodes [ [32m'a'[39m ]
09.902 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
09.902 : INFO :  Graph after {
09.902 : WARN :   Now next level a {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  clusterNode: [33mtrue[39m,
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  id: [32m'a'[39m,
  edges: [],
  clusterData: { data: [33m1[39m },
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  label: [90mundefined[39m,
}
  graph: Graph {

    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { e: [36m[Object][39m, c: [36m[Object][39m, b: [36m[Object][39m },
    _parent: { e: [32m'c'[39m, c: [32m'b'[39m, b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, e: {}, c: [36m[Object][39m, b: [36m[Object][39m },
    _in: { e: {}, c: {}, b: {} },
    _preds: { e: {}, c: {}, b: {} },
    _out: { e: {}, c: {}, b: {} },
    _sucs: { e: {}, c: {}, b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m3[39m
  }
}
09.902 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.902 : WARN :  Cluster without external connections, without a parent and with children c [33m1[39m
09.902 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.902 : WARN :  Copying children of  c root c data { data: [33m3[39m } c
09.902 : WARN :  Copying (nodes) clusterId c nodes [ [32m'e'[39m ]
09.902 : WARN :  New graph after copy node: ( c ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'e'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.902 : WARN :  Cluster without external connections, without a parent and with children b [33m1[39m
09.902 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.902 : WARN :  Copying children of  b root b data { data: [33m2[39m } b
09.902 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m ]
09.902 : WARN :  New graph after copy node: ( b ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.902 : WARN :  New list of nodes [ [32m'b'[39m ]
09.902 : WARN :   Now next level b {
  clusterNode: [33mtrue[39m,
  id: [32m'b'[39m,
  clusterData: { data: [33m2[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
09.902 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
09.896 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.896 : DEBUG :  Opting in, graph
09.896 : DEBUG :  Not a cluster  a {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
09.896 : WARN :  Cluster identified b  Replacement id in edges:  c
  C: [ [32m'D'[39m, [32m'd'[39m ],
09.896 : WARN :  Edge a -> b: {"v":"a","w":"b","name":"1"}
  D: [ [32m'd'[39m ],
09.896 : WARN :  Edge a -> b: {"data":"link1"}
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
09.896 : WARN :  Fix XXX {
}
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
09.896 : DEBUG :  Cluster identified b {
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  C1: [ [32m'a'[39m ],
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  C2: [ [32m'b'[39m ],
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  A: [ [32m'a'[39m ],
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  B: [ [32m'b'[39m ],
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  C: [ [32m'D'[39m, [32m'd'[39m ],
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
  D: [ [32m'd'[39m ],
} ids: a b Translating:  [90mundefined[39m  ---  { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
09.896 : WARN :  Fixing and trixing - removing XXX a b 1
}
09.896 : WARN :  Fix Replacing with XXX a b 1
09.896 : DEBUG :  Not a cluster  c {
09.896 : WARN :  Edge c -> d: {"v":"c","w":"d","name":"2"}
  C1: [ [32m'a'[39m ],
09.896 : WARN :  Edge c -> d: {"data":"link2"}
  C2: [ [32m'b'[39m ],
09.896 : WARN :  Fix XXX {
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
09.896 : DEBUG :  Not a cluster  d {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
09.896 : DEBUG :  Not a cluster  e {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
09.896 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ] [33m0[39m
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
09.896 : DEBUG :  Extracting node a {
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
} ids: c d Translating:  [90mundefined[39m  ---  [90mundefined[39m
09.896 : DEBUG :  Not a cluster a [33m0[39m
09.896 : WARN :  Edge d -> e: {"v":"d","w":"e","name":"2"}
09.896 : DEBUG :  Extracting node b {
09.896 : WARN :  Edge d -> e: {"data":"link2"}
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
09.896 : WARN :  Fix XXX {
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
09.896 : INFO :  cp  c  to  b  with parent  b
} ids: d e Translating:  [90mundefined[39m  ---  [90mundefined[39m
09.896 : INFO :  In copy  b root b data { data: [33m2[39m } b
09.896 : WARN :  Adjusted Graph {
09.896 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
09.896 : DEBUG :  Copying Edges [
  nodes: [
  { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m },
  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
]
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
09.896 : INFO :  Edge { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
09.896 : INFO :  Edge data { data: [32m'link2'[39m } b
  ],
09.896 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
  edges: [
09.896 : INFO :  Edge is  { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
09.896 : INFO :  Copying as  c d { data: [32m'link2'[39m } 2
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.896 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.896 : WARN :  Cluster without external connections, without a parent and with children b [33m0[39m
09.896 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
09.896 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
09.896 : INFO :  Edge { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
09.896 : INFO :  Edge data { data: [32m'link2'[39m } b
09.896 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
09.896 : INFO :  Edge is  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
09.896 : INFO :  Copying as  d e { data: [32m'link2'[39m } 2
09.896 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }, { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
09.896 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
09.896 : INFO :  Edge data { data: [32m'link1'[39m } b
09.896 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
09.896 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
  ],
09.896 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
09.896 : DEBUG :  Removing node c
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
09.896 : INFO :  cp  d  to  b  with parent  b
09.896 : INFO :  In copy  b root b data { data: [33m2[39m } b
09.896 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.896 : DEBUG :  Copying Edges [ { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }, { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
09.896 : INFO :  Edge { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
09.896 : INFO :  Edge data { data: [32m'link2'[39m } b
09.896 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
09.896 : INFO :  Edge is  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
  ],
09.896 : INFO :  Copying as  d e { data: [32m'link2'[39m } 2
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
09.896 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }, { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
09.896 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
}
09.896 : INFO :  Edge data { data: [32m'link1'[39m } b
09.896 : WARN :  Copying children of  b root b data { data: [33m2[39m } b
09.896 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
09.896 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
09.896 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
09.896 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
09.896 : DEBUG :  Removing node d
09.896 : WARN :  New graph after copy node: ( b ) {
09.896 : INFO :  cp  e  to  b  with parent  b
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
09.896 : INFO :  In copy  b root b data { data: [33m2[39m } b
09.896 : DEBUG :  Not Setting parent for node= e cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  nodes: [
09.896 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
    { v: [32m'c'[39m, value: [36m[Object][39m },
09.896 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
09.896 : INFO :  Edge data { data: [32m'link1'[39m } b
09.896 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
09.896 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
09.896 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
09.896 : DEBUG :  Removing node e
09.896 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m }, { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.896 : DEBUG :  Extracting node c {
    { v: [32m'd'[39m, value: [36m[Object][39m },
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  ],
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  edges: [
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  ],
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.896 : DEBUG :  Not a cluster c [33m0[39m
09.896 : DEBUG :  Extracting node d {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.896 : DEBUG :  Not a cluster d [33m0[39m
09.896 : DEBUG :  Extracting node e {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
}
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
09.896 : WARN :  New list of nodes [ [32m'a'[39m, [32m'b'[39m ]
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
09.896 : WARN :   Now next level a { data: [33m1[39m }
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
09.896 : WARN :   Now next level b {
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.896 : DEBUG :  Not a cluster e [33m0[39m
09.896 : DEBUG :  Done, no node has children [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
09.896 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  ],
  edges: [
  clusterNode: [33mtrue[39m,
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  id: [32m'b'[39m,
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  clusterData: { data: [33m2[39m },
}
  labelText: [90mundefined[39m,

  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m, d: [36m[Object][39m, e: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m, d: [32m'\x00'[39m, e: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {}, d: {}, e: {} },
    _in: { c: {}, d: [36m[Object][39m, e: [36m[Object][39m },
    _preds: { c: {}, d: [36m[Object][39m, e: [36m[Object][39m },
    _out: { c: [36m[Object][39m, d: [36m[Object][39m, e: {} },
    _sucs: { c: [36m[Object][39m, d: [36m[Object][39m, e: {} },
    _edgeObjs: { [32m'c\x01d\x012'[39m: [36m[Object][39m, [32m'd\x01e\x012'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'c\x01d\x012'[39m: [36m[Object][39m, [32m'd\x01e\x012'[39m: [36m[Object][39m },
    _nodeCount: [33m3[39m,
    _edgeCount: [33m2[39m
  }
}
09.896 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
09.910 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.910 : DEBUG :  Opting in, graph
09.910 : DEBUG :  Cluster identified a {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
09.910 : DEBUG :  Cluster identified b {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
09.910 : DEBUG :  Cluster identified c {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
09.910 : DEBUG :  Not a cluster  e {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
09.910 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ] [33m0[39m
09.910 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
09.910 : INFO :  cp  e  to  a  with parent  c
09.910 : DEBUG :  Setting parent e c
09.910 : DEBUG :  Copying Edges []
09.910 : DEBUG :  Removing node e
09.910 : INFO :  cp  c  to  a  with parent  c
09.910 : INFO :  In copy  c root a data { data: [33m3[39m } a
09.910 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
09.910 : DEBUG :  Copying Edges []
09.910 : DEBUG :  Removing node c
09.910 : DEBUG :  Removing node c
09.910 : INFO :  cp  b  to  a  with parent  b
09.910 : INFO :  In copy  b root a data { data: [33m2[39m } a
09.910 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
09.910 : DEBUG :  Copying Edges []
09.910 : DEBUG :  Removing node b
09.910 : DEBUG :  Removing node b
09.910 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.910 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.910 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
09.910 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
09.910 : WARN :  Cluster identified a  Replacement id in edges:  e
09.910 : WARN :  Cluster identified b  Replacement id in edges:  e
09.910 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
09.910 : DEBUG :  Extracting node e {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.910 : DEBUG :  Not a cluster e [33m0[39m
09.910 : WARN :  Cluster identified c  Replacement id in edges:  e
09.910 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.910 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
09.910 : DEBUG :  Nodes =  [ [32m'e'[39m, [32m'c'[39m, [32m'b'[39m ] [33m1[39m
09.910 : DEBUG :  Extracting node e {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [90mundefined[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m1[39m
09.910 : DEBUG :  Not a cluster e [33m1[39m
09.910 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m1[39m
09.910 : INFO :  cp  e  to  c  with parent  c
09.910 : INFO :  In copy  c root c data { data: [33m3[39m } c
09.910 : DEBUG :  Not Setting parent for node= e cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.910 : DEBUG :  Copying Edges []
09.910 : DEBUG :  Removing node e
09.910 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.910 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.910 : WARN :  Cluster without external connections, without a parent and with children a [33m0[39m
09.910 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m1[39m
09.910 : INFO :  cp  c  to  b  with parent  b
09.910 : INFO :  In copy  b root b data { data: [33m2[39m } b
09.910 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.910 : DEBUG :  Copying Edges []
09.910 : DEBUG :  Removing node c
09.910 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.910 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.910 : WARN :  Copying children of  a root a data { data: [33m1[39m } a
09.910 : WARN :  Copying (nodes) clusterId a nodes [ [32m'b'[39m ]
09.910 : WARN :  Copying children of  b root a data { data: [33m2[39m } a
09.910 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m, [32m'b'[39m ]
09.910 : WARN :  Copying children of  c root a data { data: [33m3[39m } a
09.910 : WARN :  Copying (nodes) clusterId c nodes [ [32m'e'[39m, [32m'c'[39m ]
09.910 : WARN :  Setting parent e c
09.910 : WARN :  Setting parent c b
09.910 : WARN :  New graph after copy node: ( a ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
09.910 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.910 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
09.910 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
09.910 : WARN :  New list of nodes [ [32m'a'[39m ]
09.910 : WARN :   Now next level a {
  clusterNode: [33mtrue[39m,
  id: [32m'a'[39m,
  clusterData: { data: [33m1[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { e: [36m[Object][39m, c: [36m[Object][39m, b: [36m[Object][39m },
    _parent: { e: [32m'c'[39m, c: [32m'b'[39m, b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, e: {}, c: [36m[Object][39m, b: [36m[Object][39m },
    _in: { e: {}, c: {}, b: {} },
    _preds: { e: {}, c: {}, b: {} },
    _out: { e: {}, c: {}, b: {} },
    _sucs: { e: {}, c: {}, b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m3[39m
  }
}
09.910 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.910 : WARN :  Cluster without external connections, without a parent and with children c [33m1[39m
09.910 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.910 : WARN :  Copying children of  c root c data { data: [33m3[39m } c
09.910 : WARN :  Copying (nodes) clusterId c nodes [ [32m'e'[39m ]
09.910 : WARN :  New graph after copy node: ( c ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'e'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.910 : WARN :  Cluster without external connections, without a parent and with children b [33m1[39m
09.910 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.910 : WARN :  Copying children of  b root b data { data: [33m2[39m } b
09.910 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m ]
09.910 : WARN :  New graph after copy node: ( b ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.910 : WARN :  New list of nodes [ [32m'b'[39m ]
09.910 : WARN :   Now next level b {
  clusterNode: [33mtrue[39m,
  id: [32m'b'[39m,
  clusterData: { data: [33m2[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
09.910 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
09.907 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.907 : DEBUG :  Opting in, graph
09.907 : DEBUG :  Cluster identified A Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
09.907 : DEBUG :  Cluster identified B Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
09.907 : DEBUG :  Not a cluster  b Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
09.907 : DEBUG :  Not a cluster  c Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
09.907 : DEBUG :  Not a cluster  a Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
09.907 : DEBUG :  Nodes =  [ [32m'A'[39m, [32m'B'[39m, [32m'b'[39m, [32m'c'[39m, [32m'a'[39m ] [33m0[39m
09.907 : DEBUG :  Extracting node A Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  cssClass: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m0[39m
09.907 : INFO :  cp  c  to  A  with parent  B
09.907 : DEBUG :  Setting parent c B
09.907 : DEBUG :  Copying Edges [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }, { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
09.907 : INFO :  Edge { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }
09.907 : INFO :  Edge data {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  cssClasses: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
} A
09.907 : INFO :  Descendants of  A  is  [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ]
09.907 : INFO :  Edge is  { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }
09.907 : INFO :  Copying as  b c {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  cssClasses: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
} 1
09.907 : INFO :  newGraph edges  [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m } ] {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  cssClasses: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
}
09.907 : INFO :  Edge { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
09.907 : INFO :  Edge data {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-a-c'[39m,
  cssClasses: [32m'flowchart-link LS-a LE-c'[39m
} A
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
09.907 : WARN :  Cluster identified A  Replacement id in edges:  c
09.907 : WARN :  Cluster identified B  Replacement id in edges:  c
09.907 : WARN :  Edge:  { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }  leaves cluster  B
09.907 : WARN :  Descendants of XXX  B :  [ [32m'c'[39m ]
09.907 : WARN :  Edge b -> B: {"v":"b","w":"B","name":"1"}
09.907 : WARN :  Edge b -> B: {"minlen":1,"arrowhead":"normal","arrowTypeStart":"arrow_open","arrowTypeEnd":"arrow_point","thickness":"normal","pattern":"solid","style":"fill:none","labelStyle":"","arrowheadStyle":"fill: #333","labelpos":"c","labelType":"text","label":"","id":"L-b-B","cssClasses":"flowchart-link LS-b LE-B"}
09.907 : WARN :  Fix XXX Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
09.907 : INFO :  Descendants of  A  is  [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ]
      rx: [33m0[39m,
09.907 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
09.907 : INFO :  Copying as  a c {
  minlen: [33m1[39m,
      ry: [33m0[39m,
  arrowhead: [32m'normal'[39m,
      cssClass: [32m'default'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
      style: [32m''[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
      id: [32m'A'[39m,
  thickness: [32m'normal'[39m,
      width: [33m500[39m,
  pattern: [32m'solid'[39m,
      type: [32m'group'[39m,
  style: [32m'fill:none'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
  labelStyle: [32m''[39m,
    id: [32m'c'[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
  labelpos: [32m'c'[39m,
      labelText: [32m'B'[39m,
  labelType: [32m'text'[39m,
      rx: [33m0[39m,
  label: [32m''[39m,
      ry: [33m0[39m,
  id: [32m'L-a-c'[39m,
      class: [32m'default'[39m,
  cssClasses: [32m'flowchart-link LS-a LE-c'[39m
      style: [32m''[39m,
} 2
      id: [32m'B'[39m,
09.907 : INFO :  newGraph edges  [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }, { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ] {
      width: [33m500[39m,
  minlen: [33m1[39m,
      type: [32m'group'[39m,
  arrowhead: [32m'normal'[39m,
      padding: [33m15[39m
  arrowTypeStart: [32m'arrow_open'[39m,
    },
  arrowTypeEnd: [32m'arrow_point'[39m,
    externalConnections: [33mtrue[39m
  thickness: [32m'normal'[39m,
  },
  pattern: [32m'solid'[39m,
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  style: [32m'fill:none'[39m,
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  cssClasses: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
}
09.907 : DEBUG :  Removing node c
09.907 : INFO :  cp  B  to  A  with parent  B
09.907 : INFO :  In copy  B root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  rx: [33m0[39m,
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  ry: [33m0[39m,
} ids: b B Translating:  { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }  ---  {
  class: [32m'default'[39m,
  id: [32m'c'[39m,
  style: [32m''[39m,
  clusterData: {
  id: [32m'B'[39m,
    labelStyle: [32m''[39m,
  width: [33m500[39m,
    shape: [32m'rect'[39m,
  type: [32m'group'[39m,
    labelText: [32m'B'[39m,
  padding: [33m15[39m
    rx: [33m0[39m,
} A
    ry: [33m0[39m,
09.907 : DEBUG :  Not Setting parent for node= B cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
    class: [32m'default'[39m,
09.907 : DEBUG :  Copying Edges []
    style: [32m''[39m,
09.907 : DEBUG :  Removing node B
09.907 : DEBUG :  Removing node B
09.907 : INFO :  cp  b  to  A  with parent  A
09.907 : INFO :  In copy  A root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  cssClass: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
09.907 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.907 : DEBUG :  Copying Edges []
09.907 : DEBUG :  Removing node b
09.907 : INFO :  cp  a  to  A  with parent  A
09.907 : INFO :  In copy  A root A data {
    id: [32m'B'[39m,
    width: [33m500[39m,
    type: [32m'group'[39m,
    padding: [33m15[39m
  },
  externalConnections: [33mtrue[39m
}
09.907 : WARN :  Fixing and trying - removing XXX b B 1
09.907 : WARN :  Fix Replacing with XXX b c 1
09.907 : WARN :  Edge a -> c: {"v":"a","w":"c","name":"2"}
09.907 : WARN :  Edge a -> c: {"minlen":1,"arrowhead":"normal","arrowTypeStart":"arrow_open","arrowTypeEnd":"arrow_point","thickness":"normal","pattern":"solid","style":"fill:none","labelStyle":"","arrowheadStyle":"fill: #333","labelpos":"c","labelType":"text","label":"","id":"L-a-c","cssClasses":"flowchart-link LS-a LE-c"}
09.907 : WARN :  Fix XXX Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  labelStyle: [32m''[39m,
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  shape: [32m'rect'[39m,
  [32m'B'[39m => {
  labelText: [32m'A'[39m,
    id: [32m'c'[39m,
  rx: [33m0[39m,
    clusterData: {
  ry: [33m0[39m,
      labelStyle: [32m''[39m,
  cssClass: [32m'default'[39m,
      shape: [32m'rect'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
09.907 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.907 : DEBUG :  Copying Edges []
09.907 : DEBUG :  Removing node a
09.907 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'A'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.907 : DEBUG :  Extracting node B Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
      style: [32m''[39m,
      id: [32m'B'[39m,
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
      width: [33m500[39m,
      type: [32m'group'[39m,
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
      padding: [33m15[39m
09.907 : DEBUG :  Map(9) {
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} ids: a c Translating:  { id: [32m'c'[39m, clusterData: { data: [33m1[39m } }  ---  { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
09.907 : WARN :  Fixing and trying - removing XXX a c 2
09.907 : WARN :  Fix Replacing with XXX a c 2
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
09.907 : WARN :  Adjusted Graph {
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'A'[39m => {
  nodes: [
    id: [32m'c'[39m,
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    clusterData: {
      labelStyle: [32m''[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
      shape: [32m'rect'[39m,
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
      labelText: [32m'A'[39m,
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
      rx: [33m0[39m,
  ],
      ry: [33m0[39m,
  edges: [
      cssClass: [32m'default'[39m,
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
      style: [32m''[39m,
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
      id: [32m'A'[39m,
  ],
      width: [33m500[39m,
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.907 : WARN :  extractor -  [33m0[39m {
      type: [32m'group'[39m,
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
      padding: [33m15[39m
  nodes: [
    }
    { v: [32m'A'[39m, value: [36m[Object][39m },
  },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
  [32m'B'[39m => {
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    id: [32m'c'[39m,
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    clusterData: {
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
      labelStyle: [32m''[39m,
  ],
      shape: [32m'rect'[39m,
  edges: [
      labelText: [32m'B'[39m,
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
      rx: [33m0[39m,
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
      ry: [33m0[39m,
  ],
      class: [32m'default'[39m,
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
      style: [32m''[39m,
} [90mundefined[39m
      id: [32m'B'[39m,
09.907 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
      width: [33m500[39m,
09.907 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
      type: [32m'group'[39m,
    { v: [32m'A'[39m, value: [36m[Object][39m },
      padding: [33m15[39m
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    externalConnections: [33mtrue[39m
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
  },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  ],
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  edges: [
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
}
09.907 : DEBUG :  Extracting node b Map(9) {
09.907 : WARN :  Copying children of  A root A data {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  cssClass: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
09.907 : WARN :  Copying (nodes) clusterId A nodes [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ]
09.907 : WARN :  Copying children of  B root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  width: [33m500[39m,
  [32m'A'[39m => {
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
09.907 : WARN :  Copying (nodes) clusterId B nodes [ [32m'c'[39m, [32m'B'[39m ]
09.907 : WARN :  Setting parent c B
09.907 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
    id: [32m'c'[39m,
09.907 : WARN :  Cluster **  B  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
    clusterData: {
09.907 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
09.907 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
09.907 : WARN :  Cluster **  a  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
      class: [32m'default'[39m,
09.907 : WARN :  New list of nodes [ [32m'A'[39m ]
      style: [32m''[39m,
09.907 : WARN :   Now next level A {
      id: [32m'B'[39m,
  clusterNode: [33mtrue[39m,
      width: [33m500[39m,
  id: [32m'A'[39m,
  clusterData: {
    labelStyle: [32m''[39m,
    shape: [32m'rect'[39m,
    labelText: [32m'A'[39m,
    rx: [33m0[39m,
    ry: [33m0[39m,
    cssClass: [32m'default'[39m,
    style: [32m''[39m,
    id: [32m'A'[39m,
    width: [33m500[39m,
    type: [32m'group'[39m,
    padding: [33m15[39m
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  },
09.907 : DEBUG :  Map(9) {
  label: [90mundefined[39m,
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  graph: Graph {
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
    _isDirected: [33mtrue[39m,
  [32m'A'[39m => {
    _isMultigraph: [33mtrue[39m,
    id: [32m'c'[39m,
    _isCompound: [33mtrue[39m,
    clusterData: {
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
      labelStyle: [32m''[39m,
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
      shape: [32m'rect'[39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
      labelText: [32m'A'[39m,
    _nodes: { c: [36m[Object][39m, B: [36m[Object][39m, b: [36m[Object][39m, a: [36m[Object][39m },
      rx: [33m0[39m,
    _parent: { c: [32m'B'[39m, B: [32m'\x00'[39m, b: [32m'\x00'[39m, a: [32m'\x00'[39m },
      ry: [33m0[39m,
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {}, B: [36m[Object][39m, b: {}, a: {} },
      cssClass: [32m'default'[39m,
    _in: { c: [36m[Object][39m, B: {}, b: {}, a: {} },
      style: [32m''[39m,
    _preds: { c: [36m[Object][39m, B: {}, b: {}, a: {} },
      id: [32m'A'[39m,
    _out: { c: {}, B: {}, b: [36m[Object][39m, a: [36m[Object][39m },
      width: [33m500[39m,
    _sucs: { c: {}, B: {}, b: [36m[Object][39m, a: [36m[Object][39m },
      type: [32m'group'[39m,
    _edgeObjs: { [32m'b\x01c\x011'[39m: [36m[Object][39m, [32m'a\x01c\x012'[39m: [36m[Object][39m },
      padding: [33m15[39m
    _edgeLabels: { [32m'b\x01c\x011'[39m: [36m[Object][39m, [32m'a\x01c\x012'[39m: [36m[Object][39m },
    }
  },
  [32m'B'[39m => {
    _nodeCount: [33m4[39m,
    id: [32m'c'[39m,
    _edgeCount: [33m2[39m
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
  }
    externalConnections: [33mtrue[39m
}
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
09.907 : WARN :  extractor -  [33m1[39m {
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
09.907 : DEBUG :  Extracting node c Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
  nodes: [
      labelText: [32m'A'[39m,
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
      rx: [33m0[39m,
    { v: [32m'B'[39m, value: [36m[Object][39m },
      ry: [33m0[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m },
      cssClass: [32m'default'[39m,
    { v: [32m'a'[39m, value: [36m[Object][39m }
      style: [32m''[39m,
  ],
      id: [32m'A'[39m,
  edges: [
      width: [33m500[39m,
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
      type: [32m'group'[39m,
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
      padding: [33m15[39m
  ],
    }
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  },
  [32m'B'[39m => {
} [90mundefined[39m
    id: [32m'c'[39m,
09.907 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mfalse[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
    clusterData: {
09.907 : WARN :  Cluster **  B  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [33mtrue[39m [90mundefined[39m [33m1[39m
      labelStyle: [32m''[39m,
09.907 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
      shape: [32m'rect'[39m,
09.907 : WARN :  Cluster **  a  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
      labelText: [32m'B'[39m,
09.907 : WARN :  New list of nodes [ [32m'c'[39m, [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ]
      rx: [33m0[39m,
09.907 : WARN :   Now next level c {
      ry: [33m0[39m,
  labelStyle: [32m''[39m,
      class: [32m'default'[39m,
  shape: [32m'rect'[39m,
      style: [32m''[39m,
  labelText: [32m'c'[39m,
      id: [32m'B'[39m,
  rx: [33m0[39m,
      width: [33m500[39m,
  ry: [33m0[39m,
      type: [32m'group'[39m,
  class: [32m'default'[39m,
      padding: [33m15[39m
  style: [32m''[39m,
    },
  id: [32m'c'[39m,
    externalConnections: [33mtrue[39m
  padding: [33m15[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.907 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
}
      shape: [32m'rect'[39m,
09.907 : WARN :   Now next level B {
      labelText: [32m'A'[39m,
  labelStyle: [32m''[39m,
      rx: [33m0[39m,
  shape: [32m'rect'[39m,
      ry: [33m0[39m,
  labelText: [32m'B'[39m,
      cssClass: [32m'default'[39m,
  rx: [33m0[39m,
      style: [32m''[39m,
  ry: [33m0[39m,
      id: [32m'A'[39m,
  class: [32m'default'[39m,
      width: [33m500[39m,
  style: [32m''[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  id: [32m'B'[39m,
  },
  width: [33m500[39m,
  [32m'B'[39m => {
  type: [32m'group'[39m,
    id: [32m'c'[39m,
  padding: [33m15[39m
    clusterData: {
}
      labelStyle: [32m''[39m,
09.907 : WARN :   Now next level b {
      shape: [32m'rect'[39m,
  labelStyle: [32m''[39m,
      labelText: [32m'B'[39m,
  shape: [32m'rect'[39m,
      rx: [33m0[39m,
  labelText: [32m'b'[39m,
      ry: [33m0[39m,
  rx: [33m0[39m,
      class: [32m'default'[39m,
  ry: [33m0[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
09.907 : DEBUG :  Extracting node a Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'b'[39m,
  padding: [33m15[39m
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
}
09.907 : WARN :   Now next level a {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'a'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'a'[39m,
  padding: [33m15[39m
}

      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.907 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
09.907 : DEBUG :  Nodes =  [ [32m'c'[39m, [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ] [33m1[39m
09.907 : DEBUG :  Extracting node c Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mfalse[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'c'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'c'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
09.907 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
09.907 : DEBUG :  Extracting node B Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
09.916 : WARN :  Cluster identified A  Replacement id in edges:  c
      width: [33m500[39m,
09.916 : WARN :  Cluster identified B  Replacement id in edges:  c
      type: [32m'group'[39m,
09.916 : WARN :  Edge:  { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }  leaves cluster  B
      padding: [33m15[39m
09.916 : WARN :  Descendants of XXX  B :  [ [32m'c'[39m ]
    }
09.916 : WARN :  Edge b -> B: {"v":"b","w":"B","name":"1"}
  },
  [32m'B'[39m => {
09.916 : WARN :  Edge b -> B: {"minlen":1,"arrowhead":"normal","arrowTypeStart":"arrow_open","arrowTypeEnd":"arrow_point","thickness":"normal","pattern":"solid","style":"fill:none","labelStyle":"","arrowheadStyle":"fill: #333","labelpos":"c","labelType":"text","label":"","id":"L-b-B","classes":"flowchart-link LS-b LE-B"}
    id: [32m'c'[39m,
09.916 : WARN :  Fix XXX {
    clusterData: {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
      labelStyle: [32m''[39m,
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
      shape: [32m'rect'[39m,
  A: {
      labelText: [32m'B'[39m,
    id: [32m'c'[39m,
      rx: [33m0[39m,
    clusterData: {
      ry: [33m0[39m,
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
      width: [33m500[39m,
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
      type: [32m'group'[39m,
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
      padding: [33m15[39m
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
    },
    externalConnections: [33mtrue[39m
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  },
} ids: b B Translating:  { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }  ---  {
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  id: [32m'c'[39m,
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  clusterData: {
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
    labelStyle: [32m''[39m,
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
    shape: [32m'rect'[39m,
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
    labelText: [32m'B'[39m,
} [33mfalse[39m [33mtrue[39m {
    rx: [33m0[39m,
  labelStyle: [32m''[39m,
    ry: [33m0[39m,
  shape: [32m'rect'[39m,
    class: [32m'default'[39m,
  labelText: [32m'B'[39m,
    style: [32m''[39m,
  rx: [33m0[39m,
    id: [32m'B'[39m,
  ry: [33m0[39m,
    width: [33m500[39m,
  class: [32m'default'[39m,
    type: [32m'group'[39m,
  style: [32m''[39m,
    padding: [33m15[39m
  id: [32m'B'[39m,
  },
  width: [33m500[39m,
  externalConnections: [33mtrue[39m
  type: [32m'group'[39m,
}
  padding: [33m15[39m
09.916 : WARN :  Fixing and trixing - removing XXX b B 1
} [90mundefined[39m  Depth  [33m1[39m
09.916 : WARN :  Fix Replacing with XXX b c 1
09.916 : WARN :  Edge a -> c: {"v":"a","w":"c","name":"2"}
09.916 : WARN :  Edge a -> c: {"minlen":1,"arrowhead":"normal","arrowTypeStart":"arrow_open","arrowTypeEnd":"arrow_point","thickness":"normal","pattern":"solid","style":"fill:none","labelStyle":"","arrowheadStyle":"fill: #333","labelpos":"c","labelType":"text","label":"","id":"L-a-c","classes":"flowchart-link LS-a LE-c"}
09.916 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
09.907 : DEBUG :  Map(9) {
      labelText: [32m'A'[39m,
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
      rx: [33m0[39m,
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
      ry: [33m0[39m,
  [32m'A'[39m => {
      class: [32m'default'[39m,
    id: [32m'c'[39m,
      style: [32m''[39m,
    clusterData: {
      id: [32m'A'[39m,
      labelStyle: [32m''[39m,
      width: [33m500[39m,
      shape: [32m'rect'[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      width: [33m500[39m,
      padding: [33m15[39m
      type: [32m'group'[39m,
    },
      padding: [33m15[39m
    externalConnections: [33mtrue[39m
    },
  },
    externalConnections: [33mtrue[39m
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
} ids: a c Translating:  { id: [32m'c'[39m, clusterData: { data: [33m1[39m } }  ---  { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
09.916 : WARN :  Fixing and trixing - removing XXX a c 2
}
09.916 : WARN :  Fix Replacing with XXX a c 2
09.907 : DEBUG :  Extracting node b Map(9) {
09.916 : WARN :  Adjusted Graph {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
  [32m'A'[39m => {
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    id: [32m'c'[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    clusterData: {
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
      labelStyle: [32m''[39m,
  ],
      shape: [32m'rect'[39m,
  edges: [
      labelText: [32m'A'[39m,
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
      rx: [33m0[39m,
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.916 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
      ry: [33m0[39m,
  edges: [
      cssClass: [32m'default'[39m,
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
      style: [32m''[39m,
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
      id: [32m'A'[39m,
  ],
      width: [33m500[39m,
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.916 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
      type: [32m'group'[39m,
09.916 : WARN :  Old graph before copy {
      padding: [33m15[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    }
  nodes: [
  },
    { v: [32m'A'[39m, value: [36m[Object][39m },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
      shape: [32m'rect'[39m,
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
      labelText: [32m'B'[39m,
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
      rx: [33m0[39m,
  ],
      ry: [33m0[39m,
  edges: [
      class: [32m'default'[39m,
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
      style: [32m''[39m,
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
      id: [32m'B'[39m,
  ],
      width: [33m500[39m,
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.916 : WARN :  Copying children of  A root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
09.916 : WARN :  Copying (nodes) clusterId A nodes [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ]
09.916 : WARN :  Copying children of  B root A data {
  labelText: [32m'b'[39m,
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  rx: [33m0[39m,
  width: [33m500[39m,
  ry: [33m0[39m,
  type: [32m'group'[39m,
  class: [32m'default'[39m,
  padding: [33m15[39m
  style: [32m''[39m,
} A
  id: [32m'b'[39m,
09.916 : WARN :  Copying (nodes) clusterId B nodes [ [32m'c'[39m, [32m'B'[39m ]
  padding: [33m15[39m
09.916 : WARN :  Setting parent c B
} [90mundefined[39m  Depth  [33m1[39m
09.916 : WARN :  New graph after copy node: ( A ) {
09.907 : DEBUG :  Map(9) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  nodes: [
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
  [32m'A'[39m => {
    { v: [32m'B'[39m, value: [36m[Object][39m },
    id: [32m'c'[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m },
    clusterData: {
    { v: [32m'a'[39m, value: [36m[Object][39m }
      labelStyle: [32m''[39m,
  ],
      shape: [32m'rect'[39m,
  edges: [
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
      id: [32m'B'[39m,
  ],
      width: [33m500[39m,
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
      type: [32m'group'[39m,
}
      padding: [33m15[39m
09.916 : WARN :  Cluster **  B  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
09.916 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
    },
09.916 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
09.916 : WARN :  Cluster **  a  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
09.916 : WARN :  New list of nodes [ [32m'A'[39m ]
09.916 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: {
    labelStyle: [32m''[39m,
    shape: [32m'rect'[39m,
    labelText: [32m'A'[39m,
    rx: [33m0[39m,
    ry: [33m0[39m,
    class: [32m'default'[39m,
    externalConnections: [33mtrue[39m
    style: [32m''[39m,
    id: [32m'A'[39m,
  },
    width: [33m500[39m,
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    type: [32m'group'[39m,
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
    padding: [33m15[39m
  },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m, B: [36m[Object][39m, b: [36m[Object][39m, a: [36m[Object][39m },
    _parent: { c: [32m'B'[39m, B: [32m'\x00'[39m, b: [32m'\x00'[39m, a: [32m'\x00'[39m },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {}, B: [36m[Object][39m, b: {}, a: {} },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
    _in: { c: [36m[Object][39m, B: {}, b: {}, a: {} },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
    _preds: { c: [36m[Object][39m, B: {}, b: {}, a: {} },
    _out: { c: {}, B: {}, b: [36m[Object][39m, a: [36m[Object][39m },
}
    _sucs: { c: {}, B: {}, b: [36m[Object][39m, a: [36m[Object][39m },
09.907 : DEBUG :  Extracting node a Map(9) {
    _edgeObjs: { [32m'b\x01c\x011'[39m: [36m[Object][39m, [32m'a\x01c\x012'[39m: [36m[Object][39m },
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    _edgeLabels: { [32m'b\x01c\x011'[39m: [36m[Object][39m, [32m'a\x01c\x012'[39m: [36m[Object][39m },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
    _nodeCount: [33m4[39m,
  [32m'A'[39m => {
    _edgeCount: [33m2[39m
    id: [32m'c'[39m,
  }
    clusterData: {
}
      labelStyle: [32m''[39m,
09.916 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
      shape: [32m'rect'[39m,
  nodes: [
      labelText: [32m'A'[39m,
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
09.916 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mfalse[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
      rx: [33m0[39m,
09.916 : WARN :  Cluster **  B  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [33mtrue[39m [90mundefined[39m [33m1[39m
09.916 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
      ry: [33m0[39m,
09.916 : WARN :  Cluster **  a  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
09.916 : WARN :  New list of nodes [ [32m'c'[39m, [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ]
09.916 : WARN :   Now next level c {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'c'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
  style: [32m''[39m,
      class: [32m'default'[39m,
  id: [32m'c'[39m,
      style: [32m''[39m,
  padding: [33m15[39m
      id: [32m'B'[39m,
}
      width: [33m500[39m,
09.916 : WARN :   Now next level B {
      type: [32m'group'[39m,
  labelStyle: [32m''[39m,
      padding: [33m15[39m
  shape: [32m'rect'[39m,
    },
  labelText: [32m'B'[39m,
    externalConnections: [33mtrue[39m
  rx: [33m0[39m,
  },
  ry: [33m0[39m,
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
}
09.916 : WARN :   Now next level b {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'b'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  style: [32m''[39m,
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  id: [32m'b'[39m,
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  padding: [33m15[39m
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
} [33mtrue[39m [33mtrue[39m {
09.916 : WARN :   Now next level a {
  labelStyle: [32m''[39m,
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'a'[39m,
  labelText: [32m'a'[39m,
  rx: [33m0[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  style: [32m''[39m,
  id: [32m'a'[39m,
  id: [32m'a'[39m,
  padding: [33m15[39m
  padding: [33m15[39m
}

} [90mundefined[39m  Depth  [33m1[39m
09.907 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
09.907 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
09.916 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.916 : DEBUG :  Opting in, graph
09.916 : DEBUG :  Cluster identified A {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
09.916 : DEBUG :  Cluster identified B {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
09.916 : DEBUG :  Not a cluster  b {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
09.916 : DEBUG :  Not a cluster  c {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
09.916 : DEBUG :  Not a cluster  a {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
09.916 : DEBUG :  Nodes =  [ [32m'A'[39m, [32m'B'[39m, [32m'b'[39m, [32m'c'[39m, [32m'a'[39m ] [33m0[39m
09.916 : DEBUG :  Extracting node A {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m0[39m
09.916 : INFO :  cp  c  to  A  with parent  B
09.916 : DEBUG :  Setting parent c B
09.916 : DEBUG :  Copying Edges [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }, { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
09.916 : INFO :  Edge { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }
09.916 : INFO :  Edge data {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  classes: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
} A
09.916 : INFO :  Descendants of  A  is  [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ]
09.916 : INFO :  Edge is  { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }
09.916 : INFO :  Copying as  b c {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  classes: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
} 1
09.916 : INFO :  newGraph edges  [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m } ] {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  classes: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
}
09.916 : INFO :  Edge { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
09.916 : INFO :  Edge data {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-a-c'[39m,
  classes: [32m'flowchart-link LS-a LE-c'[39m
} A
09.916 : INFO :  Descendants of  A  is  [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ]
09.916 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
09.916 : INFO :  Copying as  a c {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-a-c'[39m,
  classes: [32m'flowchart-link LS-a LE-c'[39m
} 2
09.916 : INFO :  newGraph edges  [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }, { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ] {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  classes: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
}
09.916 : DEBUG :  Removing node c
09.916 : INFO :  cp  B  to  A  with parent  B
09.916 : INFO :  In copy  B root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
09.916 : DEBUG :  Not Setting parent for node= B cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
09.916 : DEBUG :  Copying Edges []
09.916 : DEBUG :  Removing node B
09.916 : DEBUG :  Removing node B
09.916 : INFO :  cp  b  to  A  with parent  A
09.916 : INFO :  In copy  A root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
09.916 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.916 : DEBUG :  Copying Edges []
09.916 : DEBUG :  Removing node b
09.916 : INFO :  cp  a  to  A  with parent  A
09.916 : INFO :  In copy  A root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
09.916 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
09.916 : DEBUG :  Copying Edges []
09.916 : DEBUG :  Removing node a
09.916 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'A'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
09.916 : DEBUG :  Extracting node B {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.916 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
09.916 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.916 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
09.916 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.916 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
09.916 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
09.916 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
09.916 : DEBUG :  Nodes =  [ [32m'c'[39m, [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ] [33m1[39m
09.916 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mfalse[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'c'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'c'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
09.916 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
09.916 : DEBUG :  Extracting node B {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
09.916 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
09.916 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'b'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'b'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
09.916 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
09.916 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'a'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'a'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
09.916 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
09.916 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

 âœ“ packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js (15 tests) 126ms
 âœ“ packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js (15 tests) 102ms
 âœ“ packages/mermaid/src/accessibility.spec.ts (20 tests) 197ms
 âœ“ |@mermaid-js/docs| .vitepress/theme/redirect.spec.ts (28 tests) 13ms
 âœ“ packages/mermaid/src/config.spec.ts (5 tests) 22ms
stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > MMP-1 should handle a simple root definition abc122
10.906 : INFO :  Node:  root
10.906 : INFO :  addNode [33m4[39m root root [33m0[39m
10.906 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > MMP-2 should handle a hierarchical mindmap definition
10.916 : INFO :  Node:  root
10.916 : INFO :  addNode [33m4[39m root root [33m0[39m
10.916 : TRACE :  Stop NL
10.916 : INFO :  Node:  child1
10.916 : INFO :  addNode [33m6[39m child1 child1 [33m0[39m
10.916 : TRACE :  Stop NL
10.916 : INFO :  Node:  child2
10.916 : INFO :  addNode [33m6[39m child2 child2 [33m0[39m
10.916 : TRACE :  Stop NL
10.916 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > 3 should handle a simple root definition with a shape and without an id abc123
10.921 : TRACE :  Long description: root
10.921 : TRACE :  node end )
10.921 : TRACE :  node found .. (
10.921 : DEBUG :  In get type ( )
10.921 : INFO :  Node:  root
10.921 : INFO :  addNode [33m4[39m root root [33m1[39m
10.921 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > MMP-4 should handle a deeper hierarchical mindmap definition
10.924 : INFO :  Node:  root
10.924 : INFO :  addNode [33m4[39m root root [33m0[39m
10.924 : TRACE :  Stop NL
10.924 : INFO :  Node:  child1
10.924 : INFO :  addNode [33m6[39m child1 child1 [33m0[39m
10.924 : TRACE :  Stop NL
10.924 : INFO :  Node:  leaf1
10.924 : INFO :  addNode [33m8[39m leaf1 leaf1 [33m0[39m
10.924 : TRACE :  Stop NL
10.924 : INFO :  Node:  child2
10.924 : INFO :  addNode [33m6[39m child2 child2 [33m0[39m
10.924 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > 5 Multiple roots are illegal
10.928 : INFO :  Node:  root
10.928 : INFO :  addNode [33m4[39m root root [33m0[39m
10.928 : TRACE :  Stop NL
10.928 : INFO :  Node:  fakeRoot
10.928 : INFO :  addNode [33m4[39m fakeRoot fakeRoot [33m0[39m

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > MMP-6 real root in wrong place
10.931 : INFO :  Node:  root
10.931 : INFO :  addNode [33m10[39m root root [33m0[39m
10.931 : TRACE :  Stop NL
10.931 : INFO :  Node:  fakeRoot
10.931 : INFO :  addNode [33m8[39m fakeRoot fakeRoot [33m0[39m

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-7 should handle an id and type for a node definition
10.934 : TRACE :  Long description: The root
10.934 : TRACE :  node end ... ]
10.934 : TRACE :  node found .. root
10.934 : DEBUG :  In get type [ ]
10.934 : INFO :  Node:  root
10.934 : INFO :  addNode [33m4[39m root The root [33m2[39m
10.934 : TRACE :  Stop NL
10.934 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-8 should handle an id and type for a node definition
10.935 : INFO :  Node:  root
10.935 : INFO :  addNode [33m4[39m root root [33m0[39m
10.935 : TRACE :  Stop NL
10.935 : TRACE :  Long description: child1
10.935 : TRACE :  node end )
10.935 : TRACE :  node found .. theId
10.935 : DEBUG :  In get type ( )
10.935 : INFO :  Node:  theId
10.935 : INFO :  addNode [33m6[39m theId child1 [33m1[39m
10.935 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-9 should handle an id and type for a node definition
10.938 : TRACE :  Node:  root
10.938 : INFO :  addNode [33m0[39m root root [33m0[39m
10.938 : TRACE :  Stop NL
10.938 : TRACE :  Long description: child1
10.938 : TRACE :  node end )
10.938 : TRACE :  node found .. theId
10.938 : DEBUG :  In get type ( )
10.938 : INFO :  Node:  theId
10.938 : INFO :  addNode [33m6[39m theId child1 [33m1[39m
10.938 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with a node
Found block-beta
.

Lex: NODE_ID id
.

Lex: EOF
Rule: node (NODE_ID separator):  id
Rule: nodeStatement (node)  { id: [32m'id'[39m }
Rule: statement:  {
  id: [32m'id'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a node with a square shape and a label
Found block
.

Lex: NODE_ID id
Lexa: [
Lex: Starting string
LEX: STR end: A label
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ A label ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id { typeStr: [32m'[]'[39m, label: [32m'A label'[39m }
Rule: nodeStatement (node)  { id: [32m'id'[39m, label: [32m'A label'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Rule: statement:  {
  id: [32m'id'[39m,
  label: [32m'A label'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id'[39m,
    label: [32m'A label'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with multiple nodes
Found block
.

Lex: NODE_ID id1
.

Lex: NODE_ID id2
Rule: node (NODE_ID separator):  id1
Rule: nodeStatement (node)  { id: [32m'id1'[39m }
.

Lex: EOF
Rule: node (NODE_ID separator):  id2
Rule: nodeStatement (node)  { id: [32m'id2'[39m }
Rule: statement:  {
  id: [32m'id2'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id1'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id1'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id2'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with multiple nodes
Found block
.

Lex: NODE_ID id1
.

Lex: NODE_ID id2
Rule: node (NODE_ID separator):  id1
Rule: nodeStatement (node)  { id: [32m'id1'[39m }
.

Lex: NODE_ID id3
Rule: node (NODE_ID separator):  id2
Rule: nodeStatement (node)  { id: [32m'id2'[39m }
.

Lex: EOF
Rule: node (NODE_ID separator):  id3
Rule: nodeStatement (node)  { id: [32m'id3'[39m }
Rule: statement:  {
  id: [32m'id3'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id2'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id1'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id1'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id2'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id3'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a node with a square shape and a label
Found block
.

Lex: NODE_ID id
Lexa: [
Lex: Starting string
LEX: STR end: A label
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID id2
Rule: nodeShapeNLabel:  [ A label ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id { typeStr: [32m'[]'[39m, label: [32m'A label'[39m }
Rule: nodeStatement (node)  { id: [32m'id'[39m, label: [32m'A label'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Lex: EOF
Rule: node (NODE_ID separator):  id2
Rule: nodeStatement (node)  { id: [32m'id2'[39m }
Rule: statement:  {
  id: [32m'id2'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id'[39m,
  label: [32m'A label'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id'[39m,
    label: [32m'A label'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id2'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with multiple nodes with edges abc123
Found block
.

Lex: NODE_ID id1
Lexa: [
Lex: Starting string
LEX: STR end: first
LEX: POPPING STR: "
Lex: ]
.
Lex: LINK #-->   #
Rule: nodeShapeNLabel:  [ first ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id1 { typeStr: [32m'[]'[39m, label: [32m'first'[39m }
Rule: nodeStatement (node)  { id: [32m'id1'[39m, label: [32m'first'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Rule: link:  -->    -->
Lex: NODE_ID id2
Lexa: [
Lex: Starting string
LEX: STR end: second
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ second ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id2 { typeStr: [32m'[]'[39m, label: [32m'second'[39m }
Rule: (nodeStatement link node)  {
  id: [32m'id1'[39m,
  label: [32m'first'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
} { edgeTypeStr: [32m'-->   '[39m, label: [32m''[39m } { id: [32m'id2'[39m, label: [32m'second'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }  typestr:  -->
Rule: statement:  [
  { id: [32m'id1'[39m, label: [32m'first'[39m, type: [32m'square'[39m, directions: [90mundefined[39m },
  {
    id: [32m'id1-id2'[39m,
    start: [32m'id1'[39m,
    end: [32m'id2'[39m,
    label: [32m''[39m,
    type: [32m'edge'[39m,
    directions: [90mundefined[39m,
    arrowTypeEnd: [32m'arrow_point'[39m,
    arrowTypeStart: [32m'arrow_open'[39m
  },
  { id: [32m'id2'[39m, label: [32m'second'[39m, type: [32m'square'[39m, directions: [90mundefined[39m }
]
Rule: hierarchy:  [
  { id: [32m'id1'[39m, label: [32m'first'[39m, type: [32m'square'[39m, directions: [90mundefined[39m },
  {
    id: [32m'id1-id2'[39m,
    start: [32m'id1'[39m,
    end: [32m'id2'[39m,
    label: [32m''[39m,
    type: [32m'edge'[39m,
    directions: [90mundefined[39m,
    arrowTypeEnd: [32m'arrow_point'[39m,
    arrowTypeStart: [32m'arrow_open'[39m
  },
  { id: [32m'id2'[39m, label: [32m'second'[39m, type: [32m'square'[39m, directions: [90mundefined[39m }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with multiple nodes with edges abc123
Found block
.

Lex: NODE_ID id1
Lexa: [
Lex: Starting string
LEX: STR end: first
LEX: POPPING STR: "
Lex: ]
.
Lex: START_LINK --
Rule: nodeShapeNLabel:  [ first ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id1 { typeStr: [32m'[]'[39m, label: [32m'first'[39m }
Rule: nodeStatement (node)  { id: [32m'id1'[39m, label: [32m'first'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Lex: Starting string
LEX: STR end: a label
LEX: POPPING STR: "
Lex: LINK # -->   #
Rule: LABEL link:  --  a label  -->
Lex: NODE_ID id2
Lexa: [
Lex: Starting string
LEX: STR end: second
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ second ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id2 { typeStr: [32m'[]'[39m, label: [32m'second'[39m }
Rule: (nodeStatement link node)  {
  id: [32m'id1'[39m,
  label: [32m'first'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
} { edgeTypeStr: [32m' -->   '[39m, label: [32m'a label'[39m } { id: [32m'id2'[39m, label: [32m'second'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }  typestr:   -->
Rule: statement:  [
  { id: [32m'id1'[39m, label: [32m'first'[39m, type: [32m'square'[39m, directions: [90mundefined[39m },
  {
    id: [32m'id1-id2'[39m,
    start: [32m'id1'[39m,
    end: [32m'id2'[39m,
    label: [32m'a label'[39m,
    type: [32m'edge'[39m,
    directions: [90mundefined[39m,
    arrowTypeEnd: [32m'arrow_point'[39m,
    arrowTypeStart: [32m'arrow_open'[39m
  },
  { id: [32m'id2'[39m, label: [32m'second'[39m, type: [32m'square'[39m, directions: [90mundefined[39m }
]
Rule: hierarchy:  [
  { id: [32m'id1'[39m, label: [32m'first'[39m, type: [32m'square'[39m, directions: [90mundefined[39m },
  {
    id: [32m'id1-id2'[39m,
    start: [32m'id1'[39m,
    end: [32m'id2'[39m,
    label: [32m'a label'[39m,
    type: [32m'edge'[39m,
    directions: [90mundefined[39m,
    arrowTypeEnd: [32m'arrow_point'[39m,
    arrowTypeStart: [32m'arrow_open'[39m
  },
  { id: [32m'id2'[39m, label: [32m'second'[39m, type: [32m'square'[39m, directions: [90mundefined[39m }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with column statements
Found block
.

COLUMNS (LEX) 2
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'2'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  2
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m2[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m2[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram without column statements
Found block
.

Lex: NODE_ID block1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with auto column statements
Found block
.

.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [33m-1[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m22[39m }
}
COLUMNS:  [33m-1[39m
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m-1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m-1[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > blocks next to each other
Found block
.

COLUMNS (LEX) 2
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'2'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  2
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID block2
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m2[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m2[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > blocks on top of each other
Found block
.

COLUMNS (LEX) 1
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID block2
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > compound blocks 2
Found block
.

Found block
.

Lex: NODE_ID aBlock
Lexa: [
Lex: Starting string
LEX: STR end: ABlock
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID bBlock
Rule: nodeShapeNLabel:  [ ABlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  aBlock { typeStr: [32m'[]'[39m, label: [32m'ABlock'[39m }
Rule: nodeStatement (node)  { id: [32m'aBlock'[39m, label: [32m'ABlock'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Lexa: [
Lex: Starting string
LEX: STR end: BBlock
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ BBlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  bBlock { typeStr: [32m'[]'[39m, label: [32m'BBlock'[39m }
Rule: nodeStatement (node)  { id: [32m'bBlock'[39m, label: [32m'BBlock'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Rule: statement:  {
  id: [32m'bBlock'[39m,
  label: [32m'BBlock'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'aBlock'[39m,
  label: [32m'ABlock'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Lex: EOF
Rule: blockStatement :  block [
  {
    id: [32m'aBlock'[39m,
    label: [32m'ABlock'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'bBlock'[39m,
    label: [32m'BBlock'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
] end

Rule: statement:  {
  id: [32m'id-rk7p4pnx8is-1'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    {
      id: [32m'aBlock'[39m,
      label: [32m'ABlock'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'bBlock'[39m,
      label: [32m'BBlock'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: hierarchy:  [
  {
    id: [32m'id-rk7p4pnx8is-1'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > compound blocks of compound blocks
Found block
.

Found block
.

Lex: NODE_ID aBlock
Lexa: [
Lex: Starting string
LEX: STR end: ABlock
LEX: POPPING STR: "
Lex: ]
.

Found block
Rule: nodeShapeNLabel:  [ ABlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  aBlock { typeStr: [32m'[]'[39m, label: [32m'ABlock'[39m }
Rule: nodeStatement (node)  { id: [32m'aBlock'[39m, label: [32m'ABlock'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
.

Lex: NODE_ID bBlock
Lexa: [
Lex: Starting string
LEX: STR end: BBlock
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ BBlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  bBlock { typeStr: [32m'[]'[39m, label: [32m'BBlock'[39m }
Rule: nodeStatement (node)  { id: [32m'bBlock'[39m, label: [32m'BBlock'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Rule: statement:  {
  id: [32m'bBlock'[39m,
  label: [32m'BBlock'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: blockStatement :  block [
  {
    id: [32m'bBlock'[39m,
    label: [32m'BBlock'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
] end

Rule: statement:  {
  id: [32m'id-h4m932wmjyl-2'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    {
      id: [32m'bBlock'[39m,
      label: [32m'BBlock'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: statement #2:  {
  id: [32m'aBlock'[39m,
  label: [32m'ABlock'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Lex: EOF
Rule: blockStatement :  block [
  {
    id: [32m'aBlock'[39m,
    label: [32m'ABlock'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id-h4m932wmjyl-2'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m ]
  }
] end

Rule: statement:  {
  id: [32m'id-huzun0mf308-3'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    {
      id: [32m'aBlock'[39m,
      label: [32m'ABlock'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'id-h4m932wmjyl-2'[39m,
      type: [32m'composite'[39m,
      label: [32m''[39m,
      children: [36m[Array][39m
    }
  ]
}
Rule: hierarchy:  [
  {
    id: [32m'id-huzun0mf308-3'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > compound blocks with title
Found block
.

Found id-block
Lex: NODE_ID compoundBlock
Lexa: [
Lex: Starting string
LEX: STR end: Compound block
LEX: POPPING STR: "
Lex: ]
.

COLUMNS (LEX) 1
Rule: nodeShapeNLabel:  [ Compound block ]
Rule: node (NODE_ID nodeShapeNLabel separator):  compoundBlock { typeStr: [32m'[]'[39m, label: [32m'Compound block'[39m }
Rule: nodeStatement (node)  {
  id: [32m'compoundBlock'[39m,
  label: [32m'Compound block'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
.

Lex: NODE_ID block2
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m3[39m, last_line: [33m3[39m, first_column: [33m12[39m, last_column: [33m21[39m }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Lex: EOF
Rule: id-block statement :  {
  id: [32m'compoundBlock'[39m,
  label: [32m'Compound block'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
} [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]
Rule: statement:  {
  id: [32m'compoundBlock'[39m,
  label: [32m'Compound block'[39m,
  type: [32m'composite'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m,
  children: [
    { type: [32m'column-setting'[39m, columns: [33m1[39m },
    {
      id: [32m'block2'[39m,
      label: [32m'Block 2'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: hierarchy:  [
  {
    id: [32m'compoundBlock'[39m,
    label: [32m'Compound block'[39m,
    type: [32m'composite'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m,
    children: [ [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-10 multiple types (circle)
10.941 : TRACE :  Long description: the root
10.941 : TRACE :  node end ))
10.941 : TRACE :  node found .. root
10.941 : DEBUG :  In get type (( ))
10.941 : INFO :  Node:  root
10.941 : INFO :  addNode [33m1[39m root the root [33m3[39m
10.941 : TRACE :  Stop NL
10.941 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-11 multiple types (cloud)
10.943 : TRACE :  Cloud Bang
10.943 : TRACE :  Long description: the root
10.943 : TRACE :  node end ((
10.943 : TRACE :  node found .. root
10.943 : DEBUG :  In get type ) (
10.943 : INFO :  Node:  root
10.943 : INFO :  addNode [33m1[39m root the root [33m4[39m
10.943 : TRACE :  Stop NL
10.943 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-12 multiple types (bang)
10.945 : TRACE :  Explosion Bang
10.945 : TRACE :  Long description: the root
10.945 : TRACE :  node end ((
10.945 : TRACE :  node found .. root
10.945 : DEBUG :  In get type )) ((
10.945 : INFO :  Node:  root
10.945 : INFO :  addNode [33m1[39m root the root [33m5[39m
10.945 : TRACE :  Stop NL
10.945 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-12-a multiple types (hexagon)
10.948 : TRACE :  Long description: the root
10.948 : TRACE :  node end ((
10.948 : TRACE :  node found .. root
10.948 : DEBUG :  In get type {{ }}
10.948 : INFO :  Node:  root
10.948 : INFO :  addNode [33m1[39m root the root [33m6[39m
10.948 : TRACE :  Stop NL
10.948 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-13 should be possible to set an icon for the node
10.950 : TRACE :  Long description: The root
10.950 : TRACE :  node end ... ]
10.950 : TRACE :  node found .. root
10.950 : DEBUG :  In get type [ ]
10.950 : INFO :  Node:  root
10.950 : INFO :  addNode [33m4[39m root The root [33m2[39m
10.950 : TRACE :  Stop NL
10.950 : TRACE :  Begin icon
10.950 : TRACE :  end icon
10.950 : TRACE :  Icon:  bomb
10.950 : TRACE :  Stop NL
10.950 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-14 should be possible to set classes for the node
10.954 : TRACE :  Long description: The root
10.954 : TRACE :  node end ... ]
10.954 : TRACE :  node found .. root
10.954 : DEBUG :  In get type [ ]
10.954 : INFO :  Node:  root
10.954 : INFO :  addNode [33m4[39m root The root [33m2[39m
10.954 : TRACE :  Stop NL
10.954 : TRACE :  Stop NL
10.954 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-15 should be possible to set both classes and icon for the node
10.957 : TRACE :  Long description: The root
10.957 : TRACE :  node end ... ]
10.957 : TRACE :  node found .. root
10.957 : DEBUG :  In get type [ ]
10.957 : INFO :  Node:  root
10.957 : INFO :  addNode [33m4[39m root The root [33m2[39m
10.957 : TRACE :  Stop NL
10.957 : TRACE :  Stop NL
10.957 : TRACE :  Begin icon
10.957 : TRACE :  end icon
10.957 : TRACE :  Icon:  bomb
10.957 : TRACE :  Stop NL
10.957 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-16 should be possible to set both classes and icon for the node
10.961 : TRACE :  Long description: The root
10.961 : TRACE :  node end ... ]
10.961 : TRACE :  node found .. root
10.961 : DEBUG :  In get type [ ]
10.961 : INFO :  Node:  root
10.961 : INFO :  addNode [33m4[39m root The root [33m2[39m
10.961 : TRACE :  Stop NL
10.961 : TRACE :  Begin icon
10.961 : TRACE :  end icon
10.961 : TRACE :  Icon:  bomb
10.961 : TRACE :  Stop NL
10.961 : TRACE :  Stop NL
10.961 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > descriptions > MMP-17 should be possible to use node syntax in the descriptions
10.965 : TRACE :  Starting NSTR
10.965 : TRACE :  description: String containing []
10.965 : TRACE :  node end ... ]
10.965 : TRACE :  node found .. root
10.965 : DEBUG :  In get type [ ]
10.965 : INFO :  Node:  root
10.965 : INFO :  addNode [33m4[39m root String containing [] [33m2[39m
10.965 : TRACE :  Stop NL
10.965 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > descriptions > MMP-18 should be possible to use node syntax in the descriptions in children
10.967 : TRACE :  Starting NSTR
10.967 : TRACE :  description: String containing []
10.967 : TRACE :  node end ... ]
10.967 : TRACE :  node found .. root
10.967 : DEBUG :  In get type [ ]
10.967 : INFO :  Node:  root
10.967 : INFO :  addNode [33m4[39m root String containing [] [33m2[39m
10.967 : TRACE :  Stop NL
10.967 : TRACE :  Starting NSTR
10.967 : TRACE :  description: String containing ()
10.967 : TRACE :  node end ... ]
10.967 : TRACE :  node found .. child1
10.967 : DEBUG :  In get type [ ]
10.967 : INFO :  Node:  child1
10.967 : INFO :  addNode [33m6[39m child1 String containing () [33m2[39m
10.967 : TRACE :  Stop NL
10.967 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > descriptions > MMP-19 should be possible to have a child after a class assignment
10.971 : TRACE :  Long description: Root
10.971 : TRACE :  node end )
10.971 : TRACE :  node found .. root
10.971 : DEBUG :  In get type ( )
10.971 : INFO :  Node:  root
10.971 : INFO :  addNode [33m2[39m root Root [33m1[39m
10.971 : TRACE :  Stop NL
10.971 : TRACE :  Long description: Child
10.971 : TRACE :  node end )
10.971 : TRACE :  node found .. Child
10.971 : DEBUG :  In get type ( )
10.971 : INFO :  Node:  Child
10.971 : INFO :  addNode [33m4[39m Child Child [33m1[39m
10.971 : TRACE :  Stop NL
10.971 : TRACE :  Stop NL
10.971 : TRACE :  Long description: a
10.971 : TRACE :  node end )
10.971 : TRACE :  node found .. a
10.971 : DEBUG :  In get type ( )
10.971 : INFO :  Node:  a
10.971 : INFO :  addNode [33m6[39m a a [33m1[39m
10.971 : TRACE :  Stop NL
10.971 : TRACE :  Long description: New Stuff
10.971 : TRACE :  node end ... ]
10.971 : TRACE :  node found .. b
10.971 : DEBUG :  In get type [ ]
10.971 : INFO :  Node:  b
10.971 : INFO :  addNode [33m6[39m b New Stuff [33m2[39m
10.971 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-20 should be possible to have meaningless empty rows in a mindmap abc124
10.977 : TRACE :  Long description: Root
10.977 : TRACE :  node end )
10.977 : TRACE :  node found .. root
10.977 : DEBUG :  In get type ( )
10.977 : INFO :  Node:  root
10.977 : INFO :  addNode [33m2[39m root Root [33m1[39m
10.977 : TRACE :  Stop NL
10.977 : TRACE :  Long description: Child
10.977 : TRACE :  node end )
10.977 : TRACE :  node found .. Child
10.977 : DEBUG :  In get type ( )
10.977 : INFO :  Node:  Child
10.977 : INFO :  addNode [33m4[39m Child Child [33m1[39m
10.977 : TRACE :  Stop NL
10.977 : TRACE :  Long description: a
10.977 : TRACE :  node end )
10.977 : TRACE :  SPACELINE
10.977 : TRACE :  node found .. a
10.977 : DEBUG :  In get type ( )
10.977 : INFO :  Node:  a
10.977 : INFO :  addNode [33m6[39m a a [33m1[39m
10.977 : TRACE :  Long description: New Stuff
10.977 : TRACE :  node end ... ]
10.977 : TRACE :  node found .. b
10.977 : DEBUG :  In get type [ ]
10.977 : INFO :  Node:  b
10.977 : INFO :  addNode [33m6[39m b New Stuff [33m2[39m
10.977 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-21 should be possible to have comments in a mindmap
10.983 : TRACE :  Long description: Root
10.983 : TRACE :  node end )
10.983 : TRACE :  node found .. root
10.983 : DEBUG :  In get type ( )
10.983 : INFO :  Node:  root
10.983 : INFO :  addNode [33m2[39m root Root [33m1[39m
10.983 : TRACE :  Stop NL
10.983 : TRACE :  Long description: Child
10.983 : TRACE :  node end )
10.983 : TRACE :  node found .. Child
10.983 : DEBUG :  In get type ( )
10.983 : INFO :  Node:  Child
10.983 : INFO :  addNode [33m4[39m Child Child [33m1[39m
10.983 : TRACE :  Stop NL
10.983 : TRACE :  Long description: a
10.983 : TRACE :  node end )
10.983 : TRACE :  Found comment

      %% This is a comment
10.983 : TRACE :  node found .. a
10.983 : DEBUG :  In get type ( )
10.983 : INFO :  Node:  a
10.983 : INFO :  addNode [33m6[39m a a [33m1[39m
10.983 : TRACE :  Stop NL2
10.983 : TRACE :  Long description: New Stuff
10.983 : TRACE :  node end ... ]
10.983 : TRACE :  node found .. b
10.983 : DEBUG :  In get type [ ]
10.983 : INFO :  Node:  b
10.983 : INFO :  addNode [33m6[39m b New Stuff [33m2[39m
10.983 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-22 should be possible to have comments at the end of a line
10.986 : TRACE :  Long description: Root
10.986 : TRACE :  node end )
10.986 : TRACE :  node found .. root
10.986 : DEBUG :  In get type ( )
10.986 : INFO :  Node:  root
10.986 : INFO :  addNode [33m2[39m root Root [33m1[39m
10.986 : TRACE :  Stop NL
10.986 : TRACE :  Long description: Child
10.986 : TRACE :  node end )
10.986 : TRACE :  node found .. Child
10.986 : DEBUG :  In get type ( )
10.986 : INFO :  Node:  Child
10.986 : INFO :  addNode [33m4[39m Child Child [33m1[39m
10.986 : TRACE :  Stop NL
10.986 : TRACE :  Long description: a
10.986 : TRACE :  node end )
10.986 : TRACE :  Found comment  %% This is a comment
10.986 : TRACE :  node found .. a
10.986 : DEBUG :  In get type ( )
10.986 : INFO :  Node:  a
10.986 : INFO :  addNode [33m6[39m a a [33m1[39m
10.986 : TRACE :  Stop NL2
10.986 : TRACE :  Long description: New Stuff
10.986 : TRACE :  node end ... ]
10.986 : TRACE :  node found .. b
10.986 : DEBUG :  In get type [ ]
10.986 : INFO :  Node:  b
10.986 : INFO :  addNode [33m6[39m b New Stuff [33m2[39m
10.986 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-23 Rows with only spaces should not interfere
10.994 : TRACE :  Node:  root
10.994 : INFO :  addNode [33m0[39m root root [33m0[39m
10.994 : TRACE :  Stop NL
10.994 : TRACE :  SPACELINE
10.994 : INFO :  Node:  A
10.994 : INFO :  addNode [33m1[39m A A [33m0[39m
10.994 : INFO :  Node:  B
10.994 : INFO :  addNode [33m1[39m B B [33m0[39m
10.994 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-24 Handle rows above the mindmap declarations
10.996 : TRACE :  SPACELINE
10.996 : TRACE :  Node:  root
10.996 : INFO :  addNode [33m0[39m root root [33m0[39m
10.996 : TRACE :  Stop NL
10.996 : TRACE :  SPACELINE
10.996 : INFO :  Node:  A
10.996 : INFO :  addNode [33m1[39m A A [33m0[39m
10.996 : INFO :  Node:  B
10.996 : INFO :  addNode [33m1[39m B B [33m0[39m
10.996 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-25 Handle rows above the mindmap declarations, no space
10.998 : TRACE :  SPACELINE
10.998 : TRACE :  Node:  root
10.998 : INFO :  addNode [33m0[39m root root [33m0[39m
10.998 : TRACE :  Stop NL
10.998 : TRACE :  SPACELINE
10.998 : INFO :  Node:  A
10.998 : INFO :  addNode [33m1[39m A A [33m0[39m
10.998 : INFO :  Node:  B
10.998 : INFO :  addNode [33m1[39m B B [33m0[39m
10.998 : TRACE :  Stop EOF

 âœ“ packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts (26 tests) 98ms
 âœ“ packages/mermaid/src/diagrams/requirement/requirementDb.spec.ts (9 tests) 11ms
stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > KNBN-1 should handle a simple root definition abc122
10.923 : INFO :  Node:  root
10.923 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > KNBN-2 should handle a hierarchical kanban definition
10.936 : INFO :  Node:  root
10.936 : TRACE :  Stop NL
10.936 : INFO :  Node:  child1
10.936 : TRACE :  Stop NL
10.936 : INFO :  Node:  child2
10.936 : TRACE :  Stop NL
10.936 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > 3 should handle a simple root definition with a shape and without an id abc123
10.945 : TRACE :  Long description: root
10.945 : TRACE :  node end )
10.945 : TRACE :  node found .. (
10.945 : DEBUG :  In get type ( )
10.945 : INFO :  Node:  root
10.945 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > KNBN-4 should not distinguish between deeper hierarchical levels in the kanban definition
10.948 : INFO :  Node:  root
10.948 : TRACE :  Stop NL
10.948 : INFO :  Node:  child1
10.948 : TRACE :  Stop NL
10.948 : INFO :  Node:  leaf1
10.948 : TRACE :  Stop NL
10.948 : INFO :  Node:  child2
10.948 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > 5 Multiple sections are ok
10.953 : INFO :  Node:  section1
10.953 : TRACE :  Stop NL
10.953 : INFO :  Node:  section2
10.953 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > KNBN-6 real root in wrong place
10.956 : INFO :  Node:  root
10.956 : TRACE :  Stop NL
10.956 : INFO :  Node:  fakeRoot
10.956 : TRACE :  Stop NL
10.956 : INFO :  Node:  realRootWrongPlace

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > nodes > KNBN-7 should handle an id and type for a node definition
10.961 : TRACE :  Long description: The root
10.961 : TRACE :  node end ... ]
10.961 : TRACE :  node found .. root
10.961 : DEBUG :  In get type [ ]
10.961 : INFO :  Node:  root
10.961 : TRACE :  Stop NL
10.961 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > nodes > KNBN-8 should handle an id and type for a node definition
10.965 : INFO :  Node:  root
10.965 : TRACE :  Stop NL
10.965 : TRACE :  Long description: child1
10.965 : TRACE :  node end )
10.965 : TRACE :  node found .. theId
10.965 : DEBUG :  In get type ( )
10.965 : INFO :  Node:  theId
10.965 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > nodes > KNBN-9 should handle an id and type for a node definition
10.970 : TRACE :  Node:  root
10.970 : TRACE :  Stop NL
10.970 : TRACE :  Long description: child1
10.970 : TRACE :  node end )
10.970 : TRACE :  node found .. theId
10.970 : DEBUG :  In get type ( )
10.969 : INFO :  Node:  theId
10.970 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-13 should be possible to set an icon for the node
10.974 : TRACE :  Long description: The root
10.974 : TRACE :  node end ... ]
10.974 : TRACE :  node found .. root
10.974 : DEBUG :  In get type [ ]
10.974 : INFO :  Node:  root
10.974 : TRACE :  Stop NL
10.974 : TRACE :  Begin icon
10.974 : TRACE :  end icon
10.974 : TRACE :  Icon:  bomb
10.974 : TRACE :  Stop NL
10.974 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-14 should be possible to set classes for the node
10.978 : TRACE :  Long description: The root
10.978 : TRACE :  node end ... ]
10.978 : TRACE :  node found .. root
10.978 : DEBUG :  In get type [ ]
10.978 : INFO :  Node:  root
10.978 : TRACE :  Stop NL
10.978 : TRACE :  Stop NL
10.978 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-15 should be possible to set both classes and icon for the node
10.981 : TRACE :  Long description: The root
10.981 : TRACE :  node end ... ]
10.981 : TRACE :  node found .. root
10.981 : DEBUG :  In get type [ ]
10.981 : INFO :  Node:  root
10.981 : TRACE :  Stop NL
10.981 : TRACE :  Stop NL
10.981 : TRACE :  Begin icon
10.981 : TRACE :  end icon
10.981 : TRACE :  Icon:  bomb
10.981 : TRACE :  Stop NL
10.981 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-16 should be possible to set both classes and icon for the node
10.985 : TRACE :  Long description: The root
10.985 : TRACE :  node end ... ]
10.985 : TRACE :  node found .. root
10.985 : DEBUG :  In get type [ ]
10.985 : INFO :  Node:  root
10.985 : TRACE :  Stop NL
10.985 : TRACE :  Begin icon
10.985 : TRACE :  end icon
10.985 : TRACE :  Icon:  bomb
10.985 : TRACE :  Stop NL
10.985 : TRACE :  Stop NL
10.985 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > descriptions > KNBN-17 should be possible to use node syntax in the descriptions
10.989 : TRACE :  Starting NSTR
10.989 : TRACE :  description: String containing []
10.989 : TRACE :  node end ... ]
10.989 : TRACE :  node found .. root
10.989 : DEBUG :  In get type [ ]
10.989 : INFO :  Node:  root
10.989 : TRACE :  Stop NL
10.989 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > descriptions > KNBN-18 should be possible to use node syntax in the descriptions in children
10.992 : TRACE :  Starting NSTR
10.992 : TRACE :  description: String containing []
10.992 : TRACE :  node end ... ]
10.992 : TRACE :  node found .. root
10.992 : DEBUG :  In get type [ ]
10.992 : INFO :  Node:  root
10.992 : TRACE :  Stop NL
10.992 : TRACE :  Starting NSTR
10.992 : TRACE :  description: String containing ()
10.992 : TRACE :  node end ... ]
10.992 : TRACE :  node found .. child1
10.992 : DEBUG :  In get type [ ]
10.992 : INFO :  Node:  child1
10.992 : TRACE :  Stop NL
10.992 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > descriptions > KNBN-19 should be possible to have a child after a class assignment
10.998 : TRACE :  Long description: Root
10.998 : TRACE :  node end )
10.998 : TRACE :  node found .. root
10.998 : DEBUG :  In get type ( )
10.998 : INFO :  Node:  root
10.998 : TRACE :  Stop NL
10.998 : TRACE :  Long description: Child
10.998 : TRACE :  node end )
10.998 : TRACE :  node found .. Child
10.998 : DEBUG :  In get type ( )
10.998 : INFO :  Node:  Child
10.998 : TRACE :  Stop NL
10.998 : TRACE :  Stop NL
10.998 : TRACE :  Long description: a
10.998 : TRACE :  node end )
10.998 : TRACE :  node found .. a
10.998 : DEBUG :  In get type ( )
10.998 : INFO :  Node:  a
10.998 : TRACE :  Stop NL
10.998 : TRACE :  Long description: New Stuff
10.998 : TRACE :  node end ... ]
10.998 : TRACE :  node found .. b
10.998 : DEBUG :  In get type [ ]
10.998 : INFO :  Node:  b
10.998 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-20 should be possible to have meaningless empty rows in a kanban abc124
11.003 : TRACE :  Long description: Root
11.003 : TRACE :  node end )
11.003 : TRACE :  node found .. root
11.003 : DEBUG :  In get type ( )
11.003 : INFO :  Node:  root
11.003 : TRACE :  Stop NL
11.003 : TRACE :  Long description: Child
11.003 : TRACE :  node end )
11.003 : TRACE :  node found .. Child
11.003 : DEBUG :  In get type ( )
11.003 : INFO :  Node:  Child
11.003 : TRACE :  Stop NL
11.003 : TRACE :  Long description: a
11.003 : TRACE :  node end )
11.003 : TRACE :  SPACELINE
11.003 : TRACE :  node found .. a
11.003 : DEBUG :  In get type ( )
11.003 : INFO :  Node:  a
11.003 : TRACE :  Long description: New Stuff
11.003 : TRACE :  node end ... ]
11.003 : TRACE :  node found .. b
11.003 : DEBUG :  In get type [ ]
11.003 : INFO :  Node:  b
11.003 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-21 should be possible to have comments in a kanban
11.007 : TRACE :  Long description: Root
11.007 : TRACE :  node end )
11.007 : TRACE :  node found .. root
11.007 : DEBUG :  In get type ( )
11.007 : INFO :  Node:  root
11.007 : TRACE :  Stop NL
11.007 : TRACE :  Long description: Child
11.007 : TRACE :  node end )
11.007 : TRACE :  node found .. Child
11.007 : DEBUG :  In get type ( )
11.007 : INFO :  Node:  Child
11.007 : TRACE :  Stop NL
11.007 : TRACE :  Long description: a
11.007 : TRACE :  node end )
11.007 : TRACE :  Found comment

      %% This is a comment
11.007 : TRACE :  node found .. a
11.007 : DEBUG :  In get type ( )
11.007 : INFO :  Node:  a
11.007 : TRACE :  Stop NL2
11.007 : TRACE :  Long description: New Stuff
11.007 : TRACE :  node end ... ]
11.007 : TRACE :  node found .. b
11.007 : DEBUG :  In get type [ ]
11.007 : INFO :  Node:  b
11.007 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-22 should be possible to have comments at the end of a line
11.011 : TRACE :  Long description: Root
11.011 : TRACE :  node end )
11.011 : TRACE :  node found .. root
11.011 : DEBUG :  In get type ( )
11.011 : INFO :  Node:  root
11.011 : TRACE :  Stop NL
11.011 : TRACE :  Long description: Child
11.011 : TRACE :  node end )
11.011 : TRACE :  node found .. Child
11.011 : DEBUG :  In get type ( )
11.011 : INFO :  Node:  Child
11.011 : TRACE :  Stop NL
11.011 : TRACE :  Long description: a
11.011 : TRACE :  node end )
11.011 : TRACE :  Found comment  %% This is a comment
11.011 : TRACE :  node found .. a
11.011 : DEBUG :  In get type ( )
11.011 : INFO :  Node:  a
11.011 : TRACE :  Stop NL2
11.011 : TRACE :  Long description: New Stuff
11.011 : TRACE :  node end ... ]
11.011 : TRACE :  node found .. b
11.011 : DEBUG :  In get type [ ]
11.011 : INFO :  Node:  b
11.011 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-23 Rows with only spaces should not interfere
11.016 : TRACE :  Node:  root
11.016 : TRACE :  Stop NL
11.016 : TRACE :  SPACELINE
11.016 : INFO :  Node:  A
11.016 : INFO :  Node:  B
11.016 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-24 Handle rows above the kanban declarations
11.019 : TRACE :  SPACELINE
11.019 : TRACE :  Node:  root
11.019 : TRACE :  Stop NL
11.019 : TRACE :  SPACELINE
11.019 : INFO :  Node:  A
11.019 : INFO :  Node:  B
11.019 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-25 Handle rows above the kanban declarations, no space
11.022 : TRACE :  SPACELINE
11.022 : TRACE :  Node:  root
11.022 : TRACE :  Stop NL
11.022 : TRACE :  SPACELINE
11.022 : INFO :  Node:  A
11.022 : INFO :  Node:  B
11.022 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-30 should be possible to set the priority
11.024 : INFO :  Node:  root
11.024 : TRACE :  Stop NL
11.024 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-31 should be possible to set the assignment
11.029 : INFO :  Node:  root
11.029 : TRACE :  Stop NL
11.029 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-32 should be possible to set the icon
11.030 : INFO :  Node:  root
11.030 : TRACE :  Stop NL
11.030 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-33 should be possible to set the icon
11.031 : INFO :  Node:  root
11.031 : TRACE :  Stop NL
11.031 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-34 should be possible to set the metadata using multiple lines
11.033 : INFO :  Node:  root
11.033 : TRACE :  Stop NL
11.033 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-35 should be possible to set the metadata using one line
11.034 : INFO :  Node:  root
11.034 : TRACE :  Stop NL
11.034 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-36 should be possible to set the label using the new syntax
11.036 : INFO :  Node:  root
11.036 : TRACE :  Stop NL
11.036 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-37 should be possible to set the external id
11.037 : INFO :  Node:  root
11.037 : TRACE :  Stop NL
11.037 : TRACE :  Stop EOF

 âœ“ packages/mermaid/src/diagrams/kanban/kanban.spec.ts (30 tests) 120ms
 âœ“ packages/mermaid/src/diagrams/user-journey/parser/journey.spec.js (7 tests) 36ms
stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > blocks mixed with compound blocks
Found block
.

COLUMNS (LEX) 1
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.


Found block
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
.

COLUMNS (LEX) 2
.

Lex: NODE_ID block2
APA123 {
  [32m'$'[39m: [32m'2'[39m,
  [32m'_$'[39m: { first_line: [33m6[39m, last_line: [33m6[39m, first_column: [33m12[39m, last_column: [33m21[39m }
}
COLUMNS:  2
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID block3
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 3
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ Block 3 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block3 { typeStr: [32m'[]'[39m, label: [32m'Block 3'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block3'[39m,
  label: [32m'Block 3'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block3'[39m,
  label: [32m'Block 3'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m2[39m }
Lex: EOF
Rule: blockStatement :  block [
  { type: [32m'column-setting'[39m, columns: [33m2[39m },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'block3'[39m,
    label: [32m'Block 3'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
] end

Rule: statement:  {
  id: [32m'id-5dcxeuqylc-5'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    { type: [32m'column-setting'[39m, columns: [33m2[39m },
    {
      id: [32m'block2'[39m,
      label: [32m'Block 2'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'block3'[39m,
      label: [32m'Block 3'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: statement #2:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id-5dcxeuqylc-5'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m, [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > Arrow blocks
Found block
.

COLUMNS (LEX) 3
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'3'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m8[39m, last_column: [33m17[39m }
}
COLUMNS:  3
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID blockArrow
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
LEX ARR START
LEX ARR: Starting string
LEX: STR end: &nbsp;&nbsp;&nbsp;
LEX: POPPING STR: "
Lex: =>BAE
Lex (right): dir: right
Lex (ARROW_DIR end): ]>
Rule: dirList:  right
Lex: NODE_ID block2
Rule: BLOCK_ARROW nodeShapeNLabel:  <[ &nbsp;&nbsp;&nbsp;  #3: [ [32m'right'[39m ] ]>
Rule: node (NODE_ID nodeShapeNLabel separator):  blockArrow {
  typeStr: [32m'<[]>'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  directions: [ [32m'right'[39m ]
}
Rule: nodeStatement (node)  {
  id: [32m'blockArrow'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  typeStr: [32m'<[]>'[39m,
  directions: [ [32m'right'[39m ]
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
Lex: EOF
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'blockArrow'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  type: [32m'block_arrow'[39m,
  directions: [ [32m'right'[39m ],
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m3[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m3[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'blockArrow'[39m,
    label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
    type: [32m'block_arrow'[39m,
    directions: [ [32m'right'[39m ],
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > Arrow blocks with multiple points
Found block
.

COLUMNS (LEX) 1
.

Lex: NODE_ID A
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m8[39m, last_column: [33m17[39m }
}
COLUMNS:  1
.

Lex: NODE_ID blockArrow
Rule: node (NODE_ID separator):  A
Rule: nodeStatement (node)  { id: [32m'A'[39m }
LEX ARR START
LEX ARR: Starting string
LEX: STR end: &nbsp;&nbsp;&nbsp;
LEX: POPPING STR: "
Lex: =>BAE
Lex (up): up
Lex (down): down
Lex (ARROW_DIR end): ]>
Rule: dirList:  down
Rule: dirList:  up [ [32m'down'[39m ]
Found block
Rule: BLOCK_ARROW nodeShapeNLabel:  <[ &nbsp;&nbsp;&nbsp;  #3: [ [32m'up'[39m, [32m'down'[39m ] ]>
Rule: node (NODE_ID nodeShapeNLabel separator):  blockArrow {
  typeStr: [32m'<[]>'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  directions: [ [32m'up'[39m, [32m'down'[39m ]
}
Rule: nodeStatement (node)  {
  id: [32m'blockArrow'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  typeStr: [32m'<[]>'[39m,
  directions: [ [32m'up'[39m, [32m'down'[39m ]
}
.

COLUMNS (LEX) 3
.

Lex: NODE_ID B
APA123 {
  [32m'$'[39m: [32m'3'[39m,
  [32m'_$'[39m: { first_line: [33m6[39m, last_line: [33m6[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  3
.

Lex: NODE_ID C
Rule: node (NODE_ID separator):  B
Rule: nodeStatement (node)  { id: [32m'B'[39m }
.

Lex: NODE_ID D
Rule: node (NODE_ID separator):  C
Rule: nodeStatement (node)  { id: [32m'C'[39m }
.

Rule: node (NODE_ID separator):  D
Rule: nodeStatement (node)  { id: [32m'D'[39m }
Rule: statement:  {
  id: [32m'D'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'C'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'B'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m3[39m }
Lex: EOF
Rule: blockStatement :  block [
  { type: [32m'column-setting'[39m, columns: [33m3[39m },
  {
    id: [32m'B'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'C'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'D'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
] end
Rule: statement:  {
  id: [32m'id-edumwvtvkd-6'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    { type: [32m'column-setting'[39m, columns: [33m3[39m },
    {
      id: [32m'B'[39m,
      label: [90mundefined[39m,
      type: [32m'na'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'C'[39m,
      label: [90mundefined[39m,
      type: [32m'na'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'D'[39m,
      label: [90mundefined[39m,
      type: [32m'na'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: statement #2:  {
  id: [32m'blockArrow'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  type: [32m'block_arrow'[39m,
  directions: [ [32m'up'[39m, [32m'down'[39m ],
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'A'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'A'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'blockArrow'[39m,
    label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
    type: [32m'block_arrow'[39m,
    directions: [ [32m'up'[39m, [32m'down'[39m ],
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id-edumwvtvkd-6'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m, [36m[Object][39m, [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > blocks with different widths
Found block
.

COLUMNS (LEX) 3
.

Lex: NODE_ID one
APA123 {
  [32m'$'[39m: [32m'3'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m8[39m, last_column: [33m17[39m }
}
COLUMNS:  3
Lexa: [
Lex: Starting string
LEX: STR end: One Slot
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID two
Rule: nodeShapeNLabel:  [ One Slot ]
Rule: node (NODE_ID nodeShapeNLabel separator):  one { typeStr: [32m'[]'[39m, label: [32m'One Slot'[39m }
Rule: nodeStatement (node)  { id: [32m'one'[39m, label: [32m'One Slot'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Lexa: [
Lex: Starting string
LEX: STR end: Two slots
LEX: POPPING STR: "
Lex: ]
Lex: COLON :2
Rule: nodeShapeNLabel:  [ Two slots ]
Rule: node (NODE_ID nodeShapeNLabel separator):  two { typeStr: [32m'[]'[39m, label: [32m'Two slots'[39m }
.

Lex: EOF
Rule: nodeStatement (abc88 node size)  { id: [32m'two'[39m, label: [32m'Two slots'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m } 2
Rule: statement:  {
  id: [32m'two'[39m,
  label: [32m'Two slots'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m2[39m
}
Rule: statement #2:  {
  id: [32m'one'[39m,
  label: [32m'One Slot'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m3[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m3[39m },
  {
    id: [32m'one'[39m,
    label: [32m'One Slot'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'two'[39m,
    label: [32m'Two slots'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m2[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > empty blocks
Found block
.

COLUMNS (LEX) 3
.

COLUMNS (LEX) 1
APA123 {
  [32m'$'[39m: [32m'3'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m8[39m, last_column: [33m17[39m }
}
COLUMNS:  3
.

Lex: NODE_ID middle
Lexa: [
Lex: Starting string
LEX: STR end: In the middle
LEX: POPPING STR: "
Lex: ]
.

COLUMNS (LEX) 1
Rule: nodeShapeNLabel:  [ In the middle ]
Rule: node (NODE_ID nodeShapeNLabel separator):  middle { typeStr: [32m'[]'[39m, label: [32m'In the middle'[39m }
Rule: nodeStatement (node)  {
  id: [32m'middle'[39m,
  label: [32m'In the middle'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
.

Lex: EOF
Rule: statement:  {
  id: [32m'id-j1wtn0kqgps-8'[39m,
  type: [32m'space'[39m,
  label: [32m''[39m,
  width: [33m1[39m,
  children: []
}
Rule: statement #2:  {
  id: [32m'middle'[39m,
  label: [32m'In the middle'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id-zovoakhh7n-7'[39m,
  type: [32m'space'[39m,
  label: [32m''[39m,
  width: [33m1[39m,
  children: []
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m3[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m3[39m },
  {
    id: [32m'id-zovoakhh7n-7'[39m,
    type: [32m'space'[39m,
    label: [32m''[39m,
    width: [33m1[39m,
    children: []
  },
  {
    id: [32m'middle'[39m,
    label: [32m'In the middle'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id-j1wtn0kqgps-8'[39m,
    type: [32m'space'[39m,
    label: [32m''[39m,
    width: [33m1[39m,
    children: []
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > classDef statements applied to a block
Found block
.

.


Lex: NODE_ID mc
Lexa: [
Lex: Starting string
LEX: STR end: Memcache
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ Memcache ]
Rule: node (NODE_ID nodeShapeNLabel separator):  mc { typeStr: [32m'[]'[39m, label: [32m'Memcache'[39m }
Rule: nodeStatement (node)  { id: [32m'mc'[39m, label: [32m'Memcache'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
.

Lex: EOF
Rule: statement:  { type: [32m'applyClass'[39m, id: [32m'mc'[39m, styleClass: [32m'black'[39m }
Rule: statement #2:  {
  id: [32m'mc'[39m,
  label: [32m'Memcache'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'classDef'[39m, id: [32m'black'[39m, css: [32m'color:#ffffff, fill:#000000;'[39m }
Rule: hierarchy:  [
  {
    type: [32m'classDef'[39m,
    id: [32m'black'[39m,
    css: [32m'color:#ffffff, fill:#000000;'[39m
  },
  {
    id: [32m'mc'[39m,
    label: [32m'Memcache'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  { type: [32m'applyClass'[39m, id: [32m'mc'[39m, styleClass: [32m'black'[39m }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > style statements applied to a block
Found block
.

COLUMNS (LEX) 1
.

Lex: NODE_ID B
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m0[39m, last_column: [33m9[39m }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: A wide one in the middle
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ A wide one in the middle ]
Rule: node (NODE_ID nodeShapeNLabel separator):  B { typeStr: [32m'[]'[39m, label: [32m'A wide one in the middle'[39m }
Rule: nodeStatement (node)  {
  id: [32m'B'[39m,
  label: [32m'A wide one in the middle'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
.

Lex: EOF
Rule: statement:  {
  type: [32m'applyStyles'[39m,
  id: [32m'B'[39m,
  stylesStr: [32m'fill:#f9F,stroke:#333,stroke-width:4px'[39m
}
Rule: statement #2:  {
  id: [32m'B'[39m,
  label: [32m'A wide one in the middle'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'B'[39m,
    label: [32m'A wide one in the middle'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    type: [32m'applyStyles'[39m,
    id: [32m'B'[39m,
    stylesStr: [32m'fill:#f9F,stroke:#333,stroke-width:4px'[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > should log a warning when block width exceeds column width
Found block-beta
.

COLUMNS (LEX) 1
.

Lex: NODE_ID A
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m2[39m, last_column: [33m11[39m }
}
COLUMNS:  1
Lex: COLON :1
Rule: node (NODE_ID separator):  A
.

Lex: NODE_ID B
Rule: nodeStatement (abc88 node size)  { id: [32m'A'[39m } 1
Lex: COLON :2
Rule: node (NODE_ID separator):  B
.

Lex: NODE_ID C
Rule: nodeStatement (abc88 node size)  { id: [32m'B'[39m } 2
Lex: COLON :3
Rule: node (NODE_ID separator):  C
.

Lex: NODE_ID D
Rule: nodeStatement (abc88 node size)  { id: [32m'C'[39m } 3
Lex: COLON :4
Rule: node (NODE_ID separator):  D
.

Lex: NODE_ID E
Rule: nodeStatement (abc88 node size)  { id: [32m'D'[39m } 4
Lex: COLON :3
Rule: node (NODE_ID separator):  E
.

Lex: NODE_ID F
Rule: nodeStatement (abc88 node size)  { id: [32m'E'[39m } 3
Lex: COLON :2
Rule: node (NODE_ID separator):  F
.

Lex: NODE_ID G
Rule: nodeStatement (abc88 node size)  { id: [32m'F'[39m } 2
Lex: COLON :1
Rule: node (NODE_ID separator):  G
Lex: EOF
Rule: nodeStatement (abc88 node size)  { id: [32m'G'[39m } 1
Rule: statement:  {
  id: [32m'G'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'F'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m2[39m
}
Rule: statement #2:  {
  id: [32m'E'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m3[39m
}
Rule: statement #2:  {
  id: [32m'D'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m4[39m
}
Rule: statement #2:  {
  id: [32m'C'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m3[39m
}
Rule: statement #2:  {
  id: [32m'B'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m2[39m
}
Rule: statement #2:  {
  id: [32m'A'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'A'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'B'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m2[39m
  },
  {
    id: [32m'C'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m3[39m
  },
  {
    id: [32m'D'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m4[39m
  },
  {
    id: [32m'E'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m3[39m
  },
  {
    id: [32m'F'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m2[39m
  },
  {
    id: [32m'G'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > prototype properties > should work with a __proto__ property
Found block
.

Lex: NODE_ID __proto__
Lex: EOF
Rule: node (NODE_ID separator):  __proto__
Rule: nodeStatement (node)  { id: [32m'__proto__'[39m }
Rule: statement:  {
  id: [32m'__proto__'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'__proto__'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]
Found block
.

Lex: NODE_ID A;
.
Rule: node (NODE_ID separator):  A;
Rule: nodeStatement (node)  { id: [32m'A;'[39m }
Lex: EOF
Rule: statement:  {
  type: [32m'classDef'[39m,
  id: [32m'__proto__'[39m,
  css: [32m'color:#ffffff,fill:#000000; class A __proto__'[39m
}
Rule: statement #2:  {
  id: [32m'A;'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'A;'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    type: [32m'classDef'[39m,
    id: [32m'__proto__'[39m,
    css: [32m'color:#ffffff,fill:#000000; class A __proto__'[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > prototype properties > should work with a constructor property
Found block
.

Lex: NODE_ID constructor
Lex: EOF
Rule: node (NODE_ID separator):  constructor
Rule: nodeStatement (node)  { id: [32m'constructor'[39m }
Rule: statement:  {
  id: [32m'constructor'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'constructor'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]
Found block
.

Lex: NODE_ID A;
.
Rule: node (NODE_ID separator):  A;
Rule: nodeStatement (node)  { id: [32m'A;'[39m }
Lex: EOF
Rule: statement:  {
  type: [32m'classDef'[39m,
  id: [32m'constructor'[39m,
  css: [32m'color:#ffffff,fill:#000000; class A constructor'[39m
}
Rule: statement #2:  {
  id: [32m'A;'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'A;'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    type: [32m'classDef'[39m,
    id: [32m'constructor'[39m,
    css: [32m'color:#ffffff,fill:#000000; class A constructor'[39m
  }
]

 âœ“ packages/mermaid/src/diagrams/block/parser/block.spec.ts (25 tests) 77ms
 âœ“ packages/mermaid/src/diagrams/class/classTypes.spec.ts (93 tests) 67ms
 âœ“ packages/mermaid/src/diagrams/git/gitGraphRenderer.ts (30 tests) 15ms
 âœ“ packages/mermaid/src/diagrams/c4/parser/c4Person.spec.js (7 tests) 27ms
 âœ“ packages/mermaid/src/diagrams/c4/parser/c4PersonExt.spec.js (7 tests) 28ms
 âœ“ packages/mermaid/src/diagrams/c4/parser/c4Diagram.spec.js (3 tests) 19ms
 âœ“ packages/mermaid/src/diagrams/user-journey/journeyDb.spec.js (9 tests) 17ms
 âœ“ packages/mermaid/src/diagrams/class/classDiagram-styles.spec.js (10 tests) 76ms
 âœ“ packages/mermaid/src/diagrams/c4/parser/c4Boundary.spec.js (6 tests) 32ms
 âœ“ packages/mermaid/src/utils/subGraphTitleMargins.spec.ts (1 test) 7ms
 âœ“ packages/mermaid/src/diagrams/c4/parser/c4System.spec.js (42 tests) 71ms
 âœ“ packages/mermaid/src/diagrams/requirement/parser/requirementDiagram.spec.js (43 tests) 66ms
 âœ“ packages/mermaid/src/diagrams/c4/parser/c4Container.spec.js (48 tests) 96ms
 âœ“ packages/mermaid/src/diagrams/gantt/parser/gantt.spec.js (27 tests) 99ms
 âœ“ packages/mermaid/src/diagrams/timeline/timeline.spec.js (8 tests) 40ms
 âœ“ packages/mermaid/src/diagrams/sankey/parser/sankey.spec.ts (4 tests) 170ms
 âœ“ packages/mermaid/src/diagrams/block/layout.spec.ts (1 test) 5ms
 âœ“ packages/mermaid/src/diagrams/sequence/svgDraw.spec.js (6 tests) 24ms
stdout | packages/mermaid/src/dagre-wrapper/edges.spec.js > Graphlib decorations > intersection > case 1 - intersection on left edge of box
11.518 : DEBUG :  intersection calc abc89:
  outsidePoint: {"x":31,"y":143.2257070163421}
  insidePoint : {"x":99.3359375,"y":100}
  node        : x:171 y:100 w:210 h:184
11.518 : DEBUG :  sides calc abc89, Q 43.22570701634211, q 22.139152558958802, R 68.3359375, r 35 { _x: [33m66[39m, _y: [33m122.1391525589588[39m }

stdout | packages/mermaid/src/dagre-wrapper/edges.spec.js > Graphlib decorations > intersection > case 2 - intersection on left edge of box
11.525 : DEBUG :  intersection calc abc89:
  outsidePoint: {"x":310.2578125,"y":169.88002060631462}
  insidePoint : {"x":127.96875,"y":100}
  node        : x:100.23046875 y:176.75 w:184.4609375 h:337.5
11.525 : DEBUG :  sides calc abc89, Q 69.88002060631462, q 45.15711441743504, R 182.2890625, r 117.796875 { _x: [33m192.4609375[39m, _y: [33m145.15711441743503[39m }

stdout | packages/mermaid/src/dagre-wrapper/edges.spec.js > Graphlib decorations > intersection > case 3 - intersection on top of box outside point greater than inside point
11.526 : DEBUG :  intersection calc abc89:
  outsidePoint: {"x":157,"y":39}
  insidePoint : {"x":104,"y":105}
  node        : x:114 y:164 w:212 h:176
11.526 : DEBUG :  abc89 topp/bott calc, Q 66, q 37, R 53, r 29.71212121212121 { x: [33m133.71212121212122[39m, y: [33m76[39m }

stdout | packages/mermaid/src/dagre-wrapper/edges.spec.js > Graphlib decorations > intersection > case 4 - intersection on top of box inside point greater than inside point
11.527 : DEBUG :  intersection calc abc89:
  outsidePoint: {"x":144,"y":38}
  insidePoint : {"x":198,"y":105}
  node        : x:114 y:164 w:212 h:176
11.527 : DEBUG :  abc89 topp/bott calc, Q 67, q 38, R 54, r 30.62686567164179 { x: [33m174.62686567164178[39m, y: [33m76[39m }

 âœ“ packages/mermaid/src/dagre-wrapper/edges.spec.js (4 tests) 13ms
 âœ“ packages/mermaid/src/diagrams/gantt/ganttDb.spec.ts (43 tests) 63ms
 âœ“ packages/mermaid/src/diagrams/info/info.spec.ts (4 tests) 220ms
 âœ“ packages/mermaid/src/diagrams/quadrant-chart/quadrantDb.spec.ts (4 tests) 12ms
 âœ“ packages/mermaid-example-diagram/src/exampleDiagram.spec.js (1 test) 5ms
 âœ“ packages/mermaid/src/diagrams/class/svgDraw.spec.js (2 tests) 6ms
 âœ“ packages/mermaid/src/diagrams/class/parser/class.spec.js (3 tests) 23ms
 âœ“ packages/mermaid/src/setupGraphViewbox.spec.js (2 tests) 6ms
 âœ“ packages/mermaid/src/diagrams/er/erRenderer.spec.ts (1 test) 6ms
 âœ“ packages/mermaid/src/diagrams/git/gitGraphParser.ts (6 tests) 15ms
 âœ“ packages/mermaid/src/diagram-api/diagram-orchestration.spec.ts (24 tests) 26ms
 âœ“ packages/mermaid/src/diagrams/pie/pie.spec.ts (16 tests | 2 skipped) 116ms
 âœ“ packages/mermaid/src/utils.spec.ts (53 tests) 146ms
 âœ“ packages/mermaid/src/diagrams/git/gitGraph.spec.ts (69 tests | 4 skipped) 381ms
 âœ“ packages/mermaid/src/diagrams/er/parser/erDiagram.spec.js (611 tests | 1 skipped) 501ms
 âœ“ packages/mermaid/src/diagrams/packet/packet.spec.ts (15 tests) 274ms
 âœ“ packages/parser/tests/info.test.ts (12 tests) 21ms
 âœ“ packages/parser/tests/packet.test.ts (8 tests) 21ms
 âœ“ packages/parser/tests/treemap.test.ts (17 tests) 37ms
 âœ“ packages/parser/tests/architecture.test.ts (12 tests) 42ms
 âœ“ packages/mermaid/src/diagram-api/diagramAPI.spec.ts (3 tests) 418ms
 âœ“ packages/parser/tests/gitGraph.test.ts (27 tests) 49ms
 âœ“ packages/parser/tests/pie.test.ts (32 tests) 54ms
 âœ“ packages/mermaid/src/diagrams/architecture/architecture.spec.ts (6 tests) 117ms
 âœ“ packages/parser/tests/radar.test.ts (80 tests) 92ms
 âœ“ packages/examples/src/example.spec.ts (1 test) 10ms
 âœ“ packages/mermaid/src/diagrams/radar/radar.spec.ts (19 tests) 209ms
 âœ“ packages/mermaid/src/diagrams/class/classDiagram.spec.ts (368 tests | 1 skipped) 1419ms
 â¯ packages/mermaid/scripts/docs.spec.ts (0 test)
 âœ“ packages/mermaid/src/rendering-util/rendering-elements/nodes.spec.ts (39 tests) 20ms
 âœ“ packages/mermaid/src/rendering-util/createText.spec.ts (5 tests) 39ms
 âœ“ packages/mermaid/src/diagrams/flowchart/flowDb.spec.ts (13 tests) 35ms
 âœ“ packages/mermaid/src/diagrams/sequence/sequenceDiagram.spec.js (104 tests) 842ms
 âœ“ packages/mermaid/src/diagrams/state/stateDb.spec.js (6 tests) 30ms
 â†“ packages/mermaid/src/diagrams/flowchart/parser/flow-huge.spec.js (1 test | 1 skipped)
 âœ“ packages/mermaid/src/diagrams/state/parser/state-parser.spec.js (9 tests) 57ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-md-string.spec.js (2 tests) 27ms
 âœ“ packages/mermaid/src/diagrams/state/parser/state-style.spec.js (15 tests) 65ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-direction.spec.js (4 tests) 32ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-comments.spec.js (9 tests) 32ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-vertice-chaining.spec.js (7 tests) 42ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-arrows.spec.js (14 tests) 62ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/subgraph.spec.js (22 tests | 1 skipped) 73ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-lines.spec.js (12 tests) 65ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-interactions.spec.js (13 tests) 61ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-style.spec.js (24 tests) 79ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-node-data.spec.js (31 tests | 1 skipped) 121ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow.spec.js (25 tests) 114ms
 âœ“ packages/mermaid/src/diagrams/state/stateDiagram.spec.js (30 tests | 1 skipped) 237ms
 âœ“ packages/mermaid/src/diagrams/state/stateDiagram-v2.spec.js (31 tests) 304ms
 âœ“ packages/mermaid/src/diagram.spec.ts (6 tests) 1623ms
   âœ“ diagram detection > should detect inbuilt diagrams 1580ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-singlenode.spec.js (148 tests) 301ms
 âœ“ packages/mermaid/src/styles.spec.ts (81 tests) 1322ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-edges.spec.js (293 tests) 500ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-text.spec.js (342 tests) 586ms
 âœ“ packages/mermaid/src/mermaid.spec.ts (13 tests) 1050ms
   âœ“ when using mermaid and  > when using #registerExternalDiagrams > should throw error (but still render) if registerExternalDiagrams fails 964ms
 âœ“ packages/mermaid/src/mermaidAPI.spec.ts (78 tests) 1692ms
   âœ“ mermaidAPI > render > accessibility > classDiagram > should set aria-roledescription to the diagram type AND should call addSVGa11yTitleDescription 389ms

âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯ Failed Suites 1 âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯

 FAIL  packages/mermaid/scripts/docs.spec.ts [ packages/mermaid/scripts/docs.spec.ts ]
Error: ENOENT: no such file or directory, open '../mermaid/package.json'
 â¯ packages/mermaid/scripts/docs.mts:61:51
     59| const { shapesDefs } = await import('../src/rendering-util/rendering-eâ€¦
     60|
     61| export const MERMAID_RELEASE_VERSION = JSON.parse(readFileSync('../merâ€¦
       |                                                   ^
     62|   .version as string;
     63| const MERMAID_MAJOR_VERSION = MERMAID_RELEASE_VERSION.split('.')[0];
 â¯ packages/mermaid/scripts/docs.spec.ts:1:1

âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[1/1]âŽ¯


 Test Files  1 failed | 96 passed | 1 skipped (98)
      Tests  3544 passed | 10 skipped | 2 todo (3556)
   Start at  16:07:56
   Duration  9.08s (transform 45.94s, setup 0ms, collect 318.63s, tests 15.82s, environment 108.78s, prepare 18.97s)

â€‰ELIFECYCLEâ€‰ Test failed. See above for more details.
