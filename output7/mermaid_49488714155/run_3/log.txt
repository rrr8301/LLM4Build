Scope: all 10 workspace projects
Lockfile is up to date, resolution step is skipped
Already up to date

â•­ Warning â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®â”‚                                                                              â”‚â”‚   Ignored build scripts: unrs-resolver.                                      â”‚â”‚   Run "pnpm approve-builds" to pick which dependencies should be allowed     â”‚â”‚   to run scripts.                                                            â”‚â”‚                                                                              â”‚â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯

. prepare$ husky && pnpm build
. prepare: > mermaid-monorepo@10.2.4 build /usr/src/app
. prepare: > pnpm build:esbuild && pnpm build:types
. prepare: > mermaid-monorepo@10.2.4 build:esbuild /usr/src/app
. prepare: > pnpm run -r clean && tsx .esbuild/build.ts
. prepare: Scope: 9 of 10 workspace projects
. prepare: packages/parser clean$ rimraf dist src/language/generated
. prepare: packages/tiny clean$ rimraf dist
. prepare: packages/parser clean: Done
. prepare: packages/tiny clean: Done
. prepare: packages/mermaid clean$ rimraf dist
. prepare: packages/mermaid clean: Done
. prepare: packages/examples clean$ rimraf dist
. prepare: packages/mermaid-zenuml clean$ rimraf dist
. prepare: packages/mermaid-zenuml clean: Done
. prepare: packages/examples clean: Done
. prepare: Reading config from /usr/src/app/packages/parser/langium-config.json
. prepare: src/language/info/info.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/info/info.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/info/info.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/common/common.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/common/common.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/common/common.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/packet/packet.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/packet/packet.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/packet/packet.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/pie/pie.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/pie/pie.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/pie/pie.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/architecture/architecture.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/architecture/architecture.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/architecture/architecture.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:29:15 - Found multiple assignments to 'id' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:30:18 - Found multiple assignments to 'message' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:32:18 - Found multiple assignments to 'type' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:42:15 - Found multiple assignments to 'id' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:44:18 - Found multiple assignments to 'type' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:53:15 - Found multiple assignments to 'id' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/gitGraph/gitGraph.langium:55:20 - Found multiple assignments to 'parent' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/radar/radar.langium:11:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/radar/radar.langium:11:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/radar/radar.langium:11:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:5 - Found multiple assignments to 'accDescr' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:26 - Found multiple assignments to 'accTitle' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:14:47 - Found multiple assignments to 'title' with the '=' assignment operator. Consider using '+=' instead to prevent data loss.
. prepare: src/language/treemap/treemap.langium:17:10 - This rule is declared but never referenced.
. prepare: Writing generated files to /usr/src/app/packages/parser/src/language/generated
. prepare: [16:02:38] Langium generator finished successfully in 467ms
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-FPAJGGOC.mjs    75.6kb
. prepare:   packages/parser/dist/mermaid-parser.core.mjs                           5.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-FWNWRKHM.mjs     3.8kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-O7ZBX7Z2.mjs     1.9kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-T53DSG4Q.mjs     1.5kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-S6J4BHB3.mjs     1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-76Q3JFCE.mjs     1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-LHMN2FUI.mjs     1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/chunk-LBM3YZW2.mjs     1.2kb
. prepare:   ...parser/dist/chunks/mermaid-parser.core/architecture-U656AL7Q.mjs    185b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.core/gitGraph-F6HP7TQM.mjs    169b
. prepare:   ...ages/parser/dist/chunks/mermaid-parser.core/treemap-KMMF4GRG.mjs    165b
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/packet-BFZMPI3H.mjs    161b
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/radar-NHE76QYJ.mjs     157b
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/info-NVLQJR56.mjs      153b
. prepare:   packages/parser/dist/chunks/mermaid-parser.core/pie-7BOR55EZ.mjs       149b
. prepare:   ...es/parser/dist/chunks/mermaid-parser.core/chunk-FPAJGGOC.mjs.map  114.9kb
. prepare:   ...es/parser/dist/chunks/mermaid-parser.core/chunk-FWNWRKHM.mjs.map    8.6kb
. prepare:   packages/parser/dist/mermaid-parser.core.mjs.map                       5.3kb
. prepare:   ...es/parser/dist/chunks/mermaid-parser.core/chunk-O7ZBX7Z2.mjs.map    4.4kb
. prepare:   ...and 12 more output files...
. prepare: âš¡ Done in 48ms
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-CUV4ONQR.mjs    802.5kb
. prepare:   packages/parser/dist/mermaid-parser.esm.mjs                            5.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-AAKHKIIX.mjs      3.7kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-FJ76IR54.mjs      1.8kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-M7HE2OLO.mjs      1.5kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-DLEEDQTW.mjs      1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-VGLBXUVE.mjs      1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-B3PWJQJV.mjs      1.2kb
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/chunk-25RGGQC2.mjs      1.1kb
. prepare:   .../parser/dist/chunks/mermaid-parser.esm/architecture-3LUSXU7A.mjs    185b
. prepare:   ...ages/parser/dist/chunks/mermaid-parser.esm/gitGraph-QD2FAQA2.mjs    169b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/treemap-LTEPFSZC.mjs    165b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/packet-6CSEHWCI.mjs     161b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/radar-RQNMY3TF.mjs      157b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/info-GMZAA7BQ.mjs       153b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm/pie-NGLVWQ3N.mjs        149b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm/chunk-CUV4ONQR.mjs.map    1.7mb
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm/chunk-AAKHKIIX.mjs.map    8.5kb
. prepare:   packages/parser/dist/mermaid-parser.esm.mjs.map                        5.3kb
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm/chunk-FJ76IR54.mjs.map    4.3kb
. prepare:   ...and 12 more output files...
. prepare: âš¡ Done in 202ms
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-L3Q2QJVV.mjs  381.1kb
. prepare:   packages/parser/dist/mermaid-parser.esm.min.mjs                        3.5kb
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-MMNLCZD2.mjs    1.6kb
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-T7ZF25BJ.mjs    761b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-H6ZBQRVM.mjs    606b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-IHLWZL4V.mjs    470b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-OQZUXTEW.mjs    465b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-OHOCZHKG.mjs    463b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/chunk-BI2MPBQI.mjs    462b
. prepare:   ...ser/dist/chunks/mermaid-parser.esm.min/architecture-PMHMJ2ZY.mjs    132b
. prepare:   .../parser/dist/chunks/mermaid-parser.esm.min/gitGraph-EH3HN3AX.mjs    124b
. prepare:   ...s/parser/dist/chunks/mermaid-parser.esm.min/treemap-KOFTZR4J.mjs    122b
. prepare:   ...es/parser/dist/chunks/mermaid-parser.esm.min/packet-AGCPRN6G.mjs    120b
. prepare:   ...ges/parser/dist/chunks/mermaid-parser.esm.min/radar-S7LXCSCY.mjs    118b
. prepare:   ...ages/parser/dist/chunks/mermaid-parser.esm.min/info-HLY6SS6Y.mjs    116b
. prepare:   packages/parser/dist/chunks/mermaid-parser.esm.min/pie-65AXTC64.mjs    114b
. prepare:   ...parser/dist/chunks/mermaid-parser.esm.min/chunk-L3Q2QJVV.mjs.map    1.8mb
. prepare:   ...parser/dist/chunks/mermaid-parser.esm.min/chunk-MMNLCZD2.mjs.map    8.8kb
. prepare:   packages/parser/dist/mermaid-parser.esm.min.mjs.map                    5.3kb
. prepare:   ...parser/dist/chunks/mermaid-parser.esm.min/chunk-T7ZF25BJ.mjs.map    4.7kb
. prepare:   ...and 12 more output files...
. prepare: âš¡ Done in 208ms
. prepare:   packages/mermaid/dist/chunks/mermaid.core/chunk-CV3G5MRU.mjs         190.3kb
. prepare:   ...es/mermaid/dist/chunks/mermaid.core/sequenceDiagram-4MX5Z3NR.mjs  149.9kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/blockDiagram-ZYB65J3Q.mjs  134.2kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/chunk-VIW5F6AA.mjs         130.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/c4Diagram-AAMF2YG6.mjs     117.7kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/flowDiagram-THRYKUMA.mjs   102.3kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/chunk-MRT3R2DC.mjs          91.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/chunk-JBRWN2VN.mjs          77.6kb
. prepare:   ...ges/mermaid/dist/chunks/mermaid.core/xychartDiagram-FDP5SA34.mjs   72.3kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/ganttDiagram-WV7ZQ7D5.mjs   71.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/chunk-LXBSTHXV.mjs          70.1kb
. prepare:   ...es/mermaid/dist/chunks/mermaid.core/gitGraphDiagram-OJR772UL.mjs   61.4kb
. prepare:   ...es/mermaid/dist/chunks/mermaid.core/quadrantDiagram-YPSRARAO.mjs   61.1kb
. prepare:   ...mermaid/dist/chunks/mermaid.core/requirementDiagram-EGVEC5DT.mjs   51.8kb
. prepare:   packages/mermaid/dist/chunks/mermaid.core/erDiagram-HZWUO2LU.mjs      46.6kb
. prepare:   ...ermaid/dist/chunks/mermaid.core/timeline-definition-3HZDQTIS.mjs   45.6kb
. prepare:   ...ges/mermaid/dist/chunks/mermaid.core/journeyDiagram-FFXJYRFH.mjs   44.9kb
. prepare:   ...mermaid/dist/chunks/mermaid.core/mindmap-definition-LNHGMQRG.mjs   43.4kb
. prepare:   ...ermaid/dist/chunks/mermaid.core/architectureDiagram-KFL7JDKH.mjs   43.3kb
. prepare:   packages/mermaid/dist/mermaid.core.mjs                                42.6kb
. prepare:   ...and 74 more output files...
. prepare: âš¡ Done in 1624ms
. prepare:   packages/mermaid/dist/mermaid.tiny.min.js  1.6mb âš ï¸
. prepare: âš¡ Done in 2875ms
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-MBJCTAW2.mjs      433.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-L6MQJ2ZU.mjs      346.9kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/katex-RV2QPRKB.mjs      270.1kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-F632ZYSZ.mjs      241.5kb
. prepare:   ...aid/dist/chunks/mermaid.esm.min/architectureDiagram-GXAZU6X5.mjs  148.2kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-DPMNACAB.mjs      115.1kb
. prepare:   ...maid/dist/chunks/mermaid.esm.min/mindmap-definition-75HPFGON.mjs  101.9kb
. prepare:   ...mermaid/dist/chunks/mermaid.esm.min/sequenceDiagram-NCT4EGAA.mjs   86.5kb
. prepare:   ...es/mermaid/dist/chunks/mermaid.esm.min/blockDiagram-HV7WRKX4.mjs   70.4kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/c4Diagram-S26XAWAN.mjs   68.8kb
. prepare:   ...ges/mermaid/dist/chunks/mermaid.esm.min/flowDiagram-7YKJRSJY.mjs   59.5kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-IXVBHSNP.mjs       57.1kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-44WDCOIT.mjs       44.3kb
. prepare:   ...es/mermaid/dist/chunks/mermaid.esm.min/ganttDiagram-5J5FM7L2.mjs   42.3kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-7LIB5WBN.mjs       41.4kb
. prepare:   .../mermaid/dist/chunks/mermaid.esm.min/xychartDiagram-WBSIB3YZ.mjs   38.1kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-S3YGE35Q.mjs       35.8kb
. prepare:   ...mermaid/dist/chunks/mermaid.esm.min/quadrantDiagram-5BXOXB7R.mjs   33.0kb
. prepare:   ...maid/dist/chunks/mermaid.esm.min/requirementDiagram-CG6N56KZ.mjs   29.7kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm.min/chunk-FASC7IG4.mjs       27.8kb
. prepare:   ...and 124 more output files...
. prepare: âš¡ Done in 3451ms
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-COUQ6RZ3.mjs          933.4kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-YOB5EFFC.mjs          697.6kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/katex-A6QSACVP.mjs          494.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-NC4V57XB.mjs          436.7kb
. prepare:   ...mermaid/dist/chunks/mermaid.esm/architectureDiagram-L76ZKZTK.mjs  417.2kb
. prepare:   .../mermaid/dist/chunks/mermaid.esm/mindmap-definition-KYUYEQSL.mjs  250.2kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-3AU3J4PQ.mjs          232.4kb
. prepare:   ...ges/mermaid/dist/chunks/mermaid.esm/sequenceDiagram-WN2LQSXR.mjs  150.1kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/blockDiagram-5FNOSGNS.mjs   134.2kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/c4Diagram-SNKOAWKG.mjs      117.8kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/flowDiagram-ADV24XW4.mjs    102.4kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-VNOTBLTU.mjs           93.4kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-W3YOBQ4T.mjs           91.0kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/ganttDiagram-NY35QN2E.mjs    81.8kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-TGZYFRKZ.mjs           78.5kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-JUNTMEQM.mjs           77.6kb
. prepare:   ...ages/mermaid/dist/chunks/mermaid.esm/xychartDiagram-LLVWJMIC.mjs   72.3kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-JRY5QETF.mjs           70.1kb
. prepare:   packages/mermaid/dist/chunks/mermaid.esm/chunk-IHYUGLNO.mjs           62.9kb
. prepare:   ...ges/mermaid/dist/chunks/mermaid.esm/gitGraphDiagram-36KJ7O45.mjs   61.7kb
. prepare:   ...and 124 more output files...
. prepare: âš¡ Done in 4068ms
. prepare:   packages/mermaid/dist/mermaid.js       6.1mb âš ï¸
. prepare:   packages/mermaid/dist/mermaid.js.map  10.1mb
. prepare: âš¡ Done in 4735ms
. prepare:   packages/mermaid/dist/mermaid.min.js       2.6mb âš ï¸
. prepare:   packages/mermaid/dist/mermaid.min.js.map  10.2mb
. prepare: âš¡ Done in 4799ms
. prepare:   ...unks/mermaid-example-diagram.core/diagram-definition-AUF2VOIT.mjs  22.5kb
. prepare:   ...ges/mermaid-example-diagram/dist/mermaid-example-diagram.core.mjs   557b
. prepare:   ...agram/dist/chunks/mermaid-example-diagram.core/chunk-AKMCXCCK.mjs   291b
. prepare:   .../mermaid-example-diagram.core/diagram-definition-AUF2VOIT.mjs.map  40.9kb
. prepare:   ...mermaid-example-diagram/dist/mermaid-example-diagram.core.mjs.map   786b
. prepare:   ...m/dist/chunks/mermaid-example-diagram.core/chunk-AKMCXCCK.mjs.map    93b
. prepare: âš¡ Done in 43ms
. prepare:   .../mermaid-example-diagram.esm.min/diagram-definition-2JINLXFM.mjs   53.0kb
. prepare:   ...mermaid-example-diagram/dist/mermaid-example-diagram.esm.min.mjs    355b
. prepare:   ...m/dist/chunks/mermaid-example-diagram.esm.min/chunk-D2P5M7FY.mjs    164b
. prepare:   ...maid-example-diagram.esm.min/diagram-definition-2JINLXFM.mjs.map  227.2kb
. prepare:   ...aid-example-diagram/dist/mermaid-example-diagram.esm.min.mjs.map    860b
. prepare:   ...st/chunks/mermaid-example-diagram.esm.min/chunk-D2P5M7FY.mjs.map     93b
. prepare: âš¡ Done in 105ms
. prepare:   ...unks/mermaid-example-diagram.esm/diagram-definition-ZN3FLJNS.mjs  109.0kb
. prepare:   ...ges/mermaid-example-diagram/dist/mermaid-example-diagram.esm.mjs    555b
. prepare:   ...agram/dist/chunks/mermaid-example-diagram.esm/chunk-6XSXFHVP.mjs    291b
. prepare:   .../mermaid-example-diagram.esm/diagram-definition-ZN3FLJNS.mjs.map  215.0kb
. prepare:   ...mermaid-example-diagram/dist/mermaid-example-diagram.esm.mjs.map    786b
. prepare:   ...m/dist/chunks/mermaid-example-diagram.esm/chunk-6XSXFHVP.mjs.map     93b
. prepare: âš¡ Done in 108ms
. prepare:   ...uml/dist/chunks/mermaid-zenuml.core/zenuml-definition-AWJE5BBT.mjs  3.2kb
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.core.mjs                   520b
. prepare:   .../mermaid-zenuml/dist/chunks/mermaid-zenuml.core/chunk-CJCKSLXZ.mjs  151b
. prepare:   ...dist/chunks/mermaid-zenuml.core/zenuml-definition-AWJE5BBT.mjs.map  6.7kb
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.core.mjs.map               765b
. prepare:   ...maid-zenuml/dist/chunks/mermaid-zenuml.core/chunk-CJCKSLXZ.mjs.map   93b
. prepare: âš¡ Done in 4ms
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.js      5.1mb âš ï¸
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.js.map  6.4mb
. prepare: âš¡ Done in 645ms
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.min.js      4.1mb âš ï¸
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.min.js.map  6.2mb
. prepare: âš¡ Done in 659ms
. prepare:   ...ml/dist/chunks/mermaid-zenuml.esm/zenuml-definition-H5KMDA2O.mjs  4.9mb âš ï¸
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.esm.mjs                  518b
. prepare:   ...mermaid-zenuml/dist/chunks/mermaid-zenuml.esm/chunk-OS44DIFC.mjs  151b
. prepare:   ...ist/chunks/mermaid-zenuml.esm/zenuml-definition-H5KMDA2O.mjs.map  6.4mb
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.esm.mjs.map              765b
. prepare:   ...aid-zenuml/dist/chunks/mermaid-zenuml.esm/chunk-OS44DIFC.mjs.map   93b
. prepare: âš¡ Done in 691ms
. prepare:   ...ist/chunks/mermaid-zenuml.esm.min/zenuml-definition-XJYTECJ4.mjs  4.1mb âš ï¸
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.esm.min.mjs              323b
. prepare:   ...aid-zenuml/dist/chunks/mermaid-zenuml.esm.min/chunk-VDOFMJQL.mjs   95b
. prepare:   ...chunks/mermaid-zenuml.esm.min/zenuml-definition-XJYTECJ4.mjs.map  6.2mb
. prepare:   packages/mermaid-zenuml/dist/mermaid-zenuml.esm.min.mjs.map          837b
. prepare:   ...zenuml/dist/chunks/mermaid-zenuml.esm.min/chunk-VDOFMJQL.mjs.map   93b
. prepare: âš¡ Done in 740ms
. prepare:   ...ayout-elk/dist/chunks/mermaid-layout-elk.core/render-M6WAID4X.mjs  26.7kb
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.core.mjs           543b
. prepare:   ...layout-elk/dist/chunks/mermaid-layout-elk.core/chunk-ZW26E7AF.mjs   151b
. prepare:   ...t-elk/dist/chunks/mermaid-layout-elk.core/render-M6WAID4X.mjs.map  52.2kb
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.core.mjs.map       827b
. prepare:   ...ut-elk/dist/chunks/mermaid-layout-elk.core/chunk-ZW26E7AF.mjs.map    93b
. prepare: âš¡ Done in 14ms
. prepare:   ...ayout-elk/dist/chunks/mermaid-layout-elk.esm/render-P27B6YR6.mjs  3.6mb âš ï¸
. prepare:   ...layout-elk/dist/chunks/mermaid-layout-elk.esm/chunk-TWI3KLJS.mjs  1.8kb
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.esm.mjs          541b
. prepare:   ...t-elk/dist/chunks/mermaid-layout-elk.esm/render-P27B6YR6.mjs.map  4.4mb
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.esm.mjs.map      827b
. prepare:   ...ut-elk/dist/chunks/mermaid-layout-elk.esm/chunk-TWI3KLJS.mjs.map   93b
. prepare: âš¡ Done in 816ms
. prepare:   ...t-elk/dist/chunks/mermaid-layout-elk.esm.min/render-DDKIELPE.mjs  1.6mb âš ï¸
. prepare:   ...ut-elk/dist/chunks/mermaid-layout-elk.esm.min/chunk-SP2CHFBE.mjs  854b
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.esm.min.mjs      356b
. prepare:   ...k/dist/chunks/mermaid-layout-elk.esm.min/render-DDKIELPE.mjs.map  4.9mb
. prepare:   packages/mermaid-layout-elk/dist/mermaid-layout-elk.esm.min.mjs.map  842b
. prepare:   ...lk/dist/chunks/mermaid-layout-elk.esm.min/chunk-SP2CHFBE.mjs.map   93b
. prepare: âš¡ Done in 866ms
. prepare:   packages/examples/dist/mermaid-examples.core.mjs      15.7kb
. prepare:   packages/examples/dist/mermaid-examples.core.mjs.map  24.8kb
. prepare: âš¡ Done in 10ms
. prepare:   packages/examples/dist/mermaid-examples.esm.mjs      15.7kb
. prepare:   packages/examples/dist/mermaid-examples.esm.mjs.map  24.8kb
. prepare: âš¡ Done in 10ms
. prepare:   packages/examples/dist/mermaid-examples.esm.min.mjs      13.2kb
. prepare:   packages/examples/dist/mermaid-examples.esm.min.mjs.map  24.5kb
. prepare: âš¡ Done in 10ms
. prepare: > mermaid-monorepo@10.2.4 build:types /usr/src/app
. prepare: > pnpm --filter mermaid types:build-config && tsx .build/types.ts
. prepare: > mermaid@11.10.0 types:build-config /usr/src/app/packages/mermaid
. prepare: > tsx scripts/create-types-from-json-schema.mts
. prepare: Writing typescript file to ./src/config.type.ts
. prepare: Building types for parser
. prepare: Building types for mermaid
. prepare: Building types for mermaid-example-diagram
. prepare: Building types for mermaid-zenuml
. prepare: Building types for mermaid-layout-elk
. prepare: Building types for examples
. prepare: Done
Done in 32.5s using pnpm v10.4.1

> mermaid-monorepo@10.2.4 test /usr/src/app
> pnpm lint && vitest run


> mermaid-monorepo@10.2.4 lint /usr/src/app
> eslint --quiet --stats --cache --cache-strategy content . && pnpm lint:jison && prettier --cache --check .


> mermaid-monorepo@10.2.4 lint:jison /usr/src/app
> tsx ./scripts/jison/lint.mts

Linting ./packages/mermaid-example-diagram/src/parser/exampleDiagram.jison
Linting ./packages/mermaid/src/diagrams/block/parser/block.jison
Linting ./packages/mermaid/src/diagrams/c4/parser/c4Diagram.jison
Linting ./packages/mermaid/src/diagrams/class/parser/classDiagram.jison
Linting ./packages/mermaid/src/diagrams/er/parser/erDiagram.jison
Linting ./packages/mermaid/src/diagrams/flowchart/parser/flow.jison
Linting ./packages/mermaid/src/diagrams/gantt/parser/gantt.jison
Linting ./packages/mermaid/src/diagrams/kanban/parser/kanban.jison
Linting ./packages/mermaid/src/diagrams/mindmap/parser/mindmap.jison
Linting ./packages/mermaid/src/diagrams/quadrant-chart/parser/quadrant.jison
Linting ./packages/mermaid/src/diagrams/requirement/parser/requirementDiagram.jison
Linting ./packages/mermaid/src/diagrams/sankey/parser/sankey.jison
Linting ./packages/mermaid/src/diagrams/timeline/parser/timeline.jison
Linting ./packages/mermaid/src/diagrams/sequence/parser/sequenceDiagram.jison
Linting ./packages/mermaid/src/diagrams/state/parser/stateDiagram.jison
Linting ./packages/mermaid/src/diagrams/xychart/parser/xychart.jison
Linting ./packages/mermaid/src/diagrams/user-journey/parser/journey.jison
Checking formatting...
All matched files use Prettier code style!
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid-example-diagram/src/exampleDiagramDb.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid-example-diagram/src/exampleDiagramRenderer.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid-example-diagram/src/styles.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/clusters.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/createLabel.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/edges.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/index.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/intersect/index.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-circle.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-ellipse.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-line.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-node.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-polygon.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/intersect/intersect-rect.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/markers.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/mermaid-graphlib.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/nodes.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/shapes/note.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/dagre-wrapper/shapes/util.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/c4/c4Db.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/c4/c4Renderer.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/c4/styles.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/c4/svgDraw.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/class/styles.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/er/erMarkers.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/er/erRenderer.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/gantt/ganttDb.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/gantt/ganttRenderer.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/gantt/styles.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/git/styles.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/requirement/styles.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/sankey/styles.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/sequence/styles.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/sequence/svgDraw.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/state/shapes.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/state/stateRenderer.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/state/styles.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/timeline/styles.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/timeline/svgDraw.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/timeline/timelineDb.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/user-journey/journeyDb.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/user-journey/styles.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/diagrams/user-journey/svgDraw.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/insertElementsForSize.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/layout-algorithms/dagre/index.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/clusters.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/createLabel.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/edges.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/index.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-circle.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-ellipse.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-line.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-node.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-polygon.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/intersect/intersect-rect.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/rendering-util/rendering-elements/markers.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/setupGraphViewbox.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/themes/index.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/themes/theme-base.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/themes/theme-dark.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/themes/theme-default.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/themes/theme-forest.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/themes/theme-helpers.js' because it would overwrite input file.
4:04:24 PM [vite] (client) warning: @rollup/plugin-typescript TS5055: Cannot write file '/usr/src/app/packages/mermaid/src/themes/theme-neutral.js' because it would overwrite input file.

 RUN  v3.0.6 /usr/src/app

 âœ“ packages/mermaid/src/utils/lineWithOffset.ts (2 tests) 9ms
 âœ“ packages/mermaid/src/utils/imperativeState.spec.ts (3 tests) 8ms
 âœ“ packages/mermaid/src/diagrams/treemap/utils.test.ts (4 tests) 12ms
 âœ“ packages/mermaid/src/rendering-util/splitText.spec.ts (35 tests) 46ms
 âœ“ packages/mermaid/src/diagrams/common/common.spec.ts (20 tests) 52ms
 âœ“ packages/mermaid/src/diagram-api/comments.spec.ts (5 tests) 23ms
 âœ“ packages/mermaid/src/rendering-util/rendering-elements/edgeMarker.spec.ts (5 tests) 9ms
 âœ“ packages/mermaid/src/dagre-wrapper/edgeMarker.spec.ts (5 tests) 15ms
 âœ“ packages/mermaid/src/diagrams/xychart/parser/xychart.jison.spec.ts (48 tests) 50ms
 âœ“ packages/mermaid/src/diagrams/quadrant-chart/parser/quadrant.jison.spec.ts (14 tests) 47ms
 âœ“ packages/mermaid/src/diagrams/flowchart/flowChartShapes.spec.js (11 tests) 25ms
 âœ“ packages/mermaid/src/diagram-api/frontmatter.spec.ts (12 tests) 44ms
 âœ“ packages/mermaid/src/docs/.vitepress/theme/redirect.spec.ts (28 tests) 30ms
stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
28.629 : DEBUG :  Opting in, graph
28.629 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
28.629 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
28.629 : DEBUG :  Not a cluster  c Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
28.629 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
28.629 : DEBUG :  Cluster identified C2 Map(2) { [32m'C1'[39m => [ [32m'a'[39m, [32m'b'[39m ], [32m'C2'[39m => [ [32m'c'[39m ] }
28.629 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
28.629 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
28.629 : WARN :  Cluster identified C1  Replacement id in edges:  a
28.629 : WARN :  Cluster identified C2  Replacement id in edges:  c
28.629 : WARN :  Edge a -> b: {"v":"a","w":"b"}
28.629 : WARN :  Edge a -> b: {}
28.629 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: a b Translating:  [90mundefined[39m  ---  [90mundefined[39m
28.629 : WARN :  Edge C1 -> C2: {"v":"C1","w":"C2"}
28.629 : WARN :  Edge C1 -> C2: {}
28.629 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: C1 C2 Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'c'[39m, clusterData: [90mundefined[39m }
28.629 : WARN :  Fixing and trying - removing XXX C1 C2 [90mundefined[39m
28.629 : WARN :  Fix Replacing with XXX C1 C2 [90mundefined[39m
28.629 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
} [33mfalse[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
28.629 : DEBUG :  Not a cluster a [33m0[39m
28.629 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
28.629 : DEBUG :  Not a cluster b [33m0[39m
28.629 : DEBUG :  Extracting node c Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
28.629 : DEBUG :  Not a cluster c [33m0[39m
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.629 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
28.629 : DEBUG :  Extracting node C1 Map(2) {
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
} [90mundefined[39m
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
28.629 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.629 : WARN :  Old graph before copy {
28.629 : INFO :  cp  a  to  C1  with parent  C1
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
28.629 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
28.629 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.629 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m }, { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
28.629 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m }
28.629 : INFO :  Edge data {} C1
28.629 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
28.629 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m }
28.629 : INFO :  Copying as  a b {} [90mundefined[39m
28.629 : INFO :  newGraph edges  [ { v: [32m'a'[39m, w: [32m'b'[39m } ] {}
28.629 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
28.629 : INFO :  Edge data {} C1
28.629 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
28.629 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
28.629 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
28.629 : DEBUG :  Removing node a
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.629 : INFO :  cp  b  to  C1  with parent  C1
28.629 : WARN :  Copying children of  C1 root C1 data [90mundefined[39m C1
28.629 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
28.629 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m, [32m'b'[39m ]
28.629 : WARN :  New graph after copy node: ( C1 ) {
28.629 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
28.629 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
  nodes: [ { v: [32m'a'[39m, value: {} }, { v: [32m'b'[39m, value: {} } ],
28.629 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} } ],
28.629 : INFO :  Edge data {} C1
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
28.629 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
}
28.629 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
28.629 : WARN :  Cluster without external connections, without a parent and with children C2 [33m0[39m
28.629 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
28.629 : WARN :  Old graph before copy {
28.629 : DEBUG :  Removing node b
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
28.629 : DEBUG :  Old graph after copy {
  nodes: [
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    { v: [32m'C2'[39m }
  nodes: [
  ],
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.629 : DEBUG :  Extracting node C2 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.629 : INFO :  cp  c  to  C2  with parent  C2
28.629 : INFO :  In copy  C2 root C2 data [90mundefined[39m C2
28.629 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.629 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
28.629 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
28.629 : INFO :  Edge data {} C2
28.629 : INFO :  Descendants of  C2  is  [ [32m'c'[39m ]
28.629 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
28.629 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
28.629 : DEBUG :  Removing node c
28.629 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'C1'[39m, value: [36m[Object][39m }, { v: [32m'C2'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.629 : DEBUG :  Done, no node has children [ [32m'a'[39m, [32m'b'[39m ]
28.629 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
28.629 : INFO :  [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]

  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.629 : WARN :  Copying children of  C2 root C2 data [90mundefined[39m C2
28.629 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'c'[39m ]
28.629 : WARN :  New graph after copy node: ( C2 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: {} } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.629 : WARN :  New list of nodes [ [32m'C1'[39m, [32m'C2'[39m ]
28.629 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: {}, b: {} },
    _parent: { a: [32m'\x00'[39m, b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {}, b: {} },
    _in: { a: {}, b: [36m[Object][39m },
    _preds: { a: {}, b: [36m[Object][39m },
    _out: { a: [36m[Object][39m, b: {} },
    _sucs: { a: [36m[Object][39m, b: {} },
    _edgeObjs: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'a\x01b\x01\x00'[39m: {} },
    _nodeCount: [33m2[39m,
    _edgeCount: [33m1[39m
  }
}
28.629 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: {} }, { v: [32m'b'[39m, value: {} } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.629 : WARN :   Now next level C2 {
  clusterNode: [33mtrue[39m,
  id: [32m'C2'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: {} },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.629 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: {} } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
28.631 : DEBUG :  Opting in, graph
28.631 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
28.631 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
28.631 : DEBUG :  Not a cluster  c { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
28.631 : DEBUG :  Cluster identified C1 { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
28.631 : DEBUG :  Cluster identified C2 { C1: [ [32m'a'[39m, [32m'b'[39m ], C2: [ [32m'c'[39m ] }
28.631 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
28.631 : DEBUG :  Extracting node a {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
28.631 : DEBUG :  Not a cluster a [33m0[39m
28.631 : DEBUG :  Extracting node b {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
28.631 : DEBUG :  Not a cluster b [33m0[39m
28.631 : DEBUG :  Extracting node c {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m {} [90mundefined[39m  Depth  [33m0[39m
28.631 : DEBUG :  Not a cluster c [33m0[39m
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should not detect edges between clusters after adjustment
28.631 : WARN :  Cluster identified C1  Replacement id in edges:  a
28.631 : WARN :  Cluster identified C2  Replacement id in edges:  c
28.631 : WARN :  Edge a -> b: {"v":"a","w":"b"}
28.631 : WARN :  Edge a -> b: {}
28.631 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: a b Translating:  [90mundefined[39m  ---  [90mundefined[39m
28.631 : WARN :  Edge C1 -> C2: {"v":"C1","w":"C2"}
28.631 : WARN :  Edge C1 -> C2: {}
28.631 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: C1 C2 Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'c'[39m, clusterData: [90mundefined[39m }
28.631 : WARN :  Fixing and trixing - removing XXX C1 C2 [90mundefined[39m
28.631 : WARN :  Fix Replacing with XXX C1 C2 [90mundefined[39m
28.631 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
28.631 : DEBUG :  Extracting node C1 {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.631 : INFO :  cp  a  to  C1  with parent  C1
28.631 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
28.631 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    { v: [32m'C1'[39m },
28.631 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m }, { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
    { v: [32m'C2'[39m }
28.631 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m }
  ],
28.631 : INFO :  Edge data {} C1
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
28.631 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
28.631 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m }
}
28.631 : INFO :  Copying as  a b {} [90mundefined[39m
28.631 : WARN :  extractor -  [33m0[39m {
28.631 : INFO :  newGraph edges  [ { v: [32m'a'[39m, w: [32m'b'[39m } ] {}
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
28.631 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
  nodes: [
28.631 : INFO :  Edge data {} C1
28.631 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
28.631 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
28.631 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
28.631 : DEBUG :  Removing node a
28.631 : INFO :  cp  b  to  C1  with parent  C1
28.631 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
28.631 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.631 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
28.631 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
28.631 : INFO :  Edge data {} C1
28.631 : INFO :  Descendants of  C1  is  [ [32m'a'[39m, [32m'b'[39m ]
28.631 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
28.631 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
28.631 : DEBUG :  Removing node b
28.631 : DEBUG :  Old graph after copy {
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
  nodes: [
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
    { v: [32m'C2'[39m }
  ],
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
}
28.631 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
28.631 : DEBUG :  Extracting node C2 {
28.631 : WARN :  Old graph before copy {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  C2: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
  nodes: [
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
    { v: [32m'a'[39m, value: {}, parent: [32m'C1'[39m },
28.631 : INFO :  cp  c  to  C2  with parent  C2
    { v: [32m'b'[39m, value: {}, parent: [32m'C1'[39m },
28.631 : INFO :  In copy  C2 root C2 data [90mundefined[39m C2
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
28.631 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    { v: [32m'C1'[39m },
28.631 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
    { v: [32m'C2'[39m }
28.631 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
  ],
28.631 : INFO :  Edge data {} C2
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} }, { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
28.631 : INFO :  Descendants of  C2  is  [ [32m'c'[39m ]
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
28.631 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
28.631 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
28.631 : DEBUG :  Removing node c
28.631 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'C1'[39m, value: [36m[Object][39m }, { v: [32m'C2'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.631 : DEBUG :  Done, no node has children [ [32m'a'[39m, [32m'b'[39m ]
28.631 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
28.631 : INFO :  [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]

}
28.631 : WARN :  Copying children of  C1 root C1 data [90mundefined[39m C1
28.631 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m, [32m'b'[39m ]
28.631 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: {} }, { v: [32m'b'[39m, value: {} } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.631 : WARN :  Cluster without external connections, without a parent and with children C2 [33m0[39m
28.631 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: {}, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: {} } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.631 : WARN :  Copying children of  C2 root C2 data [90mundefined[39m C2
28.631 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'c'[39m ]
28.631 : WARN :  New graph after copy node: ( C2 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: {} } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.631 : WARN :  New list of nodes [ [32m'C1'[39m, [32m'C2'[39m ]
28.631 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: {}, b: {} },
    _parent: { a: [32m'\x00'[39m, b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {}, b: {} },
    _in: { a: {}, b: [36m[Object][39m },
    _preds: { a: {}, b: [36m[Object][39m },
    _out: { a: [36m[Object][39m, b: {} },
    _sucs: { a: [36m[Object][39m, b: {} },
    _edgeObjs: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'a\x01b\x01\x00'[39m: {} },
    _nodeCount: [33m2[39m,
    _edgeCount: [33m1[39m
  }
}
28.631 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: {} }, { v: [32m'b'[39m, value: {} } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: {} } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.631 : WARN :   Now next level C2 {
  clusterNode: [33mtrue[39m,
  id: [32m'C2'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: {} },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.631 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: {} } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
28.653 : DEBUG :  Opting in, graph
28.653 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
28.653 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
28.653 : DEBUG :  Not a cluster  c Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
28.653 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
28.653 : DEBUG :  Cluster identified C2 Map(2) { [32m'C1'[39m => [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], [32m'C2'[39m => [ [32m'a'[39m ] }
28.653 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
28.653 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
28.653 : DEBUG :  Not a cluster a [33m0[39m
28.653 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
28.653 : DEBUG :  Not a cluster b [33m0[39m
28.653 : DEBUG :  Extracting node c Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
28.653 : DEBUG :  Not a cluster c [33m0[39m
28.653 : DEBUG :  Extracting node C1 Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
28.653 : INFO :  cp  b  to  C1  with parent  C1
28.653 : INFO :  In copy  C1 root C1 data { data: [33m4[39m } C1
28.653 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.653 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m } ]
28.653 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m }
28.653 : INFO :  Edge data { name: [32m'C1-internal-link'[39m } C1
28.653 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
28.653 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m }
28.653 : INFO :  Copying as  a b { name: [32m'C1-internal-link'[39m } [90mundefined[39m
28.653 : INFO :  newGraph edges  [ { v: [32m'a'[39m, w: [32m'b'[39m } ] { name: [32m'C1-internal-link'[39m }
28.653 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
28.653 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
28.653 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
28.653 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
28.653 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
28.653 : DEBUG :  Removing node b
28.653 : INFO :  cp  a  to  C1  with parent  C2
28.653 : DEBUG :  Setting parent a C2
28.653 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'c'[39m } ]
28.653 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
28.653 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
28.653 : WARN :  Cluster identified C1  Replacement id in edges:  b
28.653 : WARN :  Cluster identified C2  Replacement id in edges:  a
28.653 : WARN :  Edge:  { v: [32m'a'[39m, w: [32m'b'[39m }  leaves cluster  C2
28.653 : WARN :  Descendants of XXX  C2 :  [ [32m'a'[39m ]
28.653 : WARN :  Edge a -> b: {"v":"a","w":"b"}
28.653 : WARN :  Edge a -> b: {"name":"C1-internal-link"}
28.653 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} ids: a b Translating:  [90mundefined[39m  ---  [90mundefined[39m
28.653 : WARN :  Edge C1 -> c: {"v":"C1","w":"c"}
28.653 : WARN :  Edge C1 -> c: {"name":"C1-external-link"}
28.653 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
28.653 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
28.653 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
28.653 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
28.653 : DEBUG :  Removing node a
28.653 : INFO :  cp  C2  to  C1  with parent  C2
28.653 : INFO :  In copy  C2 root C1 data { data: [33m5[39m } C1
28.653 : DEBUG :  Not Setting parent for node= C2 cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
28.653 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'c'[39m } ]
28.653 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
28.653 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
28.653 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
28.653 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
28.653 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
28.653 : DEBUG :  Removing node C2
28.653 : DEBUG :  Removing node C2
28.653 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m }, { v: [32m'C1'[39m, value: [36m[Object][39m } ],
} ids: C1 c Translating:  { id: [32m'b'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
  edges: [ { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m } ],
28.653 : WARN :  Fixing and trying - removing XXX C1 c [90mundefined[39m
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.653 : DEBUG :  Extracting node C2 Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.653 : DEBUG :  Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
}
28.653 : DEBUG :  Nodes =  [ [32m'b'[39m, [32m'a'[39m, [32m'C2'[39m ] [33m1[39m
28.653 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m1[39m
28.653 : DEBUG :  Not a cluster b [33m1[39m
28.653 : DEBUG :  Extracting node a Map(2) {
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
28.653 : WARN :  Fix Replacing with XXX C1 c [90mundefined[39m
28.653 : WARN :  Adjusted Graph {
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m1[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
28.653 : DEBUG :  Not a cluster a [33m1[39m
  nodes: [
28.653 : DEBUG :  Extracting node C2 Map(2) {
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.653 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
} [33mfalse[39m [33mtrue[39m { data: [33m5[39m } [90mundefined[39m  Depth  [33m1[39m
    { v: [32m'c'[39m, value: [36m[Object][39m },
28.653 : DEBUG :  Map(2) {
    { v: [32m'C1'[39m, value: [36m[Object][39m },
  [32m'C1'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  [32m'C2'[39m => { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
  ],
  edges: [
}
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
28.653 : INFO :  [ [32m'c'[39m, [32m'C1'[39m ]
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }

  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.653 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
28.653 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.653 : WARN :  Copying children of  C1 root C1 data { data: [33m4[39m } C1
28.653 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'b'[39m, [32m'C2'[39m ]
28.653 : WARN :  Copying children of  C2 root C1 data { data: [33m5[39m } C1
28.653 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'a'[39m, [32m'C2'[39m ]
28.653 : WARN :  Setting parent a C2
28.653 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.653 : WARN :  Cluster **  C2  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
28.653 : WARN :  New list of nodes [ [32m'c'[39m, [32m'C1'[39m ]
28.653 : WARN :   Now next level c { data: [33m3[39m }
28.653 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m4[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m, a: [36m[Object][39m, C2: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m, a: [32m'C2'[39m, C2: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {}, a: {}, C2: [36m[Object][39m },
    _in: { b: [36m[Object][39m, a: {}, C2: {} },
    _preds: { b: [36m[Object][39m, a: {}, C2: {} },
    _out: { b: {}, a: [36m[Object][39m, C2: {} },
    _sucs: { b: {}, a: [36m[Object][39m, C2: {} },
    _edgeObjs: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
    _nodeCount: [33m3[39m,
    _edgeCount: [33m1[39m
  }
}
28.653 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.653 : WARN :  Cluster **  C2  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [33mtrue[39m [90mundefined[39m [33m1[39m
28.653 : WARN :  New list of nodes [ [32m'b'[39m, [32m'a'[39m, [32m'C2'[39m ]
28.653 : WARN :   Now next level b { data: [33m2[39m }
28.653 : WARN :   Now next level a { data: [33m1[39m }
28.653 : WARN :   Now next level C2 { data: [33m5[39m }

 âœ“ packages/mermaid/src/rendering-util/handle-markdown-text.spec.ts (19 tests) 93ms
stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
28.655 : DEBUG :  Opting in, graph
28.655 : DEBUG :  Not a cluster  a { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
28.655 : DEBUG :  Not a cluster  b { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
28.655 : DEBUG :  Not a cluster  c { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
28.655 : DEBUG :  Cluster identified C1 { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
28.655 : DEBUG :  Cluster identified C2 { C1: [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ], C2: [ [32m'a'[39m ] }
28.655 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
28.655 : DEBUG :  Extracting node a {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB4
28.654 : WARN :  Cluster identified C1  Replacement id in edges:  b
28.654 : WARN :  Cluster identified C2  Replacement id in edges:  a
28.654 : WARN :  Edge:  { v: [32m'a'[39m, w: [32m'b'[39m }  leaves cluster  C2
28.654 : WARN :  Descendants of XXX  C2 :  [ [32m'a'[39m ]
28.654 : WARN :  Edge a -> b: {"v":"a","w":"b"}
28.654 : WARN :  Edge a -> b: {"name":"C1-internal-link"}
28.654 : WARN :  Fix XXX {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} ids: a b Translating:  [90mundefined[39m  ---  [90mundefined[39m
28.654 : WARN :  Edge C1 -> c: {"v":"C1","w":"c"}
28.654 : WARN :  Edge C1 -> c: {"name":"C1-external-link"}
28.654 : WARN :  Fix XXX {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} ids: C1 c Translating:  { id: [32m'b'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
28.654 : WARN :  Fixing and trixing - removing XXX C1 c [90mundefined[39m
28.654 : WARN :  Fix Replacing with XXX C1 c [90mundefined[39m
28.654 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
28.655 : DEBUG :  Not a cluster a [33m0[39m
  ],
28.655 : DEBUG :  Extracting node b {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
28.655 : DEBUG :  Not a cluster b [33m0[39m
28.655 : DEBUG :  Extracting node c {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [90mundefined[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
28.655 : DEBUG :  Not a cluster c [33m0[39m
28.655 : DEBUG :  Extracting node C1 {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
28.654 : INFO :  cp  b  to  C1  with parent  C1
28.654 : INFO :  In copy  C1 root C1 data { data: [33m4[39m } C1
28.655 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.655 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m } ]
}
28.654 : WARN :  extractor -  [33m0[39m {
28.654 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
28.654 : INFO :  Edge data { name: [32m'C1-internal-link'[39m } C1
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
28.654 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
28.654 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m }
    { v: [32m'c'[39m, value: [36m[Object][39m },
28.654 : INFO :  Copying as  a b { name: [32m'C1-internal-link'[39m } [90mundefined[39m
28.654 : INFO :  newGraph edges  [ { v: [32m'a'[39m, w: [32m'b'[39m } ] { name: [32m'C1-internal-link'[39m }
28.654 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.654 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
28.654 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
28.654 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
28.654 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
28.654 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
    { v: [32m'c'[39m, value: [36m[Object][39m },
28.654 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
    { v: [32m'C1'[39m, value: [36m[Object][39m },
28.655 : DEBUG :  Removing node b
    { v: [32m'C2'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m }
28.654 : INFO :  cp  a  to  C1  with parent  C2
  ],
28.655 : DEBUG :  Setting parent a C2
  edges: [
28.655 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'c'[39m } ]
    { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m },
28.654 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
    { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m }
28.654 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
  ],
28.654 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
28.654 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
}
28.654 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
28.654 : WARN :  Copying children of  C1 root C1 data { data: [33m4[39m } C1
28.655 : DEBUG :  Removing node a
28.654 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'b'[39m, [32m'C2'[39m ]
28.654 : INFO :  cp  C2  to  C1  with parent  C2
28.654 : WARN :  Copying children of  C2 root C1 data { data: [33m5[39m } C1
28.654 : INFO :  In copy  C2 root C1 data { data: [33m5[39m } C1
28.654 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'a'[39m, [32m'C2'[39m ]
28.655 : DEBUG :  Not Setting parent for node= C2 cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
28.654 : WARN :  Setting parent a C2
28.655 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'c'[39m } ]
28.654 : WARN :  New graph after copy node: ( C1 ) {
28.654 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
28.654 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
  nodes: [
28.654 : INFO :  Descendants of  C1  is  [ [32m'b'[39m, [32m'C2'[39m, [32m'a'[39m ]
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
28.654 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m }
    { v: [32m'C2'[39m, value: [36m[Object][39m }
28.654 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C2
  ],
28.655 : DEBUG :  Removing node C2
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m } ],
28.655 : DEBUG :  Removing node C2
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
28.655 : DEBUG :  Old graph after copy {
}
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
28.654 : WARN :  Cluster **  C2  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m }, { v: [32m'C1'[39m, value: [36m[Object][39m } ],
28.654 : WARN :  New list of nodes [ [32m'c'[39m, [32m'C1'[39m ]
  edges: [ { v: [32m'C1'[39m, w: [32m'c'[39m, value: [36m[Object][39m } ],
28.654 : WARN :   Now next level c { data: [33m3[39m }
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
28.654 : WARN :   Now next level C1 {
}
  clusterNode: [33mtrue[39m,
28.655 : DEBUG :  Extracting node C2 {
  id: [32m'C1'[39m,
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  clusterData: { data: [33m4[39m },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.655 : DEBUG :  {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
}
28.655 : DEBUG :  Nodes =  [ [32m'b'[39m, [32m'a'[39m, [32m'C2'[39m ] [33m1[39m
28.655 : DEBUG :  Extracting node b {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [90mundefined[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m1[39m
28.655 : DEBUG :  Not a cluster b [33m1[39m
28.655 : DEBUG :  Extracting node a {
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m, a: [36m[Object][39m, C2: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m, a: [32m'C2'[39m, C2: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {}, a: {}, C2: [36m[Object][39m },
    _in: { b: [36m[Object][39m, a: {}, C2: {} },
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m1[39m
28.655 : DEBUG :  Not a cluster a [33m1[39m
28.655 : DEBUG :  Extracting node C2 {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m5[39m } [90mundefined[39m  Depth  [33m1[39m
28.655 : DEBUG :  {
  C1: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'a'[39m, clusterData: { data: [33m5[39m }, externalConnections: [33mtrue[39m }
}
28.654 : INFO :  [ [32m'c'[39m, [32m'C1'[39m ]

    _preds: { b: [36m[Object][39m, a: {}, C2: {} },
stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
    _out: { b: {}, a: [36m[Object][39m, C2: {} },
28.666 : INFO :  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m, [32m'C2'[39m ]
    _sucs: { b: {}, a: [36m[Object][39m, C2: {} },
28.666 : DEBUG :  Opting in, graph
    _edgeObjs: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
28.666 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
    _edgeLabels: { [32m'a\x01b\x01\x00'[39m: [36m[Object][39m },
28.666 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
    _nodeCount: [33m3[39m,
28.666 : DEBUG :  Cluster identified C1 { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
    _edgeCount: [33m1[39m
28.666 : DEBUG :  Cluster identified C2 { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
  }
28.666 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
28.666 : DEBUG :  Extracting node a {
}
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
28.654 : WARN :  extractor -  [33m1[39m {
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
28.666 : DEBUG :  Not a cluster a [33m0[39m
28.666 : DEBUG :  Extracting node b {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
28.666 : DEBUG :  Not a cluster b [33m0[39m
28.666 : DEBUG :  Extracting node C1 {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.666 : INFO :  cp  a  to  C1  with parent  C1
28.666 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
28.666 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  nodes: [
28.666 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
    { v: [32m'b'[39m, value: [36m[Object][39m },
28.666 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
28.666 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
    { v: [32m'C2'[39m, value: [36m[Object][39m }
28.666 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
28.666 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
28.666 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
28.666 : DEBUG :  Removing node a
28.666 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.666 : DEBUG :  Extracting node C2 {
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.666 : INFO :  cp  b  to  C2  with parent  C2
28.666 : INFO :  In copy  C2 root C2 data [90mundefined[39m C2
28.666 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  ],
28.666 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, value: [36m[Object][39m } ],
28.666 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
28.666 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C2
} [90mundefined[39m
28.666 : INFO :  Descendants of  C2  is  [ [32m'b'[39m ]
28.654 : WARN :  Cluster **  C2  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [33mtrue[39m [90mundefined[39m [33m1[39m
28.666 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
28.654 : WARN :  New list of nodes [ [32m'b'[39m, [32m'a'[39m, [32m'C2'[39m ]
28.666 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
28.654 : WARN :   Now next level b { data: [33m2[39m }
28.666 : DEBUG :  Removing node b
28.654 : WARN :   Now next level a { data: [33m1[39m }
28.666 : DEBUG :  Old graph after copy {
28.654 : WARN :   Now next level C2 { data: [33m5[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },

  nodes: [ { v: [32m'C1'[39m, value: [36m[Object][39m }, { v: [32m'C2'[39m, value: [36m[Object][39m } ],
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
28.665 : WARN :  Cluster identified C1  Replacement id in edges:  a
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
28.665 : WARN :  Cluster identified C2  Replacement id in edges:  b
}
28.665 : WARN :  Edge C1 -> C2: {"v":"C1","w":"C2"}
28.666 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
28.665 : WARN :  Edge C1 -> C2: {"name":"C1-external-link"}
28.666 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
28.665 : WARN :  Fix XXX {
28.666 : INFO :  [ [32m'C1'[39m, [32m'C2'[39m ]
  C1: { id: [32m'a'[39m, clusterData: [90mundefined[39m },

  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 C2 Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'b'[39m, clusterData: [90mundefined[39m }
28.665 : WARN :  Fixing and trixing - removing XXX C1 C2 [90mundefined[39m
28.665 : WARN :  Fix Replacing with XXX C1 C2 [90mundefined[39m
28.665 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.665 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.665 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
28.665 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.665 : WARN :  Copying children of  C1 root C1 data [90mundefined[39m C1
28.665 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
28.665 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.665 : WARN :  Cluster without external connections, without a parent and with children C2 [33m0[39m
28.665 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
28.671 : DEBUG :  Opting in, graph
28.671 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
28.671 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.671 : DEBUG :  Cluster identified C1 { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
28.665 : WARN :  Copying children of  C2 root C2 data [90mundefined[39m C2
28.671 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m ] [33m0[39m
28.665 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'b'[39m ]
28.671 : DEBUG :  Extracting node a {
28.665 : WARN :  New graph after copy node: ( C2 ) {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
  edges: [],
28.671 : DEBUG :  Not a cluster a [33m0[39m
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
28.671 : DEBUG :  Extracting node b {
}
  C1: { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
28.665 : WARN :  New list of nodes [ [32m'C1'[39m, [32m'C2'[39m ]
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
28.665 : WARN :   Now next level C1 {
} [90mundefined[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
  clusterNode: [33mtrue[39m,
28.671 : DEBUG :  Not a cluster b [33m0[39m
  id: [32m'C1'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
28.671 : DEBUG :  Extracting node C1 {
    _in: { a: {} },
  C1: { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
    _preds: { a: {} },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
    _out: { a: {} },
} [33mtrue[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
    _sucs: { a: {} },
28.671 : INFO :  cp  a  to  C1  with parent  C1
    _edgeObjs: {},
28.671 : INFO :  In copy  C1 root C1 data { data: [33m3[39m } C1
    _edgeLabels: {},
28.671 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    _nodeCount: [33m1[39m
28.671 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
  }
28.671 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
}
28.671 : INFO :  Edge data { data: [32m'link1'[39m } C1
28.665 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.665 : WARN :   Now next level C2 {
  clusterNode: [33mtrue[39m,
  id: [32m'C2'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
28.671 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
28.671 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
28.671 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
28.671 : DEBUG :  Removing node a
28.671 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m }, { v: [32m'C1'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.671 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
28.671 : INFO :  [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
28.676 : INFO :  { data: [33m4[39m }
28.676 : DEBUG :  Opting in, graph
28.676 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
28.676 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
28.676 : DEBUG :  Not a cluster  c { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
28.676 : DEBUG :  Cluster identified C1 { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ] }
28.676 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m ] [33m0[39m
28.676 : DEBUG :  Extracting node a {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
28.676 : DEBUG :  Not a cluster a [33m0[39m
28.676 : DEBUG :  Extracting node b {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
28.676 : DEBUG :  Not a cluster b [33m0[39m
28.676 : DEBUG :  Extracting node c {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
28.676 : DEBUG :  Not a cluster c [33m0[39m
28.676 : DEBUG :  Extracting node C1 {
    _isDirected: [33mtrue[39m,
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
    _isMultigraph: [33mtrue[39m,
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
    _isCompound: [33mtrue[39m,
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
28.676 : INFO :  cp  a  to  C1  with parent  C1
    _parent: { b: [32m'\x00'[39m },
28.676 : INFO :  In copy  C1 root C1 data { data: [33m4[39m } C1
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
28.676 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    _in: { b: {} },
    _preds: { b: {} },
28.676 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
    _out: { b: {} },
28.676 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
    _sucs: { b: {} },
28.676 : INFO :  Edge data { data: [32m'link1'[39m } C1
    _edgeObjs: {},
28.676 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
    _edgeLabels: {},
28.676 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
    _nodeCount: [33m1[39m
28.676 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
  }
28.676 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
}
28.676 : INFO :  Edge data { data: [32m'link2'[39m } C1
28.665 : WARN :  extractor -  [33m1[39m {
28.676 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
28.676 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
28.676 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
28.676 : DEBUG :  Removing node a
28.676 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  ],
} [90mundefined[39m
  edges: [

    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
28.671 : WARN :  Cluster identified C1  Replacement id in edges:  a
  ],
28.671 : WARN :  Edge C1 -> b: {"v":"C1","w":"b","name":"1"}
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.671 : WARN :  Edge C1 -> b: {"data":"link1"}
28.671 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 b Translating:  { id: [32m'a'[39m, clusterData: { data: [33m3[39m } }  ---  [90mundefined[39m
28.671 : WARN :  Fixing and trixing - removing XXX C1 b 1
28.671 : WARN :  Fix Replacing with XXX C1 b 1
28.671 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.671 : WARN :  extractor -  [33m0[39m {
28.676 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
28.676 : INFO :  [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
  nodes: [

    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.671 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
28.671 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.671 : WARN :  Copying children of  C1 root C1 data { data: [33m3[39m } C1
28.671 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
28.671 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.671 : WARN :  New list of nodes [ [32m'b'[39m, [32m'C1'[39m ]
28.671 : WARN :   Now next level b { data: [33m2[39m }
28.671 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m3[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.671 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
28.663 : INFO :  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m, [32m'C2'[39m ]
28.663 : DEBUG :  Opting in, graph
28.663 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
28.663 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
28.663 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
28.663 : DEBUG :  Cluster identified C2 Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
28.676 : WARN :  Cluster identified C1  Replacement id in edges:  a
28.676 : WARN :  Edge C1 -> b: {"v":"C1","w":"b","name":"1"}
28.676 : WARN :  Edge C1 -> b: {"data":"link1"}
28.676 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 b Translating:  { id: [32m'a'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
28.676 : WARN :  Fixing and trixing - removing XXX C1 b 1
28.676 : WARN :  Fix Replacing with XXX C1 b 1
28.676 : WARN :  Edge C1 -> c: {"v":"C1","w":"c","name":"2"}
28.676 : WARN :  Edge C1 -> c: {"data":"link2"}
28.676 : WARN :  Fix XXX {
  C1: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 c Translating:  { id: [32m'a'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
28.676 : WARN :  Fixing and trixing - removing XXX C1 c 2
28.676 : WARN :  Fix Replacing with XXX C1 c 2
28.676 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
28.663 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m, [32m'C2'[39m ] [33m0[39m
  nodes: [
28.663 : DEBUG :  Extracting node a Map(2) {
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
    { v: [32m'c'[39m, value: [36m[Object][39m },
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
    { v: [32m'C1'[39m, value: [36m[Object][39m }
28.663 : DEBUG :  Not a cluster a [33m0[39m
  ],
28.663 : DEBUG :  Extracting node b Map(2) {
  edges: [
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
} [33mfalse[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
  ],
28.663 : DEBUG :  Not a cluster b [33m0[39m
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
28.663 : DEBUG :  Extracting node C1 Map(2) {
}
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
28.676 : WARN :  extractor -  [33m0[39m {
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  nodes: [
28.663 : INFO :  cp  a  to  C1  with parent  C1
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
28.663 : INFO :  In copy  C1 root C1 data [90mundefined[39m C1
    { v: [32m'b'[39m, value: [36m[Object][39m },
28.663 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    { v: [32m'c'[39m, value: [36m[Object][39m },
28.663 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
28.663 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
28.663 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C1
    { v: [32m'C1'[39m, value: [36m[Object][39m }
28.663 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
  ],
28.663 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
  edges: [
28.663 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C1  clusterId: C1
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
28.663 : DEBUG :  Removing node a
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
28.663 : DEBUG :  Old graph after copy {
  ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  nodes: [
} [90mundefined[39m
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
28.676 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
    { v: [32m'C1'[39m, value: [36m[Object][39m },
28.676 : WARN :  Old graph before copy {
    { v: [32m'C2'[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  ],
  nodes: [
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.663 : DEBUG :  Extracting node C2 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.663 : INFO :  cp  b  to  C2  with parent  C2
28.663 : INFO :  In copy  C2 root C2 data [90mundefined[39m C2
28.663 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.663 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'C2'[39m } ]
28.663 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'C2'[39m }
28.663 : INFO :  Edge data { name: [32m'C1-external-link'[39m } C2
28.663 : INFO :  Descendants of  C2  is  [ [32m'b'[39m ]
28.663 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'C2'[39m }
28.663 : INFO :  Skipping copy of edge  C1 --> C2  rootId:  C2  clusterId: C2
28.663 : DEBUG :  Removing node b
28.663 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'C1'[39m, value: [36m[Object][39m }, { v: [32m'C2'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.663 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
    { v: [32m'b'[39m, value: [36m[Object][39m },
28.663 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
    { v: [32m'c'[39m, value: [36m[Object][39m },
28.663 : INFO :  [ [32m'C1'[39m, [32m'C2'[39m ]
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],

  edges: [
stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
28.671 : DEBUG :  Opting in, graph
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
28.671 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
  ],
28.671 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
28.671 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
}
28.671 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'C1'[39m ] [33m0[39m
28.676 : WARN :  Copying children of  C1 root C1 data { data: [33m4[39m } C1
28.671 : DEBUG :  Extracting node a Map(2) {
28.676 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
28.676 : WARN :  New graph after copy node: ( C1 ) {
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
28.671 : DEBUG :  Not a cluster a [33m0[39m
  edges: [],
28.671 : DEBUG :  Extracting node b Map(2) {
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
}
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
28.676 : WARN :  New list of nodes [ [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m ]
} [33mfalse[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
28.676 : WARN :   Now next level b { data: [33m2[39m }
28.671 : DEBUG :  Not a cluster b [33m0[39m
28.676 : WARN :   Now next level c { data: [33m3[39m }
28.671 : DEBUG :  Extracting node C1 Map(2) {
28.676 : WARN :   Now next level C1 {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  clusterNode: [33mtrue[39m,
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
  id: [32m'C1'[39m,
} [33mtrue[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
  clusterData: { data: [33m4[39m },
28.671 : INFO :  cp  a  to  C1  with parent  C1
  labelText: [90mundefined[39m,
28.671 : INFO :  In copy  C1 root C1 data { data: [33m3[39m } C1
  graph: Graph {
28.671 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    _isDirected: [33mtrue[39m,
28.671 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
    _isMultigraph: [33mtrue[39m,
28.671 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.676 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > Validate should detect edges between clusters and transform clusters GLB5
28.663 : WARN :  Cluster identified C1  Replacement id in edges:  a
28.663 : WARN :  Cluster identified C2  Replacement id in edges:  b
28.663 : WARN :  Edge C1 -> C2: {"v":"C1","w":"C2"}
28.663 : WARN :  Edge C1 -> C2: {"name":"C1-external-link"}
28.663 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 C2 Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'b'[39m, clusterData: [90mundefined[39m }
28.663 : WARN :  Fixing and trying - removing XXX C1 C2 [90mundefined[39m
28.663 : WARN :  Fix Replacing with XXX C1 C2 [90mundefined[39m
28.663 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
28.671 : INFO :  Edge data { data: [32m'link1'[39m } C1
28.671 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
28.671 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
28.671 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
28.671 : DEBUG :  Removing node a
28.671 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m }, { v: [32m'C1'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.671 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
28.671 : INFO :  [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]

  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.663 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.663 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
28.663 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.663 : WARN :  Copying children of  C1 root C1 data [90mundefined[39m C1
28.663 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
28.663 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.663 : WARN :  Cluster without external connections, without a parent and with children C2 [33m0[39m
28.663 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'C2'[39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m },
    { v: [32m'C2'[39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'C2'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.663 : WARN :  Copying children of  C2 root C2 data [90mundefined[39m C2
28.663 : WARN :  Copying (nodes) clusterId C2 nodes [ [32m'b'[39m ]
28.663 : WARN :  New graph after copy node: ( C2 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.663 : WARN :  New list of nodes [ [32m'C1'[39m, [32m'C2'[39m ]
28.663 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.663 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.663 : WARN :   Now next level C2 {
  clusterNode: [33mtrue[39m,
  id: [32m'C2'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.663 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB6
28.671 : WARN :  Cluster identified C1  Replacement id in edges:  a
28.671 : WARN :  Edge C1 -> b: {"v":"C1","w":"b","name":"1"}
28.671 : WARN :  Edge C1 -> b: {"data":"link1"}
28.671 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m3[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 b Translating:  { id: [32m'a'[39m, clusterData: { data: [33m3[39m } }  ---  [90mundefined[39m
28.671 : WARN :  Fixing and trying - removing XXX C1 b 1
28.671 : WARN :  Fix Replacing with XXX C1 b 1
28.671 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.671 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.671 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
28.671 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.671 : WARN :  Copying children of  C1 root C1 data { data: [33m3[39m } C1
28.671 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
28.671 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.671 : WARN :  New list of nodes [ [32m'b'[39m, [32m'C1'[39m ]
28.671 : WARN :   Now next level b { data: [33m2[39m }
28.671 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m3[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.671 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
28.679 : INFO :  { data: [33m4[39m }
28.679 : DEBUG :  Opting in, graph
28.679 : DEBUG :  Not a cluster  a Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
28.679 : DEBUG :  Not a cluster  b Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB7
28.679 : DEBUG :  Not a cluster  c Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
28.679 : WARN :  Cluster identified C1  Replacement id in edges:  a
28.679 : DEBUG :  Cluster identified C1 Map(2) { [32m'C1'[39m => [ [32m'a'[39m ], [32m'C2'[39m => [ [32m'b'[39m ] }
28.679 : WARN :  Edge C1 -> b: {"v":"C1","w":"b","name":"1"}
28.679 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m ] [33m0[39m
28.679 : WARN :  Edge C1 -> b: {"data":"link1"}
28.679 : DEBUG :  Extracting node a Map(2) {
28.679 : WARN :  Fix XXX Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
28.679 : DEBUG :  Not a cluster a [33m0[39m
28.679 : DEBUG :  Extracting node b Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
28.679 : DEBUG :  Not a cluster b [33m0[39m
28.679 : DEBUG :  Extracting node c Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mtrue[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
28.679 : DEBUG :  Not a cluster c [33m0[39m
28.679 : DEBUG :  Extracting node C1 Map(2) {
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
} ids: C1 b Translating:  { id: [32m'a'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
28.679 : WARN :  Fixing and trying - removing XXX C1 b 1
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
28.679 : WARN :  Fix Replacing with XXX C1 b 1
28.679 : INFO :  cp  a  to  C1  with parent  C1
28.679 : WARN :  Edge C1 -> c: {"v":"C1","w":"c","name":"2"}
28.679 : INFO :  In copy  C1 root C1 data { data: [33m4[39m } C1
28.679 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.679 : DEBUG :  Copying Edges [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
28.679 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
28.679 : INFO :  Edge data { data: [32m'link1'[39m } C1
28.679 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
28.679 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
28.679 : INFO :  Skipping copy of edge  C1 --> b  rootId:  C1  clusterId: C1
28.679 : INFO :  Edge { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
28.679 : INFO :  Edge data { data: [32m'link2'[39m } C1
28.679 : INFO :  Descendants of  C1  is  [ [32m'a'[39m ]
28.679 : INFO :  Edge is  { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
28.679 : INFO :  Skipping copy of edge  C1 --> c  rootId:  C1  clusterId: C1
28.679 : DEBUG :  Removing node a
28.679 : WARN :  Edge C1 -> c: {"data":"link2"}
28.679 : DEBUG :  Old graph after copy {
28.679 : WARN :  Fix XXX Map(2) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'C1'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  nodes: [
  [32m'C2'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m }
    { v: [32m'b'[39m, value: [36m[Object][39m },
} ids: C1 c Translating:  { id: [32m'a'[39m, clusterData: { data: [33m4[39m } }  ---  [90mundefined[39m
    { v: [32m'c'[39m, value: [36m[Object][39m },
28.679 : WARN :  Fixing and trying - removing XXX C1 c 2
    { v: [32m'C1'[39m, value: [36m[Object][39m }
28.679 : WARN :  Fix Replacing with XXX C1 c 2
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.679 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
28.679 : INFO :  [ { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m }, { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]

28.679 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.679 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.679 : WARN :  Cluster without external connections, without a parent and with children C1 [33m0[39m
28.679 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'C1'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'C1'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'C1'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.679 : WARN :  Copying children of  C1 root C1 data { data: [33m4[39m } C1
28.679 : WARN :  Copying (nodes) clusterId C1 nodes [ [32m'a'[39m ]
28.679 : WARN :  New graph after copy node: ( C1 ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.679 : WARN :  New list of nodes [ [32m'b'[39m, [32m'c'[39m, [32m'C1'[39m ]
28.679 : WARN :   Now next level b { data: [33m2[39m }
28.679 : WARN :   Now next level c { data: [33m3[39m }
28.679 : WARN :   Now next level C1 {
  clusterNode: [33mtrue[39m,
  id: [32m'C1'[39m,
  clusterData: { data: [33m4[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.679 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
28.681 : DEBUG :  Opting in, graph
28.681 : DEBUG :  Not a cluster  a { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
28.681 : DEBUG :  Not a cluster  b { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
28.681 : DEBUG :  Not a cluster  c { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
28.681 : DEBUG :  Cluster identified A { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
28.681 : DEBUG :  Cluster identified B { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
28.681 : DEBUG :  Cluster identified C { C1: [ [32m'a'[39m ], C2: [ [32m'b'[39m ], A: [ [32m'a'[39m ], B: [ [32m'b'[39m ], C: [ [32m'c'[39m ] }
28.681 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ] [33m0[39m
28.681 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
28.681 : DEBUG :  Not a cluster a [33m0[39m
28.681 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
28.681 : DEBUG :  Not a cluster b [33m0[39m
28.681 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [90mundefined[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
28.681 : DEBUG :  Not a cluster c [33m0[39m
28.681 : DEBUG :  Extracting node A {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.681 : INFO :  cp  a  to  A  with parent  A
28.681 : INFO :  In copy  A root A data [90mundefined[39m A
28.681 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.681 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
28.681 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.681 : INFO :  Edge data { data: [32m'link1'[39m } A
28.681 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
28.681 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.681 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
28.681 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.681 : INFO :  Edge data { data: [32m'link2'[39m } A
28.681 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
28.681 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.681 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
28.681 : DEBUG :  Removing node a
28.681 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.681 : DEBUG :  Extracting node B {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.681 : INFO :  cp  b  to  B  with parent  B
28.681 : INFO :  In copy  B root B data [90mundefined[39m B
28.681 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.681 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
28.681 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.681 : INFO :  Edge data { data: [32m'link1'[39m } B
28.681 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
28.681 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.681 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
28.681 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.681 : INFO :  Edge data { data: [32m'link2'[39m } B
28.681 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
28.681 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.681 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
28.681 : DEBUG :  Removing node b
28.681 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.681 : DEBUG :  Extracting node C {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.681 : INFO :  cp  c  to  C  with parent  C
28.681 : INFO :  In copy  C root C data [90mundefined[39m C
28.681 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.681 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
28.681 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.681 : INFO :  Edge data { data: [32m'link1'[39m } C
28.681 : INFO :  Descendants of  C  is  [ [32m'c'[39m ]
28.681 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.681 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: C
28.681 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.681 : INFO :  Edge data { data: [32m'link2'[39m } C
28.681 : INFO :  Descendants of  C  is  [ [32m'c'[39m ]
28.681 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.681 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: C
28.681 : DEBUG :  Removing node c
28.681 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.681 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
28.681 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
28.681 : DEBUG :  Done, no node has children [ [32m'c'[39m ]

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
28.690 : DEBUG :  Opting in, graph
28.690 : DEBUG :  Cluster identified C {
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
28.681 : WARN :  Cluster identified A  Replacement id in edges:  a
28.681 : WARN :  Cluster identified B  Replacement id in edges:  b
28.681 : WARN :  Cluster identified C  Replacement id in edges:  c
28.681 : WARN :  Edge A -> B: {"v":"A","w":"B","name":"1"}
28.681 : WARN :  Edge A -> B: {"data":"link1"}
28.681 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: A B Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'b'[39m, clusterData: [90mundefined[39m }
28.681 : WARN :  Fixing and trixing - removing XXX A B 1
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
28.690 : DEBUG :  Cluster identified D {
28.681 : WARN :  Fix Replacing with XXX A B 1
28.681 : WARN :  Edge A -> C: {"v":"A","w":"C","name":"2"}
28.681 : WARN :  Edge A -> C: {"data":"link2"}
28.681 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'c'[39m, clusterData: [90mundefined[39m }
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
} ids: A C Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'c'[39m, clusterData: [90mundefined[39m }
  C: [ [32m'D'[39m, [32m'd'[39m ],
28.681 : WARN :  Fixing and trixing - removing XXX A C 2
28.681 : WARN :  Fix Replacing with XXX A C 2
28.681 : WARN :  Adjusted Graph {
  D: [ [32m'd'[39m ]
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
}
  nodes: [
28.690 : DEBUG :  Not a cluster  d {
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
  C1: [ [32m'a'[39m ],
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
  B: [ [32m'b'[39m ],
    { v: [32m'A'[39m },
  C: [ [32m'D'[39m, [32m'd'[39m ],
    { v: [32m'B'[39m },
  D: [ [32m'd'[39m ]
    { v: [32m'C'[39m }
}
  ],
28.690 : DEBUG :  Nodes =  [ [32m'C'[39m, [32m'D'[39m, [32m'd'[39m ] [33m0[39m
  edges: [
28.690 : DEBUG :  Extracting node C {
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  ],
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.681 : WARN :  extractor -  [33m0[39m {
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
  nodes: [
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [ [32m'd'[39m ]  Depth  [33m0[39m
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
28.690 : INFO :  cp  d  to  C  with parent  D
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
28.690 : DEBUG :  Setting parent d D
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
28.690 : DEBUG :  Copying Edges []
    { v: [32m'A'[39m },
28.690 : DEBUG :  Removing node d
    { v: [32m'B'[39m },
28.690 : INFO :  cp  D  to  C  with parent  D
    { v: [32m'C'[39m }
28.690 : INFO :  In copy  D root C data { data: [33m2[39m } C
  ],
28.690 : DEBUG :  Not Setting parent for node= D cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
  edges: [
28.690 : DEBUG :  Copying Edges []
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
28.690 : DEBUG :  Removing node D
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
28.690 : DEBUG :  Removing node D
  ],
28.690 : DEBUG :  Old graph after copy {
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
28.681 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
  nodes: [ { v: [32m'C'[39m, value: [36m[Object][39m } ],
28.681 : WARN :  Old graph before copy {
  edges: [],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  nodes: [
}
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
28.690 : DEBUG :  Extracting node D {
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    { v: [32m'A'[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
    { v: [32m'B'[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
    { v: [32m'C'[39m }
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  ],
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
  edges: [
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
28.690 : DEBUG :  {
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
}
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
28.681 : WARN :  Copying children of  A root A data [90mundefined[39m A
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
28.681 : WARN :  Copying (nodes) clusterId A nodes [ [32m'a'[39m ]
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
28.681 : WARN :  New graph after copy node: ( A ) {
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
}
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
28.690 : DEBUG :  Extracting node d {
  edges: [],
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
}
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
28.681 : WARN :  Cluster without external connections, without a parent and with children B [33m0[39m
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
28.681 : WARN :  Old graph before copy {
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.690 : DEBUG :  Not a cluster d [33m0[39m
28.690 : DEBUG :  Nodes =  [ [32m'd'[39m, [32m'D'[39m ] [33m1[39m
28.690 : DEBUG :  Extracting node d {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mfalse[39m { data: [33m3[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
28.690 : DEBUG :  Not a cluster d [33m1[39m
28.690 : DEBUG :  Extracting node D {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
  A: { id: [32m'a'[39m, clusterData: [90mundefined[39m },
28.681 : WARN :  Copying children of  B root B data [90mundefined[39m B
  B: { id: [32m'b'[39m, clusterData: [90mundefined[39m },
28.681 : WARN :  Copying (nodes) clusterId B nodes [ [32m'b'[39m ]
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
28.681 : WARN :  New graph after copy node: ( B ) {
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
28.690 : INFO :  cp  d  to  D  with parent  D
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.681 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
28.681 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m }
  ],
  edges: [
28.690 : INFO :  In copy  D root D data { data: [33m2[39m } D
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
28.690 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
28.690 : DEBUG :  Copying Edges []
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.690 : DEBUG :  Removing node d
28.690 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'D'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.690 : DEBUG :  Done, no node has children [ [32m'd'[39m ]

28.681 : WARN :  Copying children of  C root C data [90mundefined[39m C
28.681 : WARN :  Copying (nodes) clusterId C nodes [ [32m'c'[39m ]
28.681 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.681 : WARN :  New list of nodes [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ]
28.681 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.681 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.681 : WARN :   Now next level B {
  clusterNode: [33mtrue[39m,
  id: [32m'B'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.681 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.681 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: [90mundefined[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.681 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
28.685 : DEBUG :  Opting in, graph
28.685 : DEBUG :  Not a cluster  a Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
28.685 : DEBUG :  Not a cluster  b Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
28.685 : DEBUG :  Not a cluster  c Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
28.685 : DEBUG :  Cluster identified A Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
28.685 : DEBUG :  Cluster identified B Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
28.685 : DEBUG :  Cluster identified C Map(5) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'c'[39m ]
}
28.685 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ] [33m0[39m
28.685 : DEBUG :  Extracting node a Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
28.685 : DEBUG :  Not a cluster a [33m0[39m
28.685 : DEBUG :  Extracting node b Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
28.685 : DEBUG :  Not a cluster b [33m0[39m
28.685 : DEBUG :  Extracting node c Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mfalse[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m0[39m
28.685 : DEBUG :  Not a cluster c [33m0[39m
28.685 : DEBUG :  Extracting node A Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.685 : INFO :  cp  a  to  A  with parent  A
28.685 : INFO :  In copy  A root A data [90mundefined[39m A
28.685 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.685 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
28.685 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.685 : INFO :  Edge data { data: [32m'link1'[39m } A
28.685 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
28.685 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.685 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
28.685 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.685 : INFO :  Edge data { data: [32m'link2'[39m } A
28.685 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
28.685 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.685 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
28.685 : DEBUG :  Removing node a
28.685 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.685 : DEBUG :  Extracting node B Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.685 : INFO :  cp  b  to  B  with parent  B
28.685 : INFO :  In copy  B root B data [90mundefined[39m B
28.685 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.685 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
28.685 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.685 : INFO :  Edge data { data: [32m'link1'[39m } B
28.685 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
28.685 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.685 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
28.685 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.685 : INFO :  Edge data { data: [32m'link2'[39m } B
28.685 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
28.685 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.685 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
28.685 : DEBUG :  Removing node b
28.685 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.685 : DEBUG :  Extracting node C Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.685 : INFO :  cp  c  to  C  with parent  C
28.685 : INFO :  In copy  C root C data [90mundefined[39m C
28.685 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.685 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
28.685 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.685 : INFO :  Edge data { data: [32m'link1'[39m } C
28.685 : INFO :  Descendants of  C  is  [ [32m'c'[39m ]
28.685 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.685 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: C
28.685 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.685 : INFO :  Edge data { data: [32m'link2'[39m } C
28.685 : INFO :  Descendants of  C  is  [ [32m'c'[39m ]
28.685 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.685 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: C
28.685 : DEBUG :  Removing node c
28.685 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.685 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
28.685 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
28.685 : DEBUG :  Done, no node has children [ [32m'c'[39m ]

stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges GLB8
28.685 : WARN :  Cluster identified A  Replacement id in edges:  a
28.685 : WARN :  Cluster identified B  Replacement id in edges:  b
28.685 : WARN :  Cluster identified C  Replacement id in edges:  c
28.685 : WARN :  Edge A -> B: {"v":"A","w":"B","name":"1"}
28.685 : WARN :  Edge A -> B: {"data":"link1"}
28.685 : WARN :  Fix XXX Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
28.693 : DEBUG :  Opting in, graph
28.693 : DEBUG :  Cluster identified C Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
  [32m'B'[39m => [ [32m'b'[39m ],
} ids: A B Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'b'[39m, clusterData: [90mundefined[39m }
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
28.685 : WARN :  Fixing and trying - removing XXX A B 1
  [32m'D'[39m => [ [32m'd'[39m ]
}
28.693 : DEBUG :  Cluster identified D Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
28.685 : WARN :  Fix Replacing with XXX A B 1
28.685 : WARN :  Edge A -> C: {"v":"A","w":"C","name":"2"}
28.685 : WARN :  Edge A -> C: {"data":"link2"}
28.685 : WARN :  Fix XXX Map(5) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'c'[39m, clusterData: [90mundefined[39m }
} ids: A C Translating:  { id: [32m'a'[39m, clusterData: [90mundefined[39m }  ---  { id: [32m'c'[39m, clusterData: [90mundefined[39m }
28.685 : WARN :  Fixing and trying - removing XXX A C 2
28.693 : DEBUG :  Not a cluster  d Map(6) {
28.685 : WARN :  Fix Replacing with XXX A C 2
  [32m'C1'[39m => [ [32m'a'[39m ],
28.685 : WARN :  Adjusted Graph {
  [32m'C2'[39m => [ [32m'b'[39m ],
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'A'[39m => [ [32m'a'[39m ],
  nodes: [
  [32m'B'[39m => [ [32m'b'[39m ],
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
    { v: [32m'B'[39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.685 : WARN :  extractor -  [33m0[39m {
  [32m'D'[39m => [ [32m'd'[39m ]
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
}
  nodes: [
28.693 : DEBUG :  Nodes =  [ [32m'C'[39m, [32m'D'[39m, [32m'd'[39m ] [33m0[39m
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
28.693 : DEBUG :  Extracting node C Map(6) {
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    { v: [32m'A'[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
    { v: [32m'B'[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
    { v: [32m'C'[39m }
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [ [32m'd'[39m ]  Depth  [33m0[39m
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.685 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
28.685 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m },
28.693 : INFO :  cp  d  to  C  with parent  D
    { v: [32m'B'[39m },
28.693 : DEBUG :  Setting parent d D
    { v: [32m'C'[39m }
28.693 : DEBUG :  Copying Edges []
  ],
28.693 : DEBUG :  Removing node d
  edges: [
28.693 : INFO :  cp  D  to  C  with parent  D
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
28.693 : INFO :  In copy  D root C data { data: [33m2[39m } C
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.685 : WARN :  Copying children of  A root A data [90mundefined[39m A
28.685 : WARN :  Copying (nodes) clusterId A nodes [ [32m'a'[39m ]
28.685 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.685 : WARN :  Cluster without external connections, without a parent and with children B [33m0[39m
28.685 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
28.693 : DEBUG :  Not Setting parent for node= D cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
  nodes: [
28.693 : DEBUG :  Copying Edges []
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
28.693 : DEBUG :  Removing node D
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
28.693 : DEBUG :  Removing node D
    { v: [32m'A'[39m, value: [36m[Object][39m },
28.693 : DEBUG :  Old graph after copy {
    { v: [32m'B'[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    { v: [32m'C'[39m }
  nodes: [ { v: [32m'C'[39m, value: [36m[Object][39m } ],
  ],
  edges: [],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  ],
}
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.693 : DEBUG :  Extracting node D Map(6) {
28.685 : WARN :  Copying children of  B root B data [90mundefined[39m B
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
28.685 : WARN :  Copying (nodes) clusterId B nodes [ [32m'b'[39m ]
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
28.685 : WARN :  New graph after copy node: ( B ) {
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  edges: [],
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
}
28.693 : DEBUG :  Map(6) {
28.685 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
}
28.693 : DEBUG :  Extracting node d Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.693 : DEBUG :  Not a cluster d [33m0[39m
28.693 : DEBUG :  Nodes =  [ [32m'd'[39m, [32m'D'[39m ] [33m1[39m
28.693 : DEBUG :  Extracting node d Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
28.685 : WARN :  Old graph before copy {
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  nodes: [
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'C'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.685 : WARN :  Copying children of  C root C data [90mundefined[39m C
28.685 : WARN :  Copying (nodes) clusterId C nodes [ [32m'c'[39m ]
28.685 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
  edges: [],
} [33mfalse[39m [33mfalse[39m { data: [33m3[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
28.693 : DEBUG :  Not a cluster d [33m1[39m
}
28.693 : DEBUG :  Extracting node D Map(6) {
28.685 : WARN :  New list of nodes [ [32m'A'[39m, [32m'B'[39m, [32m'C'[39m ]
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
28.685 : WARN :   Now next level A {
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: [90mundefined[39m },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: [90mundefined[39m },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
28.693 : INFO :  cp  d  to  D  with parent  D
28.693 : INFO :  In copy  D root D data { data: [33m2[39m } D
28.693 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.693 : DEBUG :  Copying Edges []
28.693 : DEBUG :  Removing node d
28.693 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'D'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
  clusterNode: [33mtrue[39m,
28.693 : DEBUG :  Done, no node has children [ [32m'd'[39m ]
  id: [32m'A'[39m,

  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.685 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.685 : WARN :   Now next level B {
  clusterNode: [33mtrue[39m,
  id: [32m'B'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.685 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.685 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: [90mundefined[39m,
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.685 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
28.693 : WARN :  Cluster identified C  Replacement id in edges:  d
28.693 : WARN :  Cluster identified D  Replacement id in edges:  d
28.693 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.693 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
28.693 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
28.693 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.693 : WARN :  Copying children of  C root C data { data: [33m1[39m } C
28.693 : WARN :  Copying (nodes) clusterId C nodes [ [32m'D'[39m ]
28.693 : WARN :  Copying children of  D root C data { data: [33m2[39m } C
28.693 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m, [32m'D'[39m ]
28.693 : WARN :  Setting parent d D
28.693 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.693 : WARN :  Cluster **  D  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
28.693 : WARN :  New list of nodes [ [32m'C'[39m ]
28.693 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: { data: [33m1[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m, D: [36m[Object][39m },
    _parent: { d: [32m'D'[39m, D: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {}, D: [36m[Object][39m },
    _in: { d: {}, D: {} },
    _preds: { d: {}, D: {} },
    _out: { d: {}, D: {} },
    _sucs: { d: {}, D: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m2[39m
  }
}
28.693 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
28.693 : WARN :  Cluster without external connections, without a parent and with children D [33m1[39m
28.693 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.693 : WARN :  Copying children of  D root D data { data: [33m2[39m } D
28.693 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m ]
28.693 : WARN :  New graph after copy node: ( D ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.693 : WARN :  New list of nodes [ [32m'D'[39m ]
28.693 : WARN :   Now next level D {
  clusterNode: [33mtrue[39m,
  id: [32m'D'[39m,
  clusterData: { data: [33m2[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m },
    _parent: { d: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {} },
    _in: { d: {} },
    _preds: { d: {} },
    _out: { d: {} },
    _sucs: { d: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.693 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB10
28.690 : WARN :  Cluster identified C  Replacement id in edges:  d
28.690 : WARN :  Cluster identified D  Replacement id in edges:  d
28.690 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.690 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
28.690 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
28.690 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.690 : WARN :  Copying children of  C root C data { data: [33m1[39m } C
28.690 : WARN :  Copying (nodes) clusterId C nodes [ [32m'D'[39m ]
28.690 : WARN :  Copying children of  D root C data { data: [33m2[39m } C
28.690 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m, [32m'D'[39m ]
28.690 : WARN :  Setting parent d D
28.690 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.690 : WARN :  Cluster **  D  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
28.690 : WARN :  New list of nodes [ [32m'C'[39m ]
28.690 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: { data: [33m1[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m, D: [36m[Object][39m },
    _parent: { d: [32m'D'[39m, D: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {}, D: [36m[Object][39m },
    _in: { d: {}, D: {} },
    _preds: { d: {}, D: {} },
    _out: { d: {}, D: {} },
    _sucs: { d: {}, D: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m2[39m
  }
}
28.690 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
28.690 : WARN :  Cluster without external connections, without a parent and with children D [33m1[39m
28.690 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.690 : WARN :  Copying children of  D root D data { data: [33m2[39m } D
28.690 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m ]
28.690 : WARN :  New graph after copy node: ( D ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.690 : WARN :  New list of nodes [ [32m'D'[39m ]
28.690 : WARN :   Now next level D {
  clusterNode: [33mtrue[39m,
  id: [32m'D'[39m,
  clusterData: { data: [33m2[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m },
    _parent: { d: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {} },
    _in: { d: {} },
    _preds: { d: {} },
    _out: { d: {} },
    _sucs: { d: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.690 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
28.696 : INFO :  Graph before { data: [33m2[39m }
28.696 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.696 : DEBUG :  Opting in, graph
28.696 : DEBUG :  Cluster identified C {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
28.696 : DEBUG :  Cluster identified D {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
28.696 : DEBUG :  Not a cluster  d {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
28.696 : DEBUG :  Cluster identified B {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
28.696 : DEBUG :  Not a cluster  b {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
28.696 : DEBUG :  Cluster identified A {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
28.696 : DEBUG :  Not a cluster  a {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ]
}
28.696 : DEBUG :  Nodes =  [
  [32m'C'[39m, [32m'D'[39m, [32m'd'[39m,
  [32m'B'[39m, [32m'b'[39m, [32m'A'[39m,
  [32m'a'[39m
] [33m0[39m
28.696 : DEBUG :  Extracting node C {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [ [32m'd'[39m ]  Depth  [33m0[39m
28.696 : INFO :  cp  d  to  C  with parent  D
28.696 : DEBUG :  Setting parent d D
28.696 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
28.696 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.696 : INFO :  Edge data { data: [32m'link1'[39m } C
28.696 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
28.696 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.696 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
28.696 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.696 : INFO :  Edge data { data: [32m'link2'[39m } C
28.696 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
28.696 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.696 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
28.696 : DEBUG :  Removing node d
28.696 : INFO :  cp  D  to  C  with parent  D
28.696 : INFO :  In copy  D root C data { data: [33m2[39m } C
28.696 : DEBUG :  Not Setting parent for node= D cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
28.696 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
28.696 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.696 : INFO :  Edge data { data: [32m'link1'[39m } C
28.696 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
28.696 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.696 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
28.696 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.696 : INFO :  Edge data { data: [32m'link2'[39m } C
28.696 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
28.696 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.696 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
28.696 : DEBUG :  Removing node D
28.696 : DEBUG :  Removing node D
28.696 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.696 : DEBUG :  Extracting node D {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.696 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
}
28.696 : DEBUG :  Extracting node d {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.696 : DEBUG :  Not a cluster d [33m0[39m
28.696 : DEBUG :  Extracting node B {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
28.696 : INFO :  cp  b  to  B  with parent  B
28.696 : INFO :  In copy  B root B data { data: [33m4[39m } B
28.696 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.696 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
28.696 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.696 : INFO :  Edge data { data: [32m'link1'[39m } B
28.696 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
28.696 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.696 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
28.696 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.696 : INFO :  Edge data { data: [32m'link2'[39m } B
28.696 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
28.696 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.696 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
28.696 : DEBUG :  Removing node b
28.696 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.696 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.696 : DEBUG :  Not a cluster b [33m0[39m
28.696 : DEBUG :  Extracting node A {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m6[39m } [90mundefined[39m  Depth  [33m0[39m
28.696 : INFO :  cp  a  to  A  with parent  A
28.696 : INFO :  In copy  A root A data { data: [33m6[39m } A
28.696 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.696 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
28.696 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.696 : INFO :  Edge data { data: [32m'link1'[39m } A
28.696 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
28.696 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.696 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
28.696 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.696 : INFO :  Edge data { data: [32m'link2'[39m } A
28.696 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
28.696 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.696 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
28.696 : DEBUG :  Removing node a
28.696 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.696 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.696 : DEBUG :  Not a cluster a [33m0[39m
28.696 : DEBUG :  Nodes =  [ [32m'd'[39m, [32m'D'[39m ] [33m1[39m
28.696 : DEBUG :  Extracting node d {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mfalse[39m { data: [33m3[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
28.696 : DEBUG :  Not a cluster d [33m1[39m
28.696 : DEBUG :  Extracting node D {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
28.696 : INFO :  cp  d  to  D  with parent  D
28.696 : INFO :  In copy  D root D data { data: [33m2[39m } D
28.696 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.696 : DEBUG :  Copying Edges []
28.696 : DEBUG :  Removing node d
28.696 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'D'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.696 : DEBUG :  Done, no node has children [ [32m'd'[39m ]
28.696 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
28.696 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
28.696 : INFO :  A [ [32m'a'[39m ]

stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
28.696 : WARN :  Cluster identified C  Replacement id in edges:  d
28.696 : WARN :  Cluster identified D  Replacement id in edges:  d
28.696 : WARN :  Cluster identified B  Replacement id in edges:  b
28.696 : WARN :  Cluster identified A  Replacement id in edges:  a
28.696 : WARN :  Edge A -> B: {"v":"A","w":"B","name":"1"}
28.696 : WARN :  Edge A -> B: {"data":"link1"}
28.696 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} ids: A B Translating:  { id: [32m'a'[39m, clusterData: { data: [33m6[39m } }  ---  { id: [32m'b'[39m, clusterData: { data: [33m4[39m } }
28.696 : WARN :  Fixing and trixing - removing XXX A B 1
28.696 : WARN :  Fix Replacing with XXX A B 1
28.696 : WARN :  Edge A -> C: {"v":"A","w":"C","name":"2"}
28.696 : WARN :  Edge A -> C: {"data":"link2"}
28.696 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} ids: A C Translating:  { id: [32m'a'[39m, clusterData: { data: [33m6[39m } }  ---  { id: [32m'D'[39m, clusterData: { data: [33m1[39m } }
28.696 : WARN :  Fixing and trixing - removing XXX A C 2
28.696 : WARN :  Fix Replacing with XXX A C 2
28.696 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.696 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
28.696 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
28.696 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.696 : WARN :  Copying children of  C root C data { data: [33m1[39m } C
28.696 : WARN :  Copying (nodes) clusterId C nodes [ [32m'D'[39m ]
28.696 : WARN :  Copying children of  D root C data { data: [33m2[39m } C
28.696 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m, [32m'D'[39m ]
28.696 : WARN :  Setting parent d D
28.696 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.696 : WARN :  Cluster **  D  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
28.696 : WARN :  Cluster without external connections, without a parent and with children B [33m0[39m
28.696 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.696 : WARN :  Copying children of  B root B data { data: [33m4[39m } B
28.696 : WARN :  Copying (nodes) clusterId B nodes [ [32m'b'[39m ]
28.696 : WARN :  New graph after copy node: ( B ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.696 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
28.696 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.696 : WARN :  Copying children of  A root A data { data: [33m6[39m } A
28.696 : WARN :  Copying (nodes) clusterId A nodes [ [32m'a'[39m ]
28.696 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.696 : WARN :  New list of nodes [ [32m'C'[39m, [32m'B'[39m, [32m'A'[39m ]
28.696 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: { data: [33m1[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m, D: [36m[Object][39m },
    _parent: { d: [32m'D'[39m, D: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {}, D: [36m[Object][39m },
    _in: { d: {}, D: {} },
    _preds: { d: {}, D: {} },
    _out: { d: {}, D: {} },
    _sucs: { d: {}, D: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m2[39m
  }
}
28.696 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
28.696 : WARN :  Cluster without external connections, without a parent and with children D [33m1[39m
28.696 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.696 : WARN :  Copying children of  D root D data { data: [33m2[39m } D
28.696 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m ]
28.696 : WARN :  New graph after copy node: ( D ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.696 : WARN :  New list of nodes [ [32m'D'[39m ]
28.696 : WARN :   Now next level D {
  clusterNode: [33mtrue[39m,
  id: [32m'D'[39m,
  clusterData: { data: [33m2[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m },
    _parent: { d: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {} },
    _in: { d: {} },
    _preds: { d: {} },
    _out: { d: {} },
    _sucs: { d: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.696 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.696 : WARN :   Now next level B {
  clusterNode: [33mtrue[39m,
  id: [32m'B'[39m,
  clusterData: { data: [33m4[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.696 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.696 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: { data: [33m6[39m },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.696 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
28.699 : INFO :  Graph before { data: [33m2[39m }
28.699 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.699 : DEBUG :  Opting in, graph
28.699 : DEBUG :  Cluster identified C Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
28.699 : DEBUG :  Cluster identified D Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
28.699 : DEBUG :  Not a cluster  d Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
28.699 : DEBUG :  Cluster identified B Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
28.699 : DEBUG :  Not a cluster  b Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
28.699 : DEBUG :  Cluster identified A Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
28.699 : DEBUG :  Not a cluster  a Map(6) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ]
}
28.699 : DEBUG :  Nodes =  [
  [32m'C'[39m, [32m'D'[39m, [32m'd'[39m,
  [32m'B'[39m, [32m'b'[39m, [32m'A'[39m,
  [32m'a'[39m
] [33m0[39m
28.699 : DEBUG :  Extracting node C Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [ [32m'd'[39m ]  Depth  [33m0[39m
28.699 : INFO :  cp  d  to  C  with parent  D
28.699 : DEBUG :  Setting parent d D
28.699 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
28.699 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.699 : INFO :  Edge data { data: [32m'link1'[39m } C
28.699 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
28.699 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.699 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
28.699 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.699 : INFO :  Edge data { data: [32m'link2'[39m } C
28.699 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
28.699 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.699 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
28.699 : DEBUG :  Removing node d
28.699 : INFO :  cp  D  to  C  with parent  D
28.699 : INFO :  In copy  D root C data { data: [33m2[39m } C
28.699 : DEBUG :  Not Setting parent for node= D cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
28.699 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
28.699 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.699 : INFO :  Edge data { data: [32m'link1'[39m } C
28.699 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
28.699 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.699 : INFO :  Skipping copy of edge  A --> B  rootId:  C  clusterId: D
28.699 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.699 : INFO :  Edge data { data: [32m'link2'[39m } C
28.699 : INFO :  Descendants of  C  is  [ [32m'D'[39m, [32m'd'[39m ]
28.699 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.699 : INFO :  Skipping copy of edge  A --> C  rootId:  C  clusterId: D
28.699 : DEBUG :  Removing node D
28.699 : DEBUG :  Removing node D
28.699 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.699 : DEBUG :  Extracting node D Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.699 : DEBUG :  Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
}
28.699 : DEBUG :  Extracting node d Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.699 : DEBUG :  Not a cluster d [33m0[39m
28.699 : DEBUG :  Extracting node B Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m4[39m } [90mundefined[39m  Depth  [33m0[39m
28.699 : INFO :  cp  b  to  B  with parent  B
28.699 : INFO :  In copy  B root B data { data: [33m4[39m } B
28.699 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.699 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
28.699 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.699 : INFO :  Edge data { data: [32m'link1'[39m } B
28.699 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
28.699 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.699 : INFO :  Skipping copy of edge  A --> B  rootId:  B  clusterId: B
28.699 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.699 : INFO :  Edge data { data: [32m'link2'[39m } B
28.699 : INFO :  Descendants of  B  is  [ [32m'b'[39m ]
28.699 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.699 : INFO :  Skipping copy of edge  A --> C  rootId:  B  clusterId: B
28.699 : DEBUG :  Removing node b
28.699 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.699 : DEBUG :  Extracting node b Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.699 : DEBUG :  Not a cluster b [33m0[39m
28.699 : DEBUG :  Extracting node A Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m6[39m } [90mundefined[39m  Depth  [33m0[39m
28.699 : INFO :  cp  a  to  A  with parent  A
28.699 : INFO :  In copy  A root A data { data: [33m6[39m } A
28.699 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.699 : DEBUG :  Copying Edges [ { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }, { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m } ]
28.699 : INFO :  Edge { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.699 : INFO :  Edge data { data: [32m'link1'[39m } A
28.699 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
28.699 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m }
28.699 : INFO :  Skipping copy of edge  A --> B  rootId:  A  clusterId: A
28.699 : INFO :  Edge { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
28.699 : INFO :  Edge data { data: [32m'link2'[39m } A
28.699 : INFO :  Descendants of  A  is  [ [32m'a'[39m ]
28.699 : INFO :  Edge is  { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m }
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct data GLB11
28.699 : WARN :  Cluster identified C  Replacement id in edges:  d
28.699 : WARN :  Cluster identified D  Replacement id in edges:  d
28.699 : WARN :  Cluster identified B  Replacement id in edges:  b
28.699 : WARN :  Cluster identified A  Replacement id in edges:  a
28.699 : WARN :  Edge A -> B: {"v":"A","w":"B","name":"1"}
28.699 : WARN :  Edge A -> B: {"data":"link1"}
28.699 : WARN :  Fix XXX Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} ids: A B Translating:  { id: [32m'a'[39m, clusterData: { data: [33m6[39m } }  ---  { id: [32m'b'[39m, clusterData: { data: [33m4[39m } }
28.699 : WARN :  Fixing and trying - removing XXX A B 1
28.699 : WARN :  Fix Replacing with XXX A B 1
28.699 : WARN :  Edge A -> C: {"v":"A","w":"C","name":"2"}
28.699 : WARN :  Edge A -> C: {"data":"link2"}
28.699 : WARN :  Fix XXX Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
28.699 : INFO :  Skipping copy of edge  A --> C  rootId:  A  clusterId: A
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
28.699 : DEBUG :  Removing node a
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
28.699 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
} ids: A C Translating:  { id: [32m'a'[39m, clusterData: { data: [33m6[39m } }  ---  { id: [32m'D'[39m, clusterData: { data: [33m1[39m } }
28.699 : WARN :  Fixing and trying - removing XXX A C 2
28.699 : WARN :  Fix Replacing with XXX A C 2
28.699 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
    { v: [32m'C'[39m, value: [36m[Object][39m },
  ],
    { v: [32m'B'[39m, value: [36m[Object][39m },
  edges: [
    { v: [32m'A'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.699 : DEBUG :  Extracting node a Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.699 : DEBUG :  Not a cluster a [33m0[39m
28.699 : DEBUG :  Nodes =  [ [32m'd'[39m, [32m'D'[39m ] [33m1[39m
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
28.699 : DEBUG :  Extracting node d Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mfalse[39m { data: [33m3[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
28.699 : DEBUG :  Not a cluster d [33m1[39m
28.699 : DEBUG :  Extracting node D Map(6) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'd'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [ [32m'd'[39m ]  Depth  [33m1[39m
28.699 : INFO :  cp  d  to  D  with parent  D
28.699 : INFO :  In copy  D root D data { data: [33m2[39m } D
28.699 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.699 : DEBUG :  Copying Edges []
28.699 : DEBUG :  Removing node d
28.699 : DEBUG :  Old graph after copy {
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.699 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  ],
  nodes: [ { v: [32m'D'[39m, value: [36m[Object][39m } ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
  edges: [],
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  ],
}
28.699 : DEBUG :  Done, no node has children [ [32m'd'[39m ]
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
28.699 : DEBUG :  Done, no node has children [ [32m'b'[39m ]
28.699 : WARN :  Cluster without external connections, without a parent and with children C [33m0[39m
28.699 : WARN :  Old graph before copy {
28.699 : DEBUG :  Done, no node has children [ [32m'a'[39m ]
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
28.699 : INFO :  A [ [32m'a'[39m ]
  nodes: [

    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'D'[39m, value: [36m[Object][39m, parent: [32m'C'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.699 : WARN :  Copying children of  C root C data { data: [33m1[39m } C
28.699 : WARN :  Copying (nodes) clusterId C nodes [ [32m'D'[39m ]
28.699 : WARN :  Copying children of  D root C data { data: [33m2[39m } C
28.699 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m, [32m'D'[39m ]
28.699 : WARN :  Setting parent d D
28.699 : WARN :  New graph after copy node: ( C ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.699 : WARN :  Cluster **  D  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
28.699 : WARN :  Cluster without external connections, without a parent and with children B [33m0[39m
28.699 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.699 : WARN :  Copying children of  B root B data { data: [33m4[39m } B
28.699 : WARN :  Copying (nodes) clusterId B nodes [ [32m'b'[39m ]
28.699 : WARN :  New graph after copy node: ( B ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.699 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
28.699 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'C'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'A'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'A'[39m, w: [32m'C'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.699 : WARN :  Copying children of  A root A data { data: [33m6[39m } A
28.699 : WARN :  Copying (nodes) clusterId A nodes [ [32m'a'[39m ]
28.699 : WARN :  New graph after copy node: ( A ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.699 : WARN :  New list of nodes [ [32m'C'[39m, [32m'B'[39m, [32m'A'[39m ]
28.699 : WARN :   Now next level C {
  clusterNode: [33mtrue[39m,
  id: [32m'C'[39m,
  clusterData: { data: [33m1[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m, D: [36m[Object][39m },
    _parent: { d: [32m'D'[39m, D: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {}, D: [36m[Object][39m },
    _in: { d: {}, D: {} },
    _preds: { d: {}, D: {} },
    _out: { d: {}, D: {} },
    _sucs: { d: {}, D: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m2[39m
  }
}
28.699 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [ [32m'd'[39m ]
28.699 : WARN :  Cluster without external connections, without a parent and with children D [33m1[39m
28.699 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'D'[39m },
    { v: [32m'D'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.699 : WARN :  Copying children of  D root D data { data: [33m2[39m } D
28.699 : WARN :  Copying (nodes) clusterId D nodes [ [32m'd'[39m ]
28.699 : WARN :  New graph after copy node: ( D ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.699 : WARN :  New list of nodes [ [32m'D'[39m ]
28.699 : WARN :   Now next level D {
  clusterNode: [33mtrue[39m,
  id: [32m'D'[39m,
  clusterData: { data: [33m2[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { d: [36m[Object][39m },
    _parent: { d: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, d: {} },
    _in: { d: {} },
    _preds: { d: {} },
    _out: { d: {} },
    _sucs: { d: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.699 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'd'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.699 : WARN :   Now next level B {
  clusterNode: [33mtrue[39m,
  id: [32m'B'[39m,
  clusterData: { data: [33m4[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { b: [36m[Object][39m },
    _parent: { b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, b: {} },
    _in: { b: {} },
    _preds: { b: {} },
    _out: { b: {} },
    _sucs: { b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.699 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.699 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: { data: [33m6[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { a: [36m[Object][39m },
    _parent: { a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, a: {} },
    _in: { a: {} },
    _preds: { a: {} },
    _out: { a: {} },
    _sucs: { a: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.699 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
28.716 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
28.716 : WARN :  Cluster identified b  Replacement id in edges:  c
28.716 : WARN :  Edge a -> b: {"v":"a","w":"b","name":"1"}
  edges: [
28.716 : WARN :  Edge a -> b: {"data":"link1"}
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.716 : DEBUG :  Opting in, graph
28.716 : DEBUG :  Not a cluster  a {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
28.716 : DEBUG :  Cluster identified b {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
28.716 : WARN :  Fix XXX {
}
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
28.716 : DEBUG :  Not a cluster  c {
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  C1: [ [32m'a'[39m ],
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  C2: [ [32m'b'[39m ],
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  A: [ [32m'a'[39m ],
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  B: [ [32m'b'[39m ],
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  C: [ [32m'D'[39m, [32m'd'[39m ],
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
  D: [ [32m'd'[39m ],
} ids: a b Translating:  [90mundefined[39m  ---  { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
28.716 : WARN :  Fixing and trixing - removing XXX a b 1
28.716 : WARN :  Fix Replacing with XXX a b 1
28.716 : WARN :  Edge c -> d: {"v":"c","w":"d","name":"2"}
28.716 : WARN :  Edge c -> d: {"data":"link2"}
28.716 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} ids: c d Translating:  [90mundefined[39m  ---  [90mundefined[39m
28.716 : WARN :  Edge d -> e: {"v":"d","w":"e","name":"2"}
28.716 : WARN :  Edge d -> e: {"data":"link2"}
28.716 : WARN :  Fix XXX {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
} ids: d e Translating:  [90mundefined[39m  ---  [90mundefined[39m
}
28.716 : WARN :  Adjusted Graph {
28.716 : DEBUG :  Not a cluster  d {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.716 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  C1: [ [32m'a'[39m ],
  edges: [
  C2: [ [32m'b'[39m ],
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
28.716 : DEBUG :  Not a cluster  e {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
28.716 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ] [33m0[39m
28.716 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
} [90mundefined[39m [33mtrue[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
28.716 : DEBUG :  Not a cluster a [33m0[39m
28.716 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
28.716 : INFO :  cp  c  to  b  with parent  b
28.716 : INFO :  In copy  b root b data { data: [33m2[39m } b
28.716 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.716 : DEBUG :  Copying Edges [
  { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m },
  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m },
  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
]
28.716 : INFO :  Edge { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }
28.716 : INFO :  Edge data { data: [32m'link2'[39m } b
28.716 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
28.716 : INFO :  Edge is  { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }
28.716 : INFO :  Copying as  c d { data: [32m'link2'[39m } 2
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.716 : WARN :  Cluster without external connections, without a parent and with children b [33m0[39m
28.716 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
28.716 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
  ],
28.716 : INFO :  Edge { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
28.716 : INFO :  Edge data { data: [32m'link2'[39m } b
}
28.716 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
28.716 : WARN :  Copying children of  b root b data { data: [33m2[39m } b
28.716 : INFO :  Edge is  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
28.716 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
28.716 : INFO :  Copying as  d e { data: [32m'link2'[39m } 2
28.716 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }, { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
28.716 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
28.716 : INFO :  Edge data { data: [32m'link1'[39m } b
28.716 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
28.716 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
28.716 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
28.716 : DEBUG :  Removing node c
28.716 : INFO :  cp  d  to  b  with parent  b
28.716 : INFO :  In copy  b root b data { data: [33m2[39m } b
28.716 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.716 : DEBUG :  Copying Edges [ { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }, { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
28.716 : INFO :  Edge { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
28.716 : INFO :  Edge data { data: [32m'link2'[39m } b
28.716 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
28.716 : INFO :  Edge is  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
28.716 : INFO :  Copying as  d e { data: [32m'link2'[39m } 2
28.716 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }, { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
28.716 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
28.716 : INFO :  Edge data { data: [32m'link1'[39m } b
28.716 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
28.716 : WARN :  New graph after copy node: ( b ) {
28.716 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
28.716 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
  nodes: [
28.716 : DEBUG :  Removing node d
    { v: [32m'c'[39m, value: [36m[Object][39m },
28.716 : INFO :  cp  e  to  b  with parent  b
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  ],
28.716 : INFO :  In copy  b root b data { data: [33m2[39m } b
  edges: [
28.716 : DEBUG :  Not Setting parent for node= e cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
28.716 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
28.716 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
  ],
28.716 : INFO :  Edge data { data: [32m'link1'[39m } b
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
28.716 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
28.716 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
28.716 : WARN :  New list of nodes [ [32m'a'[39m, [32m'b'[39m ]
28.716 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
28.716 : WARN :   Now next level a { data: [33m1[39m }
28.716 : DEBUG :  Removing node e
28.716 : WARN :   Now next level b {
28.716 : DEBUG :  Old graph after copy {
  clusterNode: [33mtrue[39m,
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  id: [32m'b'[39m,
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m }, { v: [32m'b'[39m, value: [36m[Object][39m } ],
  clusterData: { data: [33m2[39m },
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m, d: [36m[Object][39m, e: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m, d: [32m'\x00'[39m, e: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {}, d: {}, e: {} },
    _in: { c: {}, d: [36m[Object][39m, e: [36m[Object][39m },
    _preds: { c: {}, d: [36m[Object][39m, e: [36m[Object][39m },
    _out: { c: [36m[Object][39m, d: [36m[Object][39m, e: {} },
    _sucs: { c: [36m[Object][39m, d: [36m[Object][39m, e: {} },
    _edgeObjs: { [32m'c\x01d\x012'[39m: [36m[Object][39m, [32m'd\x01e\x012'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'c\x01d\x012'[39m: [36m[Object][39m, [32m'd\x01e\x012'[39m: [36m[Object][39m },
    _nodeCount: [33m3[39m,
    _edgeCount: [33m2[39m
  }
}
28.716 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  ],
  edges: [
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.716 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.716 : DEBUG :  Not a cluster c [33m0[39m
28.716 : DEBUG :  Extracting node d {
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  ],
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
} [90mundefined[39m
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },

  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.716 : DEBUG :  Not a cluster d [33m0[39m
28.716 : DEBUG :  Extracting node e {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.716 : DEBUG :  Not a cluster e [33m0[39m
28.716 : DEBUG :  Done, no node has children [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
28.716 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
28.717 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.717 : DEBUG :  Opting in, graph
28.717 : DEBUG :  Not a cluster  a Map(7) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
28.717 : DEBUG :  Cluster identified b Map(7) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
28.717 : DEBUG :  Not a cluster  c Map(7) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
28.717 : DEBUG :  Not a cluster  d Map(7) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
28.717 : DEBUG :  Not a cluster  e Map(7) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
28.717 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ] [33m0[39m
28.717 : DEBUG :  Extracting node a Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
28.717 : DEBUG :  Not a cluster a [33m0[39m
28.717 : DEBUG :  Extracting node b Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m0[39m
28.717 : INFO :  cp  c  to  b  with parent  b
28.717 : INFO :  In copy  b root b data { data: [33m2[39m } b
28.717 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.717 : DEBUG :  Copying Edges [
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB20
28.717 : WARN :  Cluster identified b  Replacement id in edges:  c
28.717 : WARN :  Edge a -> b: {"v":"a","w":"b","name":"1"}
28.717 : WARN :  Edge a -> b: {"data":"link1"}
28.717 : WARN :  Fix XXX Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} ids: a b Translating:  [90mundefined[39m  ---  { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
28.717 : WARN :  Fixing and trying - removing XXX a b 1
28.717 : WARN :  Fix Replacing with XXX a b 1
28.717 : WARN :  Edge c -> d: {"v":"c","w":"d","name":"2"}
28.717 : WARN :  Edge c -> d: {"data":"link2"}
28.717 : WARN :  Fix XXX Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} ids: c d Translating:  [90mundefined[39m  ---  [90mundefined[39m
28.717 : WARN :  Edge d -> e: {"v":"d","w":"e","name":"2"}
28.717 : WARN :  Edge d -> e: {"data":"link2"}
28.717 : WARN :  Fix XXX Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m },
  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
]
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
28.717 : INFO :  Edge { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
28.717 : INFO :  Edge data { data: [32m'link2'[39m } b
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
28.717 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} ids: d e Translating:  [90mundefined[39m  ---  [90mundefined[39m
28.717 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
28.717 : INFO :  Edge is  { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }
  nodes: [
28.717 : INFO :  Copying as  c d { data: [32m'link2'[39m } 2
    { v: [32m'a'[39m, value: [36m[Object][39m },
28.717 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
    { v: [32m'b'[39m, value: [36m[Object][39m },
28.717 : INFO :  Edge { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
28.717 : INFO :  Edge data { data: [32m'link2'[39m } b
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
28.717 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
28.717 : INFO :  Edge is  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
  ],
28.717 : INFO :  Copying as  d e { data: [32m'link2'[39m } 2
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
28.717 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }, { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
28.717 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
28.717 : INFO :  Edge data { data: [32m'link1'[39m } b
28.717 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
28.717 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
28.717 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
28.717 : DEBUG :  Removing node c
28.717 : INFO :  cp  d  to  b  with parent  b
28.717 : INFO :  In copy  b root b data { data: [33m2[39m } b
28.717 : DEBUG :  Not Setting parent for node= d cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.717 : DEBUG :  Copying Edges [ { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }, { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
28.717 : INFO :  Edge { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
28.717 : INFO :  Edge data { data: [32m'link2'[39m } b
28.717 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
28.717 : INFO :  Edge is  { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m }
28.717 : INFO :  Copying as  d e { data: [32m'link2'[39m } 2
28.717 : INFO :  newGraph edges  [ { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m }, { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m } ] { data: [32m'link2'[39m }
28.717 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
  ],
28.717 : INFO :  Edge data { data: [32m'link1'[39m } b
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
28.717 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
}
28.717 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
28.717 : WARN :  extractor -  [33m0[39m {
28.717 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
28.717 : DEBUG :  Removing node d
  nodes: [
28.717 : INFO :  cp  e  to  b  with parent  b
    { v: [32m'a'[39m, value: [36m[Object][39m },
28.717 : INFO :  In copy  b root b data { data: [33m2[39m } b
28.717 : DEBUG :  Not Setting parent for node= e cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.717 : DEBUG :  Copying Edges [ { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m } ]
28.717 : INFO :  Edge { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
28.717 : INFO :  Edge data { data: [32m'link1'[39m } b
28.717 : INFO :  Descendants of  b  is  [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
28.717 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m }
28.717 : INFO :  Skipping copy of edge  a --> b  rootId:  b  clusterId: b
28.717 : DEBUG :  Removing node e
28.717 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m }, { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [ { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m } ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.717 : DEBUG :  Extracting node c Map(7) {
    { v: [32m'b'[39m, value: [36m[Object][39m },
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.717 : DEBUG :  Not a cluster c [33m0[39m
28.717 : DEBUG :  Extracting node d Map(7) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  ],
28.717 : DEBUG :  Not a cluster d [33m0[39m
  edges: [
28.717 : DEBUG :  Extracting node e Map(7) {
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  ],
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  [32m'B'[39m => { id: [32m'b'[39m, clusterData: { data: [33m4[39m } },
} [90mundefined[39m
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
28.717 : WARN :  Cluster without external connections, without a parent and with children b [33m0[39m
  [32m'D'[39m => { id: [32m'b'[39m, clusterData: { data: [33m2[39m } },
28.717 : WARN :  Old graph before copy {
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  nodes: [
28.717 : DEBUG :  Not a cluster e [33m0[39m
    { v: [32m'a'[39m, value: [36m[Object][39m },
28.717 : DEBUG :  Done, no node has children [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
    { v: [32m'b'[39m, value: [36m[Object][39m },
28.717 : INFO :  Graph after {
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

    { v: [32m'd'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'b'[39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'b'[39m, name: [32m'1'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.717 : WARN :  Copying children of  b root b data { data: [33m2[39m } b
28.717 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m, [32m'd'[39m, [32m'e'[39m ]
28.717 : WARN :  New graph after copy node: ( b ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.717 : WARN :  New list of nodes [ [32m'a'[39m, [32m'b'[39m ]
28.717 : WARN :   Now next level a { data: [33m1[39m }
28.717 : WARN :   Now next level b {
  clusterNode: [33mtrue[39m,
  id: [32m'b'[39m,
  clusterData: { data: [33m2[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m, d: [36m[Object][39m, e: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m, d: [32m'\x00'[39m, e: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {}, d: {}, e: {} },
    _in: { c: {}, d: [36m[Object][39m, e: [36m[Object][39m },
    _preds: { c: {}, d: [36m[Object][39m, e: [36m[Object][39m },
    _out: { c: [36m[Object][39m, d: [36m[Object][39m, e: {} },
    _sucs: { c: [36m[Object][39m, d: [36m[Object][39m, e: {} },
    _edgeObjs: { [32m'c\x01d\x012'[39m: [36m[Object][39m, [32m'd\x01e\x012'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'c\x01d\x012'[39m: [36m[Object][39m, [32m'd\x01e\x012'[39m: [36m[Object][39m },
    _nodeCount: [33m3[39m,
    _edgeCount: [33m2[39m
  }
}
28.717 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, value: [36m[Object][39m },
    { v: [32m'e'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'c'[39m, w: [32m'd'[39m, name: [32m'2'[39m, value: [36m[Object][39m },
    { v: [32m'd'[39m, w: [32m'e'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
28.726 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.726 : DEBUG :  Opting in, graph
28.726 : DEBUG :  Cluster identified a Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
28.726 : DEBUG :  Cluster identified b Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
28.726 : DEBUG :  Cluster identified c Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
28.726 : DEBUG :  Not a cluster  e Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'a'[39m ],
  [32m'B'[39m => [ [32m'b'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
28.726 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ] [33m0[39m
28.726 : DEBUG :  Extracting node a Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
28.726 : INFO :  cp  e  to  a  with parent  c
28.726 : DEBUG :  Setting parent e c
28.726 : DEBUG :  Copying Edges []
28.726 : DEBUG :  Removing node e
28.726 : INFO :  cp  c  to  a  with parent  c
28.726 : INFO :  In copy  c root a data { data: [33m3[39m } a
28.726 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
28.726 : DEBUG :  Copying Edges []
28.726 : DEBUG :  Removing node c
28.726 : DEBUG :  Removing node c
28.726 : INFO :  cp  b  to  a  with parent  b
28.726 : INFO :  In copy  b root a data { data: [33m2[39m } a
28.726 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
28.726 : DEBUG :  Copying Edges []
28.726 : DEBUG :  Removing node b
28.726 : DEBUG :  Removing node b
28.726 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.726 : DEBUG :  Extracting node b Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.726 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
28.726 : DEBUG :  Extracting node c Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.726 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
28.726 : DEBUG :  Extracting node e Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.726 : DEBUG :  Not a cluster e [33m0[39m
28.726 : DEBUG :  Nodes =  [ [32m'e'[39m, [32m'c'[39m, [32m'b'[39m ] [33m1[39m
28.726 : DEBUG :  Extracting node e Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m1[39m
28.726 : DEBUG :  Not a cluster e [33m1[39m
28.726 : DEBUG :  Extracting node c Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m1[39m
28.726 : INFO :  cp  e  to  c  with parent  c
28.726 : INFO :  In copy  c root c data { data: [33m3[39m } c
28.726 : DEBUG :  Not Setting parent for node= e cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.726 : DEBUG :  Copying Edges []
28.726 : DEBUG :  Removing node e
28.726 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.726 : DEBUG :  Extracting node b Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  [32m'B'[39m => { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m1[39m
28.726 : INFO :  cp  c  to  b  with parent  b
28.726 : INFO :  In copy  b root b data { data: [33m2[39m } b
28.726 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.726 : DEBUG :  Copying Edges []
28.726 : DEBUG :  Removing node c
28.726 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.726 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
28.726 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
28.726 : WARN :  Cluster identified a  Replacement id in edges:  e
28.726 : WARN :  Cluster identified b  Replacement id in edges:  e
28.726 : WARN :  Cluster identified c  Replacement id in edges:  e
28.726 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.726 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.726 : WARN :  Cluster without external connections, without a parent and with children a [33m0[39m
28.726 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.726 : WARN :  Copying children of  a root a data { data: [33m1[39m } a
28.726 : WARN :  Copying (nodes) clusterId a nodes [ [32m'b'[39m ]
28.726 : WARN :  Copying children of  b root a data { data: [33m2[39m } a
28.726 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m, [32m'b'[39m ]
28.726 : WARN :  Copying children of  c root a data { data: [33m3[39m } a
28.726 : WARN :  Copying (nodes) clusterId c nodes [ [32m'e'[39m, [32m'c'[39m ]
28.726 : WARN :  Setting parent e c
28.726 : WARN :  Setting parent c b
28.726 : WARN :  New graph after copy node: ( a ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.726 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
28.726 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
28.726 : WARN :  New list of nodes [ [32m'a'[39m ]
28.726 : WARN :   Now next level a {
  clusterNode: [33mtrue[39m,
  id: [32m'a'[39m,
  clusterData: { data: [33m1[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { e: [36m[Object][39m, c: [36m[Object][39m, b: [36m[Object][39m },
    _parent: { e: [32m'c'[39m, c: [32m'b'[39m, b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, e: {}, c: [36m[Object][39m, b: [36m[Object][39m },
    _in: { e: {}, c: {}, b: {} },
    _preds: { e: {}, c: {}, b: {} },
    _out: { e: {}, c: {}, b: {} },
    _sucs: { e: {}, c: {}, b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m3[39m
  }
}
28.726 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.726 : WARN :  Cluster without external connections, without a parent and with children c [33m1[39m
28.726 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.726 : WARN :  Copying children of  c root c data { data: [33m3[39m } c
28.726 : WARN :  Copying (nodes) clusterId c nodes [ [32m'e'[39m ]
28.726 : WARN :  New graph after copy node: ( c ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'e'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.726 : WARN :  Cluster without external connections, without a parent and with children b [33m1[39m
28.726 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.726 : WARN :  Copying children of  b root b data { data: [33m2[39m } b
28.726 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m ]
28.726 : WARN :  New graph after copy node: ( b ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.726 : WARN :  New list of nodes [ [32m'b'[39m ]
28.726 : WARN :   Now next level b {
  clusterNode: [33mtrue[39m,
  id: [32m'b'[39m,
  clusterData: { data: [33m2[39m },
  label: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m },
    _parent: { c: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
    _in: { c: {} },
    _preds: { c: {} },
    _out: { c: {} },
    _sucs: { c: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m1[39m
  }
}
28.726 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

stdout | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
28.734 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.734 : DEBUG :  Opting in, graph
28.734 : DEBUG :  Cluster identified A Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
28.734 : DEBUG :  Cluster identified B Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
28.734 : DEBUG :  Not a cluster  b Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
28.734 : DEBUG :  Not a cluster  c Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
28.734 : DEBUG :  Not a cluster  a Map(9) {
  [32m'C1'[39m => [ [32m'a'[39m ],
  [32m'C2'[39m => [ [32m'b'[39m ],
  [32m'A'[39m => [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  [32m'B'[39m => [ [32m'c'[39m ],
  [32m'C'[39m => [ [32m'D'[39m, [32m'd'[39m ],
  [32m'D'[39m => [ [32m'd'[39m ],
  [32m'b'[39m => [ [32m'c'[39m, [32m'e'[39m ],
  [32m'a'[39m => [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  [32m'c'[39m => [ [32m'e'[39m ]
}
28.734 : DEBUG :  Nodes =  [ [32m'A'[39m, [32m'B'[39m, [32m'b'[39m, [32m'c'[39m, [32m'a'[39m ] [33m0[39m
28.734 : DEBUG :  Extracting node A Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  cssClass: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m0[39m
28.734 : INFO :  cp  c  to  A  with parent  B
28.734 : DEBUG :  Setting parent c B
28.734 : DEBUG :  Copying Edges [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }, { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
28.734 : INFO :  Edge { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }
28.734 : INFO :  Edge data {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
stderr | packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
28.734 : WARN :  Cluster identified A  Replacement id in edges:  c
28.734 : WARN :  Cluster identified B  Replacement id in edges:  c
28.734 : WARN :  Edge:  { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }  leaves cluster  B
28.734 : WARN :  Descendants of XXX  B :  [ [32m'c'[39m ]
28.734 : WARN :  Edge b -> B: {"v":"b","w":"B","name":"1"}
28.734 : WARN :  Edge b -> B: {"minlen":1,"arrowhead":"normal","arrowTypeStart":"arrow_open","arrowTypeEnd":"arrow_point","thickness":"normal","pattern":"solid","style":"fill:none","labelStyle":"","arrowheadStyle":"fill: #333","labelpos":"c","labelType":"text","label":"","id":"L-b-B","cssClasses":"flowchart-link LS-b LE-B"}
28.734 : WARN :  Fix XXX Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  cssClasses: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
} A
28.734 : INFO :  Descendants of  A  is  [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ]
28.734 : INFO :  Edge is  { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }
28.734 : INFO :  Copying as  b c {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
    externalConnections: [33mtrue[39m
  pattern: [32m'solid'[39m,
  },
  style: [32m'fill:none'[39m,
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  labelStyle: [32m''[39m,
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  arrowheadStyle: [32m'fill: #333'[39m,
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  labelpos: [32m'c'[39m,
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  labelType: [32m'text'[39m,
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  label: [32m''[39m,
} ids: b B Translating:  { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }  ---  {
  id: [32m'L-b-B'[39m,
  id: [32m'c'[39m,
  cssClasses: [32m'flowchart-link LS-b LE-B'[39m,
  clusterData: {
  toCluster: [32m'B'[39m
    labelStyle: [32m''[39m,
} 1
    shape: [32m'rect'[39m,
28.734 : INFO :  newGraph edges  [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m } ] {
    labelText: [32m'B'[39m,
  minlen: [33m1[39m,
    rx: [33m0[39m,
  arrowhead: [32m'normal'[39m,
    ry: [33m0[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
    class: [32m'default'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
    style: [32m''[39m,
    id: [32m'B'[39m,
    width: [33m500[39m,
    type: [32m'group'[39m,
    padding: [33m15[39m
  },
  externalConnections: [33mtrue[39m
}
28.734 : WARN :  Fixing and trying - removing XXX b B 1
28.734 : WARN :  Fix Replacing with XXX b c 1
28.734 : WARN :  Edge a -> c: {"v":"a","w":"c","name":"2"}
28.734 : WARN :  Edge a -> c: {"minlen":1,"arrowhead":"normal","arrowTypeStart":"arrow_open","arrowTypeEnd":"arrow_point","thickness":"normal","pattern":"solid","style":"fill:none","labelStyle":"","arrowheadStyle":"fill: #333","labelpos":"c","labelType":"text","label":"","id":"L-a-c","cssClasses":"flowchart-link LS-a LE-c"}
28.734 : WARN :  Fix XXX Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
  thickness: [32m'normal'[39m,
    id: [32m'c'[39m,
  pattern: [32m'solid'[39m,
    clusterData: {
  style: [32m'fill:none'[39m,
      labelStyle: [32m''[39m,
  labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
      labelText: [32m'A'[39m,
  labelpos: [32m'c'[39m,
      rx: [33m0[39m,
  labelType: [32m'text'[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
  label: [32m''[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
  id: [32m'L-b-B'[39m,
  cssClasses: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
}
28.734 : INFO :  Edge { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
28.734 : INFO :  Edge data {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-a-c'[39m,
  cssClasses: [32m'flowchart-link LS-a LE-c'[39m
} A
      labelText: [32m'B'[39m,
28.734 : INFO :  Descendants of  A  is  [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ]
28.734 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
      rx: [33m0[39m,
28.734 : INFO :  Copying as  a c {
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} ids: a c Translating:  { id: [32m'c'[39m, clusterData: { data: [33m1[39m } }  ---  { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
28.734 : WARN :  Fixing and trying - removing XXX a c 2
28.734 : WARN :  Fix Replacing with XXX a c 2
28.734 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-a-c'[39m,
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  cssClasses: [32m'flowchart-link LS-a LE-c'[39m
}
} 2
28.734 : WARN :  extractor -  [33m0[39m {
28.734 : INFO :  newGraph edges  [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }, { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ] {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  minlen: [33m1[39m,
  nodes: [
  arrowhead: [32m'normal'[39m,
    { v: [32m'A'[39m, value: [36m[Object][39m },
  arrowTypeStart: [32m'arrow_open'[39m,
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
  arrowTypeEnd: [32m'arrow_point'[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
  thickness: [32m'normal'[39m,
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
28.734 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
28.734 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  pattern: [32m'solid'[39m,
  ],
  style: [32m'fill:none'[39m,
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  labelStyle: [32m''[39m,
}
  arrowheadStyle: [32m'fill: #333'[39m,
28.734 : WARN :  Copying children of  A root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  cssClass: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
28.734 : WARN :  Copying (nodes) clusterId A nodes [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ]
28.734 : WARN :  Copying children of  B root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  labelpos: [32m'c'[39m,
  width: [33m500[39m,
  labelType: [32m'text'[39m,
  type: [32m'group'[39m,
  label: [32m''[39m,
  padding: [33m15[39m
  id: [32m'L-b-B'[39m,
} A
  cssClasses: [32m'flowchart-link LS-b LE-B'[39m,
28.734 : WARN :  Copying (nodes) clusterId B nodes [ [32m'c'[39m, [32m'B'[39m ]
  toCluster: [32m'B'[39m
28.734 : WARN :  Setting parent c B
}
28.734 : WARN :  New graph after copy node: ( A ) {
28.734 : DEBUG :  Removing node c
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
28.734 : INFO :  cp  B  to  A  with parent  B
28.734 : INFO :  In copy  B root A data {
    { v: [32m'B'[39m, value: [36m[Object][39m },
  labelStyle: [32m''[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m },
  shape: [32m'rect'[39m,
    { v: [32m'a'[39m, value: [36m[Object][39m }
  labelText: [32m'B'[39m,
  ],
  rx: [33m0[39m,
  edges: [
  ry: [33m0[39m,
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
  class: [32m'default'[39m,
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  style: [32m''[39m,
  ],
  id: [32m'B'[39m,
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
28.734 : DEBUG :  Not Setting parent for node= B cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
28.734 : DEBUG :  Copying Edges []
28.734 : DEBUG :  Removing node B
28.734 : DEBUG :  Removing node B
28.734 : INFO :  cp  b  to  A  with parent  A
28.734 : INFO :  In copy  A root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  cssClass: [32m'default'[39m,
  style: [32m''[39m,
}
  id: [32m'A'[39m,
28.734 : WARN :  Cluster **  B  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
  width: [33m500[39m,
28.734 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
  type: [32m'group'[39m,
28.734 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
  padding: [33m15[39m
28.734 : WARN :  Cluster **  a  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
} A
28.734 : WARN :  New list of nodes [ [32m'A'[39m ]
28.734 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.734 : WARN :   Now next level A {
28.734 : DEBUG :  Copying Edges []
  clusterNode: [33mtrue[39m,
28.734 : DEBUG :  Removing node b
  id: [32m'A'[39m,
28.734 : INFO :  cp  a  to  A  with parent  A
  clusterData: {
28.734 : INFO :  In copy  A root A data {
    labelStyle: [32m''[39m,
  labelStyle: [32m''[39m,
    shape: [32m'rect'[39m,
  shape: [32m'rect'[39m,
    labelText: [32m'A'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
    rx: [33m0[39m,
  cssClass: [32m'default'[39m,
    ry: [33m0[39m,
  style: [32m''[39m,
    cssClass: [32m'default'[39m,
  id: [32m'A'[39m,
    style: [32m''[39m,
  width: [33m500[39m,
    id: [32m'A'[39m,
  type: [32m'group'[39m,
    width: [33m500[39m,
  padding: [33m15[39m
    type: [32m'group'[39m,
} A
    padding: [33m15[39m
28.734 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
  },
28.734 : DEBUG :  Copying Edges []
  label: [90mundefined[39m,
28.734 : DEBUG :  Removing node a
  graph: Graph {
28.734 : DEBUG :  Old graph after copy {
    _isDirected: [33mtrue[39m,
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'A'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.734 : DEBUG :  Extracting node B Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
    _isMultigraph: [33mtrue[39m,
      cssClass: [32m'default'[39m,
    _isCompound: [33mtrue[39m,
      style: [32m''[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
      id: [32m'A'[39m,
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
      width: [33m500[39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
      type: [32m'group'[39m,
    _nodes: { c: [36m[Object][39m, B: [36m[Object][39m, b: [36m[Object][39m, a: [36m[Object][39m },
      padding: [33m15[39m
    _parent: { c: [32m'B'[39m, B: [32m'\x00'[39m, b: [32m'\x00'[39m, a: [32m'\x00'[39m },
    }
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {}, B: [36m[Object][39m, b: {}, a: {} },
  },
    _in: { c: [36m[Object][39m, B: {}, b: {}, a: {} },
  [32m'B'[39m => {
    _preds: { c: [36m[Object][39m, B: {}, b: {}, a: {} },
    id: [32m'c'[39m,
    _out: { c: {}, B: {}, b: [36m[Object][39m, a: [36m[Object][39m },
    clusterData: {
    _sucs: { c: {}, B: {}, b: [36m[Object][39m, a: [36m[Object][39m },
      labelStyle: [32m''[39m,
    _edgeObjs: { [32m'b\x01c\x011'[39m: [36m[Object][39m, [32m'a\x01c\x012'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'b\x01c\x011'[39m: [36m[Object][39m, [32m'a\x01c\x012'[39m: [36m[Object][39m },
    _nodeCount: [33m4[39m,
    _edgeCount: [33m2[39m
  }
}
28.734 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
28.734 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mfalse[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
28.734 : WARN :  Cluster **  B  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [33mtrue[39m [90mundefined[39m [33m1[39m
28.734 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
28.734 : WARN :  Cluster **  a  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
28.734 : WARN :  New list of nodes [ [32m'c'[39m, [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ]
28.734 : WARN :   Now next level c {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'c'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'c'[39m,
  padding: [33m15[39m
}
28.734 : WARN :   Now next level B {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
}
28.734 : WARN :   Now next level b {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'b'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'b'[39m,
  padding: [33m15[39m
}
28.734 : WARN :   Now next level a {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'a'[39m,
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
  rx: [33m0[39m,
28.734 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  ry: [33m0[39m,
  [32m'A'[39m => {
  class: [32m'default'[39m,
    id: [32m'c'[39m,
  style: [32m''[39m,
    clusterData: {
  id: [32m'a'[39m,
      labelStyle: [32m''[39m,
  padding: [33m15[39m
      shape: [32m'rect'[39m,
}
      labelText: [32m'A'[39m,

stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
28.723 : WARN :  Cluster identified a  Replacement id in edges:  e
28.723 : WARN :  Cluster identified b  Replacement id in edges:  e
28.723 : WARN :  Cluster identified c  Replacement id in edges:  e
28.723 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.723 : WARN :  extractor -  [33m0[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
      rx: [33m0[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
      ry: [33m0[39m,
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
      cssClass: [32m'default'[39m,
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
      style: [32m''[39m,
  ],
      id: [32m'A'[39m,
  edges: [],
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    }
} [90mundefined[39m
  },
28.723 : WARN :  Cluster without external connections, without a parent and with children a [33m0[39m
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
28.723 : WARN :  Old graph before copy {
      labelText: [32m'B'[39m,
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
      rx: [33m0[39m,
  nodes: [
      ry: [33m0[39m,
    { v: [32m'a'[39m, value: [36m[Object][39m },
      class: [32m'default'[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
      style: [32m''[39m,
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
      id: [32m'B'[39m,
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
      width: [33m500[39m,
  ],
      type: [32m'group'[39m,
  edges: [],
      padding: [33m15[39m
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    },
}
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
28.734 : DEBUG :  Extracting node b Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
28.723 : WARN :  Copying children of  a root a data { data: [33m1[39m } a
      labelText: [32m'A'[39m,
28.723 : WARN :  Copying (nodes) clusterId a nodes [ [32m'b'[39m ]
      rx: [33m0[39m,
28.723 : WARN :  Copying children of  b root a data { data: [33m2[39m } a
      ry: [33m0[39m,
28.723 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m, [32m'b'[39m ]
      cssClass: [32m'default'[39m,
28.723 : WARN :  Copying children of  c root a data { data: [33m3[39m } a
      style: [32m''[39m,
28.723 : WARN :  Copying (nodes) clusterId c nodes [ [32m'e'[39m, [32m'c'[39m ]
      id: [32m'A'[39m,
28.723 : WARN :  Setting parent e c
      width: [33m500[39m,
28.723 : WARN :  Setting parent c b
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
28.723 : WARN :  New graph after copy node: ( a ) {
  },
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  [32m'B'[39m => {
  nodes: [
    id: [32m'c'[39m,
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    clusterData: {
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
      labelStyle: [32m''[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m }
      shape: [32m'rect'[39m,
  ],
      labelText: [32m'B'[39m,
  edges: [],
      rx: [33m0[39m,
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
      ry: [33m0[39m,
}
      class: [32m'default'[39m,
28.723 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
      style: [32m''[39m,
28.723 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
      id: [32m'B'[39m,
28.723 : WARN :  New list of nodes [ [32m'a'[39m ]
      width: [33m500[39m,
28.723 : WARN :   Now next level a {
      type: [32m'group'[39m,
  clusterNode: [33mtrue[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.734 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
  id: [32m'a'[39m,
      style: [32m''[39m,
  clusterData: { data: [33m1[39m },
      id: [32m'A'[39m,
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { e: [36m[Object][39m, c: [36m[Object][39m, b: [36m[Object][39m },
    _parent: { e: [32m'c'[39m, c: [32m'b'[39m, b: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, e: {}, c: [36m[Object][39m, b: [36m[Object][39m },
    _in: { e: {}, c: {}, b: {} },
    _preds: { e: {}, c: {}, b: {} },
      width: [33m500[39m,
    _out: { e: {}, c: {}, b: {} },
    _sucs: { e: {}, c: {}, b: {} },
    _edgeObjs: {},
    _edgeLabels: {},
    _nodeCount: [33m3[39m
  }
}
28.723 : WARN :  extractor -  [33m1[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
      type: [32m'group'[39m,
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
      padding: [33m15[39m
} [90mundefined[39m
    }
28.723 : WARN :  Cluster without external connections, without a parent and with children c [33m1[39m
28.723 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  },
  nodes: [
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m },
  [32m'B'[39m => {
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    id: [32m'c'[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m }
    clusterData: {
  ],
      labelStyle: [32m''[39m,
  edges: [],
      shape: [32m'rect'[39m,
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
      labelText: [32m'B'[39m,
}
      rx: [33m0[39m,
28.723 : WARN :  Copying children of  c root c data { data: [33m3[39m } c
      ry: [33m0[39m,
28.723 : WARN :  Copying (nodes) clusterId c nodes [ [32m'e'[39m ]
      class: [32m'default'[39m,
28.723 : WARN :  New graph after copy node: ( c ) {
      style: [32m''[39m,
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
      id: [32m'B'[39m,
  nodes: [ { v: [32m'e'[39m, value: [36m[Object][39m } ],
      width: [33m500[39m,
  edges: [],
      type: [32m'group'[39m,
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.723 : WARN :  Cluster without external connections, without a parent and with children b [33m1[39m
28.723 : WARN :  Old graph before copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.723 : WARN :  Copying children of  b root b data { data: [33m2[39m } b
28.723 : WARN :  Copying (nodes) clusterId b nodes [ [32m'c'[39m ]
28.723 : WARN :  New graph after copy node: ( b ) {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
      padding: [33m15[39m
  edges: [],
    },
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    externalConnections: [33mtrue[39m
}
  },
28.723 : WARN :  New list of nodes [ [32m'b'[39m ]
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
28.723 : WARN :   Now next level b {
  clusterNode: [33mtrue[39m,
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  id: [32m'b'[39m,
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  clusterData: { data: [33m2[39m },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  labelText: [90mundefined[39m,
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  graph: Graph {
    _isDirected: [33mtrue[39m,
}
    _isMultigraph: [33mtrue[39m,
28.734 : DEBUG :  Extracting node c Map(9) {
    _isCompound: [33mtrue[39m,
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    _label: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
  [32m'A'[39m => {
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    id: [32m'c'[39m,
    _nodes: { c: [36m[Object][39m },
    clusterData: {
    _parent: { c: [32m'\x00'[39m },
      labelStyle: [32m''[39m,
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {} },
      shape: [32m'rect'[39m,
    _in: { c: {} },
      labelText: [32m'A'[39m,
    _preds: { c: {} },
      rx: [33m0[39m,
    _out: { c: {} },
      ry: [33m0[39m,
    _sucs: { c: {} },
      cssClass: [32m'default'[39m,
    _edgeObjs: {},
      style: [32m''[39m,
    _edgeLabels: {},
      id: [32m'A'[39m,
    _nodeCount: [33m1[39m
      width: [33m500[39m,
  }
      type: [32m'group'[39m,
}
      padding: [33m15[39m
28.723 : WARN :  extractor -  [33m2[39m {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'c'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
} [90mundefined[39m

    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.734 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
stderr | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
28.733 : WARN :  Cluster identified A  Replacement id in edges:  c
28.733 : WARN :  Cluster identified B  Replacement id in edges:  c
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
28.733 : WARN :  Edge:  { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }  leaves cluster  B
      cssClass: [32m'default'[39m,
28.733 : WARN :  Descendants of XXX  B :  [ [32m'c'[39m ]
      style: [32m''[39m,
28.733 : WARN :  Edge b -> B: {"v":"b","w":"B","name":"1"}
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
28.733 : WARN :  Edge b -> B: {"minlen":1,"arrowhead":"normal","arrowTypeStart":"arrow_open","arrowTypeEnd":"arrow_point","thickness":"normal","pattern":"solid","style":"fill:none","labelStyle":"","arrowheadStyle":"fill: #333","labelpos":"c","labelType":"text","label":"","id":"L-b-B","classes":"flowchart-link LS-b LE-B"}
  },
28.733 : WARN :  Fix XXX {
  [32m'B'[39m => {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    id: [32m'c'[39m,
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  A: {
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
    id: [32m'c'[39m,
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
    clusterData: {
}
28.734 : DEBUG :  Extracting node a Map(9) {
      labelStyle: [32m''[39m,
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
      shape: [32m'rect'[39m,
  [32m'A'[39m => {
    id: [32m'c'[39m,
      labelText: [32m'A'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
      rx: [33m0[39m,
  [32m'B'[39m => {
      ry: [33m0[39m,
    id: [32m'c'[39m,
      class: [32m'default'[39m,
    clusterData: {
      style: [32m''[39m,
      labelStyle: [32m''[39m,
      id: [32m'A'[39m,
      shape: [32m'rect'[39m,
      width: [33m500[39m,
      labelText: [32m'B'[39m,
      type: [32m'group'[39m,
      rx: [33m0[39m,
      padding: [33m15[39m
      ry: [33m0[39m,
    }
      class: [32m'default'[39m,
  },
      style: [32m''[39m,
  B: {
    id: [32m'c'[39m,
      id: [32m'B'[39m,
    clusterData: {
      width: [33m500[39m,
      labelStyle: [32m''[39m,
      type: [32m'group'[39m,
      shape: [32m'rect'[39m,
      padding: [33m15[39m
    },
      labelText: [32m'B'[39m,
    externalConnections: [33mtrue[39m
      rx: [33m0[39m,
  },
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} ids: b B Translating:  { id: [32m'c'[39m, clusterData: { data: [33m2[39m } }  ---  {
  id: [32m'c'[39m,
  clusterData: {
    labelStyle: [32m''[39m,
    shape: [32m'rect'[39m,
    labelText: [32m'B'[39m,
    rx: [33m0[39m,
    ry: [33m0[39m,
    class: [32m'default'[39m,
    style: [32m''[39m,
    id: [32m'B'[39m,
    width: [33m500[39m,
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
    type: [32m'group'[39m,
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
    padding: [33m15[39m
  },
  externalConnections: [33mtrue[39m
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.733 : WARN :  Fixing and trixing - removing XXX b B 1
28.734 : DEBUG :  Map(9) {
28.733 : WARN :  Fix Replacing with XXX b c 1
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
28.733 : WARN :  Edge a -> c: {"v":"a","w":"c","name":"2"}
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
28.733 : WARN :  Edge a -> c: {"minlen":1,"arrowhead":"normal","arrowTypeStart":"arrow_open","arrowTypeEnd":"arrow_point","thickness":"normal","pattern":"solid","style":"fill:none","labelStyle":"","arrowheadStyle":"fill: #333","labelpos":"c","labelType":"text","label":"","id":"L-a-c","classes":"flowchart-link LS-a LE-c"}
  [32m'A'[39m => {
28.733 : WARN :  Fix XXX {
    id: [32m'c'[39m,
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
    clusterData: {
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
      labelStyle: [32m''[39m,
  A: {
      shape: [32m'rect'[39m,
    id: [32m'c'[39m,
      labelText: [32m'A'[39m,
    clusterData: {
      rx: [33m0[39m,
      labelStyle: [32m''[39m,
      ry: [33m0[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
      padding: [33m15[39m
    }
    },
  },
    externalConnections: [33mtrue[39m
  [32m'B'[39m => {
  },
    id: [32m'c'[39m,
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} ids: a c Translating:  { id: [32m'c'[39m, clusterData: { data: [33m1[39m } }  ---  { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
28.733 : WARN :  Fixing and trixing - removing XXX a c 2
28.733 : WARN :  Fix Replacing with XXX a c 2
28.733 : WARN :  Adjusted Graph {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
    clusterData: {
  ],
      labelStyle: [32m''[39m,
  edges: [
      shape: [32m'rect'[39m,
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
      labelText: [32m'B'[39m,
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
      rx: [33m0[39m,
  ],
      ry: [33m0[39m,
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
      class: [32m'default'[39m,
}
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
28.734 : DEBUG :  Nodes =  [ [32m'c'[39m, [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ] [33m1[39m
28.734 : DEBUG :  Extracting node c Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
28.733 : WARN :  extractor -  [33m0[39m {
  [32m'A'[39m => {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    id: [32m'c'[39m,
  nodes: [
    clusterData: {
    { v: [32m'A'[39m, value: [36m[Object][39m },
      labelStyle: [32m''[39m,
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
      shape: [32m'rect'[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
      labelText: [32m'A'[39m,
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
  edges: [
      style: [32m''[39m,
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
      id: [32m'A'[39m,
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
      width: [33m500[39m,
  ],
      type: [32m'group'[39m,
      padding: [33m15[39m
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    }
} [90mundefined[39m
  },
28.733 : WARN :  Cluster without external connections, without a parent and with children A [33m0[39m
  [32m'B'[39m => {
28.733 : WARN :  Old graph before copy {
    id: [32m'c'[39m,
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
    clusterData: {
  nodes: [
      labelStyle: [32m''[39m,
    { v: [32m'A'[39m, value: [36m[Object][39m },
      shape: [32m'rect'[39m,
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
      labelText: [32m'B'[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
      rx: [33m0[39m,
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
      ry: [33m0[39m,
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
      class: [32m'default'[39m,
  ],
      style: [32m''[39m,
  edges: [
      id: [32m'B'[39m,
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
      width: [33m500[39m,
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
      type: [32m'group'[39m,
  ],
      padding: [33m15[39m
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
    },
}
    externalConnections: [33mtrue[39m
28.733 : WARN :  Copying children of  A root A data {
  },
  labelStyle: [32m''[39m,
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  shape: [32m'rect'[39m,
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  labelText: [32m'A'[39m,
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  rx: [33m0[39m,
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  ry: [33m0[39m,
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
  class: [32m'default'[39m,
} [33mtrue[39m [33mfalse[39m {
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  labelStyle: [32m''[39m,
  type: [32m'group'[39m,
  shape: [32m'rect'[39m,
  padding: [33m15[39m
  labelText: [32m'c'[39m,
} A
  rx: [33m0[39m,
28.733 : WARN :  Copying (nodes) clusterId A nodes [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ]
  ry: [33m0[39m,
28.733 : WARN :  Copying children of  B root A data {
  class: [32m'default'[39m,
  labelStyle: [32m''[39m,
  style: [32m''[39m,
  shape: [32m'rect'[39m,
  id: [32m'c'[39m,
  labelText: [32m'B'[39m,
  padding: [33m15[39m
  rx: [33m0[39m,
} [90mundefined[39m  Depth  [33m1[39m
  ry: [33m0[39m,
28.734 : DEBUG :  Map(9) {
  class: [32m'default'[39m,
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  style: [32m''[39m,
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  id: [32m'B'[39m,
  [32m'A'[39m => {
    id: [32m'c'[39m,
  width: [33m500[39m,
    clusterData: {
  type: [32m'group'[39m,
      labelStyle: [32m''[39m,
  padding: [33m15[39m
      shape: [32m'rect'[39m,
} A
      labelText: [32m'A'[39m,
28.733 : WARN :  Copying (nodes) clusterId B nodes [ [32m'c'[39m, [32m'B'[39m ]
      rx: [33m0[39m,
28.733 : WARN :  Setting parent c B
      ry: [33m0[39m,
28.733 : WARN :  New graph after copy node: ( A ) {
      cssClass: [32m'default'[39m,
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
      style: [32m''[39m,
  nodes: [
      id: [32m'A'[39m,
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
      width: [33m500[39m,
    { v: [32m'B'[39m, value: [36m[Object][39m },
      type: [32m'group'[39m,
    { v: [32m'b'[39m, value: [36m[Object][39m },
      padding: [33m15[39m
    { v: [32m'a'[39m, value: [36m[Object][39m }
    }
  ],
  },
  edges: [
  [32m'B'[39m => {
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    id: [32m'c'[39m,
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
    clusterData: {
  ],
      labelStyle: [32m''[39m,
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
      shape: [32m'rect'[39m,
}
      labelText: [32m'B'[39m,
28.733 : WARN :  Cluster **  B  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
28.733 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
28.733 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
28.733 : WARN :  Cluster **  a  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [90mundefined[39m [90mundefined[39m [33m0[39m
28.733 : WARN :  New list of nodes [ [32m'A'[39m ]
28.733 : WARN :   Now next level A {
  clusterNode: [33mtrue[39m,
  id: [32m'A'[39m,
  clusterData: {
    labelStyle: [32m''[39m,
    shape: [32m'rect'[39m,
    labelText: [32m'A'[39m,
    rx: [33m0[39m,
    ry: [33m0[39m,
    class: [32m'default'[39m,
    style: [32m''[39m,
    id: [32m'A'[39m,
    width: [33m500[39m,
    type: [32m'group'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
28.734 : DEBUG :  Extracting node B Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    padding: [33m15[39m
  },
  labelText: [90mundefined[39m,
  graph: Graph {
    _isDirected: [33mtrue[39m,
    _isMultigraph: [33mtrue[39m,
    _isCompound: [33mtrue[39m,
    _label: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m },
    _defaultNodeLabelFn: [36m[Function (anonymous)][39m,
    _defaultEdgeLabelFn: [36m[Function (anonymous)][39m,
    _nodes: { c: [36m[Object][39m, B: [36m[Object][39m, b: [36m[Object][39m, a: [36m[Object][39m },
    _parent: { c: [32m'B'[39m, B: [32m'\x00'[39m, b: [32m'\x00'[39m, a: [32m'\x00'[39m },
    _children: { [32m'\x00'[39m: [36m[Object][39m, c: {}, B: [36m[Object][39m, b: {}, a: {} },
    _in: { c: [36m[Object][39m, B: {}, b: {}, a: {} },
    clusterData: {
      labelStyle: [32m''[39m,
    _preds: { c: [36m[Object][39m, B: {}, b: {}, a: {} },
    _out: { c: {}, B: {}, b: [36m[Object][39m, a: [36m[Object][39m },
    _sucs: { c: {}, B: {}, b: [36m[Object][39m, a: [36m[Object][39m },
    _edgeObjs: { [32m'b\x01c\x011'[39m: [36m[Object][39m, [32m'a\x01c\x012'[39m: [36m[Object][39m },
    _edgeLabels: { [32m'b\x01c\x011'[39m: [36m[Object][39m, [32m'a\x01c\x012'[39m: [36m[Object][39m },
    _nodeCount: [33m4[39m,
    _edgeCount: [33m2[39m
  }
}
28.733 : WARN :  extractor -  [33m1[39m {
      shape: [32m'rect'[39m,
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
      labelText: [32m'A'[39m,
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
} [90mundefined[39m
      rx: [33m0[39m,
      ry: [33m0[39m,
28.733 : WARN :  Cluster **  c  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mfalse[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
28.733 : WARN :  Cluster **  B  **not meeting the criteria !externalConnections: [33mfalse[39m  no parent:  [33mtrue[39m  children  [33mtrue[39m [90mundefined[39m [33m1[39m
28.733 : WARN :  Cluster **  b  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
28.733 : WARN :  Cluster **  a  **not meeting the criteria !externalConnections: [33mtrue[39m  no parent:  [33mtrue[39m  children  [33mfalse[39m [90mundefined[39m [33m1[39m
28.733 : WARN :  New list of nodes [ [32m'c'[39m, [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ]
28.733 : WARN :   Now next level c {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'c'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
      class: [32m'default'[39m,
  style: [32m''[39m,
      style: [32m''[39m,
  id: [32m'c'[39m,
      id: [32m'B'[39m,
  padding: [33m15[39m
      width: [33m500[39m,
}
      type: [32m'group'[39m,
28.733 : WARN :   Now next level B {
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  width: [33m500[39m,
  labelText: [32m'B'[39m,
  type: [32m'group'[39m,
  rx: [33m0[39m,
  padding: [33m15[39m
  ry: [33m0[39m,
  class: [32m'default'[39m,
} [90mundefined[39m  Depth  [33m1[39m
  style: [32m''[39m,
28.734 : DEBUG :  Map(9) {
  id: [32m'B'[39m,
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  width: [33m500[39m,
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  type: [32m'group'[39m,
  padding: [33m15[39m
}
  [32m'A'[39m => {
28.733 : WARN :   Now next level b {
    id: [32m'c'[39m,
  labelStyle: [32m''[39m,
    clusterData: {
  shape: [32m'rect'[39m,
      labelStyle: [32m''[39m,
  labelText: [32m'b'[39m,
      shape: [32m'rect'[39m,
  rx: [33m0[39m,
      labelText: [32m'A'[39m,
  ry: [33m0[39m,
      rx: [33m0[39m,
  class: [32m'default'[39m,
      ry: [33m0[39m,
  style: [32m''[39m,
      cssClass: [32m'default'[39m,
  id: [32m'b'[39m,
      style: [32m''[39m,
  padding: [33m15[39m
      id: [32m'A'[39m,
}
      width: [33m500[39m,
28.733 : WARN :   Now next level a {
      type: [32m'group'[39m,
  labelStyle: [32m''[39m,
      padding: [33m15[39m
  shape: [32m'rect'[39m,
    }
  labelText: [32m'a'[39m,
  },
  rx: [33m0[39m,
  [32m'B'[39m => {
  ry: [33m0[39m,
    id: [32m'c'[39m,
  class: [32m'default'[39m,
    clusterData: {
  style: [32m''[39m,
  id: [32m'a'[39m,
  padding: [33m15[39m
}

      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
28.734 : DEBUG :  Extracting node b Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'b'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'b'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
28.734 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
28.734 : DEBUG :  Extracting node a Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'a'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'a'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
28.734 : DEBUG :  Map(9) {
  [32m'C1'[39m => { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  [32m'C2'[39m => { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  [32m'A'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      cssClass: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  [32m'B'[39m => {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  [32m'C'[39m => { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  [32m'D'[39m => { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  [32m'b'[39m => { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  [32m'a'[39m => { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  [32m'c'[39m => { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
28.734 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > validate > adjustClustersAndEdges the extracted graphs shall contain the correct links  GLB21
28.723 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'a'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'a'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'e'[39m, value: [36m[Object][39m, parent: [32m'c'[39m }
  ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.723 : DEBUG :  Opting in, graph
28.723 : DEBUG :  Cluster identified a {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
28.723 : DEBUG :  Cluster identified b {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
28.723 : DEBUG :  Cluster identified c {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
28.723 : DEBUG :  Not a cluster  e {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'a'[39m ],
  B: [ [32m'b'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
28.723 : DEBUG :  Nodes =  [ [32m'a'[39m, [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ] [33m0[39m
28.723 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m1[39m } [90mundefined[39m  Depth  [33m0[39m
28.723 : INFO :  cp  e  to  a  with parent  c
28.723 : DEBUG :  Setting parent e c
28.723 : DEBUG :  Copying Edges []
28.723 : DEBUG :  Removing node e
28.723 : INFO :  cp  c  to  a  with parent  c
28.723 : INFO :  In copy  c root a data { data: [33m3[39m } a
28.723 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
28.723 : DEBUG :  Copying Edges []
28.723 : DEBUG :  Removing node c
28.723 : DEBUG :  Removing node c
28.723 : INFO :  cp  b  to  a  with parent  b
28.723 : INFO :  In copy  b root a data { data: [33m2[39m } a
28.723 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
28.723 : DEBUG :  Copying Edges []
28.723 : DEBUG :  Removing node b
28.723 : DEBUG :  Removing node b
28.723 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'a'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m10[39m, ranksep: [33m10[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.723 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.723 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
28.723 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.723 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
28.723 : DEBUG :  Extracting node e {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [90mundefined[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.723 : DEBUG :  Not a cluster e [33m0[39m
28.723 : DEBUG :  Nodes =  [ [32m'e'[39m, [32m'c'[39m, [32m'b'[39m ] [33m1[39m
28.723 : DEBUG :  Extracting node e {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [90mundefined[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m1[39m
28.723 : DEBUG :  Not a cluster e [33m1[39m
28.723 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mfalse[39m { data: [33m3[39m } [90mundefined[39m  Depth  [33m1[39m
28.723 : INFO :  cp  e  to  c  with parent  c
28.723 : INFO :  In copy  c root c data { data: [33m3[39m } c
28.723 : DEBUG :  Not Setting parent for node= e cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.723 : DEBUG :  Copying Edges []
28.723 : DEBUG :  Removing node e
28.723 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'b'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m }
  ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.723 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'B'[39m, clusterData: [90mundefined[39m },
  A: { id: [32m'a'[39m, clusterData: { data: [33m6[39m } },
  B: { id: [32m'a'[39m, clusterData: { data: [33m4[39m } },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'a'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m { data: [33m2[39m } [90mundefined[39m  Depth  [33m1[39m
28.723 : INFO :  cp  c  to  b  with parent  b
28.723 : INFO :  In copy  b root b data { data: [33m2[39m } b
28.723 : DEBUG :  Not Setting parent for node= c cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.723 : DEBUG :  Copying Edges []
28.723 : DEBUG :  Removing node c
28.723 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.723 : DEBUG :  Done, no node has children [ [32m'c'[39m ]
28.723 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'b'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

stdout | packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js > Graphlib decorations > adjustClustersAndEdges should handle nesting GLB77
28.733 : INFO :  Graph before {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'A'[39m, value: [36m[Object][39m },
    { v: [32m'B'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'b'[39m, value: [36m[Object][39m, parent: [32m'A'[39m },
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'a'[39m, value: [36m[Object][39m, parent: [32m'A'[39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'B'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.733 : DEBUG :  Opting in, graph
28.733 : DEBUG :  Cluster identified A {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
28.733 : DEBUG :  Cluster identified B {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
28.733 : DEBUG :  Not a cluster  b {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
28.733 : DEBUG :  Not a cluster  c {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
28.733 : DEBUG :  Not a cluster  a {
  C1: [ [32m'a'[39m ],
  C2: [ [32m'b'[39m ],
  A: [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ],
  B: [ [32m'c'[39m ],
  C: [ [32m'D'[39m, [32m'd'[39m ],
  D: [ [32m'd'[39m ],
  b: [ [32m'c'[39m, [32m'e'[39m ],
  a: [ [32m'b'[39m, [32m'c'[39m, [32m'e'[39m ],
  c: [ [32m'e'[39m ]
}
28.733 : DEBUG :  Nodes =  [ [32m'A'[39m, [32m'B'[39m, [32m'b'[39m, [32m'c'[39m, [32m'a'[39m ] [33m0[39m
28.733 : DEBUG :  Extracting node A {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m0[39m
28.733 : INFO :  cp  c  to  A  with parent  B
28.733 : DEBUG :  Setting parent c B
28.733 : DEBUG :  Copying Edges [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }, { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ]
28.733 : INFO :  Edge { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }
28.733 : INFO :  Edge data {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  classes: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
} A
28.733 : INFO :  Descendants of  A  is  [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ]
28.733 : INFO :  Edge is  { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }
28.733 : INFO :  Copying as  b c {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  classes: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
} 1
28.733 : INFO :  newGraph edges  [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m } ] {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  classes: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
}
28.733 : INFO :  Edge { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
28.733 : INFO :  Edge data {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-a-c'[39m,
  classes: [32m'flowchart-link LS-a LE-c'[39m
} A
28.733 : INFO :  Descendants of  A  is  [ [32m'B'[39m, [32m'b'[39m, [32m'a'[39m, [32m'c'[39m ]
28.733 : INFO :  Edge is  { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m }
28.733 : INFO :  Copying as  a c {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-a-c'[39m,
  classes: [32m'flowchart-link LS-a LE-c'[39m
} 2
28.733 : INFO :  newGraph edges  [ { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m }, { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m } ] {
  minlen: [33m1[39m,
  arrowhead: [32m'normal'[39m,
  arrowTypeStart: [32m'arrow_open'[39m,
  arrowTypeEnd: [32m'arrow_point'[39m,
  thickness: [32m'normal'[39m,
  pattern: [32m'solid'[39m,
  style: [32m'fill:none'[39m,
  labelStyle: [32m''[39m,
  arrowheadStyle: [32m'fill: #333'[39m,
  labelpos: [32m'c'[39m,
  labelType: [32m'text'[39m,
  label: [32m''[39m,
  id: [32m'L-b-B'[39m,
  classes: [32m'flowchart-link LS-b LE-B'[39m,
  toCluster: [32m'B'[39m
}
28.733 : DEBUG :  Removing node c
28.733 : INFO :  cp  B  to  A  with parent  B
28.733 : INFO :  In copy  B root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
28.733 : DEBUG :  Not Setting parent for node= B cluster!==rootId [33mtrue[39m node!==clusterId [33mfalse[39m
28.733 : DEBUG :  Copying Edges []
28.733 : DEBUG :  Removing node B
28.733 : DEBUG :  Removing node B
28.733 : INFO :  cp  b  to  A  with parent  A
28.733 : INFO :  In copy  A root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
28.733 : DEBUG :  Not Setting parent for node= b cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.733 : DEBUG :  Copying Edges []
28.733 : DEBUG :  Removing node b
28.733 : INFO :  cp  a  to  A  with parent  A
28.733 : INFO :  In copy  A root A data {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'A'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'A'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} A
28.733 : DEBUG :  Not Setting parent for node= a cluster!==rootId [33mfalse[39m node!==clusterId [33mtrue[39m
28.733 : DEBUG :  Copying Edges []
28.733 : DEBUG :  Removing node a
28.733 : DEBUG :  Old graph after copy {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [ { v: [32m'A'[39m, value: [36m[Object][39m } ],
  edges: [],
  value: { rankdir: [32m'TB'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}
28.733 : DEBUG :  Extracting node B {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.733 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
28.733 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.733 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
28.733 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.733 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
28.733 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m [90mundefined[39m [90mundefined[39m  Depth  [33m0[39m
28.733 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
28.733 : DEBUG :  Nodes =  [ [32m'c'[39m, [32m'B'[39m, [32m'b'[39m, [32m'a'[39m ] [33m1[39m
28.733 : DEBUG :  Extracting node c {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mfalse[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'c'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'c'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
28.733 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
28.733 : DEBUG :  Extracting node B {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mfalse[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'B'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'B'[39m,
  width: [33m500[39m,
  type: [32m'group'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
28.733 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
28.733 : DEBUG :  Extracting node b {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'b'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'b'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
28.733 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
28.733 : DEBUG :  Extracting node a {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
} [33mtrue[39m [33mtrue[39m {
  labelStyle: [32m''[39m,
  shape: [32m'rect'[39m,
  labelText: [32m'a'[39m,
  rx: [33m0[39m,
  ry: [33m0[39m,
  class: [32m'default'[39m,
  style: [32m''[39m,
  id: [32m'a'[39m,
  padding: [33m15[39m
} [90mundefined[39m  Depth  [33m1[39m
28.733 : DEBUG :  {
  C1: { id: [32m'A'[39m, clusterData: { data: [33m4[39m } },
  C2: { id: [32m'A'[39m, clusterData: [90mundefined[39m },
  A: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'A'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'A'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    }
  },
  B: {
    id: [32m'c'[39m,
    clusterData: {
      labelStyle: [32m''[39m,
      shape: [32m'rect'[39m,
      labelText: [32m'B'[39m,
      rx: [33m0[39m,
      ry: [33m0[39m,
      class: [32m'default'[39m,
      style: [32m''[39m,
      id: [32m'B'[39m,
      width: [33m500[39m,
      type: [32m'group'[39m,
      padding: [33m15[39m
    },
    externalConnections: [33mtrue[39m
  },
  C: { id: [32m'D'[39m, clusterData: { data: [33m1[39m } },
  D: { id: [32m'A'[39m, clusterData: { data: [33m2[39m } },
  b: { id: [32m'c'[39m, clusterData: { data: [33m2[39m } },
  a: { id: [32m'c'[39m, clusterData: { data: [33m1[39m } },
  c: { id: [32m'e'[39m, clusterData: { data: [33m3[39m } }
}
28.733 : INFO :  Graph after {
  options: { directed: [33mtrue[39m, multigraph: [33mtrue[39m, compound: [33mtrue[39m },
  nodes: [
    { v: [32m'c'[39m, value: [36m[Object][39m, parent: [32m'B'[39m },
    { v: [32m'B'[39m, value: [36m[Object][39m },
    { v: [32m'b'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, value: [36m[Object][39m }
  ],
  edges: [
    { v: [32m'b'[39m, w: [32m'c'[39m, name: [32m'1'[39m, value: [36m[Object][39m },
    { v: [32m'a'[39m, w: [32m'c'[39m, name: [32m'2'[39m, value: [36m[Object][39m }
  ],
  value: { rankdir: [32m'LR'[39m, nodesep: [33m50[39m, ranksep: [33m50[39m, marginx: [33m8[39m, marginy: [33m8[39m }
}

 âœ“ packages/mermaid/src/dagre-wrapper/mermaid-graphlib.spec.js (15 tests) 131ms
 âœ“ packages/mermaid/src/rendering-util/layout-algorithms/dagre/mermaid-graphlib.spec.js (15 tests) 137ms
 âœ“ packages/mermaid/src/accessibility.spec.ts (20 tests) 214ms
 âœ“ |@mermaid-js/docs| .vitepress/theme/redirect.spec.ts (28 tests) 13ms
 âœ“ packages/mermaid/src/config.spec.ts (5 tests) 40ms
stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with a node
Found block-beta
.

Lex: NODE_ID id
.

Lex: EOF
Rule: node (NODE_ID separator):  id
Rule: nodeStatement (node)  { id: [32m'id'[39m }
Rule: statement:  {
  id: [32m'id'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a node with a square shape and a label
Found block
.

Lex: NODE_ID id
Lexa: [
Lex: Starting string
LEX: STR end: A label
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ A label ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id { typeStr: [32m'[]'[39m, label: [32m'A label'[39m }
Rule: nodeStatement (node)  { id: [32m'id'[39m, label: [32m'A label'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Rule: statement:  {
  id: [32m'id'[39m,
  label: [32m'A label'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id'[39m,
    label: [32m'A label'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with multiple nodes
Found block
.

Lex: NODE_ID id1
.

Lex: NODE_ID id2
Rule: node (NODE_ID separator):  id1
Rule: nodeStatement (node)  { id: [32m'id1'[39m }
.

Lex: EOF
Rule: node (NODE_ID separator):  id2
Rule: nodeStatement (node)  { id: [32m'id2'[39m }
Rule: statement:  {
  id: [32m'id2'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id1'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id1'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id2'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with multiple nodes
Found block
.

Lex: NODE_ID id1
.

Lex: NODE_ID id2
Rule: node (NODE_ID separator):  id1
Rule: nodeStatement (node)  { id: [32m'id1'[39m }
.

Lex: NODE_ID id3
Rule: node (NODE_ID separator):  id2
Rule: nodeStatement (node)  { id: [32m'id2'[39m }
.

Lex: EOF
Rule: node (NODE_ID separator):  id3
Rule: nodeStatement (node)  { id: [32m'id3'[39m }
Rule: statement:  {
  id: [32m'id3'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id2'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id1'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id1'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id2'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id3'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a node with a square shape and a label
Found block
.

Lex: NODE_ID id
Lexa: [
Lex: Starting string
LEX: STR end: A label
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID id2
Rule: nodeShapeNLabel:  [ A label ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id { typeStr: [32m'[]'[39m, label: [32m'A label'[39m }
Rule: nodeStatement (node)  { id: [32m'id'[39m, label: [32m'A label'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Lex: EOF
Rule: node (NODE_ID separator):  id2
Rule: nodeStatement (node)  { id: [32m'id2'[39m }
Rule: statement:  {
  id: [32m'id2'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id'[39m,
  label: [32m'A label'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'id'[39m,
    label: [32m'A label'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id2'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with multiple nodes with edges abc123
Found block
.

Lex: NODE_ID id1
Lexa: [
Lex: Starting string
LEX: STR end: first
LEX: POPPING STR: "
Lex: ]
.
Lex: LINK #-->   #
Rule: nodeShapeNLabel:  [ first ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id1 { typeStr: [32m'[]'[39m, label: [32m'first'[39m }
Rule: nodeStatement (node)  { id: [32m'id1'[39m, label: [32m'first'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Rule: link:  -->    -->
Lex: NODE_ID id2
Lexa: [
Lex: Starting string
LEX: STR end: second
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ second ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id2 { typeStr: [32m'[]'[39m, label: [32m'second'[39m }
Rule: (nodeStatement link node)  {
  id: [32m'id1'[39m,
  label: [32m'first'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
} { edgeTypeStr: [32m'-->   '[39m, label: [32m''[39m } { id: [32m'id2'[39m, label: [32m'second'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }  typestr:  -->
Rule: statement:  [
  { id: [32m'id1'[39m, label: [32m'first'[39m, type: [32m'square'[39m, directions: [90mundefined[39m },
  {
    id: [32m'id1-id2'[39m,
    start: [32m'id1'[39m,
    end: [32m'id2'[39m,
    label: [32m''[39m,
    type: [32m'edge'[39m,
    directions: [90mundefined[39m,
    arrowTypeEnd: [32m'arrow_point'[39m,
    arrowTypeStart: [32m'arrow_open'[39m
  },
  { id: [32m'id2'[39m, label: [32m'second'[39m, type: [32m'square'[39m, directions: [90mundefined[39m }
]
Rule: hierarchy:  [
  { id: [32m'id1'[39m, label: [32m'first'[39m, type: [32m'square'[39m, directions: [90mundefined[39m },
  {
    id: [32m'id1-id2'[39m,
    start: [32m'id1'[39m,
    end: [32m'id2'[39m,
    label: [32m''[39m,
    type: [32m'edge'[39m,
    directions: [90mundefined[39m,
    arrowTypeEnd: [32m'arrow_point'[39m,
    arrowTypeStart: [32m'arrow_open'[39m
  },
  { id: [32m'id2'[39m, label: [32m'second'[39m, type: [32m'square'[39m, directions: [90mundefined[39m }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with multiple nodes with edges abc123
Found block
.

Lex: NODE_ID id1
Lexa: [
Lex: Starting string
LEX: STR end: first
LEX: POPPING STR: "
Lex: ]
.
Lex: START_LINK --
Rule: nodeShapeNLabel:  [ first ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id1 { typeStr: [32m'[]'[39m, label: [32m'first'[39m }
Rule: nodeStatement (node)  { id: [32m'id1'[39m, label: [32m'first'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Lex: Starting string
LEX: STR end: a label
LEX: POPPING STR: "
Lex: LINK # -->   #
Rule: LABEL link:  --  a label  -->
Lex: NODE_ID id2
Lexa: [
Lex: Starting string
LEX: STR end: second
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ second ]
Rule: node (NODE_ID nodeShapeNLabel separator):  id2 { typeStr: [32m'[]'[39m, label: [32m'second'[39m }
Rule: (nodeStatement link node)  {
  id: [32m'id1'[39m,
  label: [32m'first'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
} { edgeTypeStr: [32m' -->   '[39m, label: [32m'a label'[39m } { id: [32m'id2'[39m, label: [32m'second'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }  typestr:   -->
Rule: statement:  [
  { id: [32m'id1'[39m, label: [32m'first'[39m, type: [32m'square'[39m, directions: [90mundefined[39m },
  {
    id: [32m'id1-id2'[39m,
    start: [32m'id1'[39m,
    end: [32m'id2'[39m,
    label: [32m'a label'[39m,
    type: [32m'edge'[39m,
    directions: [90mundefined[39m,
    arrowTypeEnd: [32m'arrow_point'[39m,
    arrowTypeStart: [32m'arrow_open'[39m
  },
  { id: [32m'id2'[39m, label: [32m'second'[39m, type: [32m'square'[39m, directions: [90mundefined[39m }
]
Rule: hierarchy:  [
  { id: [32m'id1'[39m, label: [32m'first'[39m, type: [32m'square'[39m, directions: [90mundefined[39m },
  {
    id: [32m'id1-id2'[39m,
    start: [32m'id1'[39m,
    end: [32m'id2'[39m,
    label: [32m'a label'[39m,
    type: [32m'edge'[39m,
    directions: [90mundefined[39m,
    arrowTypeEnd: [32m'arrow_point'[39m,
    arrowTypeStart: [32m'arrow_open'[39m
  },
  { id: [32m'id2'[39m, label: [32m'second'[39m, type: [32m'square'[39m, directions: [90mundefined[39m }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with column statements
Found block
.

COLUMNS (LEX) 2
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'2'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  2
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m2[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m2[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram without column statements
Found block
.

Lex: NODE_ID block1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > a diagram with auto column statements
Found block
.

.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [33m-1[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m22[39m }
}
COLUMNS:  [33m-1[39m
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m-1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m-1[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > blocks next to each other
Found block
.

COLUMNS (LEX) 2
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'2'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  2
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID block2
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m2[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m2[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > blocks on top of each other
Found block
.

COLUMNS (LEX) 1
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID block2
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
.

Lex: EOF
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > compound blocks 2
Found block
.

Found block
.

Lex: NODE_ID aBlock
Lexa: [
Lex: Starting string
LEX: STR end: ABlock
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID bBlock
Rule: nodeShapeNLabel:  [ ABlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  aBlock { typeStr: [32m'[]'[39m, label: [32m'ABlock'[39m }
Rule: nodeStatement (node)  { id: [32m'aBlock'[39m, label: [32m'ABlock'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Lexa: [
Lex: Starting string
LEX: STR end: BBlock
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ BBlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  bBlock { typeStr: [32m'[]'[39m, label: [32m'BBlock'[39m }
Rule: nodeStatement (node)  { id: [32m'bBlock'[39m, label: [32m'BBlock'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Rule: statement:  {
  id: [32m'bBlock'[39m,
  label: [32m'BBlock'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'aBlock'[39m,
  label: [32m'ABlock'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Lex: EOF
Rule: blockStatement :  block [
  {
    id: [32m'aBlock'[39m,
    label: [32m'ABlock'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'bBlock'[39m,
    label: [32m'BBlock'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
] end

Rule: statement:  {
  id: [32m'id-yobl53gnn8-1'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    {
      id: [32m'aBlock'[39m,
      label: [32m'ABlock'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'bBlock'[39m,
      label: [32m'BBlock'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: hierarchy:  [
  {
    id: [32m'id-yobl53gnn8-1'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > compound blocks of compound blocks
Found block
.

Found block
.

Lex: NODE_ID aBlock
Lexa: [
Lex: Starting string
LEX: STR end: ABlock
LEX: POPPING STR: "
Lex: ]
.

Found block
Rule: nodeShapeNLabel:  [ ABlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  aBlock { typeStr: [32m'[]'[39m, label: [32m'ABlock'[39m }
Rule: nodeStatement (node)  { id: [32m'aBlock'[39m, label: [32m'ABlock'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
.

Lex: NODE_ID bBlock
Lexa: [
Lex: Starting string
LEX: STR end: BBlock
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ BBlock ]
Rule: node (NODE_ID nodeShapeNLabel separator):  bBlock { typeStr: [32m'[]'[39m, label: [32m'BBlock'[39m }
Rule: nodeStatement (node)  { id: [32m'bBlock'[39m, label: [32m'BBlock'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Rule: statement:  {
  id: [32m'bBlock'[39m,
  label: [32m'BBlock'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: blockStatement :  block [
  {
    id: [32m'bBlock'[39m,
    label: [32m'BBlock'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
] end

Rule: statement:  {
  id: [32m'id-sklilpcx98a-2'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    {
      id: [32m'bBlock'[39m,
      label: [32m'BBlock'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: statement #2:  {
  id: [32m'aBlock'[39m,
  label: [32m'ABlock'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Lex: EOF
Rule: blockStatement :  block [
  {
    id: [32m'aBlock'[39m,
    label: [32m'ABlock'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id-sklilpcx98a-2'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m ]
  }
] end

Rule: statement:  {
  id: [32m'id-e6sxixpjy4n-3'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    {
      id: [32m'aBlock'[39m,
      label: [32m'ABlock'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'id-sklilpcx98a-2'[39m,
      type: [32m'composite'[39m,
      label: [32m''[39m,
      children: [36m[Array][39m
    }
  ]
}
Rule: hierarchy:  [
  {
    id: [32m'id-e6sxixpjy4n-3'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > compound blocks with title
Found block
.

Found id-block
Lex: NODE_ID compoundBlock
Lexa: [
Lex: Starting string
LEX: STR end: Compound block
LEX: POPPING STR: "
Lex: ]
.

COLUMNS (LEX) 1
Rule: nodeShapeNLabel:  [ Compound block ]
Rule: node (NODE_ID nodeShapeNLabel separator):  compoundBlock { typeStr: [32m'[]'[39m, label: [32m'Compound block'[39m }
Rule: nodeStatement (node)  {
  id: [32m'compoundBlock'[39m,
  label: [32m'Compound block'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
.

Lex: NODE_ID block2
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m3[39m, last_line: [33m3[39m, first_column: [33m12[39m, last_column: [33m21[39m }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Lex: EOF
Rule: id-block statement :  {
  id: [32m'compoundBlock'[39m,
  label: [32m'Compound block'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
} [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]
Rule: statement:  {
  id: [32m'compoundBlock'[39m,
  label: [32m'Compound block'[39m,
  type: [32m'composite'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m,
  children: [
    { type: [32m'column-setting'[39m, columns: [33m1[39m },
    {
      id: [32m'block2'[39m,
      label: [32m'Block 2'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: hierarchy:  [
  {
    id: [32m'compoundBlock'[39m,
    label: [32m'Compound block'[39m,
    type: [32m'composite'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m,
    children: [ [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > blocks mixed with compound blocks
Found block
.

COLUMNS (LEX) 1
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.


Found block
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
.

COLUMNS (LEX) 2
.

Lex: NODE_ID block2
APA123 {
  [32m'$'[39m: [32m'2'[39m,
  [32m'_$'[39m: { first_line: [33m6[39m, last_line: [33m6[39m, first_column: [33m12[39m, last_column: [33m21[39m }
}
COLUMNS:  2
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID block3
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 3
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ Block 3 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block3 { typeStr: [32m'[]'[39m, label: [32m'Block 3'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block3'[39m,
  label: [32m'Block 3'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block3'[39m,
  label: [32m'Block 3'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m2[39m }
Lex: EOF
Rule: blockStatement :  block [
  { type: [32m'column-setting'[39m, columns: [33m2[39m },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'block3'[39m,
    label: [32m'Block 3'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
] end

Rule: statement:  {
  id: [32m'id-xtqyy8li6vn-5'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    { type: [32m'column-setting'[39m, columns: [33m2[39m },
    {
      id: [32m'block2'[39m,
      label: [32m'Block 2'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'block3'[39m,
      label: [32m'Block 3'[39m,
      type: [32m'square'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: statement #2:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id-xtqyy8li6vn-5'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m, [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > Arrow blocks
Found block
.

COLUMNS (LEX) 3
.

Lex: NODE_ID block1
APA123 {
  [32m'$'[39m: [32m'3'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m8[39m, last_column: [33m17[39m }
}
COLUMNS:  3
Lexa: [
Lex: Starting string
LEX: STR end: Block 1
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID blockArrow
Rule: nodeShapeNLabel:  [ Block 1 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block1 { typeStr: [32m'[]'[39m, label: [32m'Block 1'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
LEX ARR START
LEX ARR: Starting string
LEX: STR end: &nbsp;&nbsp;&nbsp;
LEX: POPPING STR: "
Lex: =>BAE
Lex (right): dir: right
Lex (ARROW_DIR end): ]>
Rule: dirList:  right
Lex: NODE_ID block2
Rule: BLOCK_ARROW nodeShapeNLabel:  <[ &nbsp;&nbsp;&nbsp;  #3: [ [32m'right'[39m ] ]>
Rule: node (NODE_ID nodeShapeNLabel separator):  blockArrow {
  typeStr: [32m'<[]>'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  directions: [ [32m'right'[39m ]
}
Rule: nodeStatement (node)  {
  id: [32m'blockArrow'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  typeStr: [32m'<[]>'[39m,
  directions: [ [32m'right'[39m ]
}
Lexa: [
Lex: Starting string
LEX: STR end: Block 2
LEX: POPPING STR: "
Lex: ]
Lex: EOF
Rule: nodeShapeNLabel:  [ Block 2 ]
Rule: node (NODE_ID nodeShapeNLabel separator):  block2 { typeStr: [32m'[]'[39m, label: [32m'Block 2'[39m }
Rule: nodeStatement (node)  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
Rule: statement:  {
  id: [32m'block2'[39m,
  label: [32m'Block 2'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'blockArrow'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  type: [32m'block_arrow'[39m,
  directions: [ [32m'right'[39m ],
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'block1'[39m,
  label: [32m'Block 1'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m3[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m3[39m },
  {
    id: [32m'block1'[39m,
    label: [32m'Block 1'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'blockArrow'[39m,
    label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
    type: [32m'block_arrow'[39m,
    directions: [ [32m'right'[39m ],
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'block2'[39m,
    label: [32m'Block 2'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > Arrow blocks with multiple points
Found block
.

COLUMNS (LEX) 1
.

Lex: NODE_ID A
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m8[39m, last_column: [33m17[39m }
}
COLUMNS:  1
.

Lex: NODE_ID blockArrow
Rule: node (NODE_ID separator):  A
Rule: nodeStatement (node)  { id: [32m'A'[39m }
LEX ARR START
LEX ARR: Starting string
LEX: STR end: &nbsp;&nbsp;&nbsp;
LEX: POPPING STR: "
Lex: =>BAE
Lex (up): up
Lex (down): down
Lex (ARROW_DIR end): ]>
Rule: dirList:  down
Rule: dirList:  up [ [32m'down'[39m ]
Found block
Rule: BLOCK_ARROW nodeShapeNLabel:  <[ &nbsp;&nbsp;&nbsp;  #3: [ [32m'up'[39m, [32m'down'[39m ] ]>
Rule: node (NODE_ID nodeShapeNLabel separator):  blockArrow {
  typeStr: [32m'<[]>'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  directions: [ [32m'up'[39m, [32m'down'[39m ]
}
Rule: nodeStatement (node)  {
  id: [32m'blockArrow'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  typeStr: [32m'<[]>'[39m,
  directions: [ [32m'up'[39m, [32m'down'[39m ]
}
.

COLUMNS (LEX) 3
.

Lex: NODE_ID B
APA123 {
  [32m'$'[39m: [32m'3'[39m,
  [32m'_$'[39m: { first_line: [33m6[39m, last_line: [33m6[39m, first_column: [33m10[39m, last_column: [33m19[39m }
}
COLUMNS:  3
.

Lex: NODE_ID C
Rule: node (NODE_ID separator):  B
Rule: nodeStatement (node)  { id: [32m'B'[39m }
.

Lex: NODE_ID D
Rule: node (NODE_ID separator):  C
Rule: nodeStatement (node)  { id: [32m'C'[39m }
.

Rule: node (NODE_ID separator):  D
Rule: nodeStatement (node)  { id: [32m'D'[39m }
Rule: statement:  {
  id: [32m'D'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'C'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'B'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m3[39m }
Lex: EOF
Rule: blockStatement :  block [
  { type: [32m'column-setting'[39m, columns: [33m3[39m },
  {
    id: [32m'B'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'C'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'D'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
] end
Rule: statement:  {
  id: [32m'id-e1axcpf9nbs-6'[39m,
  type: [32m'composite'[39m,
  label: [32m''[39m,
  children: [
    { type: [32m'column-setting'[39m, columns: [33m3[39m },
    {
      id: [32m'B'[39m,
      label: [90mundefined[39m,
      type: [32m'na'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'C'[39m,
      label: [90mundefined[39m,
      type: [32m'na'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    },
    {
      id: [32m'D'[39m,
      label: [90mundefined[39m,
      type: [32m'na'[39m,
      directions: [90mundefined[39m,
      widthInColumns: [33m1[39m
    }
  ]
}
Rule: statement #2:  {
  id: [32m'blockArrow'[39m,
  label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
  type: [32m'block_arrow'[39m,
  directions: [ [32m'up'[39m, [32m'down'[39m ],
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'A'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'A'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'blockArrow'[39m,
    label: [32m'&nbsp;&nbsp;&nbsp;'[39m,
    type: [32m'block_arrow'[39m,
    directions: [ [32m'up'[39m, [32m'down'[39m ],
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id-e1axcpf9nbs-6'[39m,
    type: [32m'composite'[39m,
    label: [32m''[39m,
    children: [ [36m[Object][39m, [36m[Object][39m, [36m[Object][39m, [36m[Object][39m ]
  }
]

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > MMP-1 should handle a simple root definition abc122
29.786 : INFO :  Node:  root
29.786 : INFO :  addNode [33m4[39m root root [33m0[39m
29.786 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > MMP-2 should handle a hierarchical mindmap definition
29.796 : INFO :  Node:  root
29.796 : INFO :  addNode [33m4[39m root root [33m0[39m
29.796 : TRACE :  Stop NL
29.796 : INFO :  Node:  child1
29.796 : INFO :  addNode [33m6[39m child1 child1 [33m0[39m
29.796 : TRACE :  Stop NL
29.796 : INFO :  Node:  child2
29.796 : INFO :  addNode [33m6[39m child2 child2 [33m0[39m
29.796 : TRACE :  Stop NL
29.796 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > 3 should handle a simple root definition with a shape and without an id abc123
29.801 : TRACE :  Long description: root
29.801 : TRACE :  node end )
29.801 : TRACE :  node found .. (
29.801 : DEBUG :  In get type ( )
29.801 : INFO :  Node:  root
29.801 : INFO :  addNode [33m4[39m root root [33m1[39m
29.801 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > MMP-4 should handle a deeper hierarchical mindmap definition
29.804 : INFO :  Node:  root
29.804 : INFO :  addNode [33m4[39m root root [33m0[39m
29.804 : TRACE :  Stop NL
29.804 : INFO :  Node:  child1
29.804 : INFO :  addNode [33m6[39m child1 child1 [33m0[39m
29.804 : TRACE :  Stop NL
29.804 : INFO :  Node:  leaf1
29.804 : INFO :  addNode [33m8[39m leaf1 leaf1 [33m0[39m
29.804 : TRACE :  Stop NL
29.804 : INFO :  Node:  child2
29.804 : INFO :  addNode [33m6[39m child2 child2 [33m0[39m
29.804 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > 5 Multiple roots are illegal
29.808 : INFO :  Node:  root
29.808 : INFO :  addNode [33m4[39m root root [33m0[39m
29.808 : TRACE :  Stop NL
29.808 : INFO :  Node:  fakeRoot
29.808 : INFO :  addNode [33m4[39m fakeRoot fakeRoot [33m0[39m

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > hierarchy > MMP-6 real root in wrong place
29.811 : INFO :  Node:  root
29.811 : INFO :  addNode [33m10[39m root root [33m0[39m
29.811 : TRACE :  Stop NL
29.811 : INFO :  Node:  fakeRoot
29.811 : INFO :  addNode [33m8[39m fakeRoot fakeRoot [33m0[39m

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-7 should handle an id and type for a node definition
29.814 : TRACE :  Long description: The root
29.814 : TRACE :  node end ... ]
29.814 : TRACE :  node found .. root
29.814 : DEBUG :  In get type [ ]
29.814 : INFO :  Node:  root
29.814 : INFO :  addNode [33m4[39m root The root [33m2[39m
29.814 : TRACE :  Stop NL
29.814 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-8 should handle an id and type for a node definition
29.815 : INFO :  Node:  root
29.815 : INFO :  addNode [33m4[39m root root [33m0[39m
29.815 : TRACE :  Stop NL
29.815 : TRACE :  Long description: child1
29.815 : TRACE :  node end )
29.815 : TRACE :  node found .. theId
29.815 : DEBUG :  In get type ( )
29.815 : INFO :  Node:  theId
29.815 : INFO :  addNode [33m6[39m theId child1 [33m1[39m
29.815 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-9 should handle an id and type for a node definition
29.818 : TRACE :  Node:  root
29.818 : INFO :  addNode [33m0[39m root root [33m0[39m
29.818 : TRACE :  Stop NL
29.818 : TRACE :  Long description: child1
29.818 : TRACE :  node end )
29.818 : TRACE :  node found .. theId
29.818 : DEBUG :  In get type ( )
29.818 : INFO :  Node:  theId
29.818 : INFO :  addNode [33m6[39m theId child1 [33m1[39m
29.818 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-10 multiple types (circle)
29.820 : TRACE :  Long description: the root
29.820 : TRACE :  node end ))
29.820 : TRACE :  node found .. root
29.820 : DEBUG :  In get type (( ))
29.820 : INFO :  Node:  root
29.820 : INFO :  addNode [33m1[39m root the root [33m3[39m
29.820 : TRACE :  Stop NL
29.820 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-11 multiple types (cloud)
29.822 : TRACE :  Cloud Bang
29.822 : TRACE :  Long description: the root
29.822 : TRACE :  node end ((
29.822 : TRACE :  node found .. root
29.822 : DEBUG :  In get type ) (
29.822 : INFO :  Node:  root
29.822 : INFO :  addNode [33m1[39m root the root [33m4[39m
29.822 : TRACE :  Stop NL
29.822 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-12 multiple types (bang)
29.824 : TRACE :  Explosion Bang
29.824 : TRACE :  Long description: the root
29.824 : TRACE :  node end ((
29.824 : TRACE :  node found .. root
29.824 : DEBUG :  In get type )) ((
29.824 : INFO :  Node:  root
29.824 : INFO :  addNode [33m1[39m root the root [33m5[39m
29.824 : TRACE :  Stop NL
29.824 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > nodes > MMP-12-a multiple types (hexagon)
29.826 : TRACE :  Long description: the root
29.826 : TRACE :  node end ((
29.826 : TRACE :  node found .. root
29.826 : DEBUG :  In get type {{ }}
29.826 : INFO :  Node:  root
29.826 : INFO :  addNode [33m1[39m root the root [33m6[39m
29.826 : TRACE :  Stop NL
29.826 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > blocks with different widths
Found block
.

COLUMNS (LEX) 3
.

Lex: NODE_ID one
APA123 {
  [32m'$'[39m: [32m'3'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m8[39m, last_column: [33m17[39m }
}
COLUMNS:  3
Lexa: [
Lex: Starting string
LEX: STR end: One Slot
LEX: POPPING STR: "
Lex: ]
.

Lex: NODE_ID two
Rule: nodeShapeNLabel:  [ One Slot ]
Rule: node (NODE_ID nodeShapeNLabel separator):  one { typeStr: [32m'[]'[39m, label: [32m'One Slot'[39m }
Rule: nodeStatement (node)  { id: [32m'one'[39m, label: [32m'One Slot'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
Lexa: [
Lex: Starting string
LEX: STR end: Two slots
LEX: POPPING STR: "
Lex: ]
Lex: COLON :2
Rule: nodeShapeNLabel:  [ Two slots ]
Rule: node (NODE_ID nodeShapeNLabel separator):  two { typeStr: [32m'[]'[39m, label: [32m'Two slots'[39m }
.

Lex: EOF
Rule: nodeStatement (abc88 node size)  { id: [32m'two'[39m, label: [32m'Two slots'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m } 2
Rule: statement:  {
  id: [32m'two'[39m,
  label: [32m'Two slots'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m2[39m
}
Rule: statement #2:  {
  id: [32m'one'[39m,
  label: [32m'One Slot'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m3[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m3[39m },
  {
    id: [32m'one'[39m,
    label: [32m'One Slot'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'two'[39m,
    label: [32m'Two slots'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m2[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > empty blocks
Found block
.

COLUMNS (LEX) 3
.

COLUMNS (LEX) 1
APA123 {
  [32m'$'[39m: [32m'3'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m8[39m, last_column: [33m17[39m }
}
COLUMNS:  3
.

Lex: NODE_ID middle
Lexa: [
Lex: Starting string
LEX: STR end: In the middle
LEX: POPPING STR: "
Lex: ]
.

COLUMNS (LEX) 1
Rule: nodeShapeNLabel:  [ In the middle ]
Rule: node (NODE_ID nodeShapeNLabel separator):  middle { typeStr: [32m'[]'[39m, label: [32m'In the middle'[39m }
Rule: nodeStatement (node)  {
  id: [32m'middle'[39m,
  label: [32m'In the middle'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
.

Lex: EOF
Rule: statement:  {
  id: [32m'id-a3i4b00zvc6-8'[39m,
  type: [32m'space'[39m,
  label: [32m''[39m,
  width: [33m1[39m,
  children: []
}
Rule: statement #2:  {
  id: [32m'middle'[39m,
  label: [32m'In the middle'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'id-x6hi3wthopq-7'[39m,
  type: [32m'space'[39m,
  label: [32m''[39m,
  width: [33m1[39m,
  children: []
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m3[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m3[39m },
  {
    id: [32m'id-x6hi3wthopq-7'[39m,
    type: [32m'space'[39m,
    label: [32m''[39m,
    width: [33m1[39m,
    children: []
  },
  {
    id: [32m'middle'[39m,
    label: [32m'In the middle'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'id-a3i4b00zvc6-8'[39m,
    type: [32m'space'[39m,
    label: [32m''[39m,
    width: [33m1[39m,
    children: []
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > classDef statements applied to a block
Found block
.

.


Lex: NODE_ID mc
Lexa: [
Lex: Starting string
LEX: STR end: Memcache
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ Memcache ]
Rule: node (NODE_ID nodeShapeNLabel separator):  mc { typeStr: [32m'[]'[39m, label: [32m'Memcache'[39m }
Rule: nodeStatement (node)  { id: [32m'mc'[39m, label: [32m'Memcache'[39m, typeStr: [32m'[]'[39m, directions: [90mundefined[39m }
.

Lex: EOF
Rule: statement:  { type: [32m'applyClass'[39m, id: [32m'mc'[39m, styleClass: [32m'black'[39m }
Rule: statement #2:  {
  id: [32m'mc'[39m,
  label: [32m'Memcache'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'classDef'[39m, id: [32m'black'[39m, css: [32m'color:#ffffff, fill:#000000;'[39m }
Rule: hierarchy:  [
  {
    type: [32m'classDef'[39m,
    id: [32m'black'[39m,
    css: [32m'color:#ffffff, fill:#000000;'[39m
  },
  {
    id: [32m'mc'[39m,
    label: [32m'Memcache'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  { type: [32m'applyClass'[39m, id: [32m'mc'[39m, styleClass: [32m'black'[39m }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > style statements applied to a block
Found block
.

COLUMNS (LEX) 1
.

Lex: NODE_ID B
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m0[39m, last_column: [33m9[39m }
}
COLUMNS:  1
Lexa: [
Lex: Starting string
LEX: STR end: A wide one in the middle
LEX: POPPING STR: "
Lex: ]
.

Rule: nodeShapeNLabel:  [ A wide one in the middle ]
Rule: node (NODE_ID nodeShapeNLabel separator):  B { typeStr: [32m'[]'[39m, label: [32m'A wide one in the middle'[39m }
Rule: nodeStatement (node)  {
  id: [32m'B'[39m,
  label: [32m'A wide one in the middle'[39m,
  typeStr: [32m'[]'[39m,
  directions: [90mundefined[39m
}
.

Lex: EOF
Rule: statement:  {
  type: [32m'applyStyles'[39m,
  id: [32m'B'[39m,
  stylesStr: [32m'fill:#f9F,stroke:#333,stroke-width:4px'[39m
}
Rule: statement #2:  {
  id: [32m'B'[39m,
  label: [32m'A wide one in the middle'[39m,
  type: [32m'square'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'B'[39m,
    label: [32m'A wide one in the middle'[39m,
    type: [32m'square'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    type: [32m'applyStyles'[39m,
    id: [32m'B'[39m,
    stylesStr: [32m'fill:#f9F,stroke:#333,stroke-width:4px'[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > when parsing a block diagram graph it should handle >  > should log a warning when block width exceeds column width
Found block-beta
.

COLUMNS (LEX) 1
.

Lex: NODE_ID A
APA123 {
  [32m'$'[39m: [32m'1'[39m,
  [32m'_$'[39m: { first_line: [33m2[39m, last_line: [33m2[39m, first_column: [33m2[39m, last_column: [33m11[39m }
}
COLUMNS:  1
Lex: COLON :1
Rule: node (NODE_ID separator):  A
.

Lex: NODE_ID B
Rule: nodeStatement (abc88 node size)  { id: [32m'A'[39m } 1
Lex: COLON :2
Rule: node (NODE_ID separator):  B
.

Lex: NODE_ID C
Rule: nodeStatement (abc88 node size)  { id: [32m'B'[39m } 2
Lex: COLON :3
Rule: node (NODE_ID separator):  C
.

Lex: NODE_ID D
Rule: nodeStatement (abc88 node size)  { id: [32m'C'[39m } 3
Lex: COLON :4
Rule: node (NODE_ID separator):  D
.

Lex: NODE_ID E
Rule: nodeStatement (abc88 node size)  { id: [32m'D'[39m } 4
Lex: COLON :3
Rule: node (NODE_ID separator):  E
.

Lex: NODE_ID F
Rule: nodeStatement (abc88 node size)  { id: [32m'E'[39m } 3
Lex: COLON :2
Rule: node (NODE_ID separator):  F
.

Lex: NODE_ID G
Rule: nodeStatement (abc88 node size)  { id: [32m'F'[39m } 2
Lex: COLON :1
Rule: node (NODE_ID separator):  G
Lex: EOF
Rule: nodeStatement (abc88 node size)  { id: [32m'G'[39m } 1
Rule: statement:  {
  id: [32m'G'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  {
  id: [32m'F'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m2[39m
}
Rule: statement #2:  {
  id: [32m'E'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m3[39m
}
Rule: statement #2:  {
  id: [32m'D'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m4[39m
}
Rule: statement #2:  {
  id: [32m'C'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m3[39m
}
Rule: statement #2:  {
  id: [32m'B'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m2[39m
}
Rule: statement #2:  {
  id: [32m'A'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: statement #2:  { type: [32m'column-setting'[39m, columns: [33m1[39m }
Rule: hierarchy:  [
  { type: [32m'column-setting'[39m, columns: [33m1[39m },
  {
    id: [32m'A'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    id: [32m'B'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m2[39m
  },
  {
    id: [32m'C'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m3[39m
  },
  {
    id: [32m'D'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m4[39m
  },
  {
    id: [32m'E'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m3[39m
  },
  {
    id: [32m'F'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m2[39m
  },
  {
    id: [32m'G'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > prototype properties > should work with a __proto__ property
Found block
.

Lex: NODE_ID __proto__
Lex: EOF
Rule: node (NODE_ID separator):  __proto__
Rule: nodeStatement (node)  { id: [32m'__proto__'[39m }
Rule: statement:  {
  id: [32m'__proto__'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'__proto__'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]
Found block
.

Lex: NODE_ID A;
.
Rule: node (NODE_ID separator):  A;
Rule: nodeStatement (node)  { id: [32m'A;'[39m }
Lex: EOF
Rule: statement:  {
  type: [32m'classDef'[39m,
  id: [32m'__proto__'[39m,
  css: [32m'color:#ffffff,fill:#000000; class A __proto__'[39m
}
Rule: statement #2:  {
  id: [32m'A;'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'A;'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    type: [32m'classDef'[39m,
    id: [32m'__proto__'[39m,
    css: [32m'color:#ffffff,fill:#000000; class A __proto__'[39m
  }
]

stdout | packages/mermaid/src/diagrams/block/parser/block.spec.ts > Block diagram > prototype properties > should work with a constructor property
Found block
.

Lex: NODE_ID constructor
Lex: EOF
Rule: node (NODE_ID separator):  constructor
Rule: nodeStatement (node)  { id: [32m'constructor'[39m }
Rule: statement:  {
  id: [32m'constructor'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'constructor'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  }
]
Found block
.

Lex: NODE_ID A;
.
Rule: node (NODE_ID separator):  A;
Rule: nodeStatement (node)  { id: [32m'A;'[39m }
Lex: EOF
Rule: statement:  {
  type: [32m'classDef'[39m,
  id: [32m'constructor'[39m,
  css: [32m'color:#ffffff,fill:#000000; class A constructor'[39m
}
Rule: statement #2:  {
  id: [32m'A;'[39m,
  label: [90mundefined[39m,
  type: [32m'na'[39m,
  directions: [90mundefined[39m,
  widthInColumns: [33m1[39m
}
Rule: hierarchy:  [
  {
    id: [32m'A;'[39m,
    label: [90mundefined[39m,
    type: [32m'na'[39m,
    directions: [90mundefined[39m,
    widthInColumns: [33m1[39m
  },
  {
    type: [32m'classDef'[39m,
    id: [32m'constructor'[39m,
    css: [32m'color:#ffffff,fill:#000000; class A constructor'[39m
  }
]

 âœ“ packages/mermaid/src/diagrams/block/parser/block.spec.ts (25 tests) 64ms
 âœ“ packages/mermaid/src/diagrams/user-journey/parser/journey.spec.js (7 tests) 30ms
stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-13 should be possible to set an icon for the node
29.829 : TRACE :  Long description: The root
29.829 : TRACE :  node end ... ]
29.829 : TRACE :  node found .. root
29.829 : DEBUG :  In get type [ ]
29.829 : INFO :  Node:  root
29.829 : INFO :  addNode [33m4[39m root The root [33m2[39m
29.829 : TRACE :  Stop NL
29.829 : TRACE :  Begin icon
29.829 : TRACE :  end icon
29.829 : TRACE :  Icon:  bomb
29.829 : TRACE :  Stop NL
29.829 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-14 should be possible to set classes for the node
29.832 : TRACE :  Long description: The root
29.832 : TRACE :  node end ... ]
29.832 : TRACE :  node found .. root
29.832 : DEBUG :  In get type [ ]
29.832 : INFO :  Node:  root
29.832 : INFO :  addNode [33m4[39m root The root [33m2[39m
29.832 : TRACE :  Stop NL
29.832 : TRACE :  Stop NL
29.832 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-15 should be possible to set both classes and icon for the node
29.836 : TRACE :  Long description: The root
29.836 : TRACE :  node end ... ]
29.836 : TRACE :  node found .. root
29.836 : DEBUG :  In get type [ ]
29.836 : INFO :  Node:  root
29.836 : INFO :  addNode [33m4[39m root The root [33m2[39m
29.836 : TRACE :  Stop NL
29.836 : TRACE :  Stop NL
29.836 : TRACE :  Begin icon
29.836 : TRACE :  end icon
29.836 : TRACE :  Icon:  bomb
29.836 : TRACE :  Stop NL
29.836 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > decorations > MMP-16 should be possible to set both classes and icon for the node
29.840 : TRACE :  Long description: The root
29.840 : TRACE :  node end ... ]
29.840 : TRACE :  node found .. root
29.840 : DEBUG :  In get type [ ]
29.840 : INFO :  Node:  root
29.840 : INFO :  addNode [33m4[39m root The root [33m2[39m
29.840 : TRACE :  Stop NL
29.840 : TRACE :  Begin icon
29.840 : TRACE :  end icon
29.840 : TRACE :  Icon:  bomb
29.840 : TRACE :  Stop NL
29.840 : TRACE :  Stop NL
29.840 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > descriptions > MMP-17 should be possible to use node syntax in the descriptions
29.844 : TRACE :  Starting NSTR
29.844 : TRACE :  description: String containing []
29.844 : TRACE :  node end ... ]
29.844 : TRACE :  node found .. root
29.844 : DEBUG :  In get type [ ]
29.844 : INFO :  Node:  root
29.844 : INFO :  addNode [33m4[39m root String containing [] [33m2[39m
29.844 : TRACE :  Stop NL
29.844 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > descriptions > MMP-18 should be possible to use node syntax in the descriptions in children
29.846 : TRACE :  Starting NSTR
29.846 : TRACE :  description: String containing []
29.846 : TRACE :  node end ... ]
29.846 : TRACE :  node found .. root
29.846 : DEBUG :  In get type [ ]
29.846 : INFO :  Node:  root
29.846 : INFO :  addNode [33m4[39m root String containing [] [33m2[39m
29.846 : TRACE :  Stop NL
29.846 : TRACE :  Starting NSTR
29.846 : TRACE :  description: String containing ()
29.846 : TRACE :  node end ... ]
29.846 : TRACE :  node found .. child1
29.846 : DEBUG :  In get type [ ]
29.846 : INFO :  Node:  child1
29.846 : INFO :  addNode [33m6[39m child1 String containing () [33m2[39m
29.846 : TRACE :  Stop NL
29.846 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > descriptions > MMP-19 should be possible to have a child after a class assignment
29.849 : TRACE :  Long description: Root
29.849 : TRACE :  node end )
29.849 : TRACE :  node found .. root
29.849 : DEBUG :  In get type ( )
29.849 : INFO :  Node:  root
29.849 : INFO :  addNode [33m2[39m root Root [33m1[39m
29.849 : TRACE :  Stop NL
29.849 : TRACE :  Long description: Child
29.849 : TRACE :  node end )
29.849 : TRACE :  node found .. Child
29.849 : DEBUG :  In get type ( )
29.849 : INFO :  Node:  Child
29.849 : INFO :  addNode [33m4[39m Child Child [33m1[39m
29.849 : TRACE :  Stop NL
29.849 : TRACE :  Stop NL
29.849 : TRACE :  Long description: a
29.849 : TRACE :  node end )
29.849 : TRACE :  node found .. a
29.849 : DEBUG :  In get type ( )
29.849 : INFO :  Node:  a
29.849 : INFO :  addNode [33m6[39m a a [33m1[39m
29.849 : TRACE :  Stop NL
29.849 : TRACE :  Long description: New Stuff
29.849 : TRACE :  node end ... ]
29.849 : TRACE :  node found .. b
29.849 : DEBUG :  In get type [ ]
29.849 : INFO :  Node:  b
29.849 : INFO :  addNode [33m6[39m b New Stuff [33m2[39m
29.849 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-20 should be possible to have meaningless empty rows in a mindmap abc124
29.856 : TRACE :  Long description: Root
29.856 : TRACE :  node end )
29.856 : TRACE :  node found .. root
29.856 : DEBUG :  In get type ( )
29.856 : INFO :  Node:  root
29.856 : INFO :  addNode [33m2[39m root Root [33m1[39m
29.856 : TRACE :  Stop NL
29.856 : TRACE :  Long description: Child
29.856 : TRACE :  node end )
29.856 : TRACE :  node found .. Child
29.856 : DEBUG :  In get type ( )
29.856 : INFO :  Node:  Child
29.856 : INFO :  addNode [33m4[39m Child Child [33m1[39m
29.856 : TRACE :  Stop NL
29.856 : TRACE :  Long description: a
29.856 : TRACE :  node end )
29.856 : TRACE :  SPACELINE
29.856 : TRACE :  node found .. a
29.856 : DEBUG :  In get type ( )
29.856 : INFO :  Node:  a
29.856 : INFO :  addNode [33m6[39m a a [33m1[39m
29.856 : TRACE :  Long description: New Stuff
29.856 : TRACE :  node end ... ]
29.856 : TRACE :  node found .. b
29.856 : DEBUG :  In get type [ ]
29.856 : INFO :  Node:  b
29.856 : INFO :  addNode [33m6[39m b New Stuff [33m2[39m
29.856 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-21 should be possible to have comments in a mindmap
29.862 : TRACE :  Long description: Root
29.862 : TRACE :  node end )
29.862 : TRACE :  node found .. root
29.862 : DEBUG :  In get type ( )
29.862 : INFO :  Node:  root
29.862 : INFO :  addNode [33m2[39m root Root [33m1[39m
29.862 : TRACE :  Stop NL
29.862 : TRACE :  Long description: Child
29.862 : TRACE :  node end )
29.862 : TRACE :  node found .. Child
29.862 : DEBUG :  In get type ( )
29.862 : INFO :  Node:  Child
29.862 : INFO :  addNode [33m4[39m Child Child [33m1[39m
29.862 : TRACE :  Stop NL
29.862 : TRACE :  Long description: a
29.862 : TRACE :  node end )
29.862 : TRACE :  Found comment

      %% This is a comment
29.862 : TRACE :  node found .. a
29.862 : DEBUG :  In get type ( )
29.862 : INFO :  Node:  a
29.862 : INFO :  addNode [33m6[39m a a [33m1[39m
29.862 : TRACE :  Stop NL2
29.862 : TRACE :  Long description: New Stuff
29.862 : TRACE :  node end ... ]
29.862 : TRACE :  node found .. b
29.862 : DEBUG :  In get type [ ]
29.862 : INFO :  Node:  b
29.862 : INFO :  addNode [33m6[39m b New Stuff [33m2[39m
29.862 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-22 should be possible to have comments at the end of a line
29.867 : TRACE :  Long description: Root
29.867 : TRACE :  node end )
29.867 : TRACE :  node found .. root
29.867 : DEBUG :  In get type ( )
29.867 : INFO :  Node:  root
29.867 : INFO :  addNode [33m2[39m root Root [33m1[39m
29.867 : TRACE :  Stop NL
29.867 : TRACE :  Long description: Child
29.867 : TRACE :  node end )
29.867 : TRACE :  node found .. Child
29.867 : DEBUG :  In get type ( )
29.867 : INFO :  Node:  Child
29.867 : INFO :  addNode [33m4[39m Child Child [33m1[39m
29.867 : TRACE :  Stop NL
29.867 : TRACE :  Long description: a
29.867 : TRACE :  node end )
29.867 : TRACE :  Found comment  %% This is a comment
29.867 : TRACE :  node found .. a
29.867 : DEBUG :  In get type ( )
29.867 : INFO :  Node:  a
29.867 : INFO :  addNode [33m6[39m a a [33m1[39m
29.867 : TRACE :  Stop NL2
29.867 : TRACE :  Long description: New Stuff
29.867 : TRACE :  node end ... ]
29.867 : TRACE :  node found .. b
29.867 : DEBUG :  In get type [ ]
29.867 : INFO :  Node:  b
29.867 : INFO :  addNode [33m6[39m b New Stuff [33m2[39m
29.867 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-23 Rows with only spaces should not interfere
29.877 : TRACE :  Node:  root
29.877 : INFO :  addNode [33m0[39m root root [33m0[39m
29.877 : TRACE :  Stop NL
29.877 : TRACE :  SPACELINE
29.877 : INFO :  Node:  A
29.877 : INFO :  addNode [33m1[39m A A [33m0[39m
29.877 : INFO :  Node:  B
29.877 : INFO :  addNode [33m1[39m B B [33m0[39m
29.877 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-24 Handle rows above the mindmap declarations
29.881 : TRACE :  SPACELINE
29.881 : TRACE :  Node:  root
29.881 : INFO :  addNode [33m0[39m root root [33m0[39m
29.881 : TRACE :  Stop NL
29.881 : TRACE :  SPACELINE
29.881 : INFO :  Node:  A
29.881 : INFO :  addNode [33m1[39m A A [33m0[39m
29.881 : INFO :  Node:  B
29.881 : INFO :  addNode [33m1[39m B B [33m0[39m
29.881 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts > when parsing a mindmap  > MMP-25 Handle rows above the mindmap declarations, no space
29.884 : TRACE :  SPACELINE
29.884 : TRACE :  Node:  root
29.884 : INFO :  addNode [33m0[39m root root [33m0[39m
29.884 : TRACE :  Stop NL
29.884 : TRACE :  SPACELINE
29.884 : INFO :  Node:  A
29.884 : INFO :  addNode [33m1[39m A A [33m0[39m
29.884 : INFO :  Node:  B
29.884 : INFO :  addNode [33m1[39m B B [33m0[39m
29.884 : TRACE :  Stop EOF

 âœ“ packages/mermaid/src/diagrams/mindmap/mindmap.spec.ts (26 tests) 106ms
 âœ“ packages/mermaid/src/diagrams/requirement/requirementDb.spec.ts (9 tests) 13ms
stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > KNBN-1 should handle a simple root definition abc122
29.831 : INFO :  Node:  root
29.831 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > KNBN-2 should handle a hierarchical kanban definition
29.843 : INFO :  Node:  root
29.843 : TRACE :  Stop NL
29.843 : INFO :  Node:  child1
29.843 : TRACE :  Stop NL
29.843 : INFO :  Node:  child2
29.843 : TRACE :  Stop NL
29.843 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > 3 should handle a simple root definition with a shape and without an id abc123
29.850 : TRACE :  Long description: root
29.850 : TRACE :  node end )
29.850 : TRACE :  node found .. (
29.850 : DEBUG :  In get type ( )
29.850 : INFO :  Node:  root
29.850 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > KNBN-4 should not distinguish between deeper hierarchical levels in the kanban definition
29.852 : INFO :  Node:  root
29.852 : TRACE :  Stop NL
29.852 : INFO :  Node:  child1
29.852 : TRACE :  Stop NL
29.852 : INFO :  Node:  leaf1
29.852 : TRACE :  Stop NL
29.852 : INFO :  Node:  child2
29.852 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > 5 Multiple sections are ok
29.857 : INFO :  Node:  section1
29.857 : TRACE :  Stop NL
29.857 : INFO :  Node:  section2
29.857 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > hierarchy > KNBN-6 real root in wrong place
29.860 : INFO :  Node:  root
29.860 : TRACE :  Stop NL
29.860 : INFO :  Node:  fakeRoot
29.860 : TRACE :  Stop NL
29.860 : INFO :  Node:  realRootWrongPlace

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > nodes > KNBN-7 should handle an id and type for a node definition
29.865 : TRACE :  Long description: The root
29.865 : TRACE :  node end ... ]
29.865 : TRACE :  node found .. root
29.865 : DEBUG :  In get type [ ]
29.865 : INFO :  Node:  root
29.865 : TRACE :  Stop NL
29.865 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > nodes > KNBN-8 should handle an id and type for a node definition
29.867 : INFO :  Node:  root
29.867 : TRACE :  Stop NL
29.867 : TRACE :  Long description: child1
29.867 : TRACE :  node end )
29.867 : TRACE :  node found .. theId
29.867 : DEBUG :  In get type ( )
29.867 : INFO :  Node:  theId
29.867 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > nodes > KNBN-9 should handle an id and type for a node definition
29.871 : TRACE :  Node:  root
29.871 : TRACE :  Stop NL
29.871 : TRACE :  Long description: child1
29.871 : TRACE :  node end )
29.871 : TRACE :  node found .. theId
29.871 : DEBUG :  In get type ( )
29.871 : INFO :  Node:  theId
29.871 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-13 should be possible to set an icon for the node
29.874 : TRACE :  Long description: The root
29.874 : TRACE :  node end ... ]
29.874 : TRACE :  node found .. root
29.874 : DEBUG :  In get type [ ]
29.874 : INFO :  Node:  root
29.874 : TRACE :  Stop NL
29.874 : TRACE :  Begin icon
29.874 : TRACE :  end icon
29.874 : TRACE :  Icon:  bomb
29.874 : TRACE :  Stop NL
29.874 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-14 should be possible to set classes for the node
29.878 : TRACE :  Long description: The root
29.878 : TRACE :  node end ... ]
29.878 : TRACE :  node found .. root
29.878 : DEBUG :  In get type [ ]
29.878 : INFO :  Node:  root
29.878 : TRACE :  Stop NL
29.878 : TRACE :  Stop NL
29.878 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-15 should be possible to set both classes and icon for the node
29.882 : TRACE :  Long description: The root
29.882 : TRACE :  node end ... ]
29.882 : TRACE :  node found .. root
29.882 : DEBUG :  In get type [ ]
29.882 : INFO :  Node:  root
29.882 : TRACE :  Stop NL
29.882 : TRACE :  Stop NL
29.882 : TRACE :  Begin icon
29.882 : TRACE :  end icon
29.882 : TRACE :  Icon:  bomb
29.882 : TRACE :  Stop NL
29.882 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > decorations > KNBN-16 should be possible to set both classes and icon for the node
29.888 : TRACE :  Long description: The root
29.888 : TRACE :  node end ... ]
29.888 : TRACE :  node found .. root
29.888 : DEBUG :  In get type [ ]
29.888 : INFO :  Node:  root
29.888 : TRACE :  Stop NL
29.888 : TRACE :  Begin icon
29.888 : TRACE :  end icon
29.888 : TRACE :  Icon:  bomb
29.888 : TRACE :  Stop NL
29.888 : TRACE :  Stop NL
29.888 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > descriptions > KNBN-17 should be possible to use node syntax in the descriptions
29.898 : TRACE :  Starting NSTR
29.898 : TRACE :  description: String containing []
29.898 : TRACE :  node end ... ]
29.898 : TRACE :  node found .. root
29.898 : DEBUG :  In get type [ ]
29.898 : INFO :  Node:  root
29.898 : TRACE :  Stop NL
29.898 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > descriptions > KNBN-18 should be possible to use node syntax in the descriptions in children
29.900 : TRACE :  Starting NSTR
29.900 : TRACE :  description: String containing []
29.900 : TRACE :  node end ... ]
29.900 : TRACE :  node found .. root
29.900 : DEBUG :  In get type [ ]
29.900 : INFO :  Node:  root
29.900 : TRACE :  Stop NL
29.900 : TRACE :  Starting NSTR
29.900 : TRACE :  description: String containing ()
29.900 : TRACE :  node end ... ]
29.900 : TRACE :  node found .. child1
29.900 : DEBUG :  In get type [ ]
29.900 : INFO :  Node:  child1
29.900 : TRACE :  Stop NL
29.900 : TRACE :  Stop EOF2

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > descriptions > KNBN-19 should be possible to have a child after a class assignment
29.903 : TRACE :  Long description: Root
29.903 : TRACE :  node end )
29.903 : TRACE :  node found .. root
29.903 : DEBUG :  In get type ( )
29.903 : INFO :  Node:  root
29.903 : TRACE :  Stop NL
29.903 : TRACE :  Long description: Child
29.903 : TRACE :  node end )
29.903 : TRACE :  node found .. Child
29.903 : DEBUG :  In get type ( )
29.903 : INFO :  Node:  Child
29.903 : TRACE :  Stop NL
29.903 : TRACE :  Stop NL
29.903 : TRACE :  Long description: a
29.903 : TRACE :  node end )
29.903 : TRACE :  node found .. a
29.903 : DEBUG :  In get type ( )
29.903 : INFO :  Node:  a
29.903 : TRACE :  Stop NL
29.903 : TRACE :  Long description: New Stuff
29.903 : TRACE :  node end ... ]
29.903 : TRACE :  node found .. b
29.903 : DEBUG :  In get type [ ]
29.903 : INFO :  Node:  b
29.903 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-20 should be possible to have meaningless empty rows in a kanban abc124
29.907 : TRACE :  Long description: Root
29.907 : TRACE :  node end )
29.907 : TRACE :  node found .. root
29.907 : DEBUG :  In get type ( )
29.907 : INFO :  Node:  root
29.907 : TRACE :  Stop NL
29.907 : TRACE :  Long description: Child
29.907 : TRACE :  node end )
29.907 : TRACE :  node found .. Child
29.907 : DEBUG :  In get type ( )
29.907 : INFO :  Node:  Child
29.907 : TRACE :  Stop NL
29.907 : TRACE :  Long description: a
29.907 : TRACE :  node end )
29.907 : TRACE :  SPACELINE
29.907 : TRACE :  node found .. a
29.907 : DEBUG :  In get type ( )
29.907 : INFO :  Node:  a
29.907 : TRACE :  Long description: New Stuff
29.907 : TRACE :  node end ... ]
29.907 : TRACE :  node found .. b
29.907 : DEBUG :  In get type [ ]
29.907 : INFO :  Node:  b
29.907 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-21 should be possible to have comments in a kanban
29.911 : TRACE :  Long description: Root
29.911 : TRACE :  node end )
29.911 : TRACE :  node found .. root
29.911 : DEBUG :  In get type ( )
29.911 : INFO :  Node:  root
29.911 : TRACE :  Stop NL
29.911 : TRACE :  Long description: Child
29.911 : TRACE :  node end )
29.911 : TRACE :  node found .. Child
29.911 : DEBUG :  In get type ( )
29.911 : INFO :  Node:  Child
29.911 : TRACE :  Stop NL
29.911 : TRACE :  Long description: a
29.911 : TRACE :  node end )
29.911 : TRACE :  Found comment

      %% This is a comment
29.911 : TRACE :  node found .. a
29.911 : DEBUG :  In get type ( )
29.911 : INFO :  Node:  a
29.911 : TRACE :  Stop NL2
29.911 : TRACE :  Long description: New Stuff
29.911 : TRACE :  node end ... ]
29.911 : TRACE :  node found .. b
29.911 : DEBUG :  In get type [ ]
29.911 : INFO :  Node:  b
29.911 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-22 should be possible to have comments at the end of a line
29.915 : TRACE :  Long description: Root
29.915 : TRACE :  node end )
29.915 : TRACE :  node found .. root
29.915 : DEBUG :  In get type ( )
29.915 : INFO :  Node:  root
29.915 : TRACE :  Stop NL
29.915 : TRACE :  Long description: Child
29.915 : TRACE :  node end )
29.915 : TRACE :  node found .. Child
29.915 : DEBUG :  In get type ( )
29.915 : INFO :  Node:  Child
29.915 : TRACE :  Stop NL
29.915 : TRACE :  Long description: a
29.915 : TRACE :  node end )
29.915 : TRACE :  Found comment  %% This is a comment
29.915 : TRACE :  node found .. a
29.915 : DEBUG :  In get type ( )
29.915 : INFO :  Node:  a
29.915 : TRACE :  Stop NL2
29.915 : TRACE :  Long description: New Stuff
29.915 : TRACE :  node end ... ]
29.915 : TRACE :  node found .. b
29.915 : DEBUG :  In get type [ ]
29.915 : INFO :  Node:  b
29.915 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-23 Rows with only spaces should not interfere
29.918 : TRACE :  Node:  root
29.918 : TRACE :  Stop NL
29.918 : TRACE :  SPACELINE
29.918 : INFO :  Node:  A
29.918 : INFO :  Node:  B
29.918 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-24 Handle rows above the kanban declarations
29.921 : TRACE :  SPACELINE
29.921 : TRACE :  Node:  root
29.921 : TRACE :  Stop NL
29.921 : TRACE :  SPACELINE
29.921 : INFO :  Node:  A
29.921 : INFO :  Node:  B
29.921 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > when parsing a kanban  > KNBN-25 Handle rows above the kanban declarations, no space
29.924 : TRACE :  SPACELINE
29.924 : TRACE :  Node:  root
29.924 : TRACE :  Stop NL
29.924 : TRACE :  SPACELINE
29.924 : INFO :  Node:  A
29.924 : INFO :  Node:  B
29.924 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-30 should be possible to set the priority
29.927 : INFO :  Node:  root
29.927 : TRACE :  Stop NL
29.927 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-31 should be possible to set the assignment
29.931 : INFO :  Node:  root
29.931 : TRACE :  Stop NL
29.931 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-32 should be possible to set the icon
29.932 : INFO :  Node:  root
29.933 : TRACE :  Stop NL
29.933 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-33 should be possible to set the icon
29.934 : INFO :  Node:  root
29.934 : TRACE :  Stop NL
29.934 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-34 should be possible to set the metadata using multiple lines
29.935 : INFO :  Node:  root
29.935 : TRACE :  Stop NL
29.935 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-35 should be possible to set the metadata using one line
29.937 : INFO :  Node:  root
29.937 : TRACE :  Stop NL
29.937 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-36 should be possible to set the label using the new syntax
29.938 : INFO :  Node:  root
29.938 : TRACE :  Stop NL
29.938 : TRACE :  Stop EOF

stdout | packages/mermaid/src/diagrams/kanban/kanban.spec.ts > item data data > KNBN-37 should be possible to set the external id
29.939 : INFO :  Node:  root
29.939 : TRACE :  Stop NL
29.939 : TRACE :  Stop EOF

 âœ“ packages/mermaid/src/diagrams/kanban/kanban.spec.ts (30 tests) 116ms
 âœ“ packages/mermaid/src/diagrams/class/classTypes.spec.ts (93 tests) 87ms
 âœ“ packages/mermaid/src/diagrams/git/gitGraphRenderer.ts (30 tests) 20ms
 âœ“ packages/mermaid/src/diagrams/c4/parser/c4Diagram.spec.js (3 tests) 22ms
 âœ“ packages/mermaid/src/diagrams/c4/parser/c4PersonExt.spec.js (7 tests) 25ms
 âœ“ packages/mermaid/src/utils/subGraphTitleMargins.spec.ts (1 test) 18ms
 âœ“ packages/mermaid/src/diagrams/c4/parser/c4Person.spec.js (7 tests) 29ms
 âœ“ packages/mermaid/src/diagrams/c4/parser/c4Boundary.spec.js (6 tests) 30ms
 âœ“ packages/mermaid/src/diagrams/requirement/parser/requirementDiagram.spec.js (43 tests) 54ms
 âœ“ packages/mermaid/src/diagrams/class/classDiagram-styles.spec.js (10 tests) 60ms
 âœ“ packages/mermaid/src/diagrams/c4/parser/c4Container.spec.js (48 tests) 88ms
 âœ“ packages/mermaid/src/diagrams/user-journey/journeyDb.spec.js (9 tests) 19ms
 âœ“ packages/mermaid/src/diagrams/c4/parser/c4System.spec.js (42 tests) 90ms
 âœ“ packages/mermaid/src/diagrams/timeline/timeline.spec.js (8 tests) 49ms
 âœ“ packages/mermaid/src/diagrams/gantt/parser/gantt.spec.js (27 tests) 51ms
 âœ“ packages/mermaid/src/diagrams/block/layout.spec.ts (1 test) 6ms
 âœ“ packages/mermaid/src/diagrams/sankey/parser/sankey.spec.ts (4 tests) 163ms
stdout | packages/mermaid/src/dagre-wrapper/edges.spec.js > Graphlib decorations > intersection > case 1 - intersection on left edge of box
30.469 : DEBUG :  intersection calc abc89:
  outsidePoint: {"x":31,"y":143.2257070163421}
  insidePoint : {"x":99.3359375,"y":100}
  node        : x:171 y:100 w:210 h:184
30.469 : DEBUG :  sides calc abc89, Q 43.22570701634211, q 22.139152558958802, R 68.3359375, r 35 { _x: [33m66[39m, _y: [33m122.1391525589588[39m }

stdout | packages/mermaid/src/dagre-wrapper/edges.spec.js > Graphlib decorations > intersection > case 2 - intersection on left edge of box
30.475 : DEBUG :  intersection calc abc89:
  outsidePoint: {"x":310.2578125,"y":169.88002060631462}
  insidePoint : {"x":127.96875,"y":100}
  node        : x:100.23046875 y:176.75 w:184.4609375 h:337.5
30.475 : DEBUG :  sides calc abc89, Q 69.88002060631462, q 45.15711441743504, R 182.2890625, r 117.796875 { _x: [33m192.4609375[39m, _y: [33m145.15711441743503[39m }

stdout | packages/mermaid/src/dagre-wrapper/edges.spec.js > Graphlib decorations > intersection > case 3 - intersection on top of box outside point greater than inside point
30.477 : DEBUG :  intersection calc abc89:
  outsidePoint: {"x":157,"y":39}
  insidePoint : {"x":104,"y":105}
  node        : x:114 y:164 w:212 h:176
30.477 : DEBUG :  abc89 topp/bott calc, Q 66, q 37, R 53, r 29.71212121212121 { x: [33m133.71212121212122[39m, y: [33m76[39m }

stdout | packages/mermaid/src/dagre-wrapper/edges.spec.js > Graphlib decorations > intersection > case 4 - intersection on top of box inside point greater than inside point
30.478 : DEBUG :  intersection calc abc89:
  outsidePoint: {"x":144,"y":38}
  insidePoint : {"x":198,"y":105}
  node        : x:114 y:164 w:212 h:176
30.478 : DEBUG :  abc89 topp/bott calc, Q 67, q 38, R 54, r 30.62686567164179 { x: [33m174.62686567164178[39m, y: [33m76[39m }

 âœ“ packages/mermaid/src/dagre-wrapper/edges.spec.js (4 tests) 14ms
 âœ“ packages/mermaid/src/diagrams/sequence/svgDraw.spec.js (6 tests) 24ms
 âœ“ packages/mermaid/src/diagrams/gantt/ganttDb.spec.ts (43 tests) 66ms
 âœ“ packages/mermaid/src/diagrams/quadrant-chart/quadrantDb.spec.ts (4 tests) 13ms
 âœ“ packages/mermaid/src/diagrams/info/info.spec.ts (4 tests) 212ms
 âœ“ packages/mermaid/src/diagrams/class/svgDraw.spec.js (2 tests) 4ms
 âœ“ packages/mermaid-example-diagram/src/exampleDiagram.spec.js (1 test) 5ms
 âœ“ packages/mermaid/src/diagrams/class/parser/class.spec.js (3 tests) 23ms
 âœ“ packages/mermaid/src/diagrams/er/erRenderer.spec.ts (1 test) 5ms
 âœ“ packages/mermaid/src/setupGraphViewbox.spec.js (2 tests) 6ms
 âœ“ packages/mermaid/src/diagrams/pie/pie.spec.ts (16 tests | 2 skipped) 143ms
 âœ“ packages/mermaid/src/diagrams/git/gitGraphParser.ts (6 tests) 11ms
 âœ“ packages/mermaid/src/diagrams/packet/packet.spec.ts (15 tests) 132ms
 âœ“ packages/mermaid/src/utils.spec.ts (53 tests) 161ms
 âœ“ packages/mermaid/src/diagrams/git/gitGraph.spec.ts (69 tests | 4 skipped) 366ms
 âœ“ packages/mermaid/src/diagram-api/diagram-orchestration.spec.ts (24 tests) 30ms
 âœ“ packages/mermaid/src/diagrams/er/parser/erDiagram.spec.js (611 tests | 1 skipped) 553ms
 âœ“ packages/mermaid/src/diagrams/architecture/architecture.spec.ts (6 tests) 93ms
 âœ“ packages/mermaid/src/diagram-api/diagramAPI.spec.ts (3 tests) 396ms
 âœ“ packages/parser/tests/info.test.ts (12 tests) 24ms
 âœ“ packages/examples/src/example.spec.ts (1 test) 9ms
 âœ“ packages/parser/tests/packet.test.ts (8 tests) 18ms
 âœ“ packages/parser/tests/pie.test.ts (32 tests) 48ms
 âœ“ packages/parser/tests/treemap.test.ts (17 tests) 39ms
 âœ“ packages/parser/tests/gitGraph.test.ts (27 tests) 53ms
 âœ“ packages/parser/tests/architecture.test.ts (12 tests) 34ms
 âœ“ packages/parser/tests/radar.test.ts (80 tests) 104ms
 âœ“ packages/mermaid/src/diagrams/radar/radar.spec.ts (19 tests) 252ms
 âœ“ packages/mermaid/src/diagrams/class/classDiagram.spec.ts (368 tests | 1 skipped) 1381ms
 âœ“ packages/mermaid/src/diagrams/sequence/sequenceDiagram.spec.js (104 tests) 715ms
 â¯ packages/mermaid/scripts/docs.spec.ts (0 test)
 âœ“ packages/mermaid/src/rendering-util/rendering-elements/nodes.spec.ts (39 tests) 12ms
 âœ“ packages/mermaid/src/diagrams/flowchart/flowDb.spec.ts (13 tests) 36ms
 âœ“ packages/mermaid/src/rendering-util/createText.spec.ts (5 tests) 40ms
 âœ“ packages/mermaid/src/diagrams/state/stateDb.spec.js (6 tests) 34ms
 â†“ packages/mermaid/src/diagrams/flowchart/parser/flow-huge.spec.js (1 test | 1 skipped)
 âœ“ packages/mermaid/src/diagrams/state/parser/state-style.spec.js (15 tests) 67ms
 âœ“ packages/mermaid/src/diagrams/state/parser/state-parser.spec.js (9 tests) 75ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-md-string.spec.js (2 tests) 24ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-direction.spec.js (4 tests) 43ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-vertice-chaining.spec.js (7 tests) 44ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-lines.spec.js (12 tests) 44ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-comments.spec.js (9 tests) 41ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-interactions.spec.js (13 tests) 67ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-arrows.spec.js (14 tests) 71ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-style.spec.js (24 tests) 81ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/subgraph.spec.js (22 tests | 1 skipped) 89ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow.spec.js (25 tests) 119ms
 âœ“ packages/mermaid/src/diagrams/state/stateDiagram-v2.spec.js (31 tests) 265ms
 âœ“ packages/mermaid/src/diagrams/state/stateDiagram.spec.js (30 tests | 1 skipped) 280ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-node-data.spec.js (31 tests | 1 skipped) 193ms
 âœ“ packages/mermaid/src/diagram.spec.ts (6 tests) 1647ms
   âœ“ diagram detection > should detect inbuilt diagrams 1617ms
 âœ“ packages/mermaid/src/styles.spec.ts (81 tests) 1296ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-singlenode.spec.js (148 tests) 324ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-edges.spec.js (293 tests) 564ms
 âœ“ packages/mermaid/src/diagrams/flowchart/parser/flow-text.spec.js (342 tests) 614ms
 âœ“ packages/mermaid/src/mermaid.spec.ts (13 tests) 1144ms
   âœ“ when using mermaid and  > when using #registerExternalDiagrams > should throw error (but still render) if registerExternalDiagrams fails 1062ms
 âœ“ packages/mermaid/src/mermaidAPI.spec.ts (78 tests) 1811ms
   âœ“ mermaidAPI > render > accessibility > classDiagram > should set aria-roledescription to the diagram type AND should call addSVGa11yTitleDescription 409ms

âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯ Failed Suites 1 âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯

 FAIL  packages/mermaid/scripts/docs.spec.ts [ packages/mermaid/scripts/docs.spec.ts ]
Error: ENOENT: no such file or directory, open '../mermaid/package.json'
 â¯ packages/mermaid/scripts/docs.mts:61:51
     59| const { shapesDefs } = await import('../src/rendering-util/rendering-eâ€¦
     60|
     61| export const MERMAID_RELEASE_VERSION = JSON.parse(readFileSync('../merâ€¦
       |                                                   ^
     62|   .version as string;
     63| const MERMAID_MAJOR_VERSION = MERMAID_RELEASE_VERSION.split('.')[0];
 â¯ packages/mermaid/scripts/docs.spec.ts:1:1

âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯âŽ¯[1/1]âŽ¯


 Test Files  1 failed | 96 passed | 1 skipped (98)
      Tests  3544 passed | 10 skipped | 2 todo (3556)
   Start at  16:04:15
   Duration  9.44s (transform 50.84s, setup 0ms, collect 341.08s, tests 16.09s, environment 105.57s, prepare 18.36s)

â€‰ELIFECYCLEâ€‰ Test failed. See above for more details.
